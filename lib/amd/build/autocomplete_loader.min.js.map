{"version":3,"file":"autocomplete_loader.min.js","sources":["../src/autocomplete_loader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Autocomplete library config\n *\n * @module      core/autocomplete_loader\n * @copyright   2023 Moodle Pty Ltd <support@moodle.com>\n * @author      2023 Carlos Castillo <carlos.castillo@moodle.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\"use strict\";\n\nimport AutoComplete from 'core/autocomplete';\nimport {get_string as getString} from \"./str\";\nimport Notification from 'core/notification';\nimport Pending from 'core/pending';\n\n/**\n * Retrieve all search result.\n *\n * @method\n * @param {string} query Selector id for search input\n * @param {string} method used to retrieve the search result\n * @returns {Promise}\n */\nconst fetchSearch = async(query, method = 'core_search_autocomplete') => {\n    const Ajax = await import('core/ajax');\n\n    const request = await Ajax.call([{\n        methodname: method,\n        args: {\n            query: query\n        }\n    }])[0];\n    return request.results;\n};\n\n/**\n * Initialise module, ensuring we load our resources and event listeners only once\n *\n * @param {string} selector Selector id for search input\n * @param {string} placeholder The placeholder to show into search input\n * @param {object} paginationConfig pagination config setting\n */\nexport const init = (selector, placeholder, paginationConfig) => {\n    let currentResults;\n    let limits = {\n        'min': 1,\n        'max': paginationConfig\n    };\n\n    const autoCompleteJS = new AutoComplete({\n        selector: \"#\" + selector,\n        searchEngine: \"strict\",\n        data: {\n            src: fetchSearch,\n            keys: [\"title\", \"settingname\", \"settingvisiblename\", \"settingdescription\"],\n            cache: false,\n            filter: (list) => {\n                // Filter duplicates\n                // in case of multiple data keys usage\n                return Array.from(\n                    new Set(list.map((value) => value.match))\n                ).map((settingname) => {\n                    return list.find((value) => value.match === settingname);\n                });\n            }\n        },\n        placeHolder: placeholder,\n        resultsList: {\n            id: 'autoComplete_list',\n            position: 'afterbegin',\n            element: async(list, data) => {\n                if (data.results.length) {\n                    list.style[\"overflow-y\"] = \"scroll\";\n                    currentResults = data;\n                    limits.min = 1;\n                    limits.max = data.results.length;\n                    await addPagination(list);\n                } else {\n                    const info = document.createElement(\"div\");\n                    info.setAttribute(\"class\", \"no_result\");\n                    list.style[\"overflow-y\"] = \"hidden\";\n                    info.innerHTML = await getString('noresultsfound', 'search', `\"${data.query}\"`);\n                    list.append(info);\n                }\n            },\n            destination: '#autoCompleteResult',\n            noResults: true,\n            maxResults: paginationConfig,\n            tabSelect: true,\n        },\n        resultItem: {\n            element: (item, data) => {\n                item.style = \"display: flex; justify-content: space-between; cursor: pointer;\";\n                item.setAttribute(\"onclick\", \"location.href='\" + data.value.url + \"'\");\n                let icon = data.key === 'settingname' ? 'fa-gear' : 'fa-bars';\n                item.innerHTML = `\n                  <span style=\"text-overflow: ellipsis; white-space: nowrap; overflow: hidden;\">\n                    <i class=\"fa ${icon}\"></i> ${data.match}\n                    <i class=\"fa fa-arrow-up-right-from-square\"></i>\n                  </span>`;\n            },\n            highlight: true,\n        },\n        events: {\n            input: {\n                focus: () => {\n                    if (autoCompleteJS.input.value.length > 2) {\n                        autoCompleteJS.start();\n                    }\n                }\n            }\n        }\n    });\n\n    /**\n     * @param {Object} container\n     */\n    const redrawAutocompleteResults = (container) => {\n        const pendingPromise = new Pending('core/datafilter:addFilterRow');\n        container.innerHTML = '';\n        currentResults.matches.entries().forEach(([index, data]) => {\n            if (index >= (limits.min - 1) && index <= (limits.max - 1)) {\n                const resultitem = document.createElement(\"li\");\n                resultitem.style = \"display: flex; justify-content: space-between; cursor: pointer;\";\n                resultitem.setAttribute(\"id\", \"autoComplete_result_\" + (index - 1));\n                resultitem.setAttribute(\"role\", \"option\");\n                resultitem.setAttribute(\"onclick\", \"location.href='\" + data.value.url + \"'\");\n                let icon = data.key === 'settingname' ? 'fa-gear' : 'fa-bars';\n                resultitem.innerHTML = `\n                  <span style=\"text-overflow: ellipsis; white-space: nowrap; overflow: hidden;\">\n                    <i class=\"fa ${icon}\"></i> ${data.match}\n                    <i class=\"fa fa-arrow-up-right-from-square\"></i>\n                  </span>`;\n                container.append(resultitem);\n            }\n        });\n        addPagination(container).then(result => {\n            pendingPromise.resolve();\n            return result;\n        })\n        .catch(Notification.exception);\n    };\n\n    /**\n     * @param {Object}  ev\n     * @param {Object} container\n     */\n    const autocompletePrev = (ev, container) => {\n        if (limits.min > 1) {\n            limits.max = (limits.max === currentResults.matches.length) ? limits.max - ((limits.max - limits.min) + 1) :\n                limits.max - autoCompleteJS.resultsList.maxResults;\n            limits.min = limits.min - autoCompleteJS.resultsList.maxResults;\n            redrawAutocompleteResults(container);\n        }\n        ev.stopPropagation();\n    };\n\n    /**\n     * @param {Object} ev\n     * @param {Object} container\n     */\n    const autocompleteNext = (ev, container) => {\n        if (limits.max < currentResults.matches.length) {\n            const exceedMax = (limits.max + autoCompleteJS.resultsList.maxResults > currentResults.matches.length);\n            limits.min = limits.min + autoCompleteJS.resultsList.maxResults;\n            limits.max = exceedMax ? currentResults.matches.length\n                : limits.max + autoCompleteJS.resultsList.maxResults;\n            redrawAutocompleteResults(container);\n        }\n        ev.stopPropagation();\n    };\n\n    /**\n     * @param {Object} element\n     */\n    const addPagination = async(element) => {\n        const createAndAppendElement = (tag, attributes = {}, innerHTML = \"\") => {\n            const element = document.createElement(tag);\n            Object.entries(attributes).forEach(([key, value]) => {\n                element.setAttribute(key, value);\n            });\n            element.innerHTML = innerHTML;\n            return element;\n        };\n\n        const pag = createAndAppendElement(\"div\", {\"class\": \"d-flex justify-content-between\"});\n        pag.onclick = (ev) => {\n            ev.stopPropagation();\n        };\n\n        const prev = createAndAppendElement(\"span\", {\n            \"class\": \"icon fa fa-left-long p-1 ml-2\",\n            style: \"cursor:pointer\"\n        });\n        prev.onclick = (ev) => {\n            autocompletePrev(ev, element);\n        };\n        if (limits.min <= 1) {\n            prev.style.visibility = \"hidden\";\n        }\n        pag.append(prev);\n\n        let searchResultParams = {\n            'link': currentResults.results[0].value.rooturl,\n        };\n        let searchResult = await getString('autocompletesearchresult', 'search', searchResultParams);\n\n        const stats = createAndAppendElement(\"p\", {\n            \"class\": \"text-muted small p-1 m-0\",\n            \"id\": \"autoComplete_stats\"\n        }, `${limits.min}-${limits.max} / ${currentResults.matches.length} - ${searchResult}`);\n\n        pag.append(stats);\n\n        const next = createAndAppendElement(\"span\", {\n            \"class\": \"icon fa fa-right-long p-1 mr-2\",\n            \"style\": \"cursor:pointer\"\n        });\n        next.onclick = (ev) => {\n            ev.preventDefault();\n            autocompleteNext(ev, element);\n        };\n        if (limits.max === currentResults.matches.length) {\n            next.style.visibility = \"hidden\";\n        }\n        pag.append(next);\n\n        element.append(pag);\n    };\n};\n"],"names":["fetchSearch","async","query","method","Ajax","request","call","methodname","args","results","selector","placeholder","paginationConfig","currentResults","limits","autoCompleteJS","AutoComplete","searchEngine","data","src","keys","cache","filter","list","Array","from","Set","map","value","match","settingname","find","placeHolder","resultsList","id","position","element","length","style","min","max","addPagination","info","document","createElement","setAttribute","innerHTML","append","destination","noResults","maxResults","tabSelect","resultItem","item","url","icon","key","highlight","events","input","focus","start","redrawAutocompleteResults","container","pendingPromise","Pending","matches","entries","forEach","_ref","index","resultitem","then","result","resolve","catch","Notification","exception","createAndAppendElement","tag","attributes","Object","_ref2","pag","onclick","ev","stopPropagation","prev","autocompletePrev","visibility","searchResultParams","rooturl","searchResult","stats","next","preventDefault","exceedMax","autocompleteNext"],"mappings":"onBAuCMA,YAAcC,eAAMC,WAAOC,8DAAS,iCAChCC,wlBAEAC,cAAgBD,KAAKE,KAAK,CAAC,CAC7BC,WAAYJ,OACZK,KAAM,CACFN,MAAOA,UAEX,UACGG,QAAQI,uBAUC,CAACC,SAAUC,YAAaC,wBACpCC,eACAC,OAAS,KACF,MACAF,wBAGLG,eAAiB,IAAIC,sBAAa,CACpCN,SAAU,IAAMA,SAChBO,aAAc,SACdC,KAAM,CACFC,IAAKnB,YACLoB,KAAM,CAAC,QAAS,cAAe,qBAAsB,sBACrDC,OAAO,EACPC,OAASC,MAGEC,MAAMC,KACT,IAAIC,IAAIH,KAAKI,KAAKC,OAAUA,MAAMC,UACpCF,KAAKG,aACIP,KAAKQ,MAAMH,OAAUA,MAAMC,QAAUC,iBAIxDE,YAAarB,YACbsB,YAAa,CACTC,GAAI,oBACJC,SAAU,aACVC,QAASnC,MAAMsB,KAAML,WACbA,KAAKT,QAAQ4B,OACbd,KAAKe,MAAM,cAAgB,SAC3BzB,eAAiBK,KACjBJ,OAAOyB,IAAM,EACbzB,OAAO0B,IAAMtB,KAAKT,QAAQ4B,aACpBI,cAAclB,UACjB,OACGmB,KAAOC,SAASC,cAAc,OACpCF,KAAKG,aAAa,QAAS,aAC3BtB,KAAKe,MAAM,cAAgB,SAC3BI,KAAKI,gBAAkB,mBAAU,iBAAkB,oBAAc5B,KAAKhB,YACtEqB,KAAKwB,OAAOL,QAGpBM,YAAa,sBACbC,WAAW,EACXC,WAAYtC,iBACZuC,WAAW,GAEfC,WAAY,CACRhB,QAAS,CAACiB,KAAMnC,QACZmC,KAAKf,MAAQ,kEACbe,KAAKR,aAAa,UAAW,kBAAoB3B,KAAKU,MAAM0B,IAAM,SAC9DC,KAAoB,gBAAbrC,KAAKsC,IAAwB,UAAY,UACpDH,KAAKP,yJAEcS,uBAAcrC,KAAKW,4GAI1C4B,WAAW,GAEfC,OAAQ,CACJC,MAAO,CACHC,MAAO,KACC7C,eAAe4C,MAAM/B,MAAMS,OAAS,GACpCtB,eAAe8C,aAU7BC,0BAA6BC,kBACzBC,eAAiB,IAAIC,iBAAQ,gCACnCF,UAAUjB,UAAY,GACtBjC,eAAeqD,QAAQC,UAAUC,SAAQC,WAAEC,MAAOpD,cAC1CoD,OAAUxD,OAAOyB,IAAM,GAAM+B,OAAUxD,OAAO0B,IAAM,EAAI,OAClD+B,WAAa5B,SAASC,cAAc,MAC1C2B,WAAWjC,MAAQ,kEACnBiC,WAAW1B,aAAa,KAAM,wBAA0ByB,MAAQ,IAChEC,WAAW1B,aAAa,OAAQ,UAChC0B,WAAW1B,aAAa,UAAW,kBAAoB3B,KAAKU,MAAM0B,IAAM,SACpEC,KAAoB,gBAAbrC,KAAKsC,IAAwB,UAAY,UACpDe,WAAWzB,yJAEQS,uBAAcrC,KAAKW,2GAGtCkC,UAAUhB,OAAOwB,gBAGzB9B,cAAcsB,WAAWS,MAAKC,SAC1BT,eAAeU,UACRD,UAEVE,MAAMC,sBAAaC,YAmClBpC,cAAgBxC,MAAAA,gBACZ6E,uBAAyB,SAACC,SAAKC,kEAAa,GAAIlC,iEAAY,SACxDV,QAAUO,SAASC,cAAcmC,YACvCE,OAAOd,QAAQa,YAAYZ,SAAQc,YAAE1B,IAAK5B,aACtCQ,QAAQS,aAAaW,IAAK5B,UAE9BQ,QAAQU,UAAYA,UACbV,SAGL+C,IAAML,uBAAuB,MAAO,OAAU,mCACpDK,IAAIC,QAAWC,KACXA,GAAGC,yBAGDC,KAAOT,uBAAuB,OAAQ,OAC/B,gCACTxC,MAAO,mBAEXiD,KAAKH,QAAWC,KA/CK,EAACA,GAAItB,aACtBjD,OAAOyB,IAAM,IACbzB,OAAO0B,IAAO1B,OAAO0B,MAAQ3B,eAAeqD,QAAQ7B,OAAUvB,OAAO0B,KAAQ1B,OAAO0B,IAAM1B,OAAOyB,IAAO,GACpGzB,OAAO0B,IAAMzB,eAAekB,YAAYiB,WAC5CpC,OAAOyB,IAAMzB,OAAOyB,IAAMxB,eAAekB,YAAYiB,WACrDY,0BAA0BC,YAE9BsB,GAAGC,mBAyCCE,CAAiBH,GAAIjD,UAErBtB,OAAOyB,KAAO,IACdgD,KAAKjD,MAAMmD,WAAa,UAE5BN,IAAIpC,OAAOwC,UAEPG,mBAAqB,MACb7E,eAAeJ,QAAQ,GAAGmB,MAAM+D,SAExCC,mBAAqB,mBAAU,2BAA4B,SAAUF,0BAEnEG,MAAQf,uBAAuB,IAAK,OAC7B,8BACH,gCACJhE,OAAOyB,gBAAOzB,OAAO0B,kBAAS3B,eAAeqD,QAAQ7B,qBAAYuD,eAEvET,IAAIpC,OAAO8C,aAELC,KAAOhB,uBAAuB,OAAQ,OAC/B,uCACA,mBAEbgB,KAAKV,QAAWC,KACZA,GAAGU,iBA1Dc,EAACV,GAAItB,gBACtBjD,OAAO0B,IAAM3B,eAAeqD,QAAQ7B,OAAQ,OACtC2D,UAAalF,OAAO0B,IAAMzB,eAAekB,YAAYiB,WAAarC,eAAeqD,QAAQ7B,OAC/FvB,OAAOyB,IAAMzB,OAAOyB,IAAMxB,eAAekB,YAAYiB,WACrDpC,OAAO0B,IAAMwD,UAAYnF,eAAeqD,QAAQ7B,OAC1CvB,OAAO0B,IAAMzB,eAAekB,YAAYiB,WAC9CY,0BAA0BC,WAE9BsB,GAAGC,mBAmDCW,CAAiBZ,GAAIjD,UAErBtB,OAAO0B,MAAQ3B,eAAeqD,QAAQ7B,SACtCyD,KAAKxD,MAAMmD,WAAa,UAE5BN,IAAIpC,OAAO+C,MAEX1D,QAAQW,OAAOoC"}