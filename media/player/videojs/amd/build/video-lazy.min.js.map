{"version":3,"file":"video-lazy.min.js","sources":["../src/video-lazy.js"],"sourcesContent":["/**\n * @license\n * Video.js 8.0.4 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/main/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.videojs = factory());\n})(this, (function () { 'use strict';\n\n  var version$5 = \"8.0.4\";\n\n  /**\n   * An Object that contains lifecycle hooks as keys which point to an array\n   * of functions that are run when a lifecycle is triggered\n   *\n   * @private\n   */\n  const hooks_ = {};\n\n  /**\n   * Get a list of hooks for a specific lifecycle\n   *\n   * @param  {string} type\n   *         the lifecyle to get hooks from\n   *\n   * @param  {Function|Function[]} [fn]\n   *         Optionally add a hook (or hooks) to the lifecycle that your are getting.\n   *\n   * @return {Array}\n   *         an array of hooks, or an empty array if there are none.\n   */\n  const hooks = function (type, fn) {\n    hooks_[type] = hooks_[type] || [];\n    if (fn) {\n      hooks_[type] = hooks_[type].concat(fn);\n    }\n    return hooks_[type];\n  };\n\n  /**\n   * Add a function hook to a specific videojs lifecycle.\n   *\n   * @param {string} type\n   *        the lifecycle to hook the function to.\n   *\n   * @param {Function|Function[]}\n   *        The function or array of functions to attach.\n   */\n  const hook = function (type, fn) {\n    hooks(type, fn);\n  };\n\n  /**\n   * Remove a hook from a specific videojs lifecycle.\n   *\n   * @param  {string} type\n   *         the lifecycle that the function hooked to\n   *\n   * @param  {Function} fn\n   *         The hooked function to remove\n   *\n   * @return {boolean}\n   *         The function that was removed or undef\n   */\n  const removeHook = function (type, fn) {\n    const index = hooks(type).indexOf(fn);\n    if (index <= -1) {\n      return false;\n    }\n    hooks_[type] = hooks_[type].slice();\n    hooks_[type].splice(index, 1);\n    return true;\n  };\n\n  /**\n   * Add a function hook that will only run once to a specific videojs lifecycle.\n   *\n   * @param {string} type\n   *        the lifecycle to hook the function to.\n   *\n   * @param {Function|Function[]}\n   *        The function or array of functions to attach.\n   */\n  const hookOnce = function (type, fn) {\n    hooks(type, [].concat(fn).map(original => {\n      const wrapper = (...args) => {\n        removeHook(type, wrapper);\n        return original(...args);\n      };\n      return wrapper;\n    }));\n  };\n\n  /**\n   * @file fullscreen-api.js\n   * @module fullscreen-api\n   */\n\n  /**\n   * Store the browser-specific methods for the fullscreen API.\n   *\n   * @type {Object}\n   * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n   * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n   */\n  const FullscreenApi = {\n    prefixed: true\n  };\n\n  // browser API methods\n  const apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'],\n  // WebKit\n  ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen'],\n  // Mozilla\n  ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror', '-moz-full-screen'],\n  // Microsoft\n  ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError', '-ms-fullscreen']];\n  const specApi = apiMap[0];\n  let browserApi;\n\n  // determine the supported set of functions\n  for (let i = 0; i < apiMap.length; i++) {\n    // check for exitFullscreen function\n    if (apiMap[i][1] in document) {\n      browserApi = apiMap[i];\n      break;\n    }\n  }\n\n  // map the browser API names to the spec API names\n  if (browserApi) {\n    for (let i = 0; i < browserApi.length; i++) {\n      FullscreenApi[specApi[i]] = browserApi[i];\n    }\n    FullscreenApi.prefixed = browserApi[0] !== specApi[0];\n  }\n\n  /**\n   * @file create-logger.js\n   * @module create-logger\n   */\n\n  // This is the private tracking variable for the logging history.\n  let history = [];\n\n  /**\n   * Log messages to the console and history based on the type of message\n   *\n   * @private\n   * @param  {string} type\n   *         The name of the console method to use.\n   *\n   * @param  {Array} args\n   *         The arguments to be passed to the matching console method.\n   */\n  const LogByTypeFactory = (name, log) => (type, level, args) => {\n    const lvl = log.levels[level];\n    const lvlRegExp = new RegExp(`^(${lvl})$`);\n    if (type !== 'log') {\n      // Add the type to the front of the message when it's not \"log\".\n      args.unshift(type.toUpperCase() + ':');\n    }\n\n    // Add console prefix after adding to history.\n    args.unshift(name + ':');\n\n    // Add a clone of the args at this point to history.\n    if (history) {\n      history.push([].concat(args));\n\n      // only store 1000 history entries\n      const splice = history.length - 1000;\n      history.splice(0, splice > 0 ? splice : 0);\n    }\n\n    // If there's no console then don't try to output messages, but they will\n    // still be stored in history.\n    if (!window.console) {\n      return;\n    }\n\n    // Was setting these once outside of this function, but containing them\n    // in the function makes it easier to test cases where console doesn't exist\n    // when the module is executed.\n    let fn = window.console[type];\n    if (!fn && type === 'debug') {\n      // Certain browsers don't have support for console.debug. For those, we\n      // should default to the closest comparable log.\n      fn = window.console.info || window.console.log;\n    }\n\n    // Bail out if there's no console or if this type is not allowed by the\n    // current logging level.\n    if (!fn || !lvl || !lvlRegExp.test(type)) {\n      return;\n    }\n    fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);\n  };\n  function createLogger$1(name) {\n    // This is the private tracking variable for logging level.\n    let level = 'info';\n\n    // the curried logByType bound to the specific log and history\n    let logByType;\n\n    /**\n     * Logs plain debug messages. Similar to `console.log`.\n     *\n     * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n     * of our JSDoc template, we cannot properly document this as both a function\n     * and a namespace, so its function signature is documented here.\n     *\n     * #### Arguments\n     * ##### *args\n     * Mixed[]\n     *\n     * Any combination of values that could be passed to `console.log()`.\n     *\n     * #### Return Value\n     *\n     * `undefined`\n     *\n     * @namespace\n     * @param    {Mixed[]} args\n     *           One or more messages or objects that should be logged.\n     */\n    const log = function (...args) {\n      logByType('log', level, args);\n    };\n\n    // This is the logByType helper that the logging methods below use\n    logByType = LogByTypeFactory(name, log);\n\n    /**\n     * Create a new sublogger which chains the old name to the new name.\n     *\n     * For example, doing `videojs.log.createLogger('player')` and then using that logger will log the following:\n     * ```js\n     *  mylogger('foo');\n     *  // > VIDEOJS: player: foo\n     * ```\n     *\n     * @param {string} name\n     *        The name to add call the new logger\n     * @return {Object}\n     */\n    log.createLogger = subname => createLogger$1(name + ': ' + subname);\n\n    /**\n     * Enumeration of available logging levels, where the keys are the level names\n     * and the values are `|`-separated strings containing logging methods allowed\n     * in that logging level. These strings are used to create a regular expression\n     * matching the function name being called.\n     *\n     * Levels provided by Video.js are:\n     *\n     * - `off`: Matches no calls. Any value that can be cast to `false` will have\n     *   this effect. The most restrictive.\n     * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n     *   `log.warn`, and `log.error`).\n     * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n     * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n     * - `warn`: Matches `log.warn` and `log.error` calls.\n     * - `error`: Matches only `log.error` calls.\n     *\n     * @type {Object}\n     */\n    log.levels = {\n      all: 'debug|log|warn|error',\n      off: '',\n      debug: 'debug|log|warn|error',\n      info: 'log|warn|error',\n      warn: 'warn|error',\n      error: 'error',\n      DEFAULT: level\n    };\n\n    /**\n     * Get or set the current logging level.\n     *\n     * If a string matching a key from {@link module:log.levels} is provided, acts\n     * as a setter.\n     *\n     * @param  {string} [lvl]\n     *         Pass a valid level to set a new logging level.\n     *\n     * @return {string}\n     *         The current logging level.\n     */\n    log.level = lvl => {\n      if (typeof lvl === 'string') {\n        if (!log.levels.hasOwnProperty(lvl)) {\n          throw new Error(`\"${lvl}\" in not a valid log level`);\n        }\n        level = lvl;\n      }\n      return level;\n    };\n\n    /**\n     * Returns an array containing everything that has been logged to the history.\n     *\n     * This array is a shallow clone of the internal history record. However, its\n     * contents are _not_ cloned; so, mutating objects inside this array will\n     * mutate them in history.\n     *\n     * @return {Array}\n     */\n    log.history = () => history ? [].concat(history) : [];\n\n    /**\n     * Allows you to filter the history by the given logger name\n     *\n     * @param {string} fname\n     *        The name to filter by\n     *\n     * @return {Array}\n     *         The filtered list to return\n     */\n    log.history.filter = fname => {\n      return (history || []).filter(historyItem => {\n        // if the first item in each historyItem includes `fname`, then it's a match\n        return new RegExp(`.*${fname}.*`).test(historyItem[0]);\n      });\n    };\n\n    /**\n     * Clears the internal history tracking, but does not prevent further history\n     * tracking.\n     */\n    log.history.clear = () => {\n      if (history) {\n        history.length = 0;\n      }\n    };\n\n    /**\n     * Disable history tracking if it is currently enabled.\n     */\n    log.history.disable = () => {\n      if (history !== null) {\n        history.length = 0;\n        history = null;\n      }\n    };\n\n    /**\n     * Enable history tracking if it is currently disabled.\n     */\n    log.history.enable = () => {\n      if (history === null) {\n        history = [];\n      }\n    };\n\n    /**\n     * Logs error messages. Similar to `console.error`.\n     *\n     * @param {Mixed[]} args\n     *        One or more messages or objects that should be logged as an error\n     */\n    log.error = (...args) => logByType('error', level, args);\n\n    /**\n     * Logs warning messages. Similar to `console.warn`.\n     *\n     * @param {Mixed[]} args\n     *        One or more messages or objects that should be logged as a warning.\n     */\n    log.warn = (...args) => logByType('warn', level, args);\n\n    /**\n     * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n     * log if `console.debug` is not available\n     *\n     * @param {Mixed[]} args\n     *        One or more messages or objects that should be logged as debug.\n     */\n    log.debug = (...args) => logByType('debug', level, args);\n    return log;\n  }\n\n  /**\n   * @file log.js\n   * @module log\n   */\n  const log$1 = createLogger$1('VIDEOJS');\n  const createLogger = log$1.createLogger;\n\n  /**\n   * @file obj.js\n   * @module obj\n   */\n\n  /**\n   * @callback obj:EachCallback\n   *\n   * @param {Mixed} value\n   *        The current key for the object that is being iterated over.\n   *\n   * @param {string} key\n   *        The current key-value for object that is being iterated over\n   */\n\n  /**\n   * @callback obj:ReduceCallback\n   *\n   * @param {Mixed} accum\n   *        The value that is accumulating over the reduce loop.\n   *\n   * @param {Mixed} value\n   *        The current key for the object that is being iterated over.\n   *\n   * @param {string} key\n   *        The current key-value for object that is being iterated over\n   *\n   * @return {Mixed}\n   *         The new accumulated value.\n   */\n  const toString$1 = Object.prototype.toString;\n\n  /**\n   * Get the keys of an Object\n   *\n   * @param {Object}\n   *        The Object to get the keys from\n   *\n   * @return {string[]}\n   *         An array of the keys from the object. Returns an empty array if the\n   *         object passed in was invalid or had no keys.\n   *\n   * @private\n   */\n  const keys = function (object) {\n    return isObject$1(object) ? Object.keys(object) : [];\n  };\n\n  /**\n   * Array-like iteration for objects.\n   *\n   * @param {Object} object\n   *        The object to iterate over\n   *\n   * @param {obj:EachCallback} fn\n   *        The callback function which is called for each key in the object.\n   */\n  function each(object, fn) {\n    keys(object).forEach(key => fn(object[key], key));\n  }\n\n  /**\n   * Array-like reduce for objects.\n   *\n   * @param {Object} object\n   *        The Object that you want to reduce.\n   *\n   * @param {Function} fn\n   *         A callback function which is called for each key in the object. It\n   *         receives the accumulated value and the per-iteration value and key\n   *         as arguments.\n   *\n   * @param {Mixed} [initial = 0]\n   *        Starting value\n   *\n   * @return {Mixed}\n   *         The final accumulated value.\n   */\n  function reduce(object, fn, initial = 0) {\n    return keys(object).reduce((accum, key) => fn(accum, object[key], key), initial);\n  }\n\n  /**\n   * Returns whether a value is an object of any kind - including DOM nodes,\n   * arrays, regular expressions, etc. Not functions, though.\n   *\n   * This avoids the gotcha where using `typeof` on a `null` value\n   * results in `'object'`.\n   *\n   * @param  {Object} value\n   * @return {boolean}\n   */\n  function isObject$1(value) {\n    return !!value && typeof value === 'object';\n  }\n\n  /**\n   * Returns whether an object appears to be a \"plain\" object - that is, a\n   * direct instance of `Object`.\n   *\n   * @param  {Object} value\n   * @return {boolean}\n   */\n  function isPlain(value) {\n    return isObject$1(value) && toString$1.call(value) === '[object Object]' && value.constructor === Object;\n  }\n\n  /**\n   * Merge two objects recursively.\n   *\n   * Performs a deep merge like\n   * {@link https://lodash.com/docs/4.17.10#merge|lodash.merge}, but only merges\n   * plain objects (not arrays, elements, or anything else).\n   *\n   * Non-plain object values will be copied directly from the right-most\n   * argument.\n   *\n   * @param   {Object[]} sources\n   *          One or more objects to merge into a new object.\n   *\n   * @return {Object}\n   *          A new object that is the merged result of all sources.\n   */\n  function merge$2(...sources) {\n    const result = {};\n    sources.forEach(source => {\n      if (!source) {\n        return;\n      }\n      each(source, (value, key) => {\n        if (!isPlain(value)) {\n          result[key] = value;\n          return;\n        }\n        if (!isPlain(result[key])) {\n          result[key] = {};\n        }\n        result[key] = merge$2(result[key], value);\n      });\n    });\n    return result;\n  }\n\n  /**\n   * Object.defineProperty but \"lazy\", which means that the value is only set after\n   * it is retrieved the first time, rather than being set right away.\n   *\n   * @param {Object} obj the object to set the property on\n   * @param {string} key the key for the property to set\n   * @param {Function} getValue the function used to get the value when it is needed.\n   * @param {boolean} setter whether a setter should be allowed or not\n   */\n  function defineLazyProperty(obj, key, getValue, setter = true) {\n    const set = value => Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      writable: true\n    });\n    const options = {\n      configurable: true,\n      enumerable: true,\n      get() {\n        const value = getValue();\n        set(value);\n        return value;\n      }\n    };\n    if (setter) {\n      options.set = set;\n    }\n    return Object.defineProperty(obj, key, options);\n  }\n\n  var Obj = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    each: each,\n    reduce: reduce,\n    isObject: isObject$1,\n    isPlain: isPlain,\n    merge: merge$2,\n    defineLazyProperty: defineLazyProperty\n  });\n\n  /**\n   * @file browser.js\n   * @module browser\n   */\n\n  /**\n   * Whether or not this device is an iPod.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_IPOD = false;\n\n  /**\n   * The detected iOS version - or `null`.\n   *\n   * @static\n   * @type {string|null}\n   */\n  let IOS_VERSION = null;\n\n  /**\n   * Whether or not this is an Android device.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_ANDROID = false;\n\n  /**\n   * The detected Android version - or `null` if not Android or indeterminable.\n   *\n   * @static\n   * @type {number|string|null}\n   */\n  let ANDROID_VERSION;\n\n  /**\n   * Whether or not this is Mozilla Firefox.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_FIREFOX = false;\n\n  /**\n   * Whether or not this is Microsoft Edge.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_EDGE = false;\n\n  /**\n   * Whether or not this is any Chromium Browser\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_CHROMIUM = false;\n\n  /**\n   * Whether or not this is any Chromium browser that is not Edge.\n   *\n   * This will also be `true` for Chrome on iOS, which will have different support\n   * as it is actually Safari under the hood.\n   *\n   * Depreacted, as the behaviour to not match Edge was to prevent Legacy Edge's UA matching.\n   * IS_CHROMIUM should be used instead.\n   * \"Chromium but not Edge\" could be explicitly tested with IS_CHROMIUM && !IS_EDGE\n   *\n   * @static\n   * @deprecated\n   * @type {Boolean}\n   */\n  let IS_CHROME = false;\n\n  /**\n   * The detected Chromium version - or `null`.\n   *\n   * @static\n   * @type {number|null}\n   */\n  let CHROMIUM_VERSION = null;\n\n  /**\n   * The detected Google Chrome version - or `null`.\n   * This has always been the _Chromium_ version, i.e. would return on Chromium Edge.\n   * Depreacted, use CHROMIUM_VERSION instead.\n   *\n   * @static\n   * @deprecated\n   * @type {number|null}\n   */\n  let CHROME_VERSION = null;\n\n  /**\n   * The detected Internet Explorer version - or `null`.\n   *\n   * @static\n   * @deprecated\n   * @type {number|null}\n   */\n  let IE_VERSION = null;\n\n  /**\n   * Whether or not this is desktop Safari.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_SAFARI = false;\n\n  /**\n   * Whether or not this is a Windows machine.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_WINDOWS = false;\n\n  /**\n   * Whether or not this device is an iPad.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  let IS_IPAD = false;\n\n  /**\n   * Whether or not this device is an iPhone.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  // The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n  // to identify iPhones, we need to exclude iPads.\n  // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\n  let IS_IPHONE = false;\n\n  /**\n   * Whether or not this device is touch-enabled.\n   *\n   * @static\n   * @const\n   * @type {Boolean}\n   */\n  const TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));\n  const UAD = window.navigator && window.navigator.userAgentData;\n  if (UAD) {\n    // If userAgentData is present, use it instead of userAgent to avoid warnings\n    // Currently only implemented on Chromium\n    // userAgentData does not expose Android version, so ANDROID_VERSION remains `null`\n\n    IS_ANDROID = UAD.platform === 'Android';\n    IS_EDGE = Boolean(UAD.brands.find(b => b.brand === 'Microsoft Edge'));\n    IS_CHROMIUM = Boolean(UAD.brands.find(b => b.brand === 'Chromium'));\n    IS_CHROME = !IS_EDGE && IS_CHROMIUM;\n    CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find(b => b.brand === 'Chromium') || {}).version || null;\n    IS_WINDOWS = UAD.platform === 'Windows';\n  }\n\n  // If the broser is not Chromium, either userAgentData is not present which could be an old Chromium browser,\n  //  or it's a browser that has added userAgentData since that we don't have tests for yet. In either case,\n  // the checks need to be made agiainst the regular userAgent string.\n  if (!IS_CHROMIUM) {\n    const USER_AGENT = window.navigator && window.navigator.userAgent || '';\n    IS_IPOD = /iPod/i.test(USER_AGENT);\n    IOS_VERSION = function () {\n      const match = USER_AGENT.match(/OS (\\d+)_/i);\n      if (match && match[1]) {\n        return match[1];\n      }\n      return null;\n    }();\n    IS_ANDROID = /Android/i.test(USER_AGENT);\n    ANDROID_VERSION = function () {\n      // This matches Android Major.Minor.Patch versions\n      // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n      const match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n      if (!match) {\n        return null;\n      }\n      const major = match[1] && parseFloat(match[1]);\n      const minor = match[2] && parseFloat(match[2]);\n      if (major && minor) {\n        return parseFloat(match[1] + '.' + match[2]);\n      } else if (major) {\n        return major;\n      }\n      return null;\n    }();\n    IS_FIREFOX = /Firefox/i.test(USER_AGENT);\n    IS_EDGE = /Edg/i.test(USER_AGENT);\n    IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);\n    IS_CHROME = !IS_EDGE && IS_CHROMIUM;\n    CHROMIUM_VERSION = CHROME_VERSION = function () {\n      const match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\n      if (match && match[2]) {\n        return parseFloat(match[2]);\n      }\n      return null;\n    }();\n    IE_VERSION = function () {\n      const result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n      let version = result && parseFloat(result[1]);\n      if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n        // IE 11 has a different user agent string than other IE versions\n        version = 11.0;\n      }\n      return version;\n    }();\n    IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\n    IS_WINDOWS = /Windows/i.test(USER_AGENT);\n    IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);\n    IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\n  }\n\n  /**\n   * Whether or not this is an iOS device.\n   *\n   * @static\n   * @const\n   * @type {Boolean}\n   */\n  const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n\n  /**\n   * Whether or not this is any flavor of Safari - including iOS.\n   *\n   * @static\n   * @const\n   * @type {Boolean}\n   */\n  const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\n\n  var browser = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get IS_IPOD () { return IS_IPOD; },\n    get IOS_VERSION () { return IOS_VERSION; },\n    get IS_ANDROID () { return IS_ANDROID; },\n    get ANDROID_VERSION () { return ANDROID_VERSION; },\n    get IS_FIREFOX () { return IS_FIREFOX; },\n    get IS_EDGE () { return IS_EDGE; },\n    get IS_CHROMIUM () { return IS_CHROMIUM; },\n    get IS_CHROME () { return IS_CHROME; },\n    get CHROMIUM_VERSION () { return CHROMIUM_VERSION; },\n    get CHROME_VERSION () { return CHROME_VERSION; },\n    get IE_VERSION () { return IE_VERSION; },\n    get IS_SAFARI () { return IS_SAFARI; },\n    get IS_WINDOWS () { return IS_WINDOWS; },\n    get IS_IPAD () { return IS_IPAD; },\n    get IS_IPHONE () { return IS_IPHONE; },\n    TOUCH_ENABLED: TOUCH_ENABLED,\n    IS_IOS: IS_IOS,\n    IS_ANY_SAFARI: IS_ANY_SAFARI\n  });\n\n  /**\n   * @file dom.js\n   * @module dom\n   */\n\n  /**\n   * Detect if a value is a string with any non-whitespace characters.\n   *\n   * @private\n   * @param  {string} str\n   *         The string to check\n   *\n   * @return {boolean}\n   *         Will be `true` if the string is non-blank, `false` otherwise.\n   *\n   */\n  function isNonBlankString(str) {\n    // we use str.trim as it will trim any whitespace characters\n    // from the front or back of non-whitespace characters. aka\n    // Any string that contains non-whitespace characters will\n    // still contain them after `trim` but whitespace only strings\n    // will have a length of 0, failing this check.\n    return typeof str === 'string' && Boolean(str.trim());\n  }\n\n  /**\n   * Throws an error if the passed string has whitespace. This is used by\n   * class methods to be relatively consistent with the classList API.\n   *\n   * @private\n   * @param  {string} str\n   *         The string to check for whitespace.\n   *\n   * @throws {Error}\n   *         Throws an error if there is whitespace in the string.\n   */\n  function throwIfWhitespace(str) {\n    // str.indexOf instead of regex because str.indexOf is faster performance wise.\n    if (str.indexOf(' ') >= 0) {\n      throw new Error('class has illegal whitespace characters');\n    }\n  }\n\n  /**\n   * Whether the current DOM interface appears to be real (i.e. not simulated).\n   *\n   * @return {boolean}\n   *         Will be `true` if the DOM appears to be real, `false` otherwise.\n   */\n  function isReal() {\n    // Both document and window will never be undefined thanks to `global`.\n    return document === window.document;\n  }\n\n  /**\n   * Determines, via duck typing, whether or not a value is a DOM element.\n   *\n   * @param  {Mixed} value\n   *         The value to check.\n   *\n   * @return {boolean}\n   *         Will be `true` if the value is a DOM element, `false` otherwise.\n   */\n  function isEl(value) {\n    return isObject$1(value) && value.nodeType === 1;\n  }\n\n  /**\n   * Determines if the current DOM is embedded in an iframe.\n   *\n   * @return {boolean}\n   *         Will be `true` if the DOM is embedded in an iframe, `false`\n   *         otherwise.\n   */\n  function isInFrame() {\n    // We need a try/catch here because Safari will throw errors when attempting\n    // to get either `parent` or `self`\n    try {\n      return window.parent !== window.self;\n    } catch (x) {\n      return true;\n    }\n  }\n\n  /**\n   * Creates functions to query the DOM using a given method.\n   *\n   * @private\n   * @param   {string} method\n   *          The method to create the query with.\n   *\n   * @return  {Function}\n   *          The query method\n   */\n  function createQuerier(method) {\n    return function (selector, context) {\n      if (!isNonBlankString(selector)) {\n        return document[method](null);\n      }\n      if (isNonBlankString(context)) {\n        context = document.querySelector(context);\n      }\n      const ctx = isEl(context) ? context : document;\n      return ctx[method] && ctx[method](selector);\n    };\n  }\n\n  /**\n   * Creates an element and applies properties, attributes, and inserts content.\n   *\n   * @param  {string} [tagName='div']\n   *         Name of tag to be created.\n   *\n   * @param  {Object} [properties={}]\n   *         Element properties to be applied.\n   *\n   * @param  {Object} [attributes={}]\n   *         Element attributes to be applied.\n   *\n   * @param {module:dom~ContentDescriptor} content\n   *        A content descriptor object.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  function createEl(tagName = 'div', properties = {}, attributes = {}, content) {\n    const el = document.createElement(tagName);\n    Object.getOwnPropertyNames(properties).forEach(function (propName) {\n      const val = properties[propName];\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n      if (propName === 'textContent') {\n        textContent(el, val);\n      } else if (el[propName] !== val || propName === 'tabIndex') {\n        el[propName] = val;\n      }\n    });\n    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n      el.setAttribute(attrName, attributes[attrName]);\n    });\n    if (content) {\n      appendContent(el, content);\n    }\n    return el;\n  }\n\n  /**\n   * Injects text into an element, replacing any existing contents entirely.\n   *\n   * @param  {Element} el\n   *         The element to add text content into\n   *\n   * @param  {string} text\n   *         The text content to add.\n   *\n   * @return {Element}\n   *         The element with added text content.\n   */\n  function textContent(el, text) {\n    if (typeof el.textContent === 'undefined') {\n      el.innerText = text;\n    } else {\n      el.textContent = text;\n    }\n    return el;\n  }\n\n  /**\n   * Insert an element as the first child node of another\n   *\n   * @param {Element} child\n   *        Element to insert\n   *\n   * @param {Element} parent\n   *        Element to insert child into\n   */\n  function prependTo(child, parent) {\n    if (parent.firstChild) {\n      parent.insertBefore(child, parent.firstChild);\n    } else {\n      parent.appendChild(child);\n    }\n  }\n\n  /**\n   * Check if an element has a class name.\n   *\n   * @param  {Element} element\n   *         Element to check\n   *\n   * @param  {string} classToCheck\n   *         Class name to check for\n   *\n   * @return {boolean}\n   *         Will be `true` if the element has a class, `false` otherwise.\n   *\n   * @throws {Error}\n   *         Throws an error if `classToCheck` has white space.\n   */\n  function hasClass(element, classToCheck) {\n    throwIfWhitespace(classToCheck);\n    return element.classList.contains(classToCheck);\n  }\n\n  /**\n   * Add a class name to an element.\n   *\n   * @param  {Element} element\n   *         Element to add class name to.\n   *\n   * @param  {...string} classesToAdd\n   *         One or more class name to add.\n   *\n   * @return {Element}\n   *         The DOM element with the added class name.\n   */\n  function addClass(element, ...classesToAdd) {\n    element.classList.add(...classesToAdd.reduce((prev, current) => prev.concat(current.split(/\\s+/)), []));\n    return element;\n  }\n\n  /**\n   * Remove a class name from an element.\n   *\n   * @param  {Element} element\n   *         Element to remove a class name from.\n   *\n   * @param  {...string} classesToRemove\n   *         One or more class name to remove.\n   *\n   * @return {Element}\n   *         The DOM element with class name removed.\n   */\n  function removeClass(element, ...classesToRemove) {\n    // Protect in case the player gets disposed\n    if (!element) {\n      log$1.warn(\"removeClass was called with an element that doesn't exist\");\n      return null;\n    }\n    element.classList.remove(...classesToRemove.reduce((prev, current) => prev.concat(current.split(/\\s+/)), []));\n    return element;\n  }\n\n  /**\n   * The callback definition for toggleClass.\n   *\n   * @callback module:dom~PredicateCallback\n   * @param    {Element} element\n   *           The DOM element of the Component.\n   *\n   * @param    {string} classToToggle\n   *           The `className` that wants to be toggled\n   *\n   * @return   {boolean|undefined}\n   *           If `true` is returned, the `classToToggle` will be added to the\n   *           `element`. If `false`, the `classToToggle` will be removed from\n   *           the `element`. If `undefined`, the callback will be ignored.\n   */\n\n  /**\n   * Adds or removes a class name to/from an element depending on an optional\n   * condition or the presence/absence of the class name.\n   *\n   * @param  {Element} element\n   *         The element to toggle a class name on.\n   *\n   * @param  {string} classToToggle\n   *         The class that should be toggled.\n   *\n   * @param  {boolean|module:dom~PredicateCallback} [predicate]\n   *         See the return value for {@link module:dom~PredicateCallback}\n   *\n   * @return {Element}\n   *         The element with a class that has been toggled.\n   */\n  function toggleClass(element, classToToggle, predicate) {\n    if (typeof predicate === 'function') {\n      predicate = predicate(element, classToToggle);\n    }\n    if (typeof predicate !== 'boolean') {\n      predicate = undefined;\n    }\n    classToToggle.split(/\\s+/).forEach(className => element.classList.toggle(className, predicate));\n    return element;\n  }\n\n  /**\n   * Apply attributes to an HTML element.\n   *\n   * @param {Element} el\n   *        Element to add attributes to.\n   *\n   * @param {Object} [attributes]\n   *        Attributes to be applied.\n   */\n  function setAttributes(el, attributes) {\n    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n      const attrValue = attributes[attrName];\n      if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n        el.removeAttribute(attrName);\n      } else {\n        el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n      }\n    });\n  }\n\n  /**\n   * Get an element's attribute values, as defined on the HTML tag.\n   *\n   * Attributes are not the same as properties. They're defined on the tag\n   * or with setAttribute.\n   *\n   * @param  {Element} tag\n   *         Element from which to get tag attributes.\n   *\n   * @return {Object}\n   *         All attributes of the element. Boolean attributes will be `true` or\n   *         `false`, others will be strings.\n   */\n  function getAttributes(tag) {\n    const obj = {};\n\n    // known boolean attributes\n    // we can check for matching boolean properties, but not all browsers\n    // and not all tags know about these attributes, so, we still want to check them manually\n    const knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n    if (tag && tag.attributes && tag.attributes.length > 0) {\n      const attrs = tag.attributes;\n      for (let i = attrs.length - 1; i >= 0; i--) {\n        const attrName = attrs[i].name;\n        let attrVal = attrs[i].value;\n\n        // check for known booleans\n        // the matching element property will return a value for typeof\n        if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n          // the value of an included boolean attribute is typically an empty\n          // string ('') which would equal false if we just check for a false value.\n          // we also don't want support bad code like autoplay='false'\n          attrVal = attrVal !== null ? true : false;\n        }\n        obj[attrName] = attrVal;\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Get the value of an element's attribute.\n   *\n   * @param {Element} el\n   *        A DOM element.\n   *\n   * @param {string} attribute\n   *        Attribute to get the value of.\n   *\n   * @return {string}\n   *         The value of the attribute.\n   */\n  function getAttribute(el, attribute) {\n    return el.getAttribute(attribute);\n  }\n\n  /**\n   * Set the value of an element's attribute.\n   *\n   * @param {Element} el\n   *        A DOM element.\n   *\n   * @param {string} attribute\n   *        Attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   */\n  function setAttribute(el, attribute, value) {\n    el.setAttribute(attribute, value);\n  }\n\n  /**\n   * Remove an element's attribute.\n   *\n   * @param {Element} el\n   *        A DOM element.\n   *\n   * @param {string} attribute\n   *        Attribute to remove.\n   */\n  function removeAttribute(el, attribute) {\n    el.removeAttribute(attribute);\n  }\n\n  /**\n   * Attempt to block the ability to select text.\n   */\n  function blockTextSelection() {\n    document.body.focus();\n    document.onselectstart = function () {\n      return false;\n    };\n  }\n\n  /**\n   * Turn off text selection blocking.\n   */\n  function unblockTextSelection() {\n    document.onselectstart = function () {\n      return true;\n    };\n  }\n\n  /**\n   * Identical to the native `getBoundingClientRect` function, but ensures that\n   * the method is supported at all (it is in all browsers we claim to support)\n   * and that the element is in the DOM before continuing.\n   *\n   * This wrapper function also shims properties which are not provided by some\n   * older browsers (namely, IE8).\n   *\n   * Additionally, some browsers do not support adding properties to a\n   * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n   * properties (except `x` and `y` which are not widely supported). This helps\n   * avoid implementations where keys are non-enumerable.\n   *\n   * @param  {Element} el\n   *         Element whose `ClientRect` we want to calculate.\n   *\n   * @return {Object|undefined}\n   *         Always returns a plain object - or `undefined` if it cannot.\n   */\n  function getBoundingClientRect(el) {\n    if (el && el.getBoundingClientRect && el.parentNode) {\n      const rect = el.getBoundingClientRect();\n      const result = {};\n      ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(k => {\n        if (rect[k] !== undefined) {\n          result[k] = rect[k];\n        }\n      });\n      if (!result.height) {\n        result.height = parseFloat(computedStyle(el, 'height'));\n      }\n      if (!result.width) {\n        result.width = parseFloat(computedStyle(el, 'width'));\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Represents the position of a DOM element on the page.\n   *\n   * @typedef  {Object} module:dom~Position\n   *\n   * @property {number} left\n   *           Pixels to the left.\n   *\n   * @property {number} top\n   *           Pixels from the top.\n   */\n\n  /**\n   * Get the position of an element in the DOM.\n   *\n   * Uses `getBoundingClientRect` technique from John Resig.\n   *\n   * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n   *\n   * @param  {Element} el\n   *         Element from which to get offset.\n   *\n   * @return {module:dom~Position}\n   *         The position of the element that was passed in.\n   */\n  function findPosition(el) {\n    if (!el || el && !el.offsetParent) {\n      return {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      };\n    }\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    let left = 0;\n    let top = 0;\n    while (el.offsetParent && el !== document[FullscreenApi.fullscreenElement]) {\n      left += el.offsetLeft;\n      top += el.offsetTop;\n      el = el.offsetParent;\n    }\n    return {\n      left,\n      top,\n      width,\n      height\n    };\n  }\n\n  /**\n   * Represents x and y coordinates for a DOM element or mouse pointer.\n   *\n   * @typedef  {Object} module:dom~Coordinates\n   *\n   * @property {number} x\n   *           x coordinate in pixels\n   *\n   * @property {number} y\n   *           y coordinate in pixels\n   */\n\n  /**\n   * Get the pointer position within an element.\n   *\n   * The base on the coordinates are the bottom left of the element.\n   *\n   * @param  {Element} el\n   *         Element on which to get the pointer position on.\n   *\n   * @param  {EventTarget~Event} event\n   *         Event object.\n   *\n   * @return {module:dom~Coordinates}\n   *         A coordinates object corresponding to the mouse position.\n   *\n   */\n  function getPointerPosition(el, event) {\n    const translated = {\n      x: 0,\n      y: 0\n    };\n    if (IS_IOS) {\n      let item = el;\n      while (item && item.nodeName.toLowerCase() !== 'html') {\n        const transform = computedStyle(item, 'transform');\n        if (/^matrix/.test(transform)) {\n          const values = transform.slice(7, -1).split(/,\\s/).map(Number);\n          translated.x += values[4];\n          translated.y += values[5];\n        } else if (/^matrix3d/.test(transform)) {\n          const values = transform.slice(9, -1).split(/,\\s/).map(Number);\n          translated.x += values[12];\n          translated.y += values[13];\n        }\n        item = item.parentNode;\n      }\n    }\n    const position = {};\n    const boxTarget = findPosition(event.target);\n    const box = findPosition(el);\n    const boxW = box.width;\n    const boxH = box.height;\n    let offsetY = event.offsetY - (box.top - boxTarget.top);\n    let offsetX = event.offsetX - (box.left - boxTarget.left);\n    if (event.changedTouches) {\n      offsetX = event.changedTouches[0].pageX - box.left;\n      offsetY = event.changedTouches[0].pageY + box.top;\n      if (IS_IOS) {\n        offsetX -= translated.x;\n        offsetY -= translated.y;\n      }\n    }\n    position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));\n    position.x = Math.max(0, Math.min(1, offsetX / boxW));\n    return position;\n  }\n\n  /**\n   * Determines, via duck typing, whether or not a value is a text node.\n   *\n   * @param  {Mixed} value\n   *         Check if this value is a text node.\n   *\n   * @return {boolean}\n   *         Will be `true` if the value is a text node, `false` otherwise.\n   */\n  function isTextNode$1(value) {\n    return isObject$1(value) && value.nodeType === 3;\n  }\n\n  /**\n   * Empties the contents of an element.\n   *\n   * @param  {Element} el\n   *         The element to empty children from\n   *\n   * @return {Element}\n   *         The element with no children\n   */\n  function emptyEl(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n    return el;\n  }\n\n  /**\n   * This is a mixed value that describes content to be injected into the DOM\n   * via some method. It can be of the following types:\n   *\n   * Type       | Description\n   * -----------|-------------\n   * `string`   | The value will be normalized into a text node.\n   * `Element`  | The value will be accepted as-is.\n   * `TextNode` | The value will be accepted as-is.\n   * `Array`    | A one-dimensional array of strings, elements, text nodes, or functions. These functions should return a string, element, or text node (any other return value, like an array, will be ignored).\n   * `Function` | A function, which is expected to return a string, element, text node, or array - any of the other possible values described above. This means that a content descriptor could be a function that returns an array of functions, but those second-level functions must return strings, elements, or text nodes.\n   *\n   * @typedef {string|Element|TextNode|Array|Function} module:dom~ContentDescriptor\n   */\n\n  /**\n   * Normalizes content for eventual insertion into the DOM.\n   *\n   * This allows a wide range of content definition methods, but helps protect\n   * from falling into the trap of simply writing to `innerHTML`, which could\n   * be an XSS concern.\n   *\n   * The content for an element can be passed in multiple types and\n   * combinations, whose behavior is as follows:\n   *\n   * @param {module:dom~ContentDescriptor} content\n   *        A content descriptor value.\n   *\n   * @return {Array}\n   *         All of the content that was passed in, normalized to an array of\n   *         elements or text nodes.\n   */\n  function normalizeContent(content) {\n    // First, invoke content if it is a function. If it produces an array,\n    // that needs to happen before normalization.\n    if (typeof content === 'function') {\n      content = content();\n    }\n\n    // Next up, normalize to an array, so one or many items can be normalized,\n    // filtered, and returned.\n    return (Array.isArray(content) ? content : [content]).map(value => {\n      // First, invoke value if it is a function to produce a new value,\n      // which will be subsequently normalized to a Node of some kind.\n      if (typeof value === 'function') {\n        value = value();\n      }\n      if (isEl(value) || isTextNode$1(value)) {\n        return value;\n      }\n      if (typeof value === 'string' && /\\S/.test(value)) {\n        return document.createTextNode(value);\n      }\n    }).filter(value => value);\n  }\n\n  /**\n   * Normalizes and appends content to an element.\n   *\n   * @param  {Element} el\n   *         Element to append normalized content to.\n   *\n   * @param {module:dom~ContentDescriptor} content\n   *        A content descriptor value.\n   *\n   * @return {Element}\n   *         The element with appended normalized content.\n   */\n  function appendContent(el, content) {\n    normalizeContent(content).forEach(node => el.appendChild(node));\n    return el;\n  }\n\n  /**\n   * Normalizes and inserts content into an element; this is identical to\n   * `appendContent()`, except it empties the element first.\n   *\n   * @param {Element} el\n   *        Element to insert normalized content into.\n   *\n   * @param {module:dom~ContentDescriptor} content\n   *        A content descriptor value.\n   *\n   * @return {Element}\n   *         The element with inserted normalized content.\n   */\n  function insertContent(el, content) {\n    return appendContent(emptyEl(el), content);\n  }\n\n  /**\n   * Check if an event was a single left click.\n   *\n   * @param  {EventTarget~Event} event\n   *         Event object.\n   *\n   * @return {boolean}\n   *         Will be `true` if a single left click, `false` otherwise.\n   */\n  function isSingleLeftClick(event) {\n    // Note: if you create something draggable, be sure to\n    // call it on both `mousedown` and `mousemove` event,\n    // otherwise `mousedown` should be enough for a button\n\n    if (event.button === undefined && event.buttons === undefined) {\n      // Why do we need `buttons` ?\n      // Because, middle mouse sometimes have this:\n      // e.button === 0 and e.buttons === 4\n      // Furthermore, we want to prevent combination click, something like\n      // HOLD middlemouse then left click, that would be\n      // e.button === 0, e.buttons === 5\n      // just `button` is not gonna work\n\n      // Alright, then what this block does ?\n      // this is for chrome `simulate mobile devices`\n      // I want to support this as well\n\n      return true;\n    }\n    if (event.button === 0 && event.buttons === undefined) {\n      // Touch screen, sometimes on some specific device, `buttons`\n      // doesn't have anything (safari on ios, blackberry...)\n\n      return true;\n    }\n\n    // `mouseup` event on a single left click has\n    // `button` and `buttons` equal to 0\n    if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {\n      return true;\n    }\n    if (event.button !== 0 || event.buttons !== 1) {\n      // This is the reason we have those if else block above\n      // if any special case we can catch and let it slide\n      // we do it above, when get to here, this definitely\n      // is-not-left-click\n\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Finds a single DOM element matching `selector` within the optional\n   * `context` of another DOM element (defaulting to `document`).\n   *\n   * @param  {string} selector\n   *         A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param  {Element|String} [context=document]\n   *         A DOM element within which to query. Can also be a selector\n   *         string in which case the first matching element will be used\n   *         as context. If missing (or no element matches selector), falls\n   *         back to `document`.\n   *\n   * @return {Element|null}\n   *         The element that was found or null.\n   */\n  const $ = createQuerier('querySelector');\n\n  /**\n   * Finds a all DOM elements matching `selector` within the optional\n   * `context` of another DOM element (defaulting to `document`).\n   *\n   * @param  {string} selector\n   *         A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param  {Element|String} [context=document]\n   *         A DOM element within which to query. Can also be a selector\n   *         string in which case the first matching element will be used\n   *         as context. If missing (or no element matches selector), falls\n   *         back to `document`.\n   *\n   * @return {NodeList}\n   *         A element list of elements that were found. Will be empty if none\n   *         were found.\n   *\n   */\n  const $$ = createQuerier('querySelectorAll');\n\n  /**\n   * A safe getComputedStyle.\n   *\n   * This is needed because in Firefox, if the player is loaded in an iframe with\n   * `display:none`, then `getComputedStyle` returns `null`, so, we do a\n   * null-check to make sure that the player doesn't break in these cases.\n   *\n   * @param    {Element} el\n   *           The element you want the computed style of\n   *\n   * @param    {string} prop\n   *           The property name you want\n   *\n   * @see      https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n   */\n  function computedStyle(el, prop) {\n    if (!el || !prop) {\n      return '';\n    }\n    if (typeof window.getComputedStyle === 'function') {\n      let computedStyleValue;\n      try {\n        computedStyleValue = window.getComputedStyle(el);\n      } catch (e) {\n        return '';\n      }\n      return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';\n    }\n    return '';\n  }\n\n  var Dom = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isReal: isReal,\n    isEl: isEl,\n    isInFrame: isInFrame,\n    createEl: createEl,\n    textContent: textContent,\n    prependTo: prependTo,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    toggleClass: toggleClass,\n    setAttributes: setAttributes,\n    getAttributes: getAttributes,\n    getAttribute: getAttribute,\n    setAttribute: setAttribute,\n    removeAttribute: removeAttribute,\n    blockTextSelection: blockTextSelection,\n    unblockTextSelection: unblockTextSelection,\n    getBoundingClientRect: getBoundingClientRect,\n    findPosition: findPosition,\n    getPointerPosition: getPointerPosition,\n    isTextNode: isTextNode$1,\n    emptyEl: emptyEl,\n    normalizeContent: normalizeContent,\n    appendContent: appendContent,\n    insertContent: insertContent,\n    isSingleLeftClick: isSingleLeftClick,\n    $: $,\n    $$: $$,\n    computedStyle: computedStyle\n  });\n\n  /**\n   * @file setup.js - Functions for setting up a player without\n   * user interaction based on the data-setup `attribute` of the video tag.\n   *\n   * @module setup\n   */\n  let _windowLoaded = false;\n  let videojs$1;\n\n  /**\n   * Set up any tags that have a data-setup `attribute` when the player is started.\n   */\n  const autoSetup = function () {\n    if (videojs$1.options.autoSetup === false) {\n      return;\n    }\n    const vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n    const audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n    const divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));\n    const mediaEls = vids.concat(audios, divs);\n\n    // Check if any media elements exist\n    if (mediaEls && mediaEls.length > 0) {\n      for (let i = 0, e = mediaEls.length; i < e; i++) {\n        const mediaEl = mediaEls[i];\n\n        // Check if element exists, has getAttribute func.\n        if (mediaEl && mediaEl.getAttribute) {\n          // Make sure this player hasn't already been set up.\n          if (mediaEl.player === undefined) {\n            const options = mediaEl.getAttribute('data-setup');\n\n            // Check if data-setup attr exists.\n            // We only auto-setup if they've added the data-setup attr.\n            if (options !== null) {\n              // Create new video.js instance.\n              videojs$1(mediaEl);\n            }\n          }\n\n          // If getAttribute isn't defined, we need to wait for the DOM.\n        } else {\n          autoSetupTimeout(1);\n          break;\n        }\n      }\n\n      // No videos were found, so keep looping unless page is finished loading.\n    } else if (!_windowLoaded) {\n      autoSetupTimeout(1);\n    }\n  };\n\n  /**\n   * Wait until the page is loaded before running autoSetup. This will be called in\n   * autoSetup if `hasLoaded` returns false.\n   *\n   * @param {number} wait\n   *        How long to wait in ms\n   *\n   * @param {module:videojs} [vjs]\n   *        The videojs library function\n   */\n  function autoSetupTimeout(wait, vjs) {\n    // Protect against breakage in non-browser environments\n    if (!isReal()) {\n      return;\n    }\n    if (vjs) {\n      videojs$1 = vjs;\n    }\n    window.setTimeout(autoSetup, wait);\n  }\n\n  /**\n   * Used to set the internal tracking of window loaded state to true.\n   *\n   * @private\n   */\n  function setWindowLoaded() {\n    _windowLoaded = true;\n    window.removeEventListener('load', setWindowLoaded);\n  }\n  if (isReal()) {\n    if (document.readyState === 'complete') {\n      setWindowLoaded();\n    } else {\n      /**\n       * Listen for the load event on window, and set _windowLoaded to true.\n       *\n       * We use a standard event listener here to avoid incrementing the GUID\n       * before any players are created.\n       *\n       * @listens load\n       */\n      window.addEventListener('load', setWindowLoaded);\n    }\n  }\n\n  /**\n   * @file stylesheet.js\n   * @module stylesheet\n   */\n\n  /**\n   * Create a DOM syle element given a className for it.\n   *\n   * @param {string} className\n   *        The className to add to the created style element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  const createStyleElement = function (className) {\n    const style = document.createElement('style');\n    style.className = className;\n    return style;\n  };\n\n  /**\n   * Add text to a DOM element.\n   *\n   * @param {Element} el\n   *        The Element to add text content to.\n   *\n   * @param {string} content\n   *        The text to add to the element.\n   */\n  const setTextContent = function (el, content) {\n    if (el.styleSheet) {\n      el.styleSheet.cssText = content;\n    } else {\n      el.textContent = content;\n    }\n  };\n\n  /**\n   * @file dom-data.js\n   * @module dom-data\n   */\n\n  /**\n   * Element Data Store.\n   *\n   * Allows for binding data to an element without putting it directly on the\n   * element. Ex. Event listeners are stored here.\n   * (also from jsninja.com, slightly modified and updated for closure compiler)\n   *\n   * @type {Object}\n   * @private\n   */\n  var DomData = new WeakMap();\n\n  /**\n   * @file guid.js\n   * @module guid\n   */\n\n  // Default value for GUIDs. This allows us to reset the GUID counter in tests.\n  //\n  // The initial GUID is 3 because some users have come to rely on the first\n  // default player ID ending up as `vjs_video_3`.\n  //\n  // See: https://github.com/videojs/video.js/pull/6216\n  const _initialGuid = 3;\n\n  /**\n   * Unique ID for an element or function\n   *\n   * @type {Number}\n   */\n  let _guid = _initialGuid;\n\n  /**\n   * Get a unique auto-incrementing ID by number that has not been returned before.\n   *\n   * @return {number}\n   *         A new unique ID.\n   */\n  function newGUID() {\n    return _guid++;\n  }\n\n  /**\n   * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n   * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n   * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n   * robust as jquery's, so there's probably some differences.\n   *\n   * @file events.js\n   * @module events\n   */\n\n  /**\n   * Clean up the listener cache and dispatchers\n   *\n   * @param {Element|Object} elem\n   *        Element to clean up\n   *\n   * @param {string} type\n   *        Type of event to clean up\n   */\n  function _cleanUpEvents(elem, type) {\n    if (!DomData.has(elem)) {\n      return;\n    }\n    const data = DomData.get(elem);\n\n    // Remove the events of a particular type if there are none left\n    if (data.handlers[type].length === 0) {\n      delete data.handlers[type];\n      // data.handlers[type] = null;\n      // Setting to null was causing an error with data.handlers\n\n      // Remove the meta-handler from the element\n      if (elem.removeEventListener) {\n        elem.removeEventListener(type, data.dispatcher, false);\n      } else if (elem.detachEvent) {\n        elem.detachEvent('on' + type, data.dispatcher);\n      }\n    }\n\n    // Remove the events object if there are no types left\n    if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n      delete data.handlers;\n      delete data.dispatcher;\n      delete data.disabled;\n    }\n\n    // Finally remove the element data if there is no data left\n    if (Object.getOwnPropertyNames(data).length === 0) {\n      DomData.delete(elem);\n    }\n  }\n\n  /**\n   * Loops through an array of event types and calls the requested method for each type.\n   *\n   * @param {Function} fn\n   *        The event method we want to use.\n   *\n   * @param {Element|Object} elem\n   *        Element or object to bind listeners to\n   *\n   * @param {string} type\n   *        Type of event to bind to.\n   *\n   * @param {EventTarget~EventListener} callback\n   *        Event listener.\n   */\n  function _handleMultipleEvents(fn, elem, types, callback) {\n    types.forEach(function (type) {\n      // Call the event method for each one of the types\n      fn(elem, type, callback);\n    });\n  }\n\n  /**\n   * Fix a native event to have standard property values\n   *\n   * @param {Object} event\n   *        Event object to fix.\n   *\n   * @return {Object}\n   *         Fixed event object.\n   */\n  function fixEvent(event) {\n    if (event.fixed_) {\n      return event;\n    }\n    function returnTrue() {\n      return true;\n    }\n    function returnFalse() {\n      return false;\n    }\n\n    // Test if fixing up is needed\n    // Used to check if !event.stopPropagation instead of isPropagationStopped\n    // But native events return true for stopPropagation, but don't have\n    // other expected methods like isPropagationStopped. Seems to be a problem\n    // with the Javascript Ninja code. So we're just overriding all events now.\n    if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {\n      const old = event || window.event;\n      event = {};\n      // Clone the old object so that we can modify the values event = {};\n      // IE8 Doesn't like when you mess with native event properties\n      // Firefox returns false for event.hasOwnProperty('type') and other props\n      //  which makes copying more difficult.\n      // TODO: Probably best to create a whitelist of event props\n      for (const key in old) {\n        // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n        // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n        // and webkitMovementX/Y\n        // Lighthouse complains if Event.path is copied\n        if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY' && key !== 'path') {\n          // Chrome 32+ warns if you try to copy deprecated returnValue, but\n          // we still want to if preventDefault isn't supported (IE8).\n          if (!(key === 'returnValue' && old.preventDefault)) {\n            event[key] = old[key];\n          }\n        }\n      }\n\n      // The event occurred on this element\n      if (!event.target) {\n        event.target = event.srcElement || document;\n      }\n\n      // Handle which other element the event is related to\n      if (!event.relatedTarget) {\n        event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n      }\n\n      // Stop the default browser action\n      event.preventDefault = function () {\n        if (old.preventDefault) {\n          old.preventDefault();\n        }\n        event.returnValue = false;\n        old.returnValue = false;\n        event.defaultPrevented = true;\n      };\n      event.defaultPrevented = false;\n\n      // Stop the event from bubbling\n      event.stopPropagation = function () {\n        if (old.stopPropagation) {\n          old.stopPropagation();\n        }\n        event.cancelBubble = true;\n        old.cancelBubble = true;\n        event.isPropagationStopped = returnTrue;\n      };\n      event.isPropagationStopped = returnFalse;\n\n      // Stop the event from bubbling and executing other handlers\n      event.stopImmediatePropagation = function () {\n        if (old.stopImmediatePropagation) {\n          old.stopImmediatePropagation();\n        }\n        event.isImmediatePropagationStopped = returnTrue;\n        event.stopPropagation();\n      };\n      event.isImmediatePropagationStopped = returnFalse;\n\n      // Handle mouse position\n      if (event.clientX !== null && event.clientX !== undefined) {\n        const doc = document.documentElement;\n        const body = document.body;\n        event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n\n      // Handle key presses\n      event.which = event.charCode || event.keyCode;\n\n      // Fix button for mouse clicks:\n      // 0 == left; 1 == middle; 2 == right\n      if (event.button !== null && event.button !== undefined) {\n        // The following is disabled because it does not pass videojs-standard\n        // and... yikes.\n        /* eslint-disable */\n        event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n        /* eslint-enable */\n      }\n    }\n\n    event.fixed_ = true;\n    // Returns fixed-up instance\n    return event;\n  }\n\n  /**\n   * Whether passive event listeners are supported\n   */\n  let _supportsPassive;\n  const supportsPassive = function () {\n    if (typeof _supportsPassive !== 'boolean') {\n      _supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          get() {\n            _supportsPassive = true;\n          }\n        });\n        window.addEventListener('test', null, opts);\n        window.removeEventListener('test', null, opts);\n      } catch (e) {\n        // disregard\n      }\n    }\n    return _supportsPassive;\n  };\n\n  /**\n   * Touch events Chrome expects to be passive\n   */\n  const passiveEvents = ['touchstart', 'touchmove'];\n\n  /**\n   * Add an event listener to element\n   * It stores the handler function in a separate cache object\n   * and adds a generic handler to the element's event,\n   * along with a unique id (guid) to the element.\n   *\n   * @param {Element|Object} elem\n   *        Element or object to bind listeners to\n   *\n   * @param {string|string[]} type\n   *        Type of event to bind to.\n   *\n   * @param {EventTarget~EventListener} fn\n   *        Event listener.\n   */\n  function on(elem, type, fn) {\n    if (Array.isArray(type)) {\n      return _handleMultipleEvents(on, elem, type, fn);\n    }\n    if (!DomData.has(elem)) {\n      DomData.set(elem, {});\n    }\n    const data = DomData.get(elem);\n\n    // We need a place to store all our handler data\n    if (!data.handlers) {\n      data.handlers = {};\n    }\n    if (!data.handlers[type]) {\n      data.handlers[type] = [];\n    }\n    if (!fn.guid) {\n      fn.guid = newGUID();\n    }\n    data.handlers[type].push(fn);\n    if (!data.dispatcher) {\n      data.disabled = false;\n      data.dispatcher = function (event, hash) {\n        if (data.disabled) {\n          return;\n        }\n        event = fixEvent(event);\n        const handlers = data.handlers[event.type];\n        if (handlers) {\n          // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n          const handlersCopy = handlers.slice(0);\n          for (let m = 0, n = handlersCopy.length; m < n; m++) {\n            if (event.isImmediatePropagationStopped()) {\n              break;\n            } else {\n              try {\n                handlersCopy[m].call(elem, event, hash);\n              } catch (e) {\n                log$1.error(e);\n              }\n            }\n          }\n        }\n      };\n    }\n    if (data.handlers[type].length === 1) {\n      if (elem.addEventListener) {\n        let options = false;\n        if (supportsPassive() && passiveEvents.indexOf(type) > -1) {\n          options = {\n            passive: true\n          };\n        }\n        elem.addEventListener(type, data.dispatcher, options);\n      } else if (elem.attachEvent) {\n        elem.attachEvent('on' + type, data.dispatcher);\n      }\n    }\n  }\n\n  /**\n   * Removes event listeners from an element\n   *\n   * @param {Element|Object} elem\n   *        Object to remove listeners from.\n   *\n   * @param {string|string[]} [type]\n   *        Type of listener to remove. Don't include to remove all events from element.\n   *\n   * @param {EventTarget~EventListener} [fn]\n   *        Specific listener to remove. Don't include to remove listeners for an event\n   *        type.\n   */\n  function off(elem, type, fn) {\n    // Don't want to add a cache object through getElData if not needed\n    if (!DomData.has(elem)) {\n      return;\n    }\n    const data = DomData.get(elem);\n\n    // If no events exist, nothing to unbind\n    if (!data.handlers) {\n      return;\n    }\n    if (Array.isArray(type)) {\n      return _handleMultipleEvents(off, elem, type, fn);\n    }\n\n    // Utility function\n    const removeType = function (el, t) {\n      data.handlers[t] = [];\n      _cleanUpEvents(el, t);\n    };\n\n    // Are we removing all bound events?\n    if (type === undefined) {\n      for (const t in data.handlers) {\n        if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n          removeType(elem, t);\n        }\n      }\n      return;\n    }\n    const handlers = data.handlers[type];\n\n    // If no handlers exist, nothing to unbind\n    if (!handlers) {\n      return;\n    }\n\n    // If no listener was provided, remove all listeners for type\n    if (!fn) {\n      removeType(elem, type);\n      return;\n    }\n\n    // We're only removing a single handler\n    if (fn.guid) {\n      for (let n = 0; n < handlers.length; n++) {\n        if (handlers[n].guid === fn.guid) {\n          handlers.splice(n--, 1);\n        }\n      }\n    }\n    _cleanUpEvents(elem, type);\n  }\n\n  /**\n   * Trigger an event for an element\n   *\n   * @param {Element|Object} elem\n   *        Element to trigger an event on\n   *\n   * @param {EventTarget~Event|string} event\n   *        A string (the type) or an event object with a type attribute\n   *\n   * @param {Object} [hash]\n   *        data hash to pass along with the event\n   *\n   * @return {boolean|undefined}\n   *         Returns the opposite of `defaultPrevented` if default was\n   *         prevented. Otherwise, returns `undefined`\n   */\n  function trigger(elem, event, hash) {\n    // Fetches element data and a reference to the parent (for bubbling).\n    // Don't want to add a data object to cache for every parent,\n    // so checking hasElData first.\n    const elemData = DomData.has(elem) ? DomData.get(elem) : {};\n    const parent = elem.parentNode || elem.ownerDocument;\n    // type = event.type || event,\n    // handler;\n\n    // If an event name was passed as a string, creates an event out of it\n    if (typeof event === 'string') {\n      event = {\n        type: event,\n        target: elem\n      };\n    } else if (!event.target) {\n      event.target = elem;\n    }\n\n    // Normalizes the event properties.\n    event = fixEvent(event);\n\n    // If the passed element has a dispatcher, executes the established handlers.\n    if (elemData.dispatcher) {\n      elemData.dispatcher.call(elem, event, hash);\n    }\n\n    // Unless explicitly stopped or the event does not bubble (e.g. media events)\n    // recursively calls this function to bubble the event up the DOM.\n    if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n      trigger.call(null, parent, event, hash);\n\n      // If at the top of the DOM, triggers the default action unless disabled.\n    } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {\n      if (!DomData.has(event.target)) {\n        DomData.set(event.target, {});\n      }\n      const targetData = DomData.get(event.target);\n\n      // Checks if the target has a default action for this event.\n      if (event.target[event.type]) {\n        // Temporarily disables event dispatching on the target as we have already executed the handler.\n        targetData.disabled = true;\n        // Executes the default action.\n        if (typeof event.target[event.type] === 'function') {\n          event.target[event.type]();\n        }\n        // Re-enables event dispatching.\n        targetData.disabled = false;\n      }\n    }\n\n    // Inform the triggerer if the default was prevented by returning false\n    return !event.defaultPrevented;\n  }\n\n  /**\n   * Trigger a listener only once for an event.\n   *\n   * @param {Element|Object} elem\n   *        Element or object to bind to.\n   *\n   * @param {string|string[]} type\n   *        Name/type of event\n   *\n   * @param {Event~EventListener} fn\n   *        Event listener function\n   */\n  function one(elem, type, fn) {\n    if (Array.isArray(type)) {\n      return _handleMultipleEvents(one, elem, type, fn);\n    }\n    const func = function () {\n      off(elem, type, func);\n      fn.apply(this, arguments);\n    };\n\n    // copy the guid to the new function so it can removed using the original function's ID\n    func.guid = fn.guid = fn.guid || newGUID();\n    on(elem, type, func);\n  }\n\n  /**\n   * Trigger a listener only once and then turn if off for all\n   * configured events\n   *\n   * @param {Element|Object} elem\n   *        Element or object to bind to.\n   *\n   * @param {string|string[]} type\n   *        Name/type of event\n   *\n   * @param {Event~EventListener} fn\n   *        Event listener function\n   */\n  function any(elem, type, fn) {\n    const func = function () {\n      off(elem, type, func);\n      fn.apply(this, arguments);\n    };\n\n    // copy the guid to the new function so it can removed using the original function's ID\n    func.guid = fn.guid = fn.guid || newGUID();\n\n    // multiple ons, but one off for everything\n    on(elem, type, func);\n  }\n\n  var Events = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fixEvent: fixEvent,\n    on: on,\n    off: off,\n    trigger: trigger,\n    one: one,\n    any: any\n  });\n\n  /**\n   * @file fn.js\n   * @module fn\n   */\n  const UPDATE_REFRESH_INTERVAL = 30;\n\n  /**\n   * A private, internal-only function for changing the context of a function.\n   *\n   * It also stores a unique id on the function so it can be easily removed from\n   * events.\n   *\n   * @private\n   * @function\n   * @param    {Mixed} context\n   *           The object to bind as scope.\n   *\n   * @param    {Function} fn\n   *           The function to be bound to a scope.\n   *\n   * @param    {number} [uid]\n   *           An optional unique ID for the function to be set\n   *\n   * @return   {Function}\n   *           The new function that will be bound into the context given\n   */\n  const bind_ = function (context, fn, uid) {\n    // Make sure the function has a unique ID\n    if (!fn.guid) {\n      fn.guid = newGUID();\n    }\n\n    // Create the new function that changes the context\n    const bound = fn.bind(context);\n\n    // Allow for the ability to individualize this function\n    // Needed in the case where multiple objects might share the same prototype\n    // IF both items add an event listener with the same function, then you try to remove just one\n    // it will remove both because they both have the same guid.\n    // when using this, you need to use the bind method when you remove the listener as well.\n    // currently used in text tracks\n    bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n    return bound;\n  };\n\n  /**\n   * Wraps the given function, `fn`, with a new function that only invokes `fn`\n   * at most once per every `wait` milliseconds.\n   *\n   * @function\n   * @param    {Function} fn\n   *           The function to be throttled.\n   *\n   * @param    {number}   wait\n   *           The number of milliseconds by which to throttle.\n   *\n   * @return   {Function}\n   */\n  const throttle = function (fn, wait) {\n    let last = window.performance.now();\n    const throttled = function (...args) {\n      const now = window.performance.now();\n      if (now - last >= wait) {\n        fn(...args);\n        last = now;\n      }\n    };\n    return throttled;\n  };\n\n  /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked.\n   *\n   * Inspired by lodash and underscore implementations.\n   *\n   * @function\n   * @param    {Function} func\n   *           The function to wrap with debounce behavior.\n   *\n   * @param    {number} wait\n   *           The number of milliseconds to wait after the last invocation.\n   *\n   * @param    {boolean} [immediate]\n   *           Whether or not to invoke the function immediately upon creation.\n   *\n   * @param    {Object} [context=window]\n   *           The \"context\" in which the debounced function should debounce. For\n   *           example, if this function should be tied to a Video.js player,\n   *           the player can be passed here. Alternatively, defaults to the\n   *           global `window` object.\n   *\n   * @return   {Function}\n   *           A debounced function.\n   */\n  const debounce = function (func, wait, immediate, context = window) {\n    let timeout;\n    const cancel = () => {\n      context.clearTimeout(timeout);\n      timeout = null;\n    };\n\n    /* eslint-disable consistent-this */\n    const debounced = function () {\n      const self = this;\n      const args = arguments;\n      let later = function () {\n        timeout = null;\n        later = null;\n        if (!immediate) {\n          func.apply(self, args);\n        }\n      };\n      if (!timeout && immediate) {\n        func.apply(self, args);\n      }\n      context.clearTimeout(timeout);\n      timeout = context.setTimeout(later, wait);\n    };\n    /* eslint-enable consistent-this */\n\n    debounced.cancel = cancel;\n    return debounced;\n  };\n\n  var Fn = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    UPDATE_REFRESH_INTERVAL: UPDATE_REFRESH_INTERVAL,\n    bind_: bind_,\n    throttle: throttle,\n    debounce: debounce\n  });\n\n  /**\n   * @file src/js/event-target.js\n   */\n  let EVENT_MAP;\n\n  /**\n   * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n   * adds shorthand functions that wrap around lengthy functions. For example:\n   * the `on` function is a wrapper around `addEventListener`.\n   *\n   * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n   * @class EventTarget\n   */\n  class EventTarget$2 {\n    /**\n     * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n     * function that will get called when an event with a certain name gets triggered.\n     *\n     * @param {string|string[]} type\n     *        An event name or an array of event names.\n     *\n     * @param {EventTarget~EventListener} fn\n     *        The function to call with `EventTarget`s\n     */\n    on(type, fn) {\n      // Remove the addEventListener alias before calling Events.on\n      // so we don't get into an infinite type loop\n      const ael = this.addEventListener;\n      this.addEventListener = () => {};\n      on(this, type, fn);\n      this.addEventListener = ael;\n    }\n    /**\n     * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n     * This makes it so that the `event listener` will no longer get called when the\n     * named event happens.\n     *\n     * @param {string|string[]} type\n     *        An event name or an array of event names.\n     *\n     * @param {EventTarget~EventListener} fn\n     *        The function to remove.\n     */\n    off(type, fn) {\n      off(this, type, fn);\n    }\n    /**\n     * This function will add an `event listener` that gets triggered only once. After the\n     * first trigger it will get removed. This is like adding an `event listener`\n     * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n     *\n     * @param {string|string[]} type\n     *        An event name or an array of event names.\n     *\n     * @param {EventTarget~EventListener} fn\n     *        The function to be called once for each event name.\n     */\n    one(type, fn) {\n      // Remove the addEventListener aliasing Events.on\n      // so we don't get into an infinite type loop\n      const ael = this.addEventListener;\n      this.addEventListener = () => {};\n      one(this, type, fn);\n      this.addEventListener = ael;\n    }\n    any(type, fn) {\n      // Remove the addEventListener aliasing Events.on\n      // so we don't get into an infinite type loop\n      const ael = this.addEventListener;\n      this.addEventListener = () => {};\n      any(this, type, fn);\n      this.addEventListener = ael;\n    }\n    /**\n     * This function causes an event to happen. This will then cause any `event listeners`\n     * that are waiting for that event, to get called. If there are no `event listeners`\n     * for an event then nothing will happen.\n     *\n     * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n     * Trigger will also call the `on` + `uppercaseEventName` function.\n     *\n     * Example:\n     * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n     * `onClick` if it exists.\n     *\n     * @param {string|EventTarget~Event|Object} event\n     *        The name of the event, an `Event`, or an object with a key of type set to\n     *        an event name.\n     */\n    trigger(event) {\n      const type = event.type || event;\n\n      // deprecation\n      // In a future version we should default target to `this`\n      // similar to how we default the target to `elem` in\n      // `Events.trigger`. Right now the default `target` will be\n      // `document` due to the `Event.fixEvent` call.\n      if (typeof event === 'string') {\n        event = {\n          type\n        };\n      }\n      event = fixEvent(event);\n      if (this.allowedEvents_[type] && this['on' + type]) {\n        this['on' + type](event);\n      }\n      trigger(this, event);\n    }\n    queueTrigger(event) {\n      // only set up EVENT_MAP if it'll be used\n      if (!EVENT_MAP) {\n        EVENT_MAP = new Map();\n      }\n      const type = event.type || event;\n      let map = EVENT_MAP.get(this);\n      if (!map) {\n        map = new Map();\n        EVENT_MAP.set(this, map);\n      }\n      const oldTimeout = map.get(type);\n      map.delete(type);\n      window.clearTimeout(oldTimeout);\n      const timeout = window.setTimeout(() => {\n        map.delete(type);\n        // if we cleared out all timeouts for the current target, delete its map\n        if (map.size === 0) {\n          map = null;\n          EVENT_MAP.delete(this);\n        }\n        this.trigger(event);\n      }, 0);\n      map.set(type, timeout);\n    }\n  }\n\n  /**\n   * A Custom DOM event.\n   *\n   * @typedef {EventTarget} Event\n   * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n   */\n\n  /**\n   * All event listeners should follow the following format.\n   *\n   * @callback EventTarget~EventListener\n   * @this {EventTarget}\n   *\n   * @param {EventTarget~Event} event\n   *        the event that triggered this function\n   *\n   * @param {Object} [hash]\n   *        hash of data sent during the event\n   */\n\n  /**\n   * An object containing event names as keys and booleans as values.\n   *\n   * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n   *         will have extra functionality. See that function for more information.\n   *\n   * @property EventTarget.prototype.allowedEvents_\n   * @private\n   */\n  EventTarget$2.prototype.allowedEvents_ = {};\n\n  /**\n   * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n   * the standard DOM API.\n   *\n   * @function\n   * @see {@link EventTarget#on}\n   */\n  EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;\n\n  /**\n   * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n   * the standard DOM API.\n   *\n   * @function\n   * @see {@link EventTarget#off}\n   */\n  EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;\n\n  /**\n   * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n   * the standard DOM API.\n   *\n   * @function\n   * @see {@link EventTarget#trigger}\n   */\n  EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;\n\n  /**\n   * @file mixins/evented.js\n   * @module evented\n   */\n  const objName = obj => {\n    if (typeof obj.name === 'function') {\n      return obj.name();\n    }\n    if (typeof obj.name === 'string') {\n      return obj.name;\n    }\n    if (obj.name_) {\n      return obj.name_;\n    }\n    if (obj.constructor && obj.constructor.name) {\n      return obj.constructor.name;\n    }\n    return typeof obj;\n  };\n\n  /**\n   * Returns whether or not an object has had the evented mixin applied.\n   *\n   * @param  {Object} object\n   *         An object to test.\n   *\n   * @return {boolean}\n   *         Whether or not the object appears to be evented.\n   */\n  const isEvented = object => object instanceof EventTarget$2 || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(k => typeof object[k] === 'function');\n\n  /**\n   * Adds a callback to run after the evented mixin applied.\n   *\n   * @param  {Object} object\n   *         An object to Add\n   * @param  {Function} callback\n   *         The callback to run.\n   */\n  const addEventedCallback = (target, callback) => {\n    if (isEvented(target)) {\n      callback();\n    } else {\n      if (!target.eventedCallbacks) {\n        target.eventedCallbacks = [];\n      }\n      target.eventedCallbacks.push(callback);\n    }\n  };\n\n  /**\n   * Whether a value is a valid event type - non-empty string or array.\n   *\n   * @private\n   * @param  {string|Array} type\n   *         The type value to test.\n   *\n   * @return {boolean}\n   *         Whether or not the type is a valid event type.\n   */\n  const isValidEventType = type =>\n  // The regex here verifies that the `type` contains at least one non-\n  // whitespace character.\n  typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length;\n\n  /**\n   * Validates a value to determine if it is a valid event target. Throws if not.\n   *\n   * @private\n   * @throws {Error}\n   *         If the target does not appear to be a valid event target.\n   *\n   * @param  {Object} target\n   *         The object to test.\n   *\n   * @param  {Object} obj\n   *         The evented object we are validating for\n   *\n   * @param  {string} fnName\n   *         The name of the evented mixin function that called this.\n   */\n  const validateTarget = (target, obj, fnName) => {\n    if (!target || !target.nodeName && !isEvented(target)) {\n      throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);\n    }\n  };\n\n  /**\n   * Validates a value to determine if it is a valid event target. Throws if not.\n   *\n   * @private\n   * @throws {Error}\n   *         If the type does not appear to be a valid event type.\n   *\n   * @param  {string|Array} type\n   *         The type to test.\n   *\n   * @param  {Object} obj\n  *         The evented object we are validating for\n   *\n   * @param  {string} fnName\n   *         The name of the evented mixin function that called this.\n   */\n  const validateEventType = (type, obj, fnName) => {\n    if (!isValidEventType(type)) {\n      throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);\n    }\n  };\n\n  /**\n   * Validates a value to determine if it is a valid listener. Throws if not.\n   *\n   * @private\n   * @throws {Error}\n   *         If the listener is not a function.\n   *\n   * @param  {Function} listener\n   *         The listener to test.\n   *\n   * @param  {Object} obj\n   *         The evented object we are validating for\n   *\n   * @param  {string} fnName\n   *         The name of the evented mixin function that called this.\n   */\n  const validateListener = (listener, obj, fnName) => {\n    if (typeof listener !== 'function') {\n      throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);\n    }\n  };\n\n  /**\n   * Takes an array of arguments given to `on()` or `one()`, validates them, and\n   * normalizes them into an object.\n   *\n   * @private\n   * @param  {Object} self\n   *         The evented object on which `on()` or `one()` was called. This\n   *         object will be bound as the `this` value for the listener.\n   *\n   * @param  {Array} args\n   *         An array of arguments passed to `on()` or `one()`.\n   *\n   * @param  {string} fnName\n   *         The name of the evented mixin function that called this.\n   *\n   * @return {Object}\n   *         An object containing useful values for `on()` or `one()` calls.\n   */\n  const normalizeListenArgs = (self, args, fnName) => {\n    // If the number of arguments is less than 3, the target is always the\n    // evented object itself.\n    const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n    let target;\n    let type;\n    let listener;\n    if (isTargetingSelf) {\n      target = self.eventBusEl_;\n\n      // Deal with cases where we got 3 arguments, but we are still listening to\n      // the evented object itself.\n      if (args.length >= 3) {\n        args.shift();\n      }\n      [type, listener] = args;\n    } else {\n      [target, type, listener] = args;\n    }\n    validateTarget(target, self, fnName);\n    validateEventType(type, self, fnName);\n    validateListener(listener, self, fnName);\n    listener = bind_(self, listener);\n    return {\n      isTargetingSelf,\n      target,\n      type,\n      listener\n    };\n  };\n\n  /**\n   * Adds the listener to the event type(s) on the target, normalizing for\n   * the type of target.\n   *\n   * @private\n   * @param  {Element|Object} target\n   *         A DOM node or evented object.\n   *\n   * @param  {string} method\n   *         The event binding method to use (\"on\" or \"one\").\n   *\n   * @param  {string|Array} type\n   *         One or more event type(s).\n   *\n   * @param  {Function} listener\n   *         A listener function.\n   */\n  const listen = (target, method, type, listener) => {\n    validateTarget(target, target, method);\n    if (target.nodeName) {\n      Events[method](target, type, listener);\n    } else {\n      target[method](type, listener);\n    }\n  };\n\n  /**\n   * Contains methods that provide event capabilities to an object which is passed\n   * to {@link module:evented|evented}.\n   *\n   * @mixin EventedMixin\n   */\n  const EventedMixin = {\n    /**\n     * Add a listener to an event (or events) on this object or another evented\n     * object.\n     *\n     * @param  {string|Array|Element|Object} targetOrType\n     *         If this is a string or array, it represents the event type(s)\n     *         that will trigger the listener.\n     *\n     *         Another evented object can be passed here instead, which will\n     *         cause the listener to listen for events on _that_ object.\n     *\n     *         In either case, the listener's `this` value will be bound to\n     *         this object.\n     *\n     * @param  {string|Array|Function} typeOrListener\n     *         If the first argument was a string or array, this should be the\n     *         listener function. Otherwise, this is a string or array of event\n     *         type(s).\n     *\n     * @param  {Function} [listener]\n     *         If the first argument was another evented object, this will be\n     *         the listener function.\n     */\n    on(...args) {\n      const {\n        isTargetingSelf,\n        target,\n        type,\n        listener\n      } = normalizeListenArgs(this, args, 'on');\n      listen(target, 'on', type, listener);\n\n      // If this object is listening to another evented object.\n      if (!isTargetingSelf) {\n        // If this object is disposed, remove the listener.\n        const removeListenerOnDispose = () => this.off(target, type, listener);\n\n        // Use the same function ID as the listener so we can remove it later it\n        // using the ID of the original listener.\n        removeListenerOnDispose.guid = listener.guid;\n\n        // Add a listener to the target's dispose event as well. This ensures\n        // that if the target is disposed BEFORE this object, we remove the\n        // removal listener that was just added. Otherwise, we create a memory leak.\n        const removeRemoverOnTargetDispose = () => this.off('dispose', removeListenerOnDispose);\n\n        // Use the same function ID as the listener so we can remove it later\n        // it using the ID of the original listener.\n        removeRemoverOnTargetDispose.guid = listener.guid;\n        listen(this, 'on', 'dispose', removeListenerOnDispose);\n        listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n      }\n    },\n    /**\n     * Add a listener to an event (or events) on this object or another evented\n     * object. The listener will be called once per event and then removed.\n     *\n     * @param  {string|Array|Element|Object} targetOrType\n     *         If this is a string or array, it represents the event type(s)\n     *         that will trigger the listener.\n     *\n     *         Another evented object can be passed here instead, which will\n     *         cause the listener to listen for events on _that_ object.\n     *\n     *         In either case, the listener's `this` value will be bound to\n     *         this object.\n     *\n     * @param  {string|Array|Function} typeOrListener\n     *         If the first argument was a string or array, this should be the\n     *         listener function. Otherwise, this is a string or array of event\n     *         type(s).\n     *\n     * @param  {Function} [listener]\n     *         If the first argument was another evented object, this will be\n     *         the listener function.\n     */\n    one(...args) {\n      const {\n        isTargetingSelf,\n        target,\n        type,\n        listener\n      } = normalizeListenArgs(this, args, 'one');\n\n      // Targeting this evented object.\n      if (isTargetingSelf) {\n        listen(target, 'one', type, listener);\n\n        // Targeting another evented object.\n      } else {\n        // TODO: This wrapper is incorrect! It should only\n        //       remove the wrapper for the event type that called it.\n        //       Instead all listners are removed on the first trigger!\n        //       see https://github.com/videojs/video.js/issues/5962\n        const wrapper = (...largs) => {\n          this.off(target, type, wrapper);\n          listener.apply(null, largs);\n        };\n\n        // Use the same function ID as the listener so we can remove it later\n        // it using the ID of the original listener.\n        wrapper.guid = listener.guid;\n        listen(target, 'one', type, wrapper);\n      }\n    },\n    /**\n     * Add a listener to an event (or events) on this object or another evented\n     * object. The listener will only be called once for the first event that is triggered\n     * then removed.\n     *\n     * @param  {string|Array|Element|Object} targetOrType\n     *         If this is a string or array, it represents the event type(s)\n     *         that will trigger the listener.\n     *\n     *         Another evented object can be passed here instead, which will\n     *         cause the listener to listen for events on _that_ object.\n     *\n     *         In either case, the listener's `this` value will be bound to\n     *         this object.\n     *\n     * @param  {string|Array|Function} typeOrListener\n     *         If the first argument was a string or array, this should be the\n     *         listener function. Otherwise, this is a string or array of event\n     *         type(s).\n     *\n     * @param  {Function} [listener]\n     *         If the first argument was another evented object, this will be\n     *         the listener function.\n     */\n    any(...args) {\n      const {\n        isTargetingSelf,\n        target,\n        type,\n        listener\n      } = normalizeListenArgs(this, args, 'any');\n\n      // Targeting this evented object.\n      if (isTargetingSelf) {\n        listen(target, 'any', type, listener);\n\n        // Targeting another evented object.\n      } else {\n        const wrapper = (...largs) => {\n          this.off(target, type, wrapper);\n          listener.apply(null, largs);\n        };\n\n        // Use the same function ID as the listener so we can remove it later\n        // it using the ID of the original listener.\n        wrapper.guid = listener.guid;\n        listen(target, 'any', type, wrapper);\n      }\n    },\n    /**\n     * Removes listener(s) from event(s) on an evented object.\n     *\n     * @param  {string|Array|Element|Object} [targetOrType]\n     *         If this is a string or array, it represents the event type(s).\n     *\n     *         Another evented object can be passed here instead, in which case\n     *         ALL 3 arguments are _required_.\n     *\n     * @param  {string|Array|Function} [typeOrListener]\n     *         If the first argument was a string or array, this may be the\n     *         listener function. Otherwise, this is a string or array of event\n     *         type(s).\n     *\n     * @param  {Function} [listener]\n     *         If the first argument was another evented object, this will be\n     *         the listener function; otherwise, _all_ listeners bound to the\n     *         event type(s) will be removed.\n     */\n    off(targetOrType, typeOrListener, listener) {\n      // Targeting this evented object.\n      if (!targetOrType || isValidEventType(targetOrType)) {\n        off(this.eventBusEl_, targetOrType, typeOrListener);\n\n        // Targeting another evented object.\n      } else {\n        const target = targetOrType;\n        const type = typeOrListener;\n\n        // Fail fast and in a meaningful way!\n        validateTarget(target, this, 'off');\n        validateEventType(type, this, 'off');\n        validateListener(listener, this, 'off');\n\n        // Ensure there's at least a guid, even if the function hasn't been used\n        listener = bind_(this, listener);\n\n        // Remove the dispose listener on this evented object, which was given\n        // the same guid as the event listener in on().\n        this.off('dispose', listener);\n        if (target.nodeName) {\n          off(target, type, listener);\n          off(target, 'dispose', listener);\n        } else if (isEvented(target)) {\n          target.off(type, listener);\n          target.off('dispose', listener);\n        }\n      }\n    },\n    /**\n     * Fire an event on this evented object, causing its listeners to be called.\n     *\n     * @param   {string|Object} event\n     *          An event type or an object with a type property.\n     *\n     * @param   {Object} [hash]\n     *          An additional object to pass along to listeners.\n     *\n     * @return {boolean}\n     *          Whether or not the default behavior was prevented.\n     */\n    trigger(event, hash) {\n      validateTarget(this.eventBusEl_, this, 'trigger');\n      const type = event && typeof event !== 'string' ? event.type : event;\n      if (!isValidEventType(type)) {\n        throw new Error(`Invalid event type for ${objName(this)}#trigger; ` + 'must be a non-empty string or object with a type key that has a non-empty value.');\n      }\n      return trigger(this.eventBusEl_, event, hash);\n    }\n  };\n\n  /**\n   * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n   *\n   * @param  {Object} target\n   *         The object to which to add event methods.\n   *\n   * @param  {Object} [options={}]\n   *         Options for customizing the mixin behavior.\n   *\n   * @param  {string} [options.eventBusKey]\n   *         By default, adds a `eventBusEl_` DOM element to the target object,\n   *         which is used as an event bus. If the target object already has a\n   *         DOM element that should be used, pass its key here.\n   *\n   * @return {Object}\n   *         The target object.\n   */\n  function evented(target, options = {}) {\n    const {\n      eventBusKey\n    } = options;\n\n    // Set or create the eventBusEl_.\n    if (eventBusKey) {\n      if (!target[eventBusKey].nodeName) {\n        throw new Error(`The eventBusKey \"${eventBusKey}\" does not refer to an element.`);\n      }\n      target.eventBusEl_ = target[eventBusKey];\n    } else {\n      target.eventBusEl_ = createEl('span', {\n        className: 'vjs-event-bus'\n      });\n    }\n    Object.assign(target, EventedMixin);\n    if (target.eventedCallbacks) {\n      target.eventedCallbacks.forEach(callback => {\n        callback();\n      });\n    }\n\n    // When any evented object is disposed, it removes all its listeners.\n    target.on('dispose', () => {\n      target.off();\n      [target, target.el_, target.eventBusEl_].forEach(function (val) {\n        if (val && DomData.has(val)) {\n          DomData.delete(val);\n        }\n      });\n      window.setTimeout(() => {\n        target.eventBusEl_ = null;\n      }, 0);\n    });\n    return target;\n  }\n\n  /**\n   * @file mixins/stateful.js\n   * @module stateful\n   */\n\n  /**\n   * Contains methods that provide statefulness to an object which is passed\n   * to {@link module:stateful}.\n   *\n   * @mixin StatefulMixin\n   */\n  const StatefulMixin = {\n    /**\n     * A hash containing arbitrary keys and values representing the state of\n     * the object.\n     *\n     * @type {Object}\n     */\n    state: {},\n    /**\n     * Set the state of an object by mutating its\n     * {@link module:stateful~StatefulMixin.state|state} object in place.\n     *\n     * @fires   module:stateful~StatefulMixin#statechanged\n     * @param   {Object|Function} stateUpdates\n     *          A new set of properties to shallow-merge into the plugin state.\n     *          Can be a plain object or a function returning a plain object.\n     *\n     * @return {Object|undefined}\n     *          An object containing changes that occurred. If no changes\n     *          occurred, returns `undefined`.\n     */\n    setState(stateUpdates) {\n      // Support providing the `stateUpdates` state as a function.\n      if (typeof stateUpdates === 'function') {\n        stateUpdates = stateUpdates();\n      }\n      let changes;\n      each(stateUpdates, (value, key) => {\n        // Record the change if the value is different from what's in the\n        // current state.\n        if (this.state[key] !== value) {\n          changes = changes || {};\n          changes[key] = {\n            from: this.state[key],\n            to: value\n          };\n        }\n        this.state[key] = value;\n      });\n\n      // Only trigger \"statechange\" if there were changes AND we have a trigger\n      // function. This allows us to not require that the target object be an\n      // evented object.\n      if (changes && isEvented(this)) {\n        /**\n         * An event triggered on an object that is both\n         * {@link module:stateful|stateful} and {@link module:evented|evented}\n         * indicating that its state has changed.\n         *\n         * @event    module:stateful~StatefulMixin#statechanged\n         * @type     {Object}\n         * @property {Object} changes\n         *           A hash containing the properties that were changed and\n         *           the values they were changed `from` and `to`.\n         */\n        this.trigger({\n          changes,\n          type: 'statechanged'\n        });\n      }\n      return changes;\n    }\n  };\n\n  /**\n   * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n   * object.\n   *\n   * If the target object is {@link module:evented|evented} and has a\n   * `handleStateChanged` method, that method will be automatically bound to the\n   * `statechanged` event on itself.\n   *\n   * @param   {Object} target\n   *          The object to be made stateful.\n   *\n   * @param   {Object} [defaultState]\n   *          A default set of properties to populate the newly-stateful object's\n   *          `state` property.\n   *\n   * @return {Object}\n   *          Returns the `target`.\n   */\n  function stateful(target, defaultState) {\n    Object.assign(target, StatefulMixin);\n\n    // This happens after the mixing-in because we need to replace the `state`\n    // added in that step.\n    target.state = Object.assign({}, target.state, defaultState);\n\n    // Auto-bind the `handleStateChanged` method of the target object if it exists.\n    if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n      target.on('statechanged', target.handleStateChanged);\n    }\n    return target;\n  }\n\n  /**\n   * @file str.js\n   * @module to-lower-case\n   */\n\n  /**\n   * Lowercase the first letter of a string.\n   *\n   * @param {string} string\n   *        String to be lowercased\n   *\n   * @return {string}\n   *         The string with a lowercased first letter\n   */\n  const toLowerCase = function (string) {\n    if (typeof string !== 'string') {\n      return string;\n    }\n    return string.replace(/./, w => w.toLowerCase());\n  };\n\n  /**\n   * Uppercase the first letter of a string.\n   *\n   * @param {string} string\n   *        String to be uppercased\n   *\n   * @return {string}\n   *         The string with an uppercased first letter\n   */\n  const toTitleCase$1 = function (string) {\n    if (typeof string !== 'string') {\n      return string;\n    }\n    return string.replace(/./, w => w.toUpperCase());\n  };\n\n  /**\n   * Compares the TitleCase versions of the two strings for equality.\n   *\n   * @param {string} str1\n   *        The first string to compare\n   *\n   * @param {string} str2\n   *        The second string to compare\n   *\n   * @return {boolean}\n   *         Whether the TitleCase versions of the strings are equal\n   */\n  const titleCaseEquals = function (str1, str2) {\n    return toTitleCase$1(str1) === toTitleCase$1(str2);\n  };\n\n  var Str = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    toLowerCase: toLowerCase,\n    toTitleCase: toTitleCase$1,\n    titleCaseEquals: titleCaseEquals\n  });\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function unwrapExports (x) {\n  \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var keycode = createCommonjsModule(function (module, exports) {\n    // Source: http://jsfiddle.net/vWx8V/\n    // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\n\n    /**\n     * Conenience method returns corresponding value for given keyName or keyCode.\n     *\n     * @param {Mixed} keyCode {Number} or keyName {String}\n     * @return {Mixed}\n     * @api public\n     */\n\n    function keyCode(searchInput) {\n      // Keyboard Events\n      if (searchInput && 'object' === typeof searchInput) {\n        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;\n        if (hasKeyCode) searchInput = hasKeyCode;\n      }\n\n      // Numbers\n      if ('number' === typeof searchInput) return names[searchInput];\n\n      // Everything else (cast to string)\n      var search = String(searchInput);\n\n      // check codes\n      var foundNamedKey = codes[search.toLowerCase()];\n      if (foundNamedKey) return foundNamedKey;\n\n      // check aliases\n      var foundNamedKey = aliases[search.toLowerCase()];\n      if (foundNamedKey) return foundNamedKey;\n\n      // weird character?\n      if (search.length === 1) return search.charCodeAt(0);\n      return undefined;\n    }\n\n    /**\n     * Compares a keyboard event with a given keyCode or keyName.\n     *\n     * @param {Event} event Keyboard event that should be tested\n     * @param {Mixed} keyCode {Number} or keyName {String}\n     * @return {Boolean}\n     * @api public\n     */\n    keyCode.isEventKey = function isEventKey(event, nameOrCode) {\n      if (event && 'object' === typeof event) {\n        var keyCode = event.which || event.keyCode || event.charCode;\n        if (keyCode === null || keyCode === undefined) {\n          return false;\n        }\n        if (typeof nameOrCode === 'string') {\n          // check codes\n          var foundNamedKey = codes[nameOrCode.toLowerCase()];\n          if (foundNamedKey) {\n            return foundNamedKey === keyCode;\n          }\n\n          // check aliases\n          var foundNamedKey = aliases[nameOrCode.toLowerCase()];\n          if (foundNamedKey) {\n            return foundNamedKey === keyCode;\n          }\n        } else if (typeof nameOrCode === 'number') {\n          return nameOrCode === keyCode;\n        }\n        return false;\n      }\n    };\n    exports = module.exports = keyCode;\n\n    /**\n     * Get by name\n     *\n     *   exports.code['enter'] // => 13\n     */\n\n    var codes = exports.code = exports.codes = {\n      'backspace': 8,\n      'tab': 9,\n      'enter': 13,\n      'shift': 16,\n      'ctrl': 17,\n      'alt': 18,\n      'pause/break': 19,\n      'caps lock': 20,\n      'esc': 27,\n      'space': 32,\n      'page up': 33,\n      'page down': 34,\n      'end': 35,\n      'home': 36,\n      'left': 37,\n      'up': 38,\n      'right': 39,\n      'down': 40,\n      'insert': 45,\n      'delete': 46,\n      'command': 91,\n      'left command': 91,\n      'right command': 93,\n      'numpad *': 106,\n      'numpad +': 107,\n      'numpad -': 109,\n      'numpad .': 110,\n      'numpad /': 111,\n      'num lock': 144,\n      'scroll lock': 145,\n      'my computer': 182,\n      'my calculator': 183,\n      ';': 186,\n      '=': 187,\n      ',': 188,\n      '-': 189,\n      '.': 190,\n      '/': 191,\n      '`': 192,\n      '[': 219,\n      '\\\\': 220,\n      ']': 221,\n      \"'\": 222\n    };\n\n    // Helper aliases\n\n    var aliases = exports.aliases = {\n      'windows': 91,\n      '': 16,\n      '': 18,\n      '': 17,\n      '': 91,\n      'ctl': 17,\n      'control': 17,\n      'option': 18,\n      'pause': 19,\n      'break': 19,\n      'caps': 20,\n      'return': 13,\n      'escape': 27,\n      'spc': 32,\n      'spacebar': 32,\n      'pgup': 33,\n      'pgdn': 34,\n      'ins': 45,\n      'del': 46,\n      'cmd': 91\n    };\n\n    /*!\n     * Programatically add the following\n     */\n\n    // lower case chars\n    for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;\n\n    // numbers\n    for (var i = 48; i < 58; i++) codes[i - 48] = i;\n\n    // function keys\n    for (i = 1; i < 13; i++) codes['f' + i] = i + 111;\n\n    // numpad keys\n    for (i = 0; i < 10; i++) codes['numpad ' + i] = i + 96;\n\n    /**\n     * Get by code\n     *\n     *   exports.name[13] // => 'Enter'\n     */\n\n    var names = exports.names = exports.title = {}; // title for backward compat\n\n    // Create reverse mapping\n    for (i in codes) names[codes[i]] = i;\n\n    // Add aliases\n    for (var alias in aliases) {\n      codes[alias] = aliases[alias];\n    }\n  });\n  keycode.code;\n  keycode.codes;\n  keycode.aliases;\n  keycode.names;\n  keycode.title;\n\n  /**\n   * Player Component - Base class for all UI objects\n   *\n   * @file component.js\n   */\n\n  /**\n   * Base class for all UI Components.\n   * Components are UI objects which represent both a javascript object and an element\n   * in the DOM. They can be children of other components, and can have\n   * children themselves.\n   *\n   * Components can also use methods from {@link EventTarget}\n   */\n  class Component$1 {\n    /**\n     * A callback that is called when a component is ready. Does not have any\n     * parameters and any callback value will be ignored.\n     *\n     * @callback Component~ReadyCallback\n     * @this Component\n     */\n\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of component options.\n     *\n     * @param {Object[]} [options.children]\n     *        An array of children objects to intialize this component with. Children objects have\n     *        a name property that will be used if more than one component of the same type needs to be\n     *        added.\n     *\n     * @param  {string} [options.className]\n     *         A class or space separated list of classes to add the component\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        Function that gets called when the `Component` is ready.\n     */\n    constructor(player, options, ready) {\n      // The component might be the player itself and we can't pass `this` to super\n      if (!player && this.play) {\n        this.player_ = player = this; // eslint-disable-line\n      } else {\n        this.player_ = player;\n      }\n      this.isDisposed_ = false;\n\n      // Hold the reference to the parent component via `addChild` method\n      this.parentComponent_ = null;\n\n      // Make a copy of prototype.options_ to protect against overriding defaults\n      this.options_ = merge$2({}, this.options_);\n\n      // Updated options with supplied options\n      options = this.options_ = merge$2(this.options_, options);\n\n      // Get ID from options or options element if one is supplied\n      this.id_ = options.id || options.el && options.el.id;\n\n      // If there was no ID from the options, generate one\n      if (!this.id_) {\n        // Don't require the player ID function in the case of mock players\n        const id = player && player.id && player.id() || 'no_player';\n        this.id_ = `${id}_component_${newGUID()}`;\n      }\n      this.name_ = options.name || null;\n\n      // Create element if one wasn't provided in options\n      if (options.el) {\n        this.el_ = options.el;\n      } else if (options.createEl !== false) {\n        this.el_ = this.createEl();\n      }\n      if (options.className && this.el_) {\n        options.className.split(' ').forEach(c => this.addClass(c));\n      }\n\n      // if evented is anything except false, we want to mixin in evented\n      if (options.evented !== false) {\n        // Make this an evented object and use `el_`, if available, as its event bus\n        evented(this, {\n          eventBusKey: this.el_ ? 'el_' : null\n        });\n        this.handleLanguagechange = this.handleLanguagechange.bind(this);\n        this.on(this.player_, 'languagechange', this.handleLanguagechange);\n      }\n      stateful(this, this.constructor.defaultState);\n      this.children_ = [];\n      this.childIndex_ = {};\n      this.childNameIndex_ = {};\n      this.setTimeoutIds_ = new Set();\n      this.setIntervalIds_ = new Set();\n      this.rafIds_ = new Set();\n      this.namedRafs_ = new Map();\n      this.clearingTimersOnDispose_ = false;\n\n      // Add any child components in options\n      if (options.initChildren !== false) {\n        this.initChildren();\n      }\n\n      // Don't want to trigger ready here or it will go before init is actually\n      // finished for all children that run this constructor\n      this.ready(ready);\n      if (options.reportTouchActivity !== false) {\n        this.enableTouchActivity();\n      }\n    }\n\n    /**\n     * Dispose of the `Component` and all child components.\n     *\n     * @fires Component#dispose\n     *\n     * @param {Object} options\n     * @param {Element} options.originalEl element with which to replace player element\n     */\n    dispose(options = {}) {\n      // Bail out if the component has already been disposed.\n      if (this.isDisposed_) {\n        return;\n      }\n      if (this.readyQueue_) {\n        this.readyQueue_.length = 0;\n      }\n\n      /**\n       * Triggered when a `Component` is disposed.\n       *\n       * @event Component#dispose\n       * @type {EventTarget~Event}\n       *\n       * @property {boolean} [bubbles=false]\n       *           set to false so that the dispose event does not\n       *           bubble up\n       */\n      this.trigger({\n        type: 'dispose',\n        bubbles: false\n      });\n      this.isDisposed_ = true;\n\n      // Dispose all children.\n      if (this.children_) {\n        for (let i = this.children_.length - 1; i >= 0; i--) {\n          if (this.children_[i].dispose) {\n            this.children_[i].dispose();\n          }\n        }\n      }\n\n      // Delete child references\n      this.children_ = null;\n      this.childIndex_ = null;\n      this.childNameIndex_ = null;\n      this.parentComponent_ = null;\n      if (this.el_) {\n        // Remove element from DOM\n        if (this.el_.parentNode) {\n          if (options.restoreEl) {\n            this.el_.parentNode.replaceChild(options.restoreEl, this.el_);\n          } else {\n            this.el_.parentNode.removeChild(this.el_);\n          }\n        }\n        this.el_ = null;\n      }\n\n      // remove reference to the player after disposing of the element\n      this.player_ = null;\n    }\n\n    /**\n     * Determine whether or not this component has been disposed.\n     *\n     * @return {boolean}\n     *         If the component has been disposed, will be `true`. Otherwise, `false`.\n     */\n    isDisposed() {\n      return Boolean(this.isDisposed_);\n    }\n\n    /**\n     * Return the {@link Player} that the `Component` has attached to.\n     *\n     * @return {Player}\n     *         The player that this `Component` has attached to.\n     */\n    player() {\n      return this.player_;\n    }\n\n    /**\n     * Deep merge of options objects with new options.\n     * > Note: When both `obj` and `options` contain properties whose values are objects.\n     *         The two properties get merged using {@link module:obj.merge}\n     *\n     * @param {Object} obj\n     *        The object that contains new options.\n     *\n     * @return {Object}\n     *         A new object of `this.options_` and `obj` merged together.\n     */\n    options(obj) {\n      if (!obj) {\n        return this.options_;\n      }\n      this.options_ = merge$2(this.options_, obj);\n      return this.options_;\n    }\n\n    /**\n     * Get the `Component`s DOM element\n     *\n     * @return {Element}\n     *         The DOM element for this `Component`.\n     */\n    el() {\n      return this.el_;\n    }\n\n    /**\n     * Create the `Component`s DOM element.\n     *\n     * @param {string} [tagName]\n     *        Element's DOM node type. e.g. 'div'\n     *\n     * @param {Object} [properties]\n     *        An object of properties that should be set.\n     *\n     * @param {Object} [attributes]\n     *        An object of attributes that should be set.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl(tagName, properties, attributes) {\n      return createEl(tagName, properties, attributes);\n    }\n\n    /**\n     * Localize a string given the string in english.\n     *\n     * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n     * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\n     *\n     * If a `defaultValue` is provided, it'll use that over `string`,\n     * if a value isn't found in provided language files.\n     * This is useful if you want to have a descriptive key for token replacement\n     * but have a succinct localized string and not require `en.json` to be included.\n     *\n     * Currently, it is used for the progress bar timing.\n     * ```js\n     * {\n     *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n     * }\n     * ```\n     * It is then used like so:\n     * ```js\n     * this.localize('progress bar timing: currentTime={1} duration{2}',\n     *               [this.player_.currentTime(), this.player_.duration()],\n     *               '{1} of {2}');\n     * ```\n     *\n     * Which outputs something like: `01:23 of 24:56`.\n     *\n     *\n     * @param {string} string\n     *        The string to localize and the key to lookup in the language files.\n     * @param {string[]} [tokens]\n     *        If the current item has token replacements, provide the tokens here.\n     * @param {string} [defaultValue]\n     *        Defaults to `string`. Can be a default value to use for token replacement\n     *        if the lookup key is needed to be separate.\n     *\n     * @return {string}\n     *         The localized string or if no localization exists the english string.\n     */\n    localize(string, tokens, defaultValue = string) {\n      const code = this.player_.language && this.player_.language();\n      const languages = this.player_.languages && this.player_.languages();\n      const language = languages && languages[code];\n      const primaryCode = code && code.split('-')[0];\n      const primaryLang = languages && languages[primaryCode];\n      let localizedString = defaultValue;\n      if (language && language[string]) {\n        localizedString = language[string];\n      } else if (primaryLang && primaryLang[string]) {\n        localizedString = primaryLang[string];\n      }\n      if (tokens) {\n        localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n          const value = tokens[index - 1];\n          let ret = value;\n          if (typeof value === 'undefined') {\n            ret = match;\n          }\n          return ret;\n        });\n      }\n      return localizedString;\n    }\n\n    /**\n     * Handles language change for the player in components. Should be overriden by sub-components.\n     *\n     * @abstract\n     */\n    handleLanguagechange() {}\n\n    /**\n     * Return the `Component`s DOM element. This is where children get inserted.\n     * This will usually be the the same as the element returned in {@link Component#el}.\n     *\n     * @return {Element}\n     *         The content element for this `Component`.\n     */\n    contentEl() {\n      return this.contentEl_ || this.el_;\n    }\n\n    /**\n     * Get this `Component`s ID\n     *\n     * @return {string}\n     *         The id of this `Component`\n     */\n    id() {\n      return this.id_;\n    }\n\n    /**\n     * Get the `Component`s name. The name gets used to reference the `Component`\n     * and is set during registration.\n     *\n     * @return {string}\n     *         The name of this `Component`.\n     */\n    name() {\n      return this.name_;\n    }\n\n    /**\n     * Get an array of all child components\n     *\n     * @return {Array}\n     *         The children\n     */\n    children() {\n      return this.children_;\n    }\n\n    /**\n     * Returns the child `Component` with the given `id`.\n     *\n     * @param {string} id\n     *        The id of the child `Component` to get.\n     *\n     * @return {Component|undefined}\n     *         The child `Component` with the given `id` or undefined.\n     */\n    getChildById(id) {\n      return this.childIndex_[id];\n    }\n\n    /**\n     * Returns the child `Component` with the given `name`.\n     *\n     * @param {string} name\n     *        The name of the child `Component` to get.\n     *\n     * @return {Component|undefined}\n     *         The child `Component` with the given `name` or undefined.\n     */\n    getChild(name) {\n      if (!name) {\n        return;\n      }\n      return this.childNameIndex_[name];\n    }\n\n    /**\n     * Returns the descendant `Component` following the givent\n     * descendant `names`. For instance ['foo', 'bar', 'baz'] would\n     * try to get 'foo' on the current component, 'bar' on the 'foo'\n     * component and 'baz' on the 'bar' component and return undefined\n     * if any of those don't exist.\n     *\n     * @param {...string[]|...string} names\n     *        The name of the child `Component` to get.\n     *\n     * @return {Component|undefined}\n     *         The descendant `Component` following the given descendant\n     *         `names` or undefined.\n     */\n    getDescendant(...names) {\n      // flatten array argument into the main array\n      names = names.reduce((acc, n) => acc.concat(n), []);\n      let currentChild = this;\n      for (let i = 0; i < names.length; i++) {\n        currentChild = currentChild.getChild(names[i]);\n        if (!currentChild || !currentChild.getChild) {\n          return;\n        }\n      }\n      return currentChild;\n    }\n\n    /**\n     * Add a child `Component` inside the current `Component`.\n     *\n     *\n     * @param {string|Component} child\n     *        The name or instance of a child to add.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of options that will get passed to children of\n     *        the child.\n     *\n     * @param {number} [index=this.children_.length]\n     *        The index to attempt to add a child into.\n     *\n     * @return {Component}\n     *         The `Component` that gets added as a child. When using a string the\n     *         `Component` will get created by this process.\n     */\n    addChild(child, options = {}, index = this.children_.length) {\n      let component;\n      let componentName;\n\n      // If child is a string, create component with options\n      if (typeof child === 'string') {\n        componentName = toTitleCase$1(child);\n        const componentClassName = options.componentClass || componentName;\n\n        // Set name through options\n        options.name = componentName;\n\n        // Create a new object & element for this controls set\n        // If there's no .player_, this is a player\n        const ComponentClass = Component$1.getComponent(componentClassName);\n        if (!ComponentClass) {\n          throw new Error(`Component ${componentClassName} does not exist`);\n        }\n\n        // data stored directly on the videojs object may be\n        // misidentified as a component to retain\n        // backwards-compatibility with 4.x. check to make sure the\n        // component class can be instantiated.\n        if (typeof ComponentClass !== 'function') {\n          return null;\n        }\n        component = new ComponentClass(this.player_ || this, options);\n\n        // child is a component instance\n      } else {\n        component = child;\n      }\n      if (component.parentComponent_) {\n        component.parentComponent_.removeChild(component);\n      }\n      this.children_.splice(index, 0, component);\n      component.parentComponent_ = this;\n      if (typeof component.id === 'function') {\n        this.childIndex_[component.id()] = component;\n      }\n\n      // If a name wasn't used to create the component, check if we can use the\n      // name function of the component\n      componentName = componentName || component.name && toTitleCase$1(component.name());\n      if (componentName) {\n        this.childNameIndex_[componentName] = component;\n        this.childNameIndex_[toLowerCase(componentName)] = component;\n      }\n\n      // Add the UI object's element to the container div (box)\n      // Having an element is not required\n      if (typeof component.el === 'function' && component.el()) {\n        // If inserting before a component, insert before that component's element\n        let refNode = null;\n        if (this.children_[index + 1]) {\n          // Most children are components, but the video tech is an HTML element\n          if (this.children_[index + 1].el_) {\n            refNode = this.children_[index + 1].el_;\n          } else if (isEl(this.children_[index + 1])) {\n            refNode = this.children_[index + 1];\n          }\n        }\n        this.contentEl().insertBefore(component.el(), refNode);\n      }\n\n      // Return so it can stored on parent object if desired.\n      return component;\n    }\n\n    /**\n     * Remove a child `Component` from this `Component`s list of children. Also removes\n     * the child `Component`s element from this `Component`s element.\n     *\n     * @param {Component} component\n     *        The child `Component` to remove.\n     */\n    removeChild(component) {\n      if (typeof component === 'string') {\n        component = this.getChild(component);\n      }\n      if (!component || !this.children_) {\n        return;\n      }\n      let childFound = false;\n      for (let i = this.children_.length - 1; i >= 0; i--) {\n        if (this.children_[i] === component) {\n          childFound = true;\n          this.children_.splice(i, 1);\n          break;\n        }\n      }\n      if (!childFound) {\n        return;\n      }\n      component.parentComponent_ = null;\n      this.childIndex_[component.id()] = null;\n      this.childNameIndex_[toTitleCase$1(component.name())] = null;\n      this.childNameIndex_[toLowerCase(component.name())] = null;\n      const compEl = component.el();\n      if (compEl && compEl.parentNode === this.contentEl()) {\n        this.contentEl().removeChild(component.el());\n      }\n    }\n\n    /**\n     * Add and initialize default child `Component`s based upon options.\n     */\n    initChildren() {\n      const children = this.options_.children;\n      if (children) {\n        // `this` is `parent`\n        const parentOptions = this.options_;\n        const handleAdd = child => {\n          const name = child.name;\n          let opts = child.opts;\n\n          // Allow options for children to be set at the parent options\n          // e.g. videojs(id, { controlBar: false });\n          // instead of videojs(id, { children: { controlBar: false });\n          if (parentOptions[name] !== undefined) {\n            opts = parentOptions[name];\n          }\n\n          // Allow for disabling default components\n          // e.g. options['children']['posterImage'] = false\n          if (opts === false) {\n            return;\n          }\n\n          // Allow options to be passed as a simple boolean if no configuration\n          // is necessary.\n          if (opts === true) {\n            opts = {};\n          }\n\n          // We also want to pass the original player options\n          // to each component as well so they don't need to\n          // reach back into the player for options later.\n          opts.playerOptions = this.options_.playerOptions;\n\n          // Create and add the child component.\n          // Add a direct reference to the child by name on the parent instance.\n          // If two of the same component are used, different names should be supplied\n          // for each\n          const newChild = this.addChild(name, opts);\n          if (newChild) {\n            this[name] = newChild;\n          }\n        };\n\n        // Allow for an array of children details to passed in the options\n        let workingChildren;\n        const Tech = Component$1.getComponent('Tech');\n        if (Array.isArray(children)) {\n          workingChildren = children;\n        } else {\n          workingChildren = Object.keys(children);\n        }\n        workingChildren\n        // children that are in this.options_ but also in workingChildren  would\n        // give us extra children we do not want. So, we want to filter them out.\n        .concat(Object.keys(this.options_).filter(function (child) {\n          return !workingChildren.some(function (wchild) {\n            if (typeof wchild === 'string') {\n              return child === wchild;\n            }\n            return child === wchild.name;\n          });\n        })).map(child => {\n          let name;\n          let opts;\n          if (typeof child === 'string') {\n            name = child;\n            opts = children[name] || this.options_[name] || {};\n          } else {\n            name = child.name;\n            opts = child;\n          }\n          return {\n            name,\n            opts\n          };\n        }).filter(child => {\n          // we have to make sure that child.name isn't in the techOrder since\n          // techs are registerd as Components but can't aren't compatible\n          // See https://github.com/videojs/video.js/issues/2772\n          const c = Component$1.getComponent(child.opts.componentClass || toTitleCase$1(child.name));\n          return c && !Tech.isTech(c);\n        }).forEach(handleAdd);\n      }\n    }\n\n    /**\n     * Builds the default DOM class name. Should be overriden by sub-components.\n     *\n     * @return {string}\n     *         The DOM class name for this object.\n     *\n     * @abstract\n     */\n    buildCSSClass() {\n      // Child classes can include a function that does:\n      // return 'CLASS NAME' + this._super();\n      return '';\n    }\n\n    /**\n     * Bind a listener to the component's ready state.\n     * Different from event listeners in that if the ready event has already happened\n     * it will trigger the function immediately.\n     *\n     * @param {Component~ReadyCallback} fn\n     *        Function that gets called when the `Component` is ready.\n     *\n     * @return {Component}\n     *         Returns itself; method can be chained.\n     */\n    ready(fn, sync = false) {\n      if (!fn) {\n        return;\n      }\n      if (!this.isReady_) {\n        this.readyQueue_ = this.readyQueue_ || [];\n        this.readyQueue_.push(fn);\n        return;\n      }\n      if (sync) {\n        fn.call(this);\n      } else {\n        // Call the function asynchronously by default for consistency\n        this.setTimeout(fn, 1);\n      }\n    }\n\n    /**\n     * Trigger all the ready listeners for this `Component`.\n     *\n     * @fires Component#ready\n     */\n    triggerReady() {\n      this.isReady_ = true;\n\n      // Ensure ready is triggered asynchronously\n      this.setTimeout(function () {\n        const readyQueue = this.readyQueue_;\n\n        // Reset Ready Queue\n        this.readyQueue_ = [];\n        if (readyQueue && readyQueue.length > 0) {\n          readyQueue.forEach(function (fn) {\n            fn.call(this);\n          }, this);\n        }\n\n        // Allow for using event listeners also\n        /**\n         * Triggered when a `Component` is ready.\n         *\n         * @event Component#ready\n         * @type {EventTarget~Event}\n         */\n        this.trigger('ready');\n      }, 1);\n    }\n\n    /**\n     * Find a single DOM element matching a `selector`. This can be within the `Component`s\n     * `contentEl()` or another custom context.\n     *\n     * @param {string} selector\n     *        A valid CSS selector, which will be passed to `querySelector`.\n     *\n     * @param {Element|string} [context=this.contentEl()]\n     *        A DOM element within which to query. Can also be a selector string in\n     *        which case the first matching element will get used as context. If\n     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n     *        nothing it falls back to `document`.\n     *\n     * @return {Element|null}\n     *         the dom element that was found, or null\n     *\n     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n     */\n    $(selector, context) {\n      return $(selector, context || this.contentEl());\n    }\n\n    /**\n     * Finds all DOM element matching a `selector`. This can be within the `Component`s\n     * `contentEl()` or another custom context.\n     *\n     * @param {string} selector\n     *        A valid CSS selector, which will be passed to `querySelectorAll`.\n     *\n     * @param {Element|string} [context=this.contentEl()]\n     *        A DOM element within which to query. Can also be a selector string in\n     *        which case the first matching element will get used as context. If\n     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n     *        nothing it falls back to `document`.\n     *\n     * @return {NodeList}\n     *         a list of dom elements that were found\n     *\n     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n     */\n    $$(selector, context) {\n      return $$(selector, context || this.contentEl());\n    }\n\n    /**\n     * Check if a component's element has a CSS class name.\n     *\n     * @param {string} classToCheck\n     *        CSS class name to check.\n     *\n     * @return {boolean}\n     *         - True if the `Component` has the class.\n     *         - False if the `Component` does not have the class`\n     */\n    hasClass(classToCheck) {\n      return hasClass(this.el_, classToCheck);\n    }\n\n    /**\n     * Add a CSS class name to the `Component`s element.\n     *\n     * @param {...string} classesToAdd\n     *        One or more CSS class name to add.\n     */\n    addClass(...classesToAdd) {\n      addClass(this.el_, ...classesToAdd);\n    }\n\n    /**\n     * Remove a CSS class name from the `Component`s element.\n     *\n     * @param {...string} classesToRemove\n     *        One or more CSS class name to remove.\n     */\n    removeClass(...classesToRemove) {\n      removeClass(this.el_, ...classesToRemove);\n    }\n\n    /**\n     * Add or remove a CSS class name from the component's element.\n     * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n     * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n     *\n     * @param  {string} classToToggle\n     *         The class to add or remove based on (@link Component#hasClass}\n     *\n     * @param  {boolean|Dom~predicate} [predicate]\n     *         An {@link Dom~predicate} function or a boolean\n     */\n    toggleClass(classToToggle, predicate) {\n      toggleClass(this.el_, classToToggle, predicate);\n    }\n\n    /**\n     * Show the `Component`s element if it is hidden by removing the\n     * 'vjs-hidden' class name from it.\n     */\n    show() {\n      this.removeClass('vjs-hidden');\n    }\n\n    /**\n     * Hide the `Component`s element if it is currently showing by adding the\n     * 'vjs-hidden` class name to it.\n     */\n    hide() {\n      this.addClass('vjs-hidden');\n    }\n\n    /**\n     * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n     * class name to it. Used during fadeIn/fadeOut.\n     *\n     * @private\n     */\n    lockShowing() {\n      this.addClass('vjs-lock-showing');\n    }\n\n    /**\n     * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n     * class name from it. Used during fadeIn/fadeOut.\n     *\n     * @private\n     */\n    unlockShowing() {\n      this.removeClass('vjs-lock-showing');\n    }\n\n    /**\n     * Get the value of an attribute on the `Component`s element.\n     *\n     * @param {string} attribute\n     *        Name of the attribute to get the value from.\n     *\n     * @return {string|null}\n     *         - The value of the attribute that was asked for.\n     *         - Can be an empty string on some browsers if the attribute does not exist\n     *           or has no value\n     *         - Most browsers will return null if the attibute does not exist or has\n     *           no value.\n     *\n     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n     */\n    getAttribute(attribute) {\n      return getAttribute(this.el_, attribute);\n    }\n\n    /**\n     * Set the value of an attribute on the `Component`'s element\n     *\n     * @param {string} attribute\n     *        Name of the attribute to set.\n     *\n     * @param {string} value\n     *        Value to set the attribute to.\n     *\n     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n     */\n    setAttribute(attribute, value) {\n      setAttribute(this.el_, attribute, value);\n    }\n\n    /**\n     * Remove an attribute from the `Component`s element.\n     *\n     * @param {string} attribute\n     *        Name of the attribute to remove.\n     *\n     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n     */\n    removeAttribute(attribute) {\n      removeAttribute(this.el_, attribute);\n    }\n\n    /**\n     * Get or set the width of the component based upon the CSS styles.\n     * See {@link Component#dimension} for more detailed information.\n     *\n     * @param {number|string} [num]\n     *        The width that you want to set postfixed with '%', 'px' or nothing.\n     *\n     * @param {boolean} [skipListeners]\n     *        Skip the componentresize event trigger\n     *\n     * @return {number|string}\n     *         The width when getting, zero if there is no width. Can be a string\n     *           postpixed with '%' or 'px'.\n     */\n    width(num, skipListeners) {\n      return this.dimension('width', num, skipListeners);\n    }\n\n    /**\n     * Get or set the height of the component based upon the CSS styles.\n     * See {@link Component#dimension} for more detailed information.\n     *\n     * @param {number|string} [num]\n     *        The height that you want to set postfixed with '%', 'px' or nothing.\n     *\n     * @param {boolean} [skipListeners]\n     *        Skip the componentresize event trigger\n     *\n     * @return {number|string}\n     *         The width when getting, zero if there is no width. Can be a string\n     *         postpixed with '%' or 'px'.\n     */\n    height(num, skipListeners) {\n      return this.dimension('height', num, skipListeners);\n    }\n\n    /**\n     * Set both the width and height of the `Component` element at the same time.\n     *\n     * @param  {number|string} width\n     *         Width to set the `Component`s element to.\n     *\n     * @param  {number|string} height\n     *         Height to set the `Component`s element to.\n     */\n    dimensions(width, height) {\n      // Skip componentresize listeners on width for optimization\n      this.width(width, true);\n      this.height(height);\n    }\n\n    /**\n     * Get or set width or height of the `Component` element. This is the shared code\n     * for the {@link Component#width} and {@link Component#height}.\n     *\n     * Things to know:\n     * - If the width or height in an number this will return the number postfixed with 'px'.\n     * - If the width/height is a percent this will return the percent postfixed with '%'\n     * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n     *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n     *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n     *   for more information\n     * - If you want the computed style of the component, use {@link Component#currentWidth}\n     *   and {@link {Component#currentHeight}\n     *\n     * @fires Component#componentresize\n     *\n     * @param {string} widthOrHeight\n     8        'width' or 'height'\n     *\n     * @param  {number|string} [num]\n     8         New dimension\n     *\n     * @param  {boolean} [skipListeners]\n     *         Skip componentresize event trigger\n     *\n     * @return {number}\n     *         The dimension when getting or 0 if unset\n     */\n    dimension(widthOrHeight, num, skipListeners) {\n      if (num !== undefined) {\n        // Set to zero if null or literally NaN (NaN !== NaN)\n        if (num === null || num !== num) {\n          num = 0;\n        }\n\n        // Check if using css width/height (% or px) and adjust\n        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n          this.el_.style[widthOrHeight] = num;\n        } else if (num === 'auto') {\n          this.el_.style[widthOrHeight] = '';\n        } else {\n          this.el_.style[widthOrHeight] = num + 'px';\n        }\n\n        // skipListeners allows us to avoid triggering the resize event when setting both width and height\n        if (!skipListeners) {\n          /**\n           * Triggered when a component is resized.\n           *\n           * @event Component#componentresize\n           * @type {EventTarget~Event}\n           */\n          this.trigger('componentresize');\n        }\n        return;\n      }\n\n      // Not setting a value, so getting it\n      // Make sure element exists\n      if (!this.el_) {\n        return 0;\n      }\n\n      // Get dimension value from style\n      const val = this.el_.style[widthOrHeight];\n      const pxIndex = val.indexOf('px');\n      if (pxIndex !== -1) {\n        // Return the pixel value with no 'px'\n        return parseInt(val.slice(0, pxIndex), 10);\n      }\n\n      // No px so using % or no style was set, so falling back to offsetWidth/height\n      // If component has display:none, offset will return 0\n      // TODO: handle display:none and no dimension style using px\n      return parseInt(this.el_['offset' + toTitleCase$1(widthOrHeight)], 10);\n    }\n\n    /**\n     * Get the computed width or the height of the component's element.\n     *\n     * Uses `window.getComputedStyle`.\n     *\n     * @param {string} widthOrHeight\n     *        A string containing 'width' or 'height'. Whichever one you want to get.\n     *\n     * @return {number}\n     *         The dimension that gets asked for or 0 if nothing was set\n     *         for that dimension.\n     */\n    currentDimension(widthOrHeight) {\n      let computedWidthOrHeight = 0;\n      if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n        throw new Error('currentDimension only accepts width or height value');\n      }\n      computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);\n\n      // remove 'px' from variable and parse as integer\n      computedWidthOrHeight = parseFloat(computedWidthOrHeight);\n\n      // if the computed value is still 0, it's possible that the browser is lying\n      // and we want to check the offset values.\n      // This code also runs wherever getComputedStyle doesn't exist.\n      if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {\n        const rule = `offset${toTitleCase$1(widthOrHeight)}`;\n        computedWidthOrHeight = this.el_[rule];\n      }\n      return computedWidthOrHeight;\n    }\n\n    /**\n     * An object that contains width and height values of the `Component`s\n     * computed style. Uses `window.getComputedStyle`.\n     *\n     * @typedef {Object} Component~DimensionObject\n     *\n     * @property {number} width\n     *           The width of the `Component`s computed style.\n     *\n     * @property {number} height\n     *           The height of the `Component`s computed style.\n     */\n\n    /**\n     * Get an object that contains computed width and height values of the\n     * component's element.\n     *\n     * Uses `window.getComputedStyle`.\n     *\n     * @return {Component~DimensionObject}\n     *         The computed dimensions of the component's element.\n     */\n    currentDimensions() {\n      return {\n        width: this.currentDimension('width'),\n        height: this.currentDimension('height')\n      };\n    }\n\n    /**\n     * Get the computed width of the component's element.\n     *\n     * Uses `window.getComputedStyle`.\n     *\n     * @return {number}\n     *         The computed width of the component's element.\n     */\n    currentWidth() {\n      return this.currentDimension('width');\n    }\n\n    /**\n     * Get the computed height of the component's element.\n     *\n     * Uses `window.getComputedStyle`.\n     *\n     * @return {number}\n     *         The computed height of the component's element.\n     */\n    currentHeight() {\n      return this.currentDimension('height');\n    }\n\n    /**\n     * Set the focus to this component\n     */\n    focus() {\n      this.el_.focus();\n    }\n\n    /**\n     * Remove the focus from this component\n     */\n    blur() {\n      this.el_.blur();\n    }\n\n    /**\n     * When this Component receives a `keydown` event which it does not process,\n     *  it passes the event to the Player for handling.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     */\n    handleKeyDown(event) {\n      if (this.player_) {\n        // We only stop propagation here because we want unhandled events to fall\n        // back to the browser. Exclude Tab for focus trapping.\n        if (!keycode.isEventKey(event, 'Tab')) {\n          event.stopPropagation();\n        }\n        this.player_.handleKeyDown(event);\n      }\n    }\n\n    /**\n     * Many components used to have a `handleKeyPress` method, which was poorly\n     * named because it listened to a `keydown` event. This method name now\n     * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`\n     * will not see their method calls stop working.\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to be called.\n     */\n    handleKeyPress(event) {\n      this.handleKeyDown(event);\n    }\n\n    /**\n     * Emit a 'tap' events when touch event support gets detected. This gets used to\n     * support toggling the controls through a tap on the video. They get enabled\n     * because every sub-component would have extra overhead otherwise.\n     *\n     * @private\n     * @fires Component#tap\n     * @listens Component#touchstart\n     * @listens Component#touchmove\n     * @listens Component#touchleave\n     * @listens Component#touchcancel\n     * @listens Component#touchend\n      */\n    emitTapEvents() {\n      // Track the start time so we can determine how long the touch lasted\n      let touchStart = 0;\n      let firstTouch = null;\n\n      // Maximum movement allowed during a touch event to still be considered a tap\n      // Other popular libs use anywhere from 2 (hammer.js) to 15,\n      // so 10 seems like a nice, round number.\n      const tapMovementThreshold = 10;\n\n      // The maximum length a touch can be while still being considered a tap\n      const touchTimeThreshold = 200;\n      let couldBeTap;\n      this.on('touchstart', function (event) {\n        // If more than one finger, don't consider treating this as a click\n        if (event.touches.length === 1) {\n          // Copy pageX/pageY from the object\n          firstTouch = {\n            pageX: event.touches[0].pageX,\n            pageY: event.touches[0].pageY\n          };\n          // Record start time so we can detect a tap vs. \"touch and hold\"\n          touchStart = window.performance.now();\n          // Reset couldBeTap tracking\n          couldBeTap = true;\n        }\n      });\n      this.on('touchmove', function (event) {\n        // If more than one finger, don't consider treating this as a click\n        if (event.touches.length > 1) {\n          couldBeTap = false;\n        } else if (firstTouch) {\n          // Some devices will throw touchmoves for all but the slightest of taps.\n          // So, if we moved only a small distance, this could still be a tap\n          const xdiff = event.touches[0].pageX - firstTouch.pageX;\n          const ydiff = event.touches[0].pageY - firstTouch.pageY;\n          const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n          if (touchDistance > tapMovementThreshold) {\n            couldBeTap = false;\n          }\n        }\n      });\n      const noTap = function () {\n        couldBeTap = false;\n      };\n\n      // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n      this.on('touchleave', noTap);\n      this.on('touchcancel', noTap);\n\n      // When the touch ends, measure how long it took and trigger the appropriate\n      // event\n      this.on('touchend', function (event) {\n        firstTouch = null;\n        // Proceed only if the touchmove/leave/cancel event didn't happen\n        if (couldBeTap === true) {\n          // Measure how long the touch lasted\n          const touchTime = window.performance.now() - touchStart;\n\n          // Make sure the touch was less than the threshold to be considered a tap\n          if (touchTime < touchTimeThreshold) {\n            // Don't let browser turn this into a click\n            event.preventDefault();\n            /**\n             * Triggered when a `Component` is tapped.\n             *\n             * @event Component#tap\n             * @type {EventTarget~Event}\n             */\n            this.trigger('tap');\n            // It may be good to copy the touchend event object and change the\n            // type to tap, if the other event properties aren't exact after\n            // Events.fixEvent runs (e.g. event.target)\n          }\n        }\n      });\n    }\n\n    /**\n     * This function reports user activity whenever touch events happen. This can get\n     * turned off by any sub-components that wants touch events to act another way.\n     *\n     * Report user touch activity when touch events occur. User activity gets used to\n     * determine when controls should show/hide. It is simple when it comes to mouse\n     * events, because any mouse event should show the controls. So we capture mouse\n     * events that bubble up to the player and report activity when that happens.\n     * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n     * controls. So touch events can't help us at the player level either.\n     *\n     * User activity gets checked asynchronously. So what could happen is a tap event\n     * on the video turns the controls off. Then the `touchend` event bubbles up to\n     * the player. Which, if it reported user activity, would turn the controls right\n     * back on. We also don't want to completely block touch events from bubbling up.\n     * Furthermore a `touchmove` event and anything other than a tap, should not turn\n     * controls back on.\n     *\n     * @listens Component#touchstart\n     * @listens Component#touchmove\n     * @listens Component#touchend\n     * @listens Component#touchcancel\n     */\n    enableTouchActivity() {\n      // Don't continue if the root player doesn't support reporting user activity\n      if (!this.player() || !this.player().reportUserActivity) {\n        return;\n      }\n\n      // listener for reporting that the user is active\n      const report = bind_(this.player(), this.player().reportUserActivity);\n      let touchHolding;\n      this.on('touchstart', function () {\n        report();\n        // For as long as the they are touching the device or have their mouse down,\n        // we consider them active even if they're not moving their finger or mouse.\n        // So we want to continue to update that they are active\n        this.clearInterval(touchHolding);\n        // report at the same interval as activityCheck\n        touchHolding = this.setInterval(report, 250);\n      });\n      const touchEnd = function (event) {\n        report();\n        // stop the interval that maintains activity if the touch is holding\n        this.clearInterval(touchHolding);\n      };\n      this.on('touchmove', report);\n      this.on('touchend', touchEnd);\n      this.on('touchcancel', touchEnd);\n    }\n\n    /**\n     * A callback that has no parameters and is bound into `Component`s context.\n     *\n     * @callback Component~GenericCallback\n     * @this Component\n     */\n\n    /**\n     * Creates a function that runs after an `x` millisecond timeout. This function is a\n     * wrapper around `window.setTimeout`. There are a few reasons to use this one\n     * instead though:\n     * 1. It gets cleared via  {@link Component#clearTimeout} when\n     *    {@link Component#dispose} gets called.\n     * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n     *\n     * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\n     *         will cause its dispose listener not to get cleaned up! Please use\n     *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\n     *\n     * @param {Component~GenericCallback} fn\n     *        The function that will be run after `timeout`.\n     *\n     * @param {number} timeout\n     *        Timeout in milliseconds to delay before executing the specified function.\n     *\n     * @return {number}\n     *         Returns a timeout ID that gets used to identify the timeout. It can also\n     *         get used in {@link Component#clearTimeout} to clear the timeout that\n     *         was set.\n     *\n     * @listens Component#dispose\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n     */\n    setTimeout(fn, timeout) {\n      // declare as variables so they are properly available in timeout function\n      // eslint-disable-next-line\n      var timeoutId;\n      fn = bind_(this, fn);\n      this.clearTimersOnDispose_();\n      timeoutId = window.setTimeout(() => {\n        if (this.setTimeoutIds_.has(timeoutId)) {\n          this.setTimeoutIds_.delete(timeoutId);\n        }\n        fn();\n      }, timeout);\n      this.setTimeoutIds_.add(timeoutId);\n      return timeoutId;\n    }\n\n    /**\n     * Clears a timeout that gets created via `window.setTimeout` or\n     * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n     * use this function instead of `window.clearTimout`. If you don't your dispose\n     * listener will not get cleaned up until {@link Component#dispose}!\n     *\n     * @param {number} timeoutId\n     *        The id of the timeout to clear. The return value of\n     *        {@link Component#setTimeout} or `window.setTimeout`.\n     *\n     * @return {number}\n     *         Returns the timeout id that was cleared.\n     *\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n     */\n    clearTimeout(timeoutId) {\n      if (this.setTimeoutIds_.has(timeoutId)) {\n        this.setTimeoutIds_.delete(timeoutId);\n        window.clearTimeout(timeoutId);\n      }\n      return timeoutId;\n    }\n\n    /**\n     * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n     * around `window.setInterval`. There are a few reasons to use this one instead though.\n     * 1. It gets cleared via  {@link Component#clearInterval} when\n     *    {@link Component#dispose} gets called.\n     * 2. The function callback will be a {@link Component~GenericCallback}\n     *\n     * @param {Component~GenericCallback} fn\n     *        The function to run every `x` seconds.\n     *\n     * @param {number} interval\n     *        Execute the specified function every `x` milliseconds.\n     *\n     * @return {number}\n     *         Returns an id that can be used to identify the interval. It can also be be used in\n     *         {@link Component#clearInterval} to clear the interval.\n     *\n     * @listens Component#dispose\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n     */\n    setInterval(fn, interval) {\n      fn = bind_(this, fn);\n      this.clearTimersOnDispose_();\n      const intervalId = window.setInterval(fn, interval);\n      this.setIntervalIds_.add(intervalId);\n      return intervalId;\n    }\n\n    /**\n     * Clears an interval that gets created via `window.setInterval` or\n     * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n     * use this function instead of `window.clearInterval`. If you don't your dispose\n     * listener will not get cleaned up until {@link Component#dispose}!\n     *\n     * @param {number} intervalId\n     *        The id of the interval to clear. The return value of\n     *        {@link Component#setInterval} or `window.setInterval`.\n     *\n     * @return {number}\n     *         Returns the interval id that was cleared.\n     *\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n     */\n    clearInterval(intervalId) {\n      if (this.setIntervalIds_.has(intervalId)) {\n        this.setIntervalIds_.delete(intervalId);\n        window.clearInterval(intervalId);\n      }\n      return intervalId;\n    }\n\n    /**\n     * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n     * with a few extra bonuses:\n     *\n     * - Supports browsers that do not support rAF by falling back to\n     *   {@link Component#setTimeout}.\n     *\n     * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n     *   bound to the component).\n     *\n     * - Automatic cancellation of the rAF callback is handled if the component\n     *   is disposed before it is called.\n     *\n     * @param  {Component~GenericCallback} fn\n     *         A function that will be bound to this component and executed just\n     *         before the browser's next repaint.\n     *\n     * @return {number}\n     *         Returns an rAF ID that gets used to identify the timeout. It can\n     *         also be used in {@link Component#cancelAnimationFrame} to cancel\n     *         the animation frame callback.\n     *\n     * @listens Component#dispose\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n     */\n    requestAnimationFrame(fn) {\n      this.clearTimersOnDispose_();\n\n      // declare as variables so they are properly available in rAF function\n      // eslint-disable-next-line\n      var id;\n      fn = bind_(this, fn);\n      id = window.requestAnimationFrame(() => {\n        if (this.rafIds_.has(id)) {\n          this.rafIds_.delete(id);\n        }\n        fn();\n      });\n      this.rafIds_.add(id);\n      return id;\n    }\n\n    /**\n     * Request an animation frame, but only one named animation\n     * frame will be queued. Another will never be added until\n     * the previous one finishes.\n     *\n     * @param {string} name\n     *        The name to give this requestAnimationFrame\n     *\n     * @param  {Component~GenericCallback} fn\n     *         A function that will be bound to this component and executed just\n     *         before the browser's next repaint.\n     */\n    requestNamedAnimationFrame(name, fn) {\n      if (this.namedRafs_.has(name)) {\n        return;\n      }\n      this.clearTimersOnDispose_();\n      fn = bind_(this, fn);\n      const id = this.requestAnimationFrame(() => {\n        fn();\n        if (this.namedRafs_.has(name)) {\n          this.namedRafs_.delete(name);\n        }\n      });\n      this.namedRafs_.set(name, id);\n      return name;\n    }\n\n    /**\n     * Cancels a current named animation frame if it exists.\n     *\n     * @param {string} name\n     *        The name of the requestAnimationFrame to cancel.\n     */\n    cancelNamedAnimationFrame(name) {\n      if (!this.namedRafs_.has(name)) {\n        return;\n      }\n      this.cancelAnimationFrame(this.namedRafs_.get(name));\n      this.namedRafs_.delete(name);\n    }\n\n    /**\n     * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n     * (rAF).\n     *\n     * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n     * use this function instead of `window.cancelAnimationFrame`. If you don't,\n     * your dispose listener will not get cleaned up until {@link Component#dispose}!\n     *\n     * @param {number} id\n     *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n     *\n     * @return {number}\n     *         Returns the rAF ID that was cleared.\n     *\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n     */\n    cancelAnimationFrame(id) {\n      if (this.rafIds_.has(id)) {\n        this.rafIds_.delete(id);\n        window.cancelAnimationFrame(id);\n      }\n      return id;\n    }\n\n    /**\n     * A function to setup `requestAnimationFrame`, `setTimeout`,\n     * and `setInterval`, clearing on dispose.\n     *\n     * > Previously each timer added and removed dispose listeners on it's own.\n     * For better performance it was decided to batch them all, and use `Set`s\n     * to track outstanding timer ids.\n     *\n     * @private\n     */\n    clearTimersOnDispose_() {\n      if (this.clearingTimersOnDispose_) {\n        return;\n      }\n      this.clearingTimersOnDispose_ = true;\n      this.one('dispose', () => {\n        [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(([idName, cancelName]) => {\n          // for a `Set` key will actually be the value again\n          // so forEach((val, val) =>` but for maps we want to use\n          // the key.\n          this[idName].forEach((val, key) => this[cancelName](key));\n        });\n        this.clearingTimersOnDispose_ = false;\n      });\n    }\n\n    /**\n     * Register a `Component` with `videojs` given the name and the component.\n     *\n     * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n     *         should be registered using {@link Tech.registerTech} or\n     *         {@link videojs:videojs.registerTech}.\n     *\n     * > NOTE: This function can also be seen on videojs as\n     *         {@link videojs:videojs.registerComponent}.\n     *\n     * @param {string} name\n     *        The name of the `Component` to register.\n     *\n     * @param {Component} ComponentToRegister\n     *        The `Component` class to register.\n     *\n     * @return {Component}\n     *         The `Component` that was registered.\n     */\n    static registerComponent(name, ComponentToRegister) {\n      if (typeof name !== 'string' || !name) {\n        throw new Error(`Illegal component name, \"${name}\"; must be a non-empty string.`);\n      }\n      const Tech = Component$1.getComponent('Tech');\n\n      // We need to make sure this check is only done if Tech has been registered.\n      const isTech = Tech && Tech.isTech(ComponentToRegister);\n      const isComp = Component$1 === ComponentToRegister || Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);\n      if (isTech || !isComp) {\n        let reason;\n        if (isTech) {\n          reason = 'techs must be registered using Tech.registerTech()';\n        } else {\n          reason = 'must be a Component subclass';\n        }\n        throw new Error(`Illegal component, \"${name}\"; ${reason}.`);\n      }\n      name = toTitleCase$1(name);\n      if (!Component$1.components_) {\n        Component$1.components_ = {};\n      }\n      const Player = Component$1.getComponent('Player');\n      if (name === 'Player' && Player && Player.players) {\n        const players = Player.players;\n        const playerNames = Object.keys(players);\n\n        // If we have players that were disposed, then their name will still be\n        // in Players.players. So, we must loop through and verify that the value\n        // for each item is not null. This allows registration of the Player component\n        // after all players have been disposed or before any were created.\n        if (players && playerNames.length > 0 && playerNames.map(pname => players[pname]).every(Boolean)) {\n          throw new Error('Can not register Player component after player has been created.');\n        }\n      }\n      Component$1.components_[name] = ComponentToRegister;\n      Component$1.components_[toLowerCase(name)] = ComponentToRegister;\n      return ComponentToRegister;\n    }\n\n    /**\n     * Get a `Component` based on the name it was registered with.\n     *\n     * @param {string} name\n     *        The Name of the component to get.\n     *\n     * @return {Component}\n     *         The `Component` that got registered under the given name.\n     */\n    static getComponent(name) {\n      if (!name || !Component$1.components_) {\n        return;\n      }\n      return Component$1.components_[name];\n    }\n  }\n  Component$1.registerComponent('Component', Component$1);\n\n  /**\n   * @file time.js\n   * @module time\n   */\n\n  /**\n   * Returns the time for the specified index at the start or end\n   * of a TimeRange object.\n   *\n   * @typedef    {Function} TimeRangeIndex\n   *\n   * @param      {number} [index=0]\n   *             The range number to return the time for.\n   *\n   * @return     {number}\n   *             The time offset at the specified index.\n   *\n   * @deprecated The index argument must be provided.\n   *             In the future, leaving it out will throw an error.\n   */\n\n  /**\n   * An object that contains ranges of time.\n   *\n   * @typedef  {Object} TimeRange\n   *\n   * @property {number} length\n   *           The number of time ranges represented by this object.\n   *\n   * @property {module:time~TimeRangeIndex} start\n   *           Returns the time offset at which a specified time range begins.\n   *\n   * @property {module:time~TimeRangeIndex} end\n   *           Returns the time offset at which a specified time range ends.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n   */\n\n  /**\n   * Check if any of the time ranges are over the maximum index.\n   *\n   * @private\n   * @param   {string} fnName\n   *          The function name to use for logging\n   *\n   * @param   {number} index\n   *          The index to check\n   *\n   * @param   {number} maxIndex\n   *          The maximum possible index\n   *\n   * @throws  {Error} if the timeRanges provided are over the maxIndex\n   */\n  function rangeCheck(fnName, index, maxIndex) {\n    if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n      throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);\n    }\n  }\n\n  /**\n   * Get the time for the specified index at the start or end\n   * of a TimeRange object.\n   *\n   * @private\n   * @param      {string} fnName\n   *             The function name to use for logging\n   *\n   * @param      {string} valueIndex\n   *             The property that should be used to get the time. should be\n   *             'start' or 'end'\n   *\n   * @param      {Array} ranges\n   *             An array of time ranges\n   *\n   * @param      {Array} [rangeIndex=0]\n   *             The index to start the search at\n   *\n   * @return     {number}\n   *             The time that offset at the specified index.\n   *\n   * @deprecated rangeIndex must be set to a value, in the future this will throw an error.\n   * @throws     {Error} if rangeIndex is more than the length of ranges\n   */\n  function getRange(fnName, valueIndex, ranges, rangeIndex) {\n    rangeCheck(fnName, rangeIndex, ranges.length - 1);\n    return ranges[rangeIndex][valueIndex];\n  }\n\n  /**\n   * Create a time range object given ranges of time.\n   *\n   * @private\n   * @param   {Array} [ranges]\n   *          An array of time ranges.\n   */\n  function createTimeRangesObj(ranges) {\n    let timeRangesObj;\n    if (ranges === undefined || ranges.length === 0) {\n      timeRangesObj = {\n        length: 0,\n        start() {\n          throw new Error('This TimeRanges object is empty');\n        },\n        end() {\n          throw new Error('This TimeRanges object is empty');\n        }\n      };\n    } else {\n      timeRangesObj = {\n        length: ranges.length,\n        start: getRange.bind(null, 'start', 0, ranges),\n        end: getRange.bind(null, 'end', 1, ranges)\n      };\n    }\n    if (window.Symbol && window.Symbol.iterator) {\n      timeRangesObj[window.Symbol.iterator] = () => (ranges || []).values();\n    }\n    return timeRangesObj;\n  }\n\n  /**\n   * Create a `TimeRange` object which mimics an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges|HTML5 TimeRanges instance}.\n   *\n   * @param {number|Array[]} start\n   *        The start of a single range (a number) or an array of ranges (an\n   *        array of arrays of two numbers each).\n   *\n   * @param {number} end\n   *        The end of a single range. Cannot be used with the array form of\n   *        the `start` argument.\n   */\n  function createTimeRanges$1(start, end) {\n    if (Array.isArray(start)) {\n      return createTimeRangesObj(start);\n    } else if (start === undefined || end === undefined) {\n      return createTimeRangesObj();\n    }\n    return createTimeRangesObj([[start, end]]);\n  }\n\n  /**\n   * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in\n   * seconds) will force a number of leading zeros to cover the length of the\n   * guide.\n   *\n   * @private\n   * @param  {number} seconds\n   *         Number of seconds to be turned into a string\n   *\n   * @param  {number} guide\n   *         Number (in seconds) to model the string after\n   *\n   * @return {string}\n   *         Time formatted as H:MM:SS or M:SS\n   */\n  const defaultImplementation = function (seconds, guide) {\n    seconds = seconds < 0 ? 0 : seconds;\n    let s = Math.floor(seconds % 60);\n    let m = Math.floor(seconds / 60 % 60);\n    let h = Math.floor(seconds / 3600);\n    const gm = Math.floor(guide / 60 % 60);\n    const gh = Math.floor(guide / 3600);\n\n    // handle invalid times\n    if (isNaN(seconds) || seconds === Infinity) {\n      // '-' is false for all relational operators (e.g. <, >=) so this setting\n      // will add the minimum number of fields specified by the guide\n      h = m = s = '-';\n    }\n\n    // Check if we need to show hours\n    h = h > 0 || gh > 0 ? h + ':' : '';\n\n    // If hours are showing, we may need to add a leading zero.\n    // Always show at least one digit of minutes.\n    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n    // Check if leading zero is need for seconds\n    s = s < 10 ? '0' + s : s;\n    return h + m + s;\n  };\n\n  // Internal pointer to the current implementation.\n  let implementation = defaultImplementation;\n\n  /**\n   * Replaces the default formatTime implementation with a custom implementation.\n   *\n   * @param {Function} customImplementation\n   *        A function which will be used in place of the default formatTime\n   *        implementation. Will receive the current time in seconds and the\n   *        guide (in seconds) as arguments.\n   */\n  function setFormatTime(customImplementation) {\n    implementation = customImplementation;\n  }\n\n  /**\n   * Resets formatTime to the default implementation.\n   */\n  function resetFormatTime() {\n    implementation = defaultImplementation;\n  }\n\n  /**\n   * Delegates to either the default time formatting function or a custom\n   * function supplied via `setFormatTime`.\n   *\n   * Formats seconds as a time string (H:MM:SS or M:SS). Supplying a\n   * guide (in seconds) will force a number of leading zeros to cover the\n   * length of the guide.\n   *\n   * @example  formatTime(125, 600) === \"02:05\"\n   * @param    {number} seconds\n   *           Number of seconds to be turned into a string\n   *\n   * @param    {number} guide\n   *           Number (in seconds) to model the string after\n   *\n   * @return   {string}\n   *           Time formatted as H:MM:SS or M:SS\n   */\n  function formatTime(seconds, guide = seconds) {\n    return implementation(seconds, guide);\n  }\n\n  var Time = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createTimeRanges: createTimeRanges$1,\n    createTimeRange: createTimeRanges$1,\n    setFormatTime: setFormatTime,\n    resetFormatTime: resetFormatTime,\n    formatTime: formatTime\n  });\n\n  /**\n   * @file buffer.js\n   * @module buffer\n   */\n\n  /**\n   * Compute the percentage of the media that has been buffered.\n   *\n   * @param {TimeRange} buffered\n   *        The current `TimeRange` object representing buffered time ranges\n   *\n   * @param {number} duration\n   *        Total duration of the media\n   *\n   * @return {number}\n   *         Percent buffered of the total duration in decimal form.\n   */\n  function bufferedPercent(buffered, duration) {\n    let bufferedDuration = 0;\n    let start;\n    let end;\n    if (!duration) {\n      return 0;\n    }\n    if (!buffered || !buffered.length) {\n      buffered = createTimeRanges$1(0, 0);\n    }\n    for (let i = 0; i < buffered.length; i++) {\n      start = buffered.start(i);\n      end = buffered.end(i);\n\n      // buffered end can be bigger than duration by a very small fraction\n      if (end > duration) {\n        end = duration;\n      }\n      bufferedDuration += end - start;\n    }\n    return bufferedDuration / duration;\n  }\n\n  /**\n   * @file media-error.js\n   */\n\n  /**\n   * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n   *\n   * @param {number|string|Object|MediaError} value\n   *        This can be of multiple types:\n   *        - number: should be a standard error code\n   *        - string: an error message (the code will be 0)\n   *        - Object: arbitrary properties\n   *        - `MediaError` (native): used to populate a video.js `MediaError` object\n   *        - `MediaError` (video.js): will return itself if it's already a\n   *          video.js `MediaError` object.\n   *\n   * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n   * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n   *\n   * @class MediaError\n   */\n  function MediaError(value) {\n    // Allow redundant calls to this constructor to avoid having `instanceof`\n    // checks peppered around the code.\n    if (value instanceof MediaError) {\n      return value;\n    }\n    if (typeof value === 'number') {\n      this.code = value;\n    } else if (typeof value === 'string') {\n      // default code is zero, so this is a custom error\n      this.message = value;\n    } else if (isObject$1(value)) {\n      // We assign the `code` property manually because native `MediaError` objects\n      // do not expose it as an own/enumerable property of the object.\n      if (typeof value.code === 'number') {\n        this.code = value.code;\n      }\n      Object.assign(this, value);\n    }\n    if (!this.message) {\n      this.message = MediaError.defaultMessages[this.code] || '';\n    }\n  }\n\n  /**\n   * The error code that refers two one of the defined `MediaError` types\n   *\n   * @type {Number}\n   */\n  MediaError.prototype.code = 0;\n\n  /**\n   * An optional message that to show with the error. Message is not part of the HTML5\n   * video spec but allows for more informative custom errors.\n   *\n   * @type {String}\n   */\n  MediaError.prototype.message = '';\n\n  /**\n   * An optional status code that can be set by plugins to allow even more detail about\n   * the error. For example a plugin might provide a specific HTTP status code and an\n   * error message for that code. Then when the plugin gets that error this class will\n   * know how to display an error message for it. This allows a custom message to show\n   * up on the `Player` error overlay.\n   *\n   * @type {Array}\n   */\n  MediaError.prototype.status = null;\n\n  /**\n   * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n   * specification listed under {@link MediaError} for more information.\n   *\n   * @enum {array}\n   * @readonly\n   * @property {string} 0 - MEDIA_ERR_CUSTOM\n   * @property {string} 1 - MEDIA_ERR_ABORTED\n   * @property {string} 2 - MEDIA_ERR_NETWORK\n   * @property {string} 3 - MEDIA_ERR_DECODE\n   * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n   * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n   */\n  MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n\n  /**\n   * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n   *\n   * @type {Array}\n   * @constant\n   */\n  MediaError.defaultMessages = {\n    1: 'You aborted the media playback',\n    2: 'A network error caused the media download to fail part-way.',\n    3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n    4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n    5: 'The media is encrypted and we do not have the keys to decrypt it.'\n  };\n\n  // Add types as properties on MediaError\n  // e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\n  for (let errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n    MediaError[MediaError.errorTypes[errNum]] = errNum;\n    // values should be accessible on both the class and instance\n    MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n  }\n\n  var tuple = SafeParseTuple;\n  function SafeParseTuple(obj, reviver) {\n    var json;\n    var error = null;\n    try {\n      json = JSON.parse(obj, reviver);\n    } catch (err) {\n      error = err;\n    }\n    return [error, json];\n  }\n\n  /**\n   * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n   *\n   * @param  {Object}  value\n   *         An object that may or may not be `Promise`-like.\n   *\n   * @return {boolean}\n   *         Whether or not the object is `Promise`-like.\n   */\n  function isPromise(value) {\n    return value !== undefined && value !== null && typeof value.then === 'function';\n  }\n\n  /**\n   * Silence a Promise-like object.\n   *\n   * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n   * play promise\" rejection error messages.\n   *\n   * @param  {Object} value\n   *         An object that may or may not be `Promise`-like.\n   */\n  function silencePromise(value) {\n    if (isPromise(value)) {\n      value.then(null, e => {});\n    }\n  }\n\n  /**\n   * @file text-track-list-converter.js Utilities for capturing text track state and\n   * re-creating tracks based on a capture.\n   *\n   * @module text-track-list-converter\n   */\n\n  /**\n   * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n   * represents the {@link TextTrack}'s state.\n   *\n   * @param {TextTrack} track\n   *        The text track to query.\n   *\n   * @return {Object}\n   *         A serializable javascript representation of the TextTrack.\n   * @private\n   */\n  const trackToJson_ = function (track) {\n    const ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce((acc, prop, i) => {\n      if (track[prop]) {\n        acc[prop] = track[prop];\n      }\n      return acc;\n    }, {\n      cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n        return {\n          startTime: cue.startTime,\n          endTime: cue.endTime,\n          text: cue.text,\n          id: cue.id\n        };\n      })\n    });\n    return ret;\n  };\n\n  /**\n   * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n   * state of all {@link TextTrack}s currently configured. The return array is compatible with\n   * {@link text-track-list-converter:jsonToTextTracks}.\n   *\n   * @param {Tech} tech\n   *        The tech object to query\n   *\n   * @return {Array}\n   *         A serializable javascript representation of the {@link Tech}s\n   *         {@link TextTrackList}.\n   */\n  const textTracksToJson = function (tech) {\n    const trackEls = tech.$$('track');\n    const trackObjs = Array.prototype.map.call(trackEls, t => t.track);\n    const tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n      const json = trackToJson_(trackEl.track);\n      if (trackEl.src) {\n        json.src = trackEl.src;\n      }\n      return json;\n    });\n    return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n      return trackObjs.indexOf(track) === -1;\n    }).map(trackToJson_));\n  };\n\n  /**\n   * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n   * object {@link TextTrack} representations.\n   *\n   * @param {Array} json\n   *        An array of `TextTrack` representation objects, like those that would be\n   *        produced by `textTracksToJson`.\n   *\n   * @param {Tech} tech\n   *        The `Tech` to create the `TextTrack`s on.\n   */\n  const jsonToTextTracks = function (json, tech) {\n    json.forEach(function (track) {\n      const addedTrack = tech.addRemoteTextTrack(track).track;\n      if (!track.src && track.cues) {\n        track.cues.forEach(cue => addedTrack.addCue(cue));\n      }\n    });\n    return tech.textTracks();\n  };\n  var textTrackConverter = {\n    textTracksToJson,\n    jsonToTextTracks,\n    trackToJson_\n  };\n\n  /**\n   * @file modal-dialog.js\n   */\n  const MODAL_CLASS_NAME = 'vjs-modal-dialog';\n\n  /**\n   * The `ModalDialog` displays over the video and its controls, which blocks\n   * interaction with the player until it is closed.\n   *\n   * Modal dialogs include a \"Close\" button and will close when that button\n   * is activated - or when ESC is pressed anywhere.\n   *\n   * @extends Component\n   */\n  class ModalDialog extends Component$1 {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Mixed} [options.content=undefined]\n     *        Provide customized content for this modal.\n     *\n     * @param {string} [options.description]\n     *        A text description for the modal, primarily for accessibility.\n     *\n     * @param {boolean} [options.fillAlways=false]\n     *        Normally, modals are automatically filled only the first time\n     *        they open. This tells the modal to refresh its content\n     *        every time it opens.\n     *\n     * @param {string} [options.label]\n     *        A text label for the modal, primarily for accessibility.\n     *\n     * @param {boolean} [options.pauseOnOpen=true]\n     *        If `true`, playback will will be paused if playing when\n     *        the modal opens, and resumed when it closes.\n     *\n     * @param {boolean} [options.temporary=true]\n     *        If `true`, the modal can only be opened once; it will be\n     *        disposed as soon as it's closed.\n     *\n     * @param {boolean} [options.uncloseable=false]\n     *        If `true`, the user will not be able to close the modal\n     *        through the UI in the normal ways. Programmatic closing is\n     *        still possible.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.handleKeyDown_ = e => this.handleKeyDown(e);\n      this.close_ = e => this.close(e);\n      this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;\n      this.closeable(!this.options_.uncloseable);\n      this.content(this.options_.content);\n\n      // Make sure the contentEl is defined AFTER any children are initialized\n      // because we only want the contents of the modal in the contentEl\n      // (not the UI elements like the close button).\n      this.contentEl_ = createEl('div', {\n        className: `${MODAL_CLASS_NAME}-content`\n      }, {\n        role: 'document'\n      });\n      this.descEl_ = createEl('p', {\n        className: `${MODAL_CLASS_NAME}-description vjs-control-text`,\n        id: this.el().getAttribute('aria-describedby')\n      });\n      textContent(this.descEl_, this.description());\n      this.el_.appendChild(this.descEl_);\n      this.el_.appendChild(this.contentEl_);\n    }\n\n    /**\n     * Create the `ModalDialog`'s DOM element\n     *\n     * @return {Element}\n     *         The DOM element that gets created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: this.buildCSSClass(),\n        tabIndex: -1\n      }, {\n        'aria-describedby': `${this.id()}_description`,\n        'aria-hidden': 'true',\n        'aria-label': this.label(),\n        'role': 'dialog'\n      });\n    }\n    dispose() {\n      this.contentEl_ = null;\n      this.descEl_ = null;\n      this.previouslyActiveEl_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Returns the label string for this modal. Primarily used for accessibility.\n     *\n     * @return {string}\n     *         the localized or raw label of this modal.\n     */\n    label() {\n      return this.localize(this.options_.label || 'Modal Window');\n    }\n\n    /**\n     * Returns the description string for this modal. Primarily used for\n     * accessibility.\n     *\n     * @return {string}\n     *         The localized or raw description of this modal.\n     */\n    description() {\n      let desc = this.options_.description || this.localize('This is a modal window.');\n\n      // Append a universal closeability message if the modal is closeable.\n      if (this.closeable()) {\n        desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n      }\n      return desc;\n    }\n\n    /**\n     * Opens the modal.\n     *\n     * @fires ModalDialog#beforemodalopen\n     * @fires ModalDialog#modalopen\n     */\n    open() {\n      if (!this.opened_) {\n        const player = this.player();\n\n        /**\n          * Fired just before a `ModalDialog` is opened.\n          *\n          * @event ModalDialog#beforemodalopen\n          * @type {EventTarget~Event}\n          */\n        this.trigger('beforemodalopen');\n        this.opened_ = true;\n\n        // Fill content if the modal has never opened before and\n        // never been filled.\n        if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n          this.fill();\n        }\n\n        // If the player was playing, pause it and take note of its previously\n        // playing state.\n        this.wasPlaying_ = !player.paused();\n        if (this.options_.pauseOnOpen && this.wasPlaying_) {\n          player.pause();\n        }\n        this.on('keydown', this.handleKeyDown_);\n\n        // Hide controls and note if they were enabled.\n        this.hadControls_ = player.controls();\n        player.controls(false);\n        this.show();\n        this.conditionalFocus_();\n        this.el().setAttribute('aria-hidden', 'false');\n\n        /**\n          * Fired just after a `ModalDialog` is opened.\n          *\n          * @event ModalDialog#modalopen\n          * @type {EventTarget~Event}\n          */\n        this.trigger('modalopen');\n        this.hasBeenOpened_ = true;\n      }\n    }\n\n    /**\n     * If the `ModalDialog` is currently open or closed.\n     *\n     * @param  {boolean} [value]\n     *         If given, it will open (`true`) or close (`false`) the modal.\n     *\n     * @return {boolean}\n     *         the current open state of the modaldialog\n     */\n    opened(value) {\n      if (typeof value === 'boolean') {\n        this[value ? 'open' : 'close']();\n      }\n      return this.opened_;\n    }\n\n    /**\n     * Closes the modal, does nothing if the `ModalDialog` is\n     * not open.\n     *\n     * @fires ModalDialog#beforemodalclose\n     * @fires ModalDialog#modalclose\n     */\n    close() {\n      if (!this.opened_) {\n        return;\n      }\n      const player = this.player();\n\n      /**\n        * Fired just before a `ModalDialog` is closed.\n        *\n        * @event ModalDialog#beforemodalclose\n        * @type {EventTarget~Event}\n        */\n      this.trigger('beforemodalclose');\n      this.opened_ = false;\n      if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n        player.play();\n      }\n      this.off('keydown', this.handleKeyDown_);\n      if (this.hadControls_) {\n        player.controls(true);\n      }\n      this.hide();\n      this.el().setAttribute('aria-hidden', 'true');\n\n      /**\n        * Fired just after a `ModalDialog` is closed.\n        *\n        * @event ModalDialog#modalclose\n        * @type {EventTarget~Event}\n        */\n      this.trigger('modalclose');\n      this.conditionalBlur_();\n      if (this.options_.temporary) {\n        this.dispose();\n      }\n    }\n\n    /**\n     * Check to see if the `ModalDialog` is closeable via the UI.\n     *\n     * @param  {boolean} [value]\n     *         If given as a boolean, it will set the `closeable` option.\n     *\n     * @return {boolean}\n     *         Returns the final value of the closable option.\n     */\n    closeable(value) {\n      if (typeof value === 'boolean') {\n        const closeable = this.closeable_ = !!value;\n        let close = this.getChild('closeButton');\n\n        // If this is being made closeable and has no close button, add one.\n        if (closeable && !close) {\n          // The close button should be a child of the modal - not its\n          // content element, so temporarily change the content element.\n          const temp = this.contentEl_;\n          this.contentEl_ = this.el_;\n          close = this.addChild('closeButton', {\n            controlText: 'Close Modal Dialog'\n          });\n          this.contentEl_ = temp;\n          this.on(close, 'close', this.close_);\n        }\n\n        // If this is being made uncloseable and has a close button, remove it.\n        if (!closeable && close) {\n          this.off(close, 'close', this.close_);\n          this.removeChild(close);\n          close.dispose();\n        }\n      }\n      return this.closeable_;\n    }\n\n    /**\n     * Fill the modal's content element with the modal's \"content\" option.\n     * The content element will be emptied before this change takes place.\n     */\n    fill() {\n      this.fillWith(this.content());\n    }\n\n    /**\n     * Fill the modal's content element with arbitrary content.\n     * The content element will be emptied before this change takes place.\n     *\n     * @fires ModalDialog#beforemodalfill\n     * @fires ModalDialog#modalfill\n     *\n     * @param {Mixed} [content]\n     *        The same rules apply to this as apply to the `content` option.\n     */\n    fillWith(content) {\n      const contentEl = this.contentEl();\n      const parentEl = contentEl.parentNode;\n      const nextSiblingEl = contentEl.nextSibling;\n\n      /**\n        * Fired just before a `ModalDialog` is filled with content.\n        *\n        * @event ModalDialog#beforemodalfill\n        * @type {EventTarget~Event}\n        */\n      this.trigger('beforemodalfill');\n      this.hasBeenFilled_ = true;\n\n      // Detach the content element from the DOM before performing\n      // manipulation to avoid modifying the live DOM multiple times.\n      parentEl.removeChild(contentEl);\n      this.empty();\n      insertContent(contentEl, content);\n      /**\n       * Fired just after a `ModalDialog` is filled with content.\n       *\n       * @event ModalDialog#modalfill\n       * @type {EventTarget~Event}\n       */\n      this.trigger('modalfill');\n\n      // Re-inject the re-filled content element.\n      if (nextSiblingEl) {\n        parentEl.insertBefore(contentEl, nextSiblingEl);\n      } else {\n        parentEl.appendChild(contentEl);\n      }\n\n      // make sure that the close button is last in the dialog DOM\n      const closeButton = this.getChild('closeButton');\n      if (closeButton) {\n        parentEl.appendChild(closeButton.el_);\n      }\n    }\n\n    /**\n     * Empties the content element. This happens anytime the modal is filled.\n     *\n     * @fires ModalDialog#beforemodalempty\n     * @fires ModalDialog#modalempty\n     */\n    empty() {\n      /**\n      * Fired just before a `ModalDialog` is emptied.\n      *\n      * @event ModalDialog#beforemodalempty\n      * @type {EventTarget~Event}\n      */\n      this.trigger('beforemodalempty');\n      emptyEl(this.contentEl());\n\n      /**\n      * Fired just after a `ModalDialog` is emptied.\n      *\n      * @event ModalDialog#modalempty\n      * @type {EventTarget~Event}\n      */\n      this.trigger('modalempty');\n    }\n\n    /**\n     * Gets or sets the modal content, which gets normalized before being\n     * rendered into the DOM.\n     *\n     * This does not update the DOM or fill the modal, but it is called during\n     * that process.\n     *\n     * @param  {Mixed} [value]\n     *         If defined, sets the internal content value to be used on the\n     *         next call(s) to `fill`. This value is normalized before being\n     *         inserted. To \"clear\" the internal content value, pass `null`.\n     *\n     * @return {Mixed}\n     *         The current content of the modal dialog\n     */\n    content(value) {\n      if (typeof value !== 'undefined') {\n        this.content_ = value;\n      }\n      return this.content_;\n    }\n\n    /**\n     * conditionally focus the modal dialog if focus was previously on the player.\n     *\n     * @private\n     */\n    conditionalFocus_() {\n      const activeEl = document.activeElement;\n      const playerEl = this.player_.el_;\n      this.previouslyActiveEl_ = null;\n      if (playerEl.contains(activeEl) || playerEl === activeEl) {\n        this.previouslyActiveEl_ = activeEl;\n        this.focus();\n      }\n    }\n\n    /**\n     * conditionally blur the element and refocus the last focused element\n     *\n     * @private\n     */\n    conditionalBlur_() {\n      if (this.previouslyActiveEl_) {\n        this.previouslyActiveEl_.focus();\n        this.previouslyActiveEl_ = null;\n      }\n    }\n\n    /**\n     * Keydown handler. Attached when modal is focused.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Do not allow keydowns to reach out of the modal dialog.\n      event.stopPropagation();\n      if (keycode.isEventKey(event, 'Escape') && this.closeable()) {\n        event.preventDefault();\n        this.close();\n        return;\n      }\n\n      // exit early if it isn't a tab key\n      if (!keycode.isEventKey(event, 'Tab')) {\n        return;\n      }\n      const focusableEls = this.focusableEls_();\n      const activeEl = this.el_.querySelector(':focus');\n      let focusIndex;\n      for (let i = 0; i < focusableEls.length; i++) {\n        if (activeEl === focusableEls[i]) {\n          focusIndex = i;\n          break;\n        }\n      }\n      if (document.activeElement === this.el_) {\n        focusIndex = 0;\n      }\n      if (event.shiftKey && focusIndex === 0) {\n        focusableEls[focusableEls.length - 1].focus();\n        event.preventDefault();\n      } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n        focusableEls[0].focus();\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * get all focusable elements\n     *\n     * @private\n     */\n    focusableEls_() {\n      const allChildren = this.el_.querySelectorAll('*');\n      return Array.prototype.filter.call(allChildren, child => {\n        return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n      });\n    }\n  }\n\n  /**\n   * Default options for `ModalDialog` default options.\n   *\n   * @type {Object}\n   * @private\n   */\n  ModalDialog.prototype.options_ = {\n    pauseOnOpen: true,\n    temporary: true\n  };\n  Component$1.registerComponent('ModalDialog', ModalDialog);\n\n  /**\n   * @file track-list.js\n   */\n\n  /**\n   * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n   * {@link VideoTrackList}\n   *\n   * @extends EventTarget\n   */\n  class TrackList extends EventTarget$2 {\n    /**\n     * Create an instance of this class\n     *\n     * @param {Track[]} tracks\n     *        A list of tracks to initialize the list with.\n     *\n     * @abstract\n     */\n    constructor(tracks = []) {\n      super();\n      this.tracks_ = [];\n\n      /**\n       * @memberof TrackList\n       * @member {number} length\n       *         The current number of `Track`s in the this Trackist.\n       * @instance\n       */\n      Object.defineProperty(this, 'length', {\n        get() {\n          return this.tracks_.length;\n        }\n      });\n      for (let i = 0; i < tracks.length; i++) {\n        this.addTrack(tracks[i]);\n      }\n    }\n\n    /**\n     * Add a {@link Track} to the `TrackList`\n     *\n     * @param {Track} track\n     *        The audio, video, or text track to add to the list.\n     *\n     * @fires TrackList#addtrack\n     */\n    addTrack(track) {\n      const index = this.tracks_.length;\n      if (!('' + index in this)) {\n        Object.defineProperty(this, index, {\n          get() {\n            return this.tracks_[index];\n          }\n        });\n      }\n\n      // Do not add duplicate tracks\n      if (this.tracks_.indexOf(track) === -1) {\n        this.tracks_.push(track);\n        /**\n         * Triggered when a track is added to a track list.\n         *\n         * @event TrackList#addtrack\n         * @type {EventTarget~Event}\n         * @property {Track} track\n         *           A reference to track that was added.\n         */\n        this.trigger({\n          track,\n          type: 'addtrack',\n          target: this\n        });\n      }\n\n      /**\n       * Triggered when a track label is changed.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */\n      track.labelchange_ = () => {\n        this.trigger({\n          track,\n          type: 'labelchange',\n          target: this\n        });\n      };\n      if (isEvented(track)) {\n        track.addEventListener('labelchange', track.labelchange_);\n      }\n    }\n\n    /**\n     * Remove a {@link Track} from the `TrackList`\n     *\n     * @param {Track} rtrack\n     *        The audio, video, or text track to remove from the list.\n     *\n     * @fires TrackList#removetrack\n     */\n    removeTrack(rtrack) {\n      let track;\n      for (let i = 0, l = this.length; i < l; i++) {\n        if (this[i] === rtrack) {\n          track = this[i];\n          if (track.off) {\n            track.off();\n          }\n          this.tracks_.splice(i, 1);\n          break;\n        }\n      }\n      if (!track) {\n        return;\n      }\n\n      /**\n       * Triggered when a track is removed from track list.\n       *\n       * @event TrackList#removetrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was removed.\n       */\n      this.trigger({\n        track,\n        type: 'removetrack',\n        target: this\n      });\n    }\n\n    /**\n     * Get a Track from the TrackList by a tracks id\n     *\n     * @param {string} id - the id of the track to get\n     * @method getTrackById\n     * @return {Track}\n     * @private\n     */\n    getTrackById(id) {\n      let result = null;\n      for (let i = 0, l = this.length; i < l; i++) {\n        const track = this[i];\n        if (track.id === id) {\n          result = track;\n          break;\n        }\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Triggered when a different track is selected/enabled.\n   *\n   * @event TrackList#change\n   * @type {EventTarget~Event}\n   */\n\n  /**\n   * Events that can be called with on + eventName. See {@link EventHandler}.\n   *\n   * @property {Object} TrackList#allowedEvents_\n   * @private\n   */\n  TrackList.prototype.allowedEvents_ = {\n    change: 'change',\n    addtrack: 'addtrack',\n    removetrack: 'removetrack',\n    labelchange: 'labelchange'\n  };\n\n  // emulate attribute EventHandler support to allow for feature detection\n  for (const event in TrackList.prototype.allowedEvents_) {\n    TrackList.prototype['on' + event] = null;\n  }\n\n  /**\n   * @file audio-track-list.js\n   */\n\n  /**\n   * Anywhere we call this function we diverge from the spec\n   * as we only support one enabled audiotrack at a time\n   *\n   * @param {AudioTrackList} list\n   *        list to work on\n   *\n   * @param {AudioTrack} track\n   *        The track to skip\n   *\n   * @private\n   */\n  const disableOthers$1 = function (list, track) {\n    for (let i = 0; i < list.length; i++) {\n      if (!Object.keys(list[i]).length || track.id === list[i].id) {\n        continue;\n      }\n      // another audio track is enabled, disable it\n      list[i].enabled = false;\n    }\n  };\n\n  /**\n   * The current list of {@link AudioTrack} for a media file.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n   * @extends TrackList\n   */\n  class AudioTrackList extends TrackList {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {AudioTrack[]} [tracks=[]]\n     *        A list of `AudioTrack` to instantiate the list with.\n     */\n    constructor(tracks = []) {\n      // make sure only 1 track is enabled\n      // sorted from last index to first index\n      for (let i = tracks.length - 1; i >= 0; i--) {\n        if (tracks[i].enabled) {\n          disableOthers$1(tracks, tracks[i]);\n          break;\n        }\n      }\n      super(tracks);\n      this.changing_ = false;\n    }\n\n    /**\n     * Add an {@link AudioTrack} to the `AudioTrackList`.\n     *\n     * @param {AudioTrack} track\n     *        The AudioTrack to add to the list\n     *\n     * @fires TrackList#addtrack\n     */\n    addTrack(track) {\n      if (track.enabled) {\n        disableOthers$1(this, track);\n      }\n      super.addTrack(track);\n      // native tracks don't have this\n      if (!track.addEventListener) {\n        return;\n      }\n      track.enabledChange_ = () => {\n        // when we are disabling other tracks (since we don't support\n        // more than one track at a time) we will set changing_\n        // to true so that we don't trigger additional change events\n        if (this.changing_) {\n          return;\n        }\n        this.changing_ = true;\n        disableOthers$1(this, track);\n        this.changing_ = false;\n        this.trigger('change');\n      };\n\n      /**\n       * @listens AudioTrack#enabledchange\n       * @fires TrackList#change\n       */\n      track.addEventListener('enabledchange', track.enabledChange_);\n    }\n    removeTrack(rtrack) {\n      super.removeTrack(rtrack);\n      if (rtrack.removeEventListener && rtrack.enabledChange_) {\n        rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);\n        rtrack.enabledChange_ = null;\n      }\n    }\n  }\n\n  /**\n   * @file video-track-list.js\n   */\n\n  /**\n   * Un-select all other {@link VideoTrack}s that are selected.\n   *\n   * @param {VideoTrackList} list\n   *        list to work on\n   *\n   * @param {VideoTrack} track\n   *        The track to skip\n   *\n   * @private\n   */\n  const disableOthers = function (list, track) {\n    for (let i = 0; i < list.length; i++) {\n      if (!Object.keys(list[i]).length || track.id === list[i].id) {\n        continue;\n      }\n      // another video track is enabled, disable it\n      list[i].selected = false;\n    }\n  };\n\n  /**\n   * The current list of {@link VideoTrack} for a video.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n   * @extends TrackList\n   */\n  class VideoTrackList extends TrackList {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {VideoTrack[]} [tracks=[]]\n     *        A list of `VideoTrack` to instantiate the list with.\n     */\n    constructor(tracks = []) {\n      // make sure only 1 track is enabled\n      // sorted from last index to first index\n      for (let i = tracks.length - 1; i >= 0; i--) {\n        if (tracks[i].selected) {\n          disableOthers(tracks, tracks[i]);\n          break;\n        }\n      }\n      super(tracks);\n      this.changing_ = false;\n\n      /**\n       * @member {number} VideoTrackList#selectedIndex\n       *         The current index of the selected {@link VideoTrack`}.\n       */\n      Object.defineProperty(this, 'selectedIndex', {\n        get() {\n          for (let i = 0; i < this.length; i++) {\n            if (this[i].selected) {\n              return i;\n            }\n          }\n          return -1;\n        },\n        set() {}\n      });\n    }\n\n    /**\n     * Add a {@link VideoTrack} to the `VideoTrackList`.\n     *\n     * @param {VideoTrack} track\n     *        The VideoTrack to add to the list\n     *\n     * @fires TrackList#addtrack\n     */\n    addTrack(track) {\n      if (track.selected) {\n        disableOthers(this, track);\n      }\n      super.addTrack(track);\n      // native tracks don't have this\n      if (!track.addEventListener) {\n        return;\n      }\n      track.selectedChange_ = () => {\n        if (this.changing_) {\n          return;\n        }\n        this.changing_ = true;\n        disableOthers(this, track);\n        this.changing_ = false;\n        this.trigger('change');\n      };\n\n      /**\n       * @listens VideoTrack#selectedchange\n       * @fires TrackList#change\n       */\n      track.addEventListener('selectedchange', track.selectedChange_);\n    }\n    removeTrack(rtrack) {\n      super.removeTrack(rtrack);\n      if (rtrack.removeEventListener && rtrack.selectedChange_) {\n        rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);\n        rtrack.selectedChange_ = null;\n      }\n    }\n  }\n\n  /**\n   * @file text-track-list.js\n   */\n\n  /**\n   * The current list of {@link TextTrack} for a media file.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n   * @extends TrackList\n   */\n  class TextTrackList extends TrackList {\n    /**\n     * Add a {@link TextTrack} to the `TextTrackList`\n     *\n     * @param {TextTrack} track\n     *        The text track to add to the list.\n     *\n     * @fires TrackList#addtrack\n     */\n    addTrack(track) {\n      super.addTrack(track);\n      if (!this.queueChange_) {\n        this.queueChange_ = () => this.queueTrigger('change');\n      }\n      if (!this.triggerSelectedlanguagechange) {\n        this.triggerSelectedlanguagechange_ = () => this.trigger('selectedlanguagechange');\n      }\n\n      /**\n       * @listens TextTrack#modechange\n       * @fires TrackList#change\n       */\n      track.addEventListener('modechange', this.queueChange_);\n      const nonLanguageTextTrackKind = ['metadata', 'chapters'];\n      if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n        track.addEventListener('modechange', this.triggerSelectedlanguagechange_);\n      }\n    }\n    removeTrack(rtrack) {\n      super.removeTrack(rtrack);\n\n      // manually remove the event handlers we added\n      if (rtrack.removeEventListener) {\n        if (this.queueChange_) {\n          rtrack.removeEventListener('modechange', this.queueChange_);\n        }\n        if (this.selectedlanguagechange_) {\n          rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);\n        }\n      }\n    }\n  }\n\n  /**\n   * @file html-track-element-list.js\n   */\n\n  /**\n   * The current list of {@link HtmlTrackElement}s.\n   */\n  class HtmlTrackElementList {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {HtmlTrackElement[]} [tracks=[]]\n     *        A list of `HtmlTrackElement` to instantiate the list with.\n     */\n    constructor(trackElements = []) {\n      this.trackElements_ = [];\n\n      /**\n       * @memberof HtmlTrackElementList\n       * @member {number} length\n       *         The current number of `Track`s in the this Trackist.\n       * @instance\n       */\n      Object.defineProperty(this, 'length', {\n        get() {\n          return this.trackElements_.length;\n        }\n      });\n      for (let i = 0, length = trackElements.length; i < length; i++) {\n        this.addTrackElement_(trackElements[i]);\n      }\n    }\n\n    /**\n     * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n     *\n     * @param {HtmlTrackElement} trackElement\n     *        The track element to add to the list.\n     *\n     * @private\n     */\n    addTrackElement_(trackElement) {\n      const index = this.trackElements_.length;\n      if (!('' + index in this)) {\n        Object.defineProperty(this, index, {\n          get() {\n            return this.trackElements_[index];\n          }\n        });\n      }\n\n      // Do not add duplicate elements\n      if (this.trackElements_.indexOf(trackElement) === -1) {\n        this.trackElements_.push(trackElement);\n      }\n    }\n\n    /**\n     * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n     * {@link TextTrack}.\n     *\n     * @param {TextTrack} track\n     *        The track associated with a track element.\n     *\n     * @return {HtmlTrackElement|undefined}\n     *         The track element that was found or undefined.\n     *\n     * @private\n     */\n    getTrackElementByTrack_(track) {\n      let trackElement_;\n      for (let i = 0, length = this.trackElements_.length; i < length; i++) {\n        if (track === this.trackElements_[i].track) {\n          trackElement_ = this.trackElements_[i];\n          break;\n        }\n      }\n      return trackElement_;\n    }\n\n    /**\n     * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n     *\n     * @param {HtmlTrackElement} trackElement\n     *        The track element to remove from the list.\n     *\n     * @private\n     */\n    removeTrackElement_(trackElement) {\n      for (let i = 0, length = this.trackElements_.length; i < length; i++) {\n        if (trackElement === this.trackElements_[i]) {\n          if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {\n            this.trackElements_[i].track.off();\n          }\n          if (typeof this.trackElements_[i].off === 'function') {\n            this.trackElements_[i].off();\n          }\n          this.trackElements_.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * @file text-track-cue-list.js\n   */\n\n  /**\n   * @typedef {Object} TextTrackCueList~TextTrackCue\n   *\n   * @property {string} id\n   *           The unique id for this text track cue\n   *\n   * @property {number} startTime\n   *           The start time for this text track cue\n   *\n   * @property {number} endTime\n   *           The end time for this text track cue\n   *\n   * @property {boolean} pauseOnExit\n   *           Pause when the end time is reached if true.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n   */\n\n  /**\n   * A List of TextTrackCues.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n   */\n  class TextTrackCueList {\n    /**\n     * Create an instance of this class..\n     *\n     * @param {Array} cues\n     *        A list of cues to be initialized with\n     */\n    constructor(cues) {\n      TextTrackCueList.prototype.setCues_.call(this, cues);\n\n      /**\n       * @memberof TextTrackCueList\n       * @member {number} length\n       *         The current number of `TextTrackCue`s in the TextTrackCueList.\n       * @instance\n       */\n      Object.defineProperty(this, 'length', {\n        get() {\n          return this.length_;\n        }\n      });\n    }\n\n    /**\n     * A setter for cues in this list. Creates getters\n     * an an index for the cues.\n     *\n     * @param {Array} cues\n     *        An array of cues to set\n     *\n     * @private\n     */\n    setCues_(cues) {\n      const oldLength = this.length || 0;\n      let i = 0;\n      const l = cues.length;\n      this.cues_ = cues;\n      this.length_ = cues.length;\n      const defineProp = function (index) {\n        if (!('' + index in this)) {\n          Object.defineProperty(this, '' + index, {\n            get() {\n              return this.cues_[index];\n            }\n          });\n        }\n      };\n      if (oldLength < l) {\n        i = oldLength;\n        for (; i < l; i++) {\n          defineProp.call(this, i);\n        }\n      }\n    }\n\n    /**\n     * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n     *\n     * @param {string} id\n     *        The id of the cue that should be searched for.\n     *\n     * @return {TextTrackCueList~TextTrackCue|null}\n     *         A single cue or null if none was found.\n     */\n    getCueById(id) {\n      let result = null;\n      for (let i = 0, l = this.length; i < l; i++) {\n        const cue = this[i];\n        if (cue.id === id) {\n          result = cue;\n          break;\n        }\n      }\n      return result;\n    }\n  }\n\n  /**\n   * @file track-kinds.js\n   */\n\n  /**\n   * All possible `VideoTrackKind`s\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n   * @typedef VideoTrack~Kind\n   * @enum\n   */\n  const VideoTrackKind = {\n    alternative: 'alternative',\n    captions: 'captions',\n    main: 'main',\n    sign: 'sign',\n    subtitles: 'subtitles',\n    commentary: 'commentary'\n  };\n\n  /**\n   * All possible `AudioTrackKind`s\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n   * @typedef AudioTrack~Kind\n   * @enum\n   */\n  const AudioTrackKind = {\n    'alternative': 'alternative',\n    'descriptions': 'descriptions',\n    'main': 'main',\n    'main-desc': 'main-desc',\n    'translation': 'translation',\n    'commentary': 'commentary'\n  };\n\n  /**\n   * All possible `TextTrackKind`s\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n   * @typedef TextTrack~Kind\n   * @enum\n   */\n  const TextTrackKind = {\n    subtitles: 'subtitles',\n    captions: 'captions',\n    descriptions: 'descriptions',\n    chapters: 'chapters',\n    metadata: 'metadata'\n  };\n\n  /**\n   * All possible `TextTrackMode`s\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n   * @typedef TextTrack~Mode\n   * @enum\n   */\n  const TextTrackMode = {\n    disabled: 'disabled',\n    hidden: 'hidden',\n    showing: 'showing'\n  };\n\n  /**\n   * @file track.js\n   */\n\n  /**\n   * A Track class that contains all of the common functionality for {@link AudioTrack},\n   * {@link VideoTrack}, and {@link TextTrack}.\n   *\n   * > Note: This class should not be used directly\n   *\n   * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n   * @extends EventTarget\n   * @abstract\n   */\n  class Track extends EventTarget$2 {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Object} [options={}]\n     *        Object of option names and values\n     *\n     * @param {string} [options.kind='']\n     *        A valid kind for the track type you are creating.\n     *\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n     *        A unique id for this AudioTrack.\n     *\n     * @param {string} [options.label='']\n     *        The menu label for this track.\n     *\n     * @param {string} [options.language='']\n     *        A valid two character language code.\n     *\n     * @abstract\n     */\n    constructor(options = {}) {\n      super();\n      const trackProps = {\n        id: options.id || 'vjs_track_' + newGUID(),\n        kind: options.kind || '',\n        language: options.language || ''\n      };\n      let label = options.label || '';\n\n      /**\n       * @memberof Track\n       * @member {string} id\n       *         The id of this track. Cannot be changed after creation.\n       * @instance\n       *\n       * @readonly\n       */\n\n      /**\n       * @memberof Track\n       * @member {string} kind\n       *         The kind of track that this is. Cannot be changed after creation.\n       * @instance\n       *\n       * @readonly\n       */\n\n      /**\n       * @memberof Track\n       * @member {string} language\n       *         The two letter language code for this track. Cannot be changed after\n       *         creation.\n       * @instance\n       *\n       * @readonly\n       */\n\n      for (const key in trackProps) {\n        Object.defineProperty(this, key, {\n          get() {\n            return trackProps[key];\n          },\n          set() {}\n        });\n      }\n\n      /**\n       * @memberof Track\n       * @member {string} label\n       *         The label of this track. Cannot be changed after creation.\n       * @instance\n       *\n       * @fires Track#labelchange\n       */\n      Object.defineProperty(this, 'label', {\n        get() {\n          return label;\n        },\n        set(newLabel) {\n          if (newLabel !== label) {\n            label = newLabel;\n\n            /**\n             * An event that fires when label changes on this track.\n             *\n             * > Note: This is not part of the spec!\n             *\n             * @event Track#labelchange\n             * @type {EventTarget~Event}\n             */\n            this.trigger('labelchange');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * @file url.js\n   * @module url\n   */\n\n  /**\n   * @typedef {Object} url:URLObject\n   *\n   * @property {string} protocol\n   *           The protocol of the url that was parsed.\n   *\n   * @property {string} hostname\n   *           The hostname of the url that was parsed.\n   *\n   * @property {string} port\n   *           The port of the url that was parsed.\n   *\n   * @property {string} pathname\n   *           The pathname of the url that was parsed.\n   *\n   * @property {string} search\n   *           The search query of the url that was parsed.\n   *\n   * @property {string} hash\n   *           The hash of the url that was parsed.\n   *\n   * @property {string} host\n   *           The host of the url that was parsed.\n   */\n\n  /**\n   * Resolve and parse the elements of a URL.\n   *\n   * @function\n   * @param    {String} url\n   *           The url to parse\n   *\n   * @return   {url:URLObject}\n   *           An object of url details\n   */\n  const parseUrl = function (url) {\n    // This entire method can be replace with URL once we are able to drop IE11\n\n    const props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n    // add the url to an anchor and let the browser parse the URL\n    const a = document.createElement('a');\n    a.href = url;\n\n    // Copy the specific URL properties to a new object\n    // This is also needed for IE because the anchor loses its\n    // properties when it's removed from the dom\n    const details = {};\n    for (let i = 0; i < props.length; i++) {\n      details[props[i]] = a[props[i]];\n    }\n\n    // IE adds the port to the host property unlike everyone else. If\n    // a port identifier is added for standard ports, strip it.\n    if (details.protocol === 'http:') {\n      details.host = details.host.replace(/:80$/, '');\n    }\n    if (details.protocol === 'https:') {\n      details.host = details.host.replace(/:443$/, '');\n    }\n    if (!details.protocol) {\n      details.protocol = window.location.protocol;\n    }\n\n    /* istanbul ignore if */\n    if (!details.host) {\n      details.host = window.location.host;\n    }\n    return details;\n  };\n\n  /**\n   * Get absolute version of relative URL.\n   *\n   * @function\n   * @param    {string} url\n   *           URL to make absolute\n   *\n   * @return   {string}\n   *           Absolute URL\n   *\n   * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n   */\n  const getAbsoluteURL = function (url) {\n    // Check if absolute URL\n    if (!url.match(/^https?:\\/\\//)) {\n      // Add the url to an anchor and let the browser parse it to convert to an absolute url\n      const a = document.createElement('a');\n      a.href = url;\n      url = a.href;\n    }\n    return url;\n  };\n\n  /**\n   * Returns the extension of the passed file name. It will return an empty string\n   * if passed an invalid path.\n   *\n   * @function\n   * @param    {string} path\n   *           The fileName path like '/path/to/file.mp4'\n   *\n   * @return  {string}\n   *           The extension in lower case or an empty string if no\n   *           extension could be found.\n   */\n  const getFileExtension = function (path) {\n    if (typeof path === 'string') {\n      const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\n      const pathParts = splitPathRe.exec(path);\n      if (pathParts) {\n        return pathParts.pop().toLowerCase();\n      }\n    }\n    return '';\n  };\n\n  /**\n   * Returns whether the url passed is a cross domain request or not.\n   *\n   * @function\n   * @param    {string} url\n   *           The url to check.\n   *\n   * @param    {Object} [winLoc]\n   *           the domain to check the url against, defaults to window.location\n   *\n   * @param    {string} [winLoc.protocol]\n   *           The window location protocol defaults to window.location.protocol\n   *\n   * @param    {string} [winLoc.host]\n   *           The window location host defaults to window.location.host\n   *\n   * @return   {boolean}\n   *           Whether it is a cross domain request or not.\n   */\n  const isCrossOrigin = function (url, winLoc = window.location) {\n    const urlInfo = parseUrl(url);\n\n    // IE8 protocol relative urls will return ':' for protocol\n    const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n    // Check if url is for another domain/origin\n    // IE8 doesn't know location.origin, so we won't rely on it here\n    const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n    return crossOrigin;\n  };\n\n  var Url = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    parseUrl: parseUrl,\n    getAbsoluteURL: getAbsoluteURL,\n    getFileExtension: getFileExtension,\n    isCrossOrigin: isCrossOrigin\n  });\n\n  var win;\n  if (typeof window !== \"undefined\") {\n    win = window;\n  } else if (typeof commonjsGlobal !== \"undefined\") {\n    win = commonjsGlobal;\n  } else if (typeof self !== \"undefined\") {\n    win = self;\n  } else {\n    win = {};\n  }\n  var window_1 = win;\n\n  var _extends_1 = createCommonjsModule(function (module) {\n    function _extends() {\n      module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n      return _extends.apply(this, arguments);\n    }\n    module.exports = _extends, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  });\n  var _extends$1 = unwrapExports(_extends_1);\n\n  var isFunction_1 = isFunction;\n  var toString = Object.prototype.toString;\n  function isFunction(fn) {\n    if (!fn) {\n      return false;\n    }\n    var string = toString.call(fn);\n    return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (\n    // IE8 and below\n    fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);\n  }\n\n  var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {\n    if (decodeResponseBody === void 0) {\n      decodeResponseBody = false;\n    }\n    return function (err, response, responseBody) {\n      // if the XHR failed, return that error\n      if (err) {\n        callback(err);\n        return;\n      } // if the HTTP status code is 4xx or 5xx, the request also failed\n\n      if (response.statusCode >= 400 && response.statusCode <= 599) {\n        var cause = responseBody;\n        if (decodeResponseBody) {\n          if (window_1.TextDecoder) {\n            var charset = getCharset(response.headers && response.headers['content-type']);\n            try {\n              cause = new TextDecoder(charset).decode(responseBody);\n            } catch (e) {}\n          } else {\n            cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));\n          }\n        }\n        callback({\n          cause: cause\n        });\n        return;\n      } // otherwise, request succeeded\n\n      callback(null, responseBody);\n    };\n  };\n  function getCharset(contentTypeHeader) {\n    if (contentTypeHeader === void 0) {\n      contentTypeHeader = '';\n    }\n    return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {\n      var _contentType$split = contentType.split('='),\n        type = _contentType$split[0],\n        value = _contentType$split[1];\n      if (type.trim() === 'charset') {\n        return value.trim();\n      }\n      return charset;\n    }, 'utf-8');\n  }\n  var httpHandler = httpResponseHandler;\n\n  createXHR.httpHandler = httpHandler;\n  /**\n   * @license\n   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>\n   * Copyright (c) 2014 David Bjrklund\n   * Available under the MIT license\n   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>\n   */\n\n  var parseHeaders = function parseHeaders(headers) {\n    var result = {};\n    if (!headers) {\n      return result;\n    }\n    headers.trim().split('\\n').forEach(function (row) {\n      var index = row.indexOf(':');\n      var key = row.slice(0, index).trim().toLowerCase();\n      var value = row.slice(index + 1).trim();\n      if (typeof result[key] === 'undefined') {\n        result[key] = value;\n      } else if (Array.isArray(result[key])) {\n        result[key].push(value);\n      } else {\n        result[key] = [result[key], value];\n      }\n    });\n    return result;\n  };\n  var lib = createXHR; // Allow use of default import syntax in TypeScript\n\n  var default_1 = createXHR;\n  createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop$1;\n  createXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window_1.XDomainRequest;\n  forEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n      options = initParams(uri, options, callback);\n      options.method = method.toUpperCase();\n      return _createXHR(options);\n    };\n  });\n  function forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n      iterator(array[i]);\n    }\n  }\n  function isEmpty(obj) {\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) return false;\n    }\n    return true;\n  }\n  function initParams(uri, options, callback) {\n    var params = uri;\n    if (isFunction_1(options)) {\n      callback = options;\n      if (typeof uri === \"string\") {\n        params = {\n          uri: uri\n        };\n      }\n    } else {\n      params = _extends_1({}, options, {\n        uri: uri\n      });\n    }\n    params.callback = callback;\n    return params;\n  }\n  function createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback);\n    return _createXHR(options);\n  }\n  function _createXHR(options) {\n    if (typeof options.callback === \"undefined\") {\n      throw new Error(\"callback argument missing\");\n    }\n    var called = false;\n    var callback = function cbOnce(err, response, body) {\n      if (!called) {\n        called = true;\n        options.callback(err, response, body);\n      }\n    };\n    function readystatechange() {\n      if (xhr.readyState === 4) {\n        setTimeout(loadFunc, 0);\n      }\n    }\n    function getBody() {\n      // Chrome with requestType=blob throws errors arround when even testing access to responseText\n      var body = undefined;\n      if (xhr.response) {\n        body = xhr.response;\n      } else {\n        body = xhr.responseText || getXml(xhr);\n      }\n      if (isJson) {\n        try {\n          body = JSON.parse(body);\n        } catch (e) {}\n      }\n      return body;\n    }\n    function errorFunc(evt) {\n      clearTimeout(timeoutTimer);\n      if (!(evt instanceof Error)) {\n        evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n      }\n      evt.statusCode = 0;\n      return callback(evt, failureResponse);\n    } // will load the data & process the response in a special response object\n\n    function loadFunc() {\n      if (aborted) return;\n      var status;\n      clearTimeout(timeoutTimer);\n      if (options.useXDR && xhr.status === undefined) {\n        //IE8 CORS GET successful response doesn't have a status field, but body is fine\n        status = 200;\n      } else {\n        status = xhr.status === 1223 ? 204 : xhr.status;\n      }\n      var response = failureResponse;\n      var err = null;\n      if (status !== 0) {\n        response = {\n          body: getBody(),\n          statusCode: status,\n          method: method,\n          headers: {},\n          url: uri,\n          rawRequest: xhr\n        };\n        if (xhr.getAllResponseHeaders) {\n          //remember xhr can in fact be XDR for CORS in IE\n          response.headers = parseHeaders(xhr.getAllResponseHeaders());\n        }\n      } else {\n        err = new Error(\"Internal XMLHttpRequest Error\");\n      }\n      return callback(err, response, response.body);\n    }\n    var xhr = options.xhr || null;\n    if (!xhr) {\n      if (options.cors || options.useXDR) {\n        xhr = new createXHR.XDomainRequest();\n      } else {\n        xhr = new createXHR.XMLHttpRequest();\n      }\n    }\n    var key;\n    var aborted;\n    var uri = xhr.url = options.uri || options.url;\n    var method = xhr.method = options.method || \"GET\";\n    var body = options.body || options.data;\n    var headers = xhr.headers = options.headers || {};\n    var sync = !!options.sync;\n    var isJson = false;\n    var timeoutTimer;\n    var failureResponse = {\n      body: undefined,\n      headers: {},\n      statusCode: 0,\n      method: method,\n      url: uri,\n      rawRequest: xhr\n    };\n    if (\"json\" in options && options.json !== false) {\n      isJson = true;\n      headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n      if (method !== \"GET\" && method !== \"HEAD\") {\n        headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n        body = JSON.stringify(options.json === true ? body : options.json);\n      }\n    }\n    xhr.onreadystatechange = readystatechange;\n    xhr.onload = loadFunc;\n    xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.\n\n    xhr.onprogress = function () {// IE must die\n    };\n    xhr.onabort = function () {\n      aborted = true;\n    };\n    xhr.ontimeout = errorFunc;\n    xhr.open(method, uri, !sync, options.username, options.password); //has to be after open\n\n    if (!sync) {\n      xhr.withCredentials = !!options.withCredentials;\n    } // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n\n    if (!sync && options.timeout > 0) {\n      timeoutTimer = setTimeout(function () {\n        if (aborted) return;\n        aborted = true; //IE9 may still call readystatechange\n\n        xhr.abort(\"timeout\");\n        var e = new Error(\"XMLHttpRequest timeout\");\n        e.code = \"ETIMEDOUT\";\n        errorFunc(e);\n      }, options.timeout);\n    }\n    if (xhr.setRequestHeader) {\n      for (key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    } else if (options.headers && !isEmpty(options.headers)) {\n      throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n    }\n    if (\"responseType\" in options) {\n      xhr.responseType = options.responseType;\n    }\n    if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n      options.beforeSend(xhr);\n    } // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n\n    xhr.send(body || null);\n    return xhr;\n  }\n  function getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n      if (xhr.responseType === \"document\") {\n        return xhr.responseXML;\n      }\n      var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n      if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n        return xhr.responseXML;\n      }\n    } catch (e) {}\n    return null;\n  }\n  function noop$1() {}\n  lib.default = default_1;\n\n  /**\n   * @file text-track.js\n   */\n\n  /**\n   * Takes a webvtt file contents and parses it into cues\n   *\n   * @param {string} srcContent\n   *        webVTT file contents\n   *\n   * @param {TextTrack} track\n   *        TextTrack to add cues to. Cues come from the srcContent.\n   *\n   * @private\n   */\n  const parseCues = function (srcContent, track) {\n    const parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());\n    const errors = [];\n    parser.oncue = function (cue) {\n      track.addCue(cue);\n    };\n    parser.onparsingerror = function (error) {\n      errors.push(error);\n    };\n    parser.onflush = function () {\n      track.trigger({\n        type: 'loadeddata',\n        target: track\n      });\n    };\n    parser.parse(srcContent);\n    if (errors.length > 0) {\n      if (window.console && window.console.groupCollapsed) {\n        window.console.groupCollapsed(`Text Track parsing errors for ${track.src}`);\n      }\n      errors.forEach(error => log$1.error(error));\n      if (window.console && window.console.groupEnd) {\n        window.console.groupEnd();\n      }\n    }\n    parser.flush();\n  };\n\n  /**\n   * Load a `TextTrack` from a specified url.\n   *\n   * @param {string} src\n   *        Url to load track from.\n   *\n   * @param {TextTrack} track\n   *        Track to add cues to. Comes from the content at the end of `url`.\n   *\n   * @private\n   */\n  const loadTrack = function (src, track) {\n    const opts = {\n      uri: src\n    };\n    const crossOrigin = isCrossOrigin(src);\n    if (crossOrigin) {\n      opts.cors = crossOrigin;\n    }\n    const withCredentials = track.tech_.crossOrigin() === 'use-credentials';\n    if (withCredentials) {\n      opts.withCredentials = withCredentials;\n    }\n    lib(opts, bind_(this, function (err, response, responseBody) {\n      if (err) {\n        return log$1.error(err, response);\n      }\n      track.loaded_ = true;\n\n      // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n      // NOTE: this is only used for the alt/video.novtt.js build\n      if (typeof window.WebVTT !== 'function') {\n        if (track.tech_) {\n          // to prevent use before define eslint error, we define loadHandler\n          // as a let here\n          track.tech_.any(['vttjsloaded', 'vttjserror'], event => {\n            if (event.type === 'vttjserror') {\n              log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);\n              return;\n            }\n            return parseCues(responseBody, track);\n          });\n        }\n      } else {\n        parseCues(responseBody, track);\n      }\n    }));\n  };\n\n  /**\n   * A representation of a single `TextTrack`.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n   * @extends Track\n   */\n  class TextTrack extends Track {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Object} options={}\n     *        Object of option names and values\n     *\n     * @param {Tech} options.tech\n     *        A reference to the tech that owns this TextTrack.\n     *\n     * @param {TextTrack~Kind} [options.kind='subtitles']\n     *        A valid text track kind.\n     *\n     * @param {TextTrack~Mode} [options.mode='disabled']\n     *        A valid text track mode.\n     *\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n     *        A unique id for this TextTrack.\n     *\n     * @param {string} [options.label='']\n     *        The menu label for this track.\n     *\n     * @param {string} [options.language='']\n     *        A valid two character language code.\n     *\n     * @param {string} [options.srclang='']\n     *        A valid two character language code. An alternative, but deprioritized\n     *        version of `options.language`\n     *\n     * @param {string} [options.src]\n     *        A url to TextTrack cues.\n     *\n     * @param {boolean} [options.default]\n     *        If this track should default to on or off.\n     */\n    constructor(options = {}) {\n      if (!options.tech) {\n        throw new Error('A tech was not provided.');\n      }\n      const settings = merge$2(options, {\n        kind: TextTrackKind[options.kind] || 'subtitles',\n        language: options.language || options.srclang || ''\n      });\n      let mode = TextTrackMode[settings.mode] || 'disabled';\n      const default_ = settings.default;\n      if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n        mode = 'hidden';\n      }\n      super(settings);\n      this.tech_ = settings.tech;\n      this.cues_ = [];\n      this.activeCues_ = [];\n      this.preload_ = this.tech_.preloadTextTracks !== false;\n      const cues = new TextTrackCueList(this.cues_);\n      const activeCues = new TextTrackCueList(this.activeCues_);\n      let changed = false;\n      this.timeupdateHandler = bind_(this, function (event = {}) {\n        if (this.tech_.isDisposed()) {\n          return;\n        }\n        if (!this.tech_.isReady_) {\n          if (event.type !== 'timeupdate') {\n            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n          }\n          return;\n        }\n\n        // Accessing this.activeCues for the side-effects of updating itself\n        // due to its nature as a getter function. Do not remove or cues will\n        // stop updating!\n        // Use the setter to prevent deletion from uglify (pure_getters rule)\n        this.activeCues = this.activeCues;\n        if (changed) {\n          this.trigger('cuechange');\n          changed = false;\n        }\n        if (event.type !== 'timeupdate') {\n          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n        }\n      });\n      const disposeHandler = () => {\n        this.stopTracking();\n      };\n      this.tech_.one('dispose', disposeHandler);\n      if (mode !== 'disabled') {\n        this.startTracking();\n      }\n      Object.defineProperties(this, {\n        /**\n         * @memberof TextTrack\n         * @member {boolean} default\n         *         If this track was set to be on or off by default. Cannot be changed after\n         *         creation.\n         * @instance\n         *\n         * @readonly\n         */\n        default: {\n          get() {\n            return default_;\n          },\n          set() {}\n        },\n        /**\n         * @memberof TextTrack\n         * @member {string} mode\n         *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n         *         not be set if setting to an invalid mode.\n         * @instance\n         *\n         * @fires TextTrack#modechange\n         */\n        mode: {\n          get() {\n            return mode;\n          },\n          set(newMode) {\n            if (!TextTrackMode[newMode]) {\n              return;\n            }\n            if (mode === newMode) {\n              return;\n            }\n            mode = newMode;\n            if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {\n              // On-demand load.\n              loadTrack(this.src, this);\n            }\n            this.stopTracking();\n            if (mode !== 'disabled') {\n              this.startTracking();\n            }\n            /**\n             * An event that fires when mode changes on this track. This allows\n             * the TextTrackList that holds this track to act accordingly.\n             *\n             * > Note: This is not part of the spec!\n             *\n             * @event TextTrack#modechange\n             * @type {EventTarget~Event}\n             */\n            this.trigger('modechange');\n          }\n        },\n        /**\n         * @memberof TextTrack\n         * @member {TextTrackCueList} cues\n         *         The text track cue list for this TextTrack.\n         * @instance\n         */\n        cues: {\n          get() {\n            if (!this.loaded_) {\n              return null;\n            }\n            return cues;\n          },\n          set() {}\n        },\n        /**\n         * @memberof TextTrack\n         * @member {TextTrackCueList} activeCues\n         *         The list text track cues that are currently active for this TextTrack.\n         * @instance\n         */\n        activeCues: {\n          get() {\n            if (!this.loaded_) {\n              return null;\n            }\n\n            // nothing to do\n            if (this.cues.length === 0) {\n              return activeCues;\n            }\n            const ct = this.tech_.currentTime();\n            const active = [];\n            for (let i = 0, l = this.cues.length; i < l; i++) {\n              const cue = this.cues[i];\n              if (cue.startTime <= ct && cue.endTime >= ct) {\n                active.push(cue);\n              }\n            }\n            changed = false;\n            if (active.length !== this.activeCues_.length) {\n              changed = true;\n            } else {\n              for (let i = 0; i < active.length; i++) {\n                if (this.activeCues_.indexOf(active[i]) === -1) {\n                  changed = true;\n                }\n              }\n            }\n            this.activeCues_ = active;\n            activeCues.setCues_(this.activeCues_);\n            return activeCues;\n          },\n          // /!\\ Keep this setter empty (see the timeupdate handler above)\n          set() {}\n        }\n      });\n      if (settings.src) {\n        this.src = settings.src;\n        if (!this.preload_) {\n          // Tracks will load on-demand.\n          // Act like we're loaded for other purposes.\n          this.loaded_ = true;\n        }\n        if (this.preload_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {\n          loadTrack(this.src, this);\n        }\n      } else {\n        this.loaded_ = true;\n      }\n    }\n    startTracking() {\n      // More precise cues based on requestVideoFrameCallback with a requestAnimationFram fallback\n      this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n      // Also listen to timeupdate in case rVFC/rAF stops (window in background, audio in video el)\n      this.tech_.on('timeupdate', this.timeupdateHandler);\n    }\n    stopTracking() {\n      if (this.rvf_) {\n        this.tech_.cancelVideoFrameCallback(this.rvf_);\n        this.rvf_ = undefined;\n      }\n      this.tech_.off('timeupdate', this.timeupdateHandler);\n    }\n\n    /**\n     * Add a cue to the internal list of cues.\n     *\n     * @param {TextTrack~Cue} cue\n     *        The cue to add to our internal list\n     */\n    addCue(originalCue) {\n      let cue = originalCue;\n      if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {\n        cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n        for (const prop in originalCue) {\n          if (!(prop in cue)) {\n            cue[prop] = originalCue[prop];\n          }\n        }\n\n        // make sure that `id` is copied over\n        cue.id = originalCue.id;\n        cue.originalCue_ = originalCue;\n      }\n      const tracks = this.tech_.textTracks();\n      for (let i = 0; i < tracks.length; i++) {\n        if (tracks[i] !== this) {\n          tracks[i].removeCue(cue);\n        }\n      }\n      this.cues_.push(cue);\n      this.cues.setCues_(this.cues_);\n    }\n\n    /**\n     * Remove a cue from our internal list\n     *\n     * @param {TextTrack~Cue} removeCue\n     *        The cue to remove from our internal list\n     */\n    removeCue(removeCue) {\n      let i = this.cues_.length;\n      while (i--) {\n        const cue = this.cues_[i];\n        if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {\n          this.cues_.splice(i, 1);\n          this.cues.setCues_(this.cues_);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * cuechange - One or more cues in the track have become active or stopped being active.\n   */\n  TextTrack.prototype.allowedEvents_ = {\n    cuechange: 'cuechange'\n  };\n\n  /**\n   * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n   * only one `AudioTrack` in the list will be enabled at a time.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n   * @extends Track\n   */\n  class AudioTrack extends Track {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Object} [options={}]\n     *        Object of option names and values\n     *\n     * @param {AudioTrack~Kind} [options.kind='']\n     *        A valid audio track kind\n     *\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n     *        A unique id for this AudioTrack.\n     *\n     * @param {string} [options.label='']\n     *        The menu label for this track.\n     *\n     * @param {string} [options.language='']\n     *        A valid two character language code.\n     *\n     * @param {boolean} [options.enabled]\n     *        If this track is the one that is currently playing. If this track is part of\n     *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n     */\n    constructor(options = {}) {\n      const settings = merge$2(options, {\n        kind: AudioTrackKind[options.kind] || ''\n      });\n      super(settings);\n      let enabled = false;\n\n      /**\n       * @memberof AudioTrack\n       * @member {boolean} enabled\n       *         If this `AudioTrack` is enabled or not. When setting this will\n       *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n       * @instance\n       *\n       * @fires VideoTrack#selectedchange\n       */\n      Object.defineProperty(this, 'enabled', {\n        get() {\n          return enabled;\n        },\n        set(newEnabled) {\n          // an invalid or unchanged value\n          if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n            return;\n          }\n          enabled = newEnabled;\n\n          /**\n           * An event that fires when enabled changes on this track. This allows\n           * the AudioTrackList that holds this track to act accordingly.\n           *\n           * > Note: This is not part of the spec! Native tracks will do\n           *         this internally without an event.\n           *\n           * @event AudioTrack#enabledchange\n           * @type {EventTarget~Event}\n           */\n          this.trigger('enabledchange');\n        }\n      });\n\n      // if the user sets this track to selected then\n      // set selected to that true value otherwise\n      // we keep it false\n      if (settings.enabled) {\n        this.enabled = settings.enabled;\n      }\n      this.loaded_ = true;\n    }\n  }\n\n  /**\n   * A representation of a single `VideoTrack`.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n   * @extends Track\n   */\n  class VideoTrack extends Track {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Object} [options={}]\n     *        Object of option names and values\n     *\n     * @param {string} [options.kind='']\n     *        A valid {@link VideoTrack~Kind}\n     *\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n     *        A unique id for this AudioTrack.\n     *\n     * @param {string} [options.label='']\n     *        The menu label for this track.\n     *\n     * @param {string} [options.language='']\n     *        A valid two character language code.\n     *\n     * @param {boolean} [options.selected]\n     *        If this track is the one that is currently playing.\n     */\n    constructor(options = {}) {\n      const settings = merge$2(options, {\n        kind: VideoTrackKind[options.kind] || ''\n      });\n      super(settings);\n      let selected = false;\n\n      /**\n       * @memberof VideoTrack\n       * @member {boolean} selected\n       *         If this `VideoTrack` is selected or not. When setting this will\n       *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n       * @instance\n       *\n       * @fires VideoTrack#selectedchange\n       */\n      Object.defineProperty(this, 'selected', {\n        get() {\n          return selected;\n        },\n        set(newSelected) {\n          // an invalid or unchanged value\n          if (typeof newSelected !== 'boolean' || newSelected === selected) {\n            return;\n          }\n          selected = newSelected;\n\n          /**\n           * An event that fires when selected changes on this track. This allows\n           * the VideoTrackList that holds this track to act accordingly.\n           *\n           * > Note: This is not part of the spec! Native tracks will do\n           *         this internally without an event.\n           *\n           * @event VideoTrack#selectedchange\n           * @type {EventTarget~Event}\n           */\n          this.trigger('selectedchange');\n        }\n      });\n\n      // if the user sets this track to selected then\n      // set selected to that true value otherwise\n      // we keep it false\n      if (settings.selected) {\n        this.selected = settings.selected;\n      }\n    }\n  }\n\n  /**\n   * @file html-track-element.js\n   */\n\n  /**\n   * A single track represented in the DOM.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n   * @extends EventTarget\n   */\n  class HTMLTrackElement extends EventTarget$2 {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Object} options={}\n     *        Object of option names and values\n     *\n     * @param {Tech} options.tech\n     *        A reference to the tech that owns this HTMLTrackElement.\n     *\n     * @param {TextTrack~Kind} [options.kind='subtitles']\n     *        A valid text track kind.\n     *\n     * @param {TextTrack~Mode} [options.mode='disabled']\n     *        A valid text track mode.\n     *\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n     *        A unique id for this TextTrack.\n     *\n     * @param {string} [options.label='']\n     *        The menu label for this track.\n     *\n     * @param {string} [options.language='']\n     *        A valid two character language code.\n     *\n     * @param {string} [options.srclang='']\n     *        A valid two character language code. An alternative, but deprioritized\n     *        version of `options.language`\n     *\n     * @param {string} [options.src]\n     *        A url to TextTrack cues.\n     *\n     * @param {boolean} [options.default]\n     *        If this track should default to on or off.\n     */\n    constructor(options = {}) {\n      super();\n      let readyState;\n      const track = new TextTrack(options);\n      this.kind = track.kind;\n      this.src = track.src;\n      this.srclang = track.language;\n      this.label = track.label;\n      this.default = track.default;\n      Object.defineProperties(this, {\n        /**\n         * @memberof HTMLTrackElement\n         * @member {HTMLTrackElement~ReadyState} readyState\n         *         The current ready state of the track element.\n         * @instance\n         */\n        readyState: {\n          get() {\n            return readyState;\n          }\n        },\n        /**\n         * @memberof HTMLTrackElement\n         * @member {TextTrack} track\n         *         The underlying TextTrack object.\n         * @instance\n         *\n         */\n        track: {\n          get() {\n            return track;\n          }\n        }\n      });\n      readyState = HTMLTrackElement.NONE;\n\n      /**\n       * @listens TextTrack#loadeddata\n       * @fires HTMLTrackElement#load\n       */\n      track.addEventListener('loadeddata', () => {\n        readyState = HTMLTrackElement.LOADED;\n        this.trigger({\n          type: 'load',\n          target: this\n        });\n      });\n    }\n  }\n  HTMLTrackElement.prototype.allowedEvents_ = {\n    load: 'load'\n  };\n\n  /**\n   * The text track not loaded state.\n   *\n   * @type {number}\n   * @static\n   */\n  HTMLTrackElement.NONE = 0;\n\n  /**\n   * The text track loading state.\n   *\n   * @type {number}\n   * @static\n   */\n  HTMLTrackElement.LOADING = 1;\n\n  /**\n   * The text track loaded state.\n   *\n   * @type {number}\n   * @static\n   */\n  HTMLTrackElement.LOADED = 2;\n\n  /**\n   * The text track failed to load state.\n   *\n   * @type {number}\n   * @static\n   */\n  HTMLTrackElement.ERROR = 3;\n\n  /*\n   * This file contains all track properties that are used in\n   * player.js, tech.js, html5.js and possibly other techs in the future.\n   */\n\n  const NORMAL = {\n    audio: {\n      ListClass: AudioTrackList,\n      TrackClass: AudioTrack,\n      capitalName: 'Audio'\n    },\n    video: {\n      ListClass: VideoTrackList,\n      TrackClass: VideoTrack,\n      capitalName: 'Video'\n    },\n    text: {\n      ListClass: TextTrackList,\n      TrackClass: TextTrack,\n      capitalName: 'Text'\n    }\n  };\n  Object.keys(NORMAL).forEach(function (type) {\n    NORMAL[type].getterName = `${type}Tracks`;\n    NORMAL[type].privateName = `${type}Tracks_`;\n  });\n  const REMOTE = {\n    remoteText: {\n      ListClass: TextTrackList,\n      TrackClass: TextTrack,\n      capitalName: 'RemoteText',\n      getterName: 'remoteTextTracks',\n      privateName: 'remoteTextTracks_'\n    },\n    remoteTextEl: {\n      ListClass: HtmlTrackElementList,\n      TrackClass: HTMLTrackElement,\n      capitalName: 'RemoteTextTrackEls',\n      getterName: 'remoteTextTrackEls',\n      privateName: 'remoteTextTrackEls_'\n    }\n  };\n  const ALL = Object.assign({}, NORMAL, REMOTE);\n  REMOTE.names = Object.keys(REMOTE);\n  NORMAL.names = Object.keys(NORMAL);\n  ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n\n  var minDoc = {};\n\n  var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : {};\n  var doccy;\n  if (typeof document !== 'undefined') {\n    doccy = document;\n  } else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n    if (!doccy) {\n      doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n  }\n  var document_1 = doccy;\n\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n  /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n  var _objCreate = Object.create || function () {\n    function F() {}\n    return function (o) {\n      if (arguments.length !== 1) {\n        throw new Error('Object.create shim only accepts one parameter.');\n      }\n      F.prototype = o;\n      return new F();\n    };\n  }();\n\n  // Creates a new ParserError object from an errorData object. The errorData\n  // object should have default code and message properties. The default message\n  // property can be overriden by passing in a message parameter.\n  // See ParsingError.Errors below for acceptable errors.\n  function ParsingError(errorData, message) {\n    this.name = \"ParsingError\";\n    this.code = errorData.code;\n    this.message = message || errorData.message;\n  }\n  ParsingError.prototype = _objCreate(Error.prototype);\n  ParsingError.prototype.constructor = ParsingError;\n\n  // ParsingError metadata for acceptable ParsingErrors.\n  ParsingError.Errors = {\n    BadSignature: {\n      code: 0,\n      message: \"Malformed WebVTT signature.\"\n    },\n    BadTimeStamp: {\n      code: 1,\n      message: \"Malformed time stamp.\"\n    }\n  };\n\n  // Try to parse input as a time stamp.\n  function parseTimeStamp(input) {\n    function computeSeconds(h, m, s, f) {\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n    }\n    var m = input.match(/^(\\d+):(\\d{1,2})(:\\d{1,2})?\\.(\\d{3})/);\n    if (!m) {\n      return null;\n    }\n    if (m[3]) {\n      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n      return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n    } else if (m[1] > 59) {\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n      // First position is hours as it's over 59.\n      return computeSeconds(m[1], m[2], 0, m[4]);\n    } else {\n      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n      return computeSeconds(0, m[1], m[2], m[4]);\n    }\n  }\n\n  // A settings object holds key/value pairs and will ignore anything but the first\n  // assignment to a specific key.\n  function Settings() {\n    this.values = _objCreate(null);\n  }\n  Settings.prototype = {\n    // Only accept the first assignment to any key.\n    set: function (k, v) {\n      if (!this.get(k) && v !== \"\") {\n        this.values[k] = v;\n      }\n    },\n    // Return the value for a key, or a default value.\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n    // a number of possible default values as properties where 'defaultKey' is\n    // the key of the property that will be chosen; otherwise it's assumed to be\n    // a single value.\n    get: function (k, dflt, defaultKey) {\n      if (defaultKey) {\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\n      }\n      return this.has(k) ? this.values[k] : dflt;\n    },\n    // Check whether we have a value for a key.\n    has: function (k) {\n      return k in this.values;\n    },\n    // Accept a setting if its one of the given alternatives.\n    alt: function (k, v, a) {\n      for (var n = 0; n < a.length; ++n) {\n        if (v === a[n]) {\n          this.set(k, v);\n          break;\n        }\n      }\n    },\n    // Accept a setting if its a valid (signed) integer.\n    integer: function (k, v) {\n      if (/^-?\\d+$/.test(v)) {\n        // integer\n        this.set(k, parseInt(v, 10));\n      }\n    },\n    // Accept a setting if its a valid percentage.\n    percent: function (k, v) {\n      if (v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n        v = parseFloat(v);\n        if (v >= 0 && v <= 100) {\n          this.set(k, v);\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n\n  // Helper function to parse input into groups separated by 'groupDelim', and\n  // interprete each group as a key/value pair separated by 'keyValueDelim'.\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\n    var groups = groupDelim ? input.split(groupDelim) : [input];\n    for (var i in groups) {\n      if (typeof groups[i] !== \"string\") {\n        continue;\n      }\n      var kv = groups[i].split(keyValueDelim);\n      if (kv.length !== 2) {\n        continue;\n      }\n      var k = kv[0].trim();\n      var v = kv[1].trim();\n      callback(k, v);\n    }\n  }\n  function parseCue(input, cue, regionList) {\n    // Remember the original input if we need to throw an error.\n    var oInput = input;\n    // 4.1 WebVTT timestamp\n    function consumeTimeStamp() {\n      var ts = parseTimeStamp(input);\n      if (ts === null) {\n        throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed timestamp: \" + oInput);\n      }\n      // Remove time stamp from input.\n      input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n      return ts;\n    }\n\n    // 4.4.2 WebVTT cue settings\n    function consumeCueSettings(input, cue) {\n      var settings = new Settings();\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case \"region\":\n            // Find the last region we parsed with the same region id.\n            for (var i = regionList.length - 1; i >= 0; i--) {\n              if (regionList[i].id === v) {\n                settings.set(k, regionList[i].region);\n                break;\n              }\n            }\n            break;\n          case \"vertical\":\n            settings.alt(k, v, [\"rl\", \"lr\"]);\n            break;\n          case \"line\":\n            var vals = v.split(\",\"),\n              vals0 = vals[0];\n            settings.integer(k, vals0);\n            settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n            settings.alt(k, vals0, [\"auto\"]);\n            if (vals.length === 2) {\n              settings.alt(\"lineAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n            }\n            break;\n          case \"position\":\n            vals = v.split(\",\");\n            settings.percent(k, vals[0]);\n            if (vals.length === 2) {\n              settings.alt(\"positionAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n            }\n            break;\n          case \"size\":\n            settings.percent(k, v);\n            break;\n          case \"align\":\n            settings.alt(k, v, [\"start\", \"center\", \"end\", \"left\", \"right\"]);\n            break;\n        }\n      }, /:/, /\\s/);\n\n      // Apply default values for any missing fields.\n      cue.region = settings.get(\"region\", null);\n      cue.vertical = settings.get(\"vertical\", \"\");\n      try {\n        cue.line = settings.get(\"line\", \"auto\");\n      } catch (e) {}\n      cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n      cue.snapToLines = settings.get(\"snapToLines\", true);\n      cue.size = settings.get(\"size\", 100);\n      // Safari still uses the old middle value and won't accept center\n      try {\n        cue.align = settings.get(\"align\", \"center\");\n      } catch (e) {\n        cue.align = settings.get(\"align\", \"middle\");\n      }\n      try {\n        cue.position = settings.get(\"position\", \"auto\");\n      } catch (e) {\n        cue.position = settings.get(\"position\", {\n          start: 0,\n          left: 0,\n          center: 50,\n          middle: 50,\n          end: 100,\n          right: 100\n        }, cue.align);\n      }\n      cue.positionAlign = settings.get(\"positionAlign\", {\n        start: \"start\",\n        left: \"start\",\n        center: \"center\",\n        middle: \"center\",\n        end: \"end\",\n        right: \"end\"\n      }, cue.align);\n    }\n    function skipWhitespace() {\n      input = input.replace(/^\\s+/, \"\");\n    }\n\n    // 4.1 WebVTT cue timings.\n    skipWhitespace();\n    cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n    skipWhitespace();\n    if (input.substr(0, 3) !== \"-->\") {\n      // (3) next characters must match \"-->\"\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n    }\n    input = input.substr(3);\n    skipWhitespace();\n    cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n    // 4.1 WebVTT cue settings list.\n    skipWhitespace();\n    consumeCueSettings(input, cue);\n  }\n\n  // When evaluating this file as part of a Webpack bundle for server\n  // side rendering, `document` is an empty object.\n  var TEXTAREA_ELEMENT = document_1.createElement && document_1.createElement(\"textarea\");\n  var TAG_NAME = {\n    c: \"span\",\n    i: \"i\",\n    b: \"b\",\n    u: \"u\",\n    ruby: \"ruby\",\n    rt: \"rt\",\n    v: \"span\",\n    lang: \"span\"\n  };\n\n  // 5.1 default text color\n  // 5.2 default text background color is equivalent to text color with bg_ prefix\n  var DEFAULT_COLOR_CLASS = {\n    white: 'rgba(255,255,255,1)',\n    lime: 'rgba(0,255,0,1)',\n    cyan: 'rgba(0,255,255,1)',\n    red: 'rgba(255,0,0,1)',\n    yellow: 'rgba(255,255,0,1)',\n    magenta: 'rgba(255,0,255,1)',\n    blue: 'rgba(0,0,255,1)',\n    black: 'rgba(0,0,0,1)'\n  };\n  var TAG_ANNOTATION = {\n    v: \"title\",\n    lang: \"lang\"\n  };\n  var NEEDS_PARENT = {\n    rt: \"ruby\"\n  };\n\n  // Parse content into a document fragment.\n  function parseContent(window, input) {\n    function nextToken() {\n      // Check for end-of-string.\n      if (!input) {\n        return null;\n      }\n\n      // Consume 'n' characters from the input.\n      function consume(result) {\n        input = input.substr(result.length);\n        return result;\n      }\n      var m = input.match(/^([^<]*)(<[^>]*>?)?/);\n      // If there is some text before the next tag, return it, otherwise return\n      // the tag.\n      return consume(m[1] ? m[1] : m[2]);\n    }\n    function unescape(s) {\n      TEXTAREA_ELEMENT.innerHTML = s;\n      s = TEXTAREA_ELEMENT.textContent;\n      TEXTAREA_ELEMENT.textContent = \"\";\n      return s;\n    }\n    function shouldAdd(current, element) {\n      return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;\n    }\n\n    // Create an element for this tag.\n    function createElement(type, annotation) {\n      var tagName = TAG_NAME[type];\n      if (!tagName) {\n        return null;\n      }\n      var element = window.document.createElement(tagName);\n      var name = TAG_ANNOTATION[type];\n      if (name && annotation) {\n        element[name] = annotation.trim();\n      }\n      return element;\n    }\n    var rootDiv = window.document.createElement(\"div\"),\n      current = rootDiv,\n      t,\n      tagStack = [];\n    while ((t = nextToken()) !== null) {\n      if (t[0] === '<') {\n        if (t[1] === \"/\") {\n          // If the closing tag matches, move back up to the parent node.\n          if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n            tagStack.pop();\n            current = current.parentNode;\n          }\n          // Otherwise just ignore the end tag.\n          continue;\n        }\n        var ts = parseTimeStamp(t.substr(1, t.length - 2));\n        var node;\n        if (ts) {\n          // Timestamps are lead nodes as well.\n          node = window.document.createProcessingInstruction(\"timestamp\", ts);\n          current.appendChild(node);\n          continue;\n        }\n        var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n        // If we can't parse the tag, skip to the next tag.\n        if (!m) {\n          continue;\n        }\n        // Try to construct an element, and ignore the tag if we couldn't.\n        node = createElement(m[1], m[3]);\n        if (!node) {\n          continue;\n        }\n        // Determine if the tag should be added based on the context of where it\n        // is placed in the cuetext.\n        if (!shouldAdd(current, node)) {\n          continue;\n        }\n        // Set the class list (as a list of classes, separated by space).\n        if (m[2]) {\n          var classes = m[2].split('.');\n          classes.forEach(function (cl) {\n            var bgColor = /^bg_/.test(cl);\n            // slice out `bg_` if it's a background color\n            var colorName = bgColor ? cl.slice(3) : cl;\n            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {\n              var propName = bgColor ? 'background-color' : 'color';\n              var propValue = DEFAULT_COLOR_CLASS[colorName];\n              node.style[propName] = propValue;\n            }\n          });\n          node.className = classes.join(' ');\n        }\n        // Append the node to the current node, and enter the scope of the new\n        // node.\n        tagStack.push(m[1]);\n        current.appendChild(node);\n        current = node;\n        continue;\n      }\n\n      // Text nodes are leaf nodes.\n      current.appendChild(window.document.createTextNode(unescape(t)));\n    }\n    return rootDiv;\n  }\n\n  // This is a list of all the Unicode characters that have a strong\n  // right-to-left category. What this means is that these characters are\n  // written right-to-left for sure. It was generated by pulling all the strong\n  // right-to-left characters out of the Unicode data table. That table can\n  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\n  var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n  function isStrongRTLChar(charCode) {\n    for (var i = 0; i < strongRTLRanges.length; i++) {\n      var currentRange = strongRTLRanges[i];\n      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function determineBidi(cueDiv) {\n    var nodeStack = [],\n      text = \"\",\n      charCode;\n    if (!cueDiv || !cueDiv.childNodes) {\n      return \"ltr\";\n    }\n    function pushNodes(nodeStack, node) {\n      for (var i = node.childNodes.length - 1; i >= 0; i--) {\n        nodeStack.push(node.childNodes[i]);\n      }\n    }\n    function nextTextNode(nodeStack) {\n      if (!nodeStack || !nodeStack.length) {\n        return null;\n      }\n      var node = nodeStack.pop(),\n        text = node.textContent || node.innerText;\n      if (text) {\n        // TODO: This should match all unicode type B characters (paragraph\n        // separator characters). See issue #115.\n        var m = text.match(/^.*(\\n|\\r)/);\n        if (m) {\n          nodeStack.length = 0;\n          return m[0];\n        }\n        return text;\n      }\n      if (node.tagName === \"ruby\") {\n        return nextTextNode(nodeStack);\n      }\n      if (node.childNodes) {\n        pushNodes(nodeStack, node);\n        return nextTextNode(nodeStack);\n      }\n    }\n    pushNodes(nodeStack, cueDiv);\n    while (text = nextTextNode(nodeStack)) {\n      for (var i = 0; i < text.length; i++) {\n        charCode = text.charCodeAt(i);\n        if (isStrongRTLChar(charCode)) {\n          return \"rtl\";\n        }\n      }\n    }\n    return \"ltr\";\n  }\n  function computeLinePos(cue) {\n    if (typeof cue.line === \"number\" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {\n      return cue.line;\n    }\n    if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {\n      return -1;\n    }\n    var track = cue.track,\n      trackList = track.textTrackList,\n      count = 0;\n    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n      if (trackList[i].mode === \"showing\") {\n        count++;\n      }\n    }\n    return ++count * -1;\n  }\n  function StyleBox() {}\n\n  // Apply styles to a div. If there is no div passed then it defaults to the\n  // div on 'this'.\n  StyleBox.prototype.applyStyles = function (styles, div) {\n    div = div || this.div;\n    for (var prop in styles) {\n      if (styles.hasOwnProperty(prop)) {\n        div.style[prop] = styles[prop];\n      }\n    }\n  };\n  StyleBox.prototype.formatStyle = function (val, unit) {\n    return val === 0 ? 0 : val + unit;\n  };\n\n  // Constructs the computed display state of the cue (a div). Places the div\n  // into the overlay which should be a block level element (usually a div).\n  function CueStyleBox(window, cue, styleOptions) {\n    StyleBox.call(this);\n    this.cue = cue;\n\n    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n    // have inline positioning and will function as the cue background box.\n    this.cueDiv = parseContent(window, cue.text);\n    var styles = {\n      color: \"rgba(255, 255, 255, 1)\",\n      backgroundColor: \"rgba(0, 0, 0, 0.8)\",\n      position: \"relative\",\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n      display: \"inline\",\n      writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\n      unicodeBidi: \"plaintext\"\n    };\n    this.applyStyles(styles, this.cueDiv);\n\n    // Create an absolutely positioned div that will be used to position the cue\n    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n    // mirrors of them except middle instead of center on Safari.\n    this.div = window.document.createElement(\"div\");\n    styles = {\n      direction: determineBidi(this.cueDiv),\n      writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\n      unicodeBidi: \"plaintext\",\n      textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n      font: styleOptions.font,\n      whiteSpace: \"pre-line\",\n      position: \"absolute\"\n    };\n    this.applyStyles(styles);\n    this.div.appendChild(this.cueDiv);\n\n    // Calculate the distance from the reference edge of the viewport to the text\n    // position of the cue box. The reference edge will be resolved later when\n    // the box orientation styles are applied.\n    var textPos = 0;\n    switch (cue.positionAlign) {\n      case \"start\":\n        textPos = cue.position;\n        break;\n      case \"center\":\n        textPos = cue.position - cue.size / 2;\n        break;\n      case \"end\":\n        textPos = cue.position - cue.size;\n        break;\n    }\n\n    // Horizontal box orientation; textPos is the distance from the left edge of the\n    // area to the left edge of the box and cue.size is the distance extending to\n    // the right from there.\n    if (cue.vertical === \"\") {\n      this.applyStyles({\n        left: this.formatStyle(textPos, \"%\"),\n        width: this.formatStyle(cue.size, \"%\")\n      });\n      // Vertical box orientation; textPos is the distance from the top edge of the\n      // area to the top edge of the box and cue.size is the height extending\n      // downwards from there.\n    } else {\n      this.applyStyles({\n        top: this.formatStyle(textPos, \"%\"),\n        height: this.formatStyle(cue.size, \"%\")\n      });\n    }\n    this.move = function (box) {\n      this.applyStyles({\n        top: this.formatStyle(box.top, \"px\"),\n        bottom: this.formatStyle(box.bottom, \"px\"),\n        left: this.formatStyle(box.left, \"px\"),\n        right: this.formatStyle(box.right, \"px\"),\n        height: this.formatStyle(box.height, \"px\"),\n        width: this.formatStyle(box.width, \"px\")\n      });\n    };\n  }\n  CueStyleBox.prototype = _objCreate(StyleBox.prototype);\n  CueStyleBox.prototype.constructor = CueStyleBox;\n\n  // Represents the co-ordinates of an Element in a way that we can easily\n  // compute things with such as if it overlaps or intersects with another Element.\n  // Can initialize it with either a StyleBox or another BoxPosition.\n  function BoxPosition(obj) {\n    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n    // was passed in and we need to copy the results of 'getBoundingClientRect'\n    // as the object returned is readonly. All co-ordinate values are in reference\n    // to the viewport origin (top left).\n    var lh, height, width, top;\n    if (obj.div) {\n      height = obj.div.offsetHeight;\n      width = obj.div.offsetWidth;\n      top = obj.div.offsetTop;\n      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();\n      obj = obj.div.getBoundingClientRect();\n      // In certain cases the outter div will be slightly larger then the sum of\n      // the inner div's lines. This could be due to bold text, etc, on some platforms.\n      // In this case we should get the average line height and use that. This will\n      // result in the desired behaviour.\n      lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;\n    }\n    this.left = obj.left;\n    this.right = obj.right;\n    this.top = obj.top || top;\n    this.height = obj.height || height;\n    this.bottom = obj.bottom || top + (obj.height || height);\n    this.width = obj.width || width;\n    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n  }\n\n  // Move the box along a particular axis. Optionally pass in an amount to move\n  // the box. If no amount is passed then the default is the line height of the\n  // box.\n  BoxPosition.prototype.move = function (axis, toMove) {\n    toMove = toMove !== undefined ? toMove : this.lineHeight;\n    switch (axis) {\n      case \"+x\":\n        this.left += toMove;\n        this.right += toMove;\n        break;\n      case \"-x\":\n        this.left -= toMove;\n        this.right -= toMove;\n        break;\n      case \"+y\":\n        this.top += toMove;\n        this.bottom += toMove;\n        break;\n      case \"-y\":\n        this.top -= toMove;\n        this.bottom -= toMove;\n        break;\n    }\n  };\n\n  // Check if this box overlaps another box, b2.\n  BoxPosition.prototype.overlaps = function (b2) {\n    return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;\n  };\n\n  // Check if this box overlaps any other boxes in boxes.\n  BoxPosition.prototype.overlapsAny = function (boxes) {\n    for (var i = 0; i < boxes.length; i++) {\n      if (this.overlaps(boxes[i])) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Check if this box is within another box.\n  BoxPosition.prototype.within = function (container) {\n    return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;\n  };\n\n  // Check if this box is entirely within the container or it is overlapping\n  // on the edge opposite of the axis direction passed. For example, if \"+x\" is\n  // passed and the box is overlapping on the left edge of the container, then\n  // return true.\n  BoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {\n    switch (axis) {\n      case \"+x\":\n        return this.left < container.left;\n      case \"-x\":\n        return this.right > container.right;\n      case \"+y\":\n        return this.top < container.top;\n      case \"-y\":\n        return this.bottom > container.bottom;\n    }\n  };\n\n  // Find the percentage of the area that this box is overlapping with another\n  // box.\n  BoxPosition.prototype.intersectPercentage = function (b2) {\n    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n      intersectArea = x * y;\n    return intersectArea / (this.height * this.width);\n  };\n\n  // Convert the positions from this box to CSS compatible positions using\n  // the reference container's positions. This has to be done because this\n  // box's positions are in reference to the viewport origin, whereas, CSS\n  // values are in referecne to their respective edges.\n  BoxPosition.prototype.toCSSCompatValues = function (reference) {\n    return {\n      top: this.top - reference.top,\n      bottom: reference.bottom - this.bottom,\n      left: this.left - reference.left,\n      right: reference.right - this.right,\n      height: this.height,\n      width: this.width\n    };\n  };\n\n  // Get an object that represents the box's position without anything extra.\n  // Can pass a StyleBox, HTMLElement, or another BoxPositon.\n  BoxPosition.getSimpleBoxPosition = function (obj) {\n    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n    obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;\n    var ret = {\n      left: obj.left,\n      right: obj.right,\n      top: obj.top || top,\n      height: obj.height || height,\n      bottom: obj.bottom || top + (obj.height || height),\n      width: obj.width || width\n    };\n    return ret;\n  };\n\n  // Move a StyleBox to its specified, or next best, position. The containerBox\n  // is the box that contains the StyleBox, such as a div. boxPositions are\n  // a list of other boxes that the styleBox can't overlap with.\n  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n    // Find the best position for a cue box, b, on the video. The axis parameter\n    // is a list of axis, the order of which, it will move the box along. For example:\n    // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n    // direction. If it doesn't find a good position for it there it will then move\n    // it along the x axis in the negative direction.\n    function findBestPosition(b, axis) {\n      var bestPosition,\n        specifiedPosition = new BoxPosition(b),\n        percentage = 1; // Highest possible so the first thing we get is better.\n\n      for (var i = 0; i < axis.length; i++) {\n        while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {\n          b.move(axis[i]);\n        }\n        // We found a spot where we aren't overlapping anything. This is our\n        // best position.\n        if (b.within(containerBox)) {\n          return b;\n        }\n        var p = b.intersectPercentage(containerBox);\n        // If we're outside the container box less then we were on our last try\n        // then remember this position as the best position.\n        if (percentage > p) {\n          bestPosition = new BoxPosition(b);\n          percentage = p;\n        }\n        // Reset the box position to the specified position.\n        b = new BoxPosition(specifiedPosition);\n      }\n      return bestPosition || specifiedPosition;\n    }\n    var boxPosition = new BoxPosition(styleBox),\n      cue = styleBox.cue,\n      linePos = computeLinePos(cue),\n      axis = [];\n\n    // If we have a line number to align the cue to.\n    if (cue.snapToLines) {\n      var size;\n      switch (cue.vertical) {\n        case \"\":\n          axis = [\"+y\", \"-y\"];\n          size = \"height\";\n          break;\n        case \"rl\":\n          axis = [\"+x\", \"-x\"];\n          size = \"width\";\n          break;\n        case \"lr\":\n          axis = [\"-x\", \"+x\"];\n          size = \"width\";\n          break;\n      }\n      var step = boxPosition.lineHeight,\n        position = step * Math.round(linePos),\n        maxPosition = containerBox[size] + step,\n        initialAxis = axis[0];\n\n      // If the specified intial position is greater then the max position then\n      // clamp the box to the amount of steps it would take for the box to\n      // reach the max position.\n      if (Math.abs(position) > maxPosition) {\n        position = position < 0 ? -1 : 1;\n        position *= Math.ceil(maxPosition / step) * step;\n      }\n\n      // If computed line position returns negative then line numbers are\n      // relative to the bottom of the video instead of the top. Therefore, we\n      // need to increase our initial position by the length or width of the\n      // video, depending on the writing direction, and reverse our axis directions.\n      if (linePos < 0) {\n        position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n        axis = axis.reverse();\n      }\n\n      // Move the box to the specified position. This may not be its best\n      // position.\n      boxPosition.move(initialAxis, position);\n    } else {\n      // If we have a percentage line value for the cue.\n      var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;\n      switch (cue.lineAlign) {\n        case \"center\":\n          linePos -= calculatedPercentage / 2;\n          break;\n        case \"end\":\n          linePos -= calculatedPercentage;\n          break;\n      }\n\n      // Apply initial line position to the cue box.\n      switch (cue.vertical) {\n        case \"\":\n          styleBox.applyStyles({\n            top: styleBox.formatStyle(linePos, \"%\")\n          });\n          break;\n        case \"rl\":\n          styleBox.applyStyles({\n            left: styleBox.formatStyle(linePos, \"%\")\n          });\n          break;\n        case \"lr\":\n          styleBox.applyStyles({\n            right: styleBox.formatStyle(linePos, \"%\")\n          });\n          break;\n      }\n      axis = [\"+y\", \"-x\", \"+x\", \"-y\"];\n\n      // Get the box position again after we've applied the specified positioning\n      // to it.\n      boxPosition = new BoxPosition(styleBox);\n    }\n    var bestPosition = findBestPosition(boxPosition, axis);\n    styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n  }\n  function WebVTT$1() {\n    // Nothing\n  }\n\n  // Helper to allow strings to be decoded instead of the default binary utf8 data.\n  WebVTT$1.StringDecoder = function () {\n    return {\n      decode: function (data) {\n        if (!data) {\n          return \"\";\n        }\n        if (typeof data !== \"string\") {\n          throw new Error(\"Error - expected string data.\");\n        }\n        return decodeURIComponent(encodeURIComponent(data));\n      }\n    };\n  };\n  WebVTT$1.convertCueToDOMTree = function (window, cuetext) {\n    if (!window || !cuetext) {\n      return null;\n    }\n    return parseContent(window, cuetext);\n  };\n  var FONT_SIZE_PERCENT = 0.05;\n  var FONT_STYLE = \"sans-serif\";\n  var CUE_BACKGROUND_PADDING = \"1.5%\";\n\n  // Runs the processing model over the cues and regions passed to it.\n  // @param overlay A block level element (usually a div) that the computed cues\n  //                and regions will be placed into.\n  WebVTT$1.processCues = function (window, cues, overlay) {\n    if (!window || !cues || !overlay) {\n      return null;\n    }\n\n    // Remove all previous children.\n    while (overlay.firstChild) {\n      overlay.removeChild(overlay.firstChild);\n    }\n    var paddedOverlay = window.document.createElement(\"div\");\n    paddedOverlay.style.position = \"absolute\";\n    paddedOverlay.style.left = \"0\";\n    paddedOverlay.style.right = \"0\";\n    paddedOverlay.style.top = \"0\";\n    paddedOverlay.style.bottom = \"0\";\n    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n    overlay.appendChild(paddedOverlay);\n\n    // Determine if we need to compute the display states of the cues. This could\n    // be the case if a cue's state has been changed since the last computation or\n    // if it has not been computed yet.\n    function shouldCompute(cues) {\n      for (var i = 0; i < cues.length; i++) {\n        if (cues[i].hasBeenReset || !cues[i].displayState) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // We don't need to recompute the cues' display states. Just reuse them.\n    if (!shouldCompute(cues)) {\n      for (var i = 0; i < cues.length; i++) {\n        paddedOverlay.appendChild(cues[i].displayState);\n      }\n      return;\n    }\n    var boxPositions = [],\n      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n    var styleOptions = {\n      font: fontSize + \"px \" + FONT_STYLE\n    };\n    (function () {\n      var styleBox, cue;\n      for (var i = 0; i < cues.length; i++) {\n        cue = cues[i];\n\n        // Compute the intial position and styles of the cue div.\n        styleBox = new CueStyleBox(window, cue, styleOptions);\n        paddedOverlay.appendChild(styleBox.div);\n\n        // Move the cue div to it's correct line position.\n        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n        // Remember the computed div so that we don't have to recompute it later\n        // if we don't have too.\n        cue.displayState = styleBox.div;\n        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n      }\n    })();\n  };\n  WebVTT$1.Parser = function (window, vttjs, decoder) {\n    if (!decoder) {\n      decoder = vttjs;\n      vttjs = {};\n    }\n    if (!vttjs) {\n      vttjs = {};\n    }\n    this.window = window;\n    this.vttjs = vttjs;\n    this.state = \"INITIAL\";\n    this.buffer = \"\";\n    this.decoder = decoder || new TextDecoder(\"utf8\");\n    this.regionList = [];\n  };\n  WebVTT$1.Parser.prototype = {\n    // If the error is a ParsingError then report it to the consumer if\n    // possible. If it's not a ParsingError then throw it like normal.\n    reportOrThrowError: function (e) {\n      if (e instanceof ParsingError) {\n        this.onparsingerror && this.onparsingerror(e);\n      } else {\n        throw e;\n      }\n    },\n    parse: function (data) {\n      var self = this;\n\n      // If there is no data then we won't decode it, but will just try to parse\n      // whatever is in buffer already. This may occur in circumstances, for\n      // example when flush() is called.\n      if (data) {\n        // Try to decode the data that we received.\n        self.buffer += self.decoder.decode(data, {\n          stream: true\n        });\n      }\n      function collectNextLine() {\n        var buffer = self.buffer;\n        var pos = 0;\n        while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n          ++pos;\n        }\n        var line = buffer.substr(0, pos);\n        // Advance the buffer early in case we fail below.\n        if (buffer[pos] === '\\r') {\n          ++pos;\n        }\n        if (buffer[pos] === '\\n') {\n          ++pos;\n        }\n        self.buffer = buffer.substr(pos);\n        return line;\n      }\n\n      // 3.4 WebVTT region and WebVTT region settings syntax\n      function parseRegion(input) {\n        var settings = new Settings();\n        parseOptions(input, function (k, v) {\n          switch (k) {\n            case \"id\":\n              settings.set(k, v);\n              break;\n            case \"width\":\n              settings.percent(k, v);\n              break;\n            case \"lines\":\n              settings.integer(k, v);\n              break;\n            case \"regionanchor\":\n            case \"viewportanchor\":\n              var xy = v.split(',');\n              if (xy.length !== 2) {\n                break;\n              }\n              // We have to make sure both x and y parse, so use a temporary\n              // settings object here.\n              var anchor = new Settings();\n              anchor.percent(\"x\", xy[0]);\n              anchor.percent(\"y\", xy[1]);\n              if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n                break;\n              }\n              settings.set(k + \"X\", anchor.get(\"x\"));\n              settings.set(k + \"Y\", anchor.get(\"y\"));\n              break;\n            case \"scroll\":\n              settings.alt(k, v, [\"up\"]);\n              break;\n          }\n        }, /=/, /\\s/);\n\n        // Create the region, using default values for any values that were not\n        // specified.\n        if (settings.has(\"id\")) {\n          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n          region.width = settings.get(\"width\", 100);\n          region.lines = settings.get(\"lines\", 3);\n          region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n          region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n          region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n          region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n          region.scroll = settings.get(\"scroll\", \"\");\n          // Register the region.\n          self.onregion && self.onregion(region);\n          // Remember the VTTRegion for later in case we parse any VTTCues that\n          // reference it.\n          self.regionList.push({\n            id: settings.get(\"id\"),\n            region: region\n          });\n        }\n      }\n\n      // draft-pantos-http-live-streaming-20\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n      // 3.5 WebVTT\n      function parseTimestampMap(input) {\n        var settings = new Settings();\n        parseOptions(input, function (k, v) {\n          switch (k) {\n            case \"MPEGT\":\n              settings.integer(k + 'S', v);\n              break;\n            case \"LOCA\":\n              settings.set(k + 'L', parseTimeStamp(v));\n              break;\n          }\n        }, /[^\\d]:/, /,/);\n        self.ontimestampmap && self.ontimestampmap({\n          \"MPEGTS\": settings.get(\"MPEGTS\"),\n          \"LOCAL\": settings.get(\"LOCAL\")\n        });\n      }\n\n      // 3.2 WebVTT metadata header syntax\n      function parseHeader(input) {\n        if (input.match(/X-TIMESTAMP-MAP/)) {\n          // This line contains HLS X-TIMESTAMP-MAP metadata\n          parseOptions(input, function (k, v) {\n            switch (k) {\n              case \"X-TIMESTAMP-MAP\":\n                parseTimestampMap(v);\n                break;\n            }\n          }, /=/);\n        } else {\n          parseOptions(input, function (k, v) {\n            switch (k) {\n              case \"Region\":\n                // 3.3 WebVTT region metadata header syntax\n                parseRegion(v);\n                break;\n            }\n          }, /:/);\n        }\n      }\n\n      // 5.1 WebVTT file parsing.\n      try {\n        var line;\n        if (self.state === \"INITIAL\") {\n          // We can't start parsing until we have the first line.\n          if (!/\\r\\n|\\n/.test(self.buffer)) {\n            return this;\n          }\n          line = collectNextLine();\n          var m = line.match(/^WEBVTT([ \\t].*)?$/);\n          if (!m || !m[0]) {\n            throw new ParsingError(ParsingError.Errors.BadSignature);\n          }\n          self.state = \"HEADER\";\n        }\n        var alreadyCollectedLine = false;\n        while (self.buffer) {\n          // We can't parse a line until we have the full line.\n          if (!/\\r\\n|\\n/.test(self.buffer)) {\n            return this;\n          }\n          if (!alreadyCollectedLine) {\n            line = collectNextLine();\n          } else {\n            alreadyCollectedLine = false;\n          }\n          switch (self.state) {\n            case \"HEADER\":\n              // 13-18 - Allow a header (metadata) under the WEBVTT line.\n              if (/:/.test(line)) {\n                parseHeader(line);\n              } else if (!line) {\n                // An empty line terminates the header and starts the body (cues).\n                self.state = \"ID\";\n              }\n              continue;\n            case \"NOTE\":\n              // Ignore NOTE blocks.\n              if (!line) {\n                self.state = \"ID\";\n              }\n              continue;\n            case \"ID\":\n              // Check for the start of NOTE blocks.\n              if (/^NOTE($|[ \\t])/.test(line)) {\n                self.state = \"NOTE\";\n                break;\n              }\n              // 19-29 - Allow any number of line terminators, then initialize new cue values.\n              if (!line) {\n                continue;\n              }\n              self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n              // Safari still uses the old middle value and won't accept center\n              try {\n                self.cue.align = \"center\";\n              } catch (e) {\n                self.cue.align = \"middle\";\n              }\n              self.state = \"CUE\";\n              // 30-39 - Check if self line contains an optional identifier or timing data.\n              if (line.indexOf(\"-->\") === -1) {\n                self.cue.id = line;\n                continue;\n              }\n            // Process line as start of a cue.\n            /*falls through*/\n            case \"CUE\":\n              // 40 - Collect cue timings and settings.\n              try {\n                parseCue(line, self.cue, self.regionList);\n              } catch (e) {\n                self.reportOrThrowError(e);\n                // In case of an error ignore rest of the cue.\n                self.cue = null;\n                self.state = \"BADCUE\";\n                continue;\n              }\n              self.state = \"CUETEXT\";\n              continue;\n            case \"CUETEXT\":\n              var hasSubstring = line.indexOf(\"-->\") !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                self.oncue && self.oncue(self.cue);\n                self.cue = null;\n                self.state = \"ID\";\n                continue;\n              }\n              if (self.cue.text) {\n                self.cue.text += \"\\n\";\n              }\n              self.cue.text += line.replace(/\\u2028/g, '\\n').replace(/u2029/g, '\\n');\n              continue;\n            case \"BADCUE\":\n              // BADCUE\n              // 54-62 - Collect and discard the remaining cue.\n              if (!line) {\n                self.state = \"ID\";\n              }\n              continue;\n          }\n        }\n      } catch (e) {\n        self.reportOrThrowError(e);\n\n        // If we are currently parsing a cue, report what we have.\n        if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n          self.oncue(self.cue);\n        }\n        self.cue = null;\n        // Enter BADWEBVTT state if header was not parsed correctly otherwise\n        // another exception occurred so enter BADCUE state.\n        self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n      }\n      return this;\n    },\n    flush: function () {\n      var self = this;\n      try {\n        // Finish decoding the stream.\n        self.buffer += self.decoder.decode();\n        // Synthesize the end of the current cue or region.\n        if (self.cue || self.state === \"HEADER\") {\n          self.buffer += \"\\n\\n\";\n          self.parse();\n        }\n        // If we've flushed, parsed, and we're still on the INITIAL state then\n        // that means we don't have enough of the stream to parse the first\n        // line.\n        if (self.state === \"INITIAL\") {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n      } catch (e) {\n        self.reportOrThrowError(e);\n      }\n      self.onflush && self.onflush();\n      return this;\n    }\n  };\n  var vtt = WebVTT$1;\n\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var autoKeyword = \"auto\";\n  var directionSetting = {\n    \"\": 1,\n    \"lr\": 1,\n    \"rl\": 1\n  };\n  var alignSetting = {\n    \"start\": 1,\n    \"center\": 1,\n    \"end\": 1,\n    \"left\": 1,\n    \"right\": 1,\n    \"auto\": 1,\n    \"line-left\": 1,\n    \"line-right\": 1\n  };\n  function findDirectionSetting(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    var dir = directionSetting[value.toLowerCase()];\n    return dir ? value.toLowerCase() : false;\n  }\n  function findAlignSetting(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    var align = alignSetting[value.toLowerCase()];\n    return align ? value.toLowerCase() : false;\n  }\n  function VTTCue(startTime, endTime, text) {\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    this.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = \"\";\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = \"\";\n    var _snapToLines = true;\n    var _line = \"auto\";\n    var _lineAlign = \"start\";\n    var _position = \"auto\";\n    var _positionAlign = \"auto\";\n    var _size = 100;\n    var _align = \"center\";\n    Object.defineProperties(this, {\n      \"id\": {\n        enumerable: true,\n        get: function () {\n          return _id;\n        },\n        set: function (value) {\n          _id = \"\" + value;\n        }\n      },\n      \"pauseOnExit\": {\n        enumerable: true,\n        get: function () {\n          return _pauseOnExit;\n        },\n        set: function (value) {\n          _pauseOnExit = !!value;\n        }\n      },\n      \"startTime\": {\n        enumerable: true,\n        get: function () {\n          return _startTime;\n        },\n        set: function (value) {\n          if (typeof value !== \"number\") {\n            throw new TypeError(\"Start time must be set to a number.\");\n          }\n          _startTime = value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"endTime\": {\n        enumerable: true,\n        get: function () {\n          return _endTime;\n        },\n        set: function (value) {\n          if (typeof value !== \"number\") {\n            throw new TypeError(\"End time must be set to a number.\");\n          }\n          _endTime = value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"text\": {\n        enumerable: true,\n        get: function () {\n          return _text;\n        },\n        set: function (value) {\n          _text = \"\" + value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"region\": {\n        enumerable: true,\n        get: function () {\n          return _region;\n        },\n        set: function (value) {\n          _region = value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"vertical\": {\n        enumerable: true,\n        get: function () {\n          return _vertical;\n        },\n        set: function (value) {\n          var setting = findDirectionSetting(value);\n          // Have to check for false because the setting an be an empty string.\n          if (setting === false) {\n            throw new SyntaxError(\"Vertical: an invalid or illegal direction string was specified.\");\n          }\n          _vertical = setting;\n          this.hasBeenReset = true;\n        }\n      },\n      \"snapToLines\": {\n        enumerable: true,\n        get: function () {\n          return _snapToLines;\n        },\n        set: function (value) {\n          _snapToLines = !!value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"line\": {\n        enumerable: true,\n        get: function () {\n          return _line;\n        },\n        set: function (value) {\n          if (typeof value !== \"number\" && value !== autoKeyword) {\n            throw new SyntaxError(\"Line: an invalid number or illegal string was specified.\");\n          }\n          _line = value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"lineAlign\": {\n        enumerable: true,\n        get: function () {\n          return _lineAlign;\n        },\n        set: function (value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            console.warn(\"lineAlign: an invalid or illegal string was specified.\");\n          } else {\n            _lineAlign = setting;\n            this.hasBeenReset = true;\n          }\n        }\n      },\n      \"position\": {\n        enumerable: true,\n        get: function () {\n          return _position;\n        },\n        set: function (value) {\n          if (value < 0 || value > 100) {\n            throw new Error(\"Position must be between 0 and 100.\");\n          }\n          _position = value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"positionAlign\": {\n        enumerable: true,\n        get: function () {\n          return _positionAlign;\n        },\n        set: function (value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            console.warn(\"positionAlign: an invalid or illegal string was specified.\");\n          } else {\n            _positionAlign = setting;\n            this.hasBeenReset = true;\n          }\n        }\n      },\n      \"size\": {\n        enumerable: true,\n        get: function () {\n          return _size;\n        },\n        set: function (value) {\n          if (value < 0 || value > 100) {\n            throw new Error(\"Size must be between 0 and 100.\");\n          }\n          _size = value;\n          this.hasBeenReset = true;\n        }\n      },\n      \"align\": {\n        enumerable: true,\n        get: function () {\n          return _align;\n        },\n        set: function (value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError(\"align: an invalid or illegal alignment string was specified.\");\n          }\n          _align = setting;\n          this.hasBeenReset = true;\n        }\n      }\n    });\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    this.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    return WebVTT.convertCueToDOMTree(window, this.text);\n  };\n  var vttcue = VTTCue;\n\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var scrollSetting = {\n    \"\": true,\n    \"up\": true\n  };\n  function findScrollSetting(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    var scroll = scrollSetting[value.toLowerCase()];\n    return scroll ? value.toLowerCase() : false;\n  }\n  function isValidPercentValue(value) {\n    return typeof value === \"number\" && value >= 0 && value <= 100;\n  }\n\n  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\n  function VTTRegion() {\n    var _width = 100;\n    var _lines = 3;\n    var _regionAnchorX = 0;\n    var _regionAnchorY = 100;\n    var _viewportAnchorX = 0;\n    var _viewportAnchorY = 100;\n    var _scroll = \"\";\n    Object.defineProperties(this, {\n      \"width\": {\n        enumerable: true,\n        get: function () {\n          return _width;\n        },\n        set: function (value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"Width must be between 0 and 100.\");\n          }\n          _width = value;\n        }\n      },\n      \"lines\": {\n        enumerable: true,\n        get: function () {\n          return _lines;\n        },\n        set: function (value) {\n          if (typeof value !== \"number\") {\n            throw new TypeError(\"Lines must be set to a number.\");\n          }\n          _lines = value;\n        }\n      },\n      \"regionAnchorY\": {\n        enumerable: true,\n        get: function () {\n          return _regionAnchorY;\n        },\n        set: function (value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n          }\n          _regionAnchorY = value;\n        }\n      },\n      \"regionAnchorX\": {\n        enumerable: true,\n        get: function () {\n          return _regionAnchorX;\n        },\n        set: function (value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n          }\n          _regionAnchorX = value;\n        }\n      },\n      \"viewportAnchorY\": {\n        enumerable: true,\n        get: function () {\n          return _viewportAnchorY;\n        },\n        set: function (value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n          }\n          _viewportAnchorY = value;\n        }\n      },\n      \"viewportAnchorX\": {\n        enumerable: true,\n        get: function () {\n          return _viewportAnchorX;\n        },\n        set: function (value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n          }\n          _viewportAnchorX = value;\n        }\n      },\n      \"scroll\": {\n        enumerable: true,\n        get: function () {\n          return _scroll;\n        },\n        set: function (value) {\n          var setting = findScrollSetting(value);\n          // Have to check for false as an empty string is a legal value.\n          if (setting === false) {\n            console.warn(\"Scroll: an invalid or illegal string was specified.\");\n          } else {\n            _scroll = setting;\n          }\n        }\n      }\n    });\n  }\n  var vttregion = VTTRegion;\n\n  var browserIndex = createCommonjsModule(function (module) {\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    // Default exports for Node. Export the extended versions of VTTCue and\n    // VTTRegion in Node since we likely want the capability to convert back and\n    // forth between JSON. If we don't then it's not that big of a deal since we're\n    // off browser.\n\n    var vttjs = module.exports = {\n      WebVTT: vtt,\n      VTTCue: vttcue,\n      VTTRegion: vttregion\n    };\n    window_1.vttjs = vttjs;\n    window_1.WebVTT = vttjs.WebVTT;\n    var cueShim = vttjs.VTTCue;\n    var regionShim = vttjs.VTTRegion;\n    var nativeVTTCue = window_1.VTTCue;\n    var nativeVTTRegion = window_1.VTTRegion;\n    vttjs.shim = function () {\n      window_1.VTTCue = cueShim;\n      window_1.VTTRegion = regionShim;\n    };\n    vttjs.restore = function () {\n      window_1.VTTCue = nativeVTTCue;\n      window_1.VTTRegion = nativeVTTRegion;\n    };\n    if (!window_1.VTTCue) {\n      vttjs.shim();\n    }\n  });\n  browserIndex.WebVTT;\n  browserIndex.VTTCue;\n  browserIndex.VTTRegion;\n\n  /**\n   * @file tech.js\n   */\n\n  /**\n   * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n   * that just contains the src url alone.\n   * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n     * `var SourceString = 'http://example.com/some-video.mp4';`\n   *\n   * @typedef {Object|string} Tech~SourceObject\n   *\n   * @property {string} src\n   *           The url to the source\n   *\n   * @property {string} type\n   *           The mime type of the source\n   */\n\n  /**\n   * A function used by {@link Tech} to create a new {@link TextTrack}.\n   *\n   * @private\n   *\n   * @param {Tech} self\n   *        An instance of the Tech class.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @param {Object} [options={}]\n   *        An object with additional text track options\n   *\n   * @return {TextTrack}\n   *          The text track that was created.\n   */\n  function createTrackHelper(self, kind, label, language, options = {}) {\n    const tracks = self.textTracks();\n    options.kind = kind;\n    if (label) {\n      options.label = label;\n    }\n    if (language) {\n      options.language = language;\n    }\n    options.tech = self;\n    const track = new ALL.text.TrackClass(options);\n    tracks.addTrack(track);\n    return track;\n  }\n\n  /**\n   * This is the base class for media playback technology controllers, such as\n   * {@link HTML5}\n   *\n   * @extends Component\n   */\n  class Tech extends Component$1 {\n    /**\n    * Create an instance of this Tech.\n    *\n    * @param {Object} [options]\n    *        The key/value store of player options.\n    *\n    * @param {Component~ReadyCallback} [ready]\n    *        Callback function to call when the `HTML5` Tech is ready.\n    */\n    constructor(options = {}, ready = function () {}) {\n      // we don't want the tech to report user activity automatically.\n      // This is done manually in addControlsListeners\n      options.reportTouchActivity = false;\n      super(null, options, ready);\n      this.onDurationChange_ = e => this.onDurationChange(e);\n      this.trackProgress_ = e => this.trackProgress(e);\n      this.trackCurrentTime_ = e => this.trackCurrentTime(e);\n      this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e);\n      this.disposeSourceHandler_ = e => this.disposeSourceHandler(e);\n      this.queuedHanders_ = new Set();\n\n      // keep track of whether the current source has played at all to\n      // implement a very limited played()\n      this.hasStarted_ = false;\n      this.on('playing', function () {\n        this.hasStarted_ = true;\n      });\n      this.on('loadstart', function () {\n        this.hasStarted_ = false;\n      });\n      ALL.names.forEach(name => {\n        const props = ALL[name];\n        if (options && options[props.getterName]) {\n          this[props.privateName] = options[props.getterName];\n        }\n      });\n\n      // Manually track progress in cases where the browser/tech doesn't report it.\n      if (!this.featuresProgressEvents) {\n        this.manualProgressOn();\n      }\n\n      // Manually track timeupdates in cases where the browser/tech doesn't report it.\n      if (!this.featuresTimeupdateEvents) {\n        this.manualTimeUpdatesOn();\n      }\n      ['Text', 'Audio', 'Video'].forEach(track => {\n        if (options[`native${track}Tracks`] === false) {\n          this[`featuresNative${track}Tracks`] = false;\n        }\n      });\n      if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n        this.featuresNativeTextTracks = false;\n      } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n        this.featuresNativeTextTracks = true;\n      }\n      if (!this.featuresNativeTextTracks) {\n        this.emulateTextTracks();\n      }\n      this.preloadTextTracks = options.preloadTextTracks !== false;\n      this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n      this.initTrackListeners();\n\n      // Turn on component tap events only if not using native controls\n      if (!options.nativeControlsForTouch) {\n        this.emitTapEvents();\n      }\n      if (this.constructor) {\n        this.name_ = this.constructor.name || 'Unknown Tech';\n      }\n    }\n\n    /**\n     * A special function to trigger source set in a way that will allow player\n     * to re-trigger if the player or tech are not ready yet.\n     *\n     * @fires Tech#sourceset\n     * @param {string} src The source string at the time of the source changing.\n     */\n    triggerSourceset(src) {\n      if (!this.isReady_) {\n        // on initial ready we have to trigger source set\n        // 1ms after ready so that player can watch for it.\n        this.one('ready', () => this.setTimeout(() => this.triggerSourceset(src), 1));\n      }\n\n      /**\n       * Fired when the source is set on the tech causing the media element\n       * to reload.\n       *\n       * @see {@link Player#event:sourceset}\n       * @event Tech#sourceset\n       * @type {EventTarget~Event}\n       */\n      this.trigger({\n        src,\n        type: 'sourceset'\n      });\n    }\n\n    /* Fallbacks for unsupported event types\n    ================================================================================ */\n\n    /**\n     * Polyfill the `progress` event for browsers that don't support it natively.\n     *\n     * @see {@link Tech#trackProgress}\n     */\n    manualProgressOn() {\n      this.on('durationchange', this.onDurationChange_);\n      this.manualProgress = true;\n\n      // Trigger progress watching when a source begins loading\n      this.one('ready', this.trackProgress_);\n    }\n\n    /**\n     * Turn off the polyfill for `progress` events that was created in\n     * {@link Tech#manualProgressOn}\n     */\n    manualProgressOff() {\n      this.manualProgress = false;\n      this.stopTrackingProgress();\n      this.off('durationchange', this.onDurationChange_);\n    }\n\n    /**\n     * This is used to trigger a `progress` event when the buffered percent changes. It\n     * sets an interval function that will be called every 500 milliseconds to check if the\n     * buffer end percent has changed.\n     *\n     * > This function is called by {@link Tech#manualProgressOn}\n     *\n     * @param {EventTarget~Event} event\n     *        The `ready` event that caused this to run.\n     *\n     * @listens Tech#ready\n     * @fires Tech#progress\n     */\n    trackProgress(event) {\n      this.stopTrackingProgress();\n      this.progressInterval = this.setInterval(bind_(this, function () {\n        // Don't trigger unless buffered amount is greater than last time\n\n        const numBufferedPercent = this.bufferedPercent();\n        if (this.bufferedPercent_ !== numBufferedPercent) {\n          /**\n           * See {@link Player#progress}\n           *\n           * @event Tech#progress\n           * @type {EventTarget~Event}\n           */\n          this.trigger('progress');\n        }\n        this.bufferedPercent_ = numBufferedPercent;\n        if (numBufferedPercent === 1) {\n          this.stopTrackingProgress();\n        }\n      }), 500);\n    }\n\n    /**\n     * Update our internal duration on a `durationchange` event by calling\n     * {@link Tech#duration}.\n     *\n     * @param {EventTarget~Event} event\n     *        The `durationchange` event that caused this to run.\n     *\n     * @listens Tech#durationchange\n     */\n    onDurationChange(event) {\n      this.duration_ = this.duration();\n    }\n\n    /**\n     * Get and create a `TimeRange` object for buffering.\n     *\n     * @return {TimeRange}\n     *         The time range object that was created.\n     */\n    buffered() {\n      return createTimeRanges$1(0, 0);\n    }\n\n    /**\n     * Get the percentage of the current video that is currently buffered.\n     *\n     * @return {number}\n     *         A number from 0 to 1 that represents the decimal percentage of the\n     *         video that is buffered.\n     *\n     */\n    bufferedPercent() {\n      return bufferedPercent(this.buffered(), this.duration_);\n    }\n\n    /**\n     * Turn off the polyfill for `progress` events that was created in\n     * {@link Tech#manualProgressOn}\n     * Stop manually tracking progress events by clearing the interval that was set in\n     * {@link Tech#trackProgress}.\n     */\n    stopTrackingProgress() {\n      this.clearInterval(this.progressInterval);\n    }\n\n    /**\n     * Polyfill the `timeupdate` event for browsers that don't support it.\n     *\n     * @see {@link Tech#trackCurrentTime}\n     */\n    manualTimeUpdatesOn() {\n      this.manualTimeUpdates = true;\n      this.on('play', this.trackCurrentTime_);\n      this.on('pause', this.stopTrackingCurrentTime_);\n    }\n\n    /**\n     * Turn off the polyfill for `timeupdate` events that was created in\n     * {@link Tech#manualTimeUpdatesOn}\n     */\n    manualTimeUpdatesOff() {\n      this.manualTimeUpdates = false;\n      this.stopTrackingCurrentTime();\n      this.off('play', this.trackCurrentTime_);\n      this.off('pause', this.stopTrackingCurrentTime_);\n    }\n\n    /**\n     * Sets up an interval function to track current time and trigger `timeupdate` every\n     * 250 milliseconds.\n     *\n     * @listens Tech#play\n     * @triggers Tech#timeupdate\n     */\n    trackCurrentTime() {\n      if (this.currentTimeInterval) {\n        this.stopTrackingCurrentTime();\n      }\n      this.currentTimeInterval = this.setInterval(function () {\n        /**\n         * Triggered at an interval of 250ms to indicated that time is passing in the video.\n         *\n         * @event Tech#timeupdate\n         * @type {EventTarget~Event}\n         */\n        this.trigger({\n          type: 'timeupdate',\n          target: this,\n          manuallyTriggered: true\n        });\n\n        // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n      }, 250);\n    }\n\n    /**\n     * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n     * `timeupdate` event is no longer triggered.\n     *\n     * @listens {Tech#pause}\n     */\n    stopTrackingCurrentTime() {\n      this.clearInterval(this.currentTimeInterval);\n\n      // #1002 - if the video ends right before the next timeupdate would happen,\n      // the progress bar won't make it all the way to the end\n      this.trigger({\n        type: 'timeupdate',\n        target: this,\n        manuallyTriggered: true\n      });\n    }\n\n    /**\n     * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n     * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n     *\n     * @fires Component#dispose\n     */\n    dispose() {\n      // clear out all tracks because we can't reuse them between techs\n      this.clearTracks(NORMAL.names);\n\n      // Turn off any manual progress or timeupdate tracking\n      if (this.manualProgress) {\n        this.manualProgressOff();\n      }\n      if (this.manualTimeUpdates) {\n        this.manualTimeUpdatesOff();\n      }\n      super.dispose();\n    }\n\n    /**\n     * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n     *\n     * > Note: Techs without source handlers should call this between sources for `video`\n     *         & `audio` tracks. You don't want to use them between tracks!\n     *\n     * @param {string[]|string} types\n     *        TrackList names to clear, valid names are `video`, `audio`, and\n     *        `text`.\n     */\n    clearTracks(types) {\n      types = [].concat(types);\n      // clear out all tracks because we can't reuse them between techs\n      types.forEach(type => {\n        const list = this[`${type}Tracks`]() || [];\n        let i = list.length;\n        while (i--) {\n          const track = list[i];\n          if (type === 'text') {\n            this.removeRemoteTextTrack(track);\n          }\n          list.removeTrack(track);\n        }\n      });\n    }\n\n    /**\n     * Remove any TextTracks added via addRemoteTextTrack that are\n     * flagged for automatic garbage collection\n     */\n    cleanupAutoTextTracks() {\n      const list = this.autoRemoteTextTracks_ || [];\n      let i = list.length;\n      while (i--) {\n        const track = list[i];\n        this.removeRemoteTextTrack(track);\n      }\n    }\n\n    /**\n     * Reset the tech, which will removes all sources and reset the internal readyState.\n     *\n     * @abstract\n     */\n    reset() {}\n\n    /**\n     * Get the value of `crossOrigin` from the tech.\n     *\n     * @abstract\n     *\n     * @see {Html5#crossOrigin}\n     */\n    crossOrigin() {}\n\n    /**\n     * Set the value of `crossOrigin` on the tech.\n     *\n     * @abstract\n     *\n     * @param {string} crossOrigin the crossOrigin value\n     * @see {Html5#setCrossOrigin}\n     */\n    setCrossOrigin() {}\n\n    /**\n     * Get or set an error on the Tech.\n     *\n     * @param {MediaError} [err]\n     *        Error to set on the Tech\n     *\n     * @return {MediaError|null}\n     *         The current error object on the tech, or null if there isn't one.\n     */\n    error(err) {\n      if (err !== undefined) {\n        this.error_ = new MediaError(err);\n        this.trigger('error');\n      }\n      return this.error_;\n    }\n\n    /**\n     * Returns the `TimeRange`s that have been played through for the current source.\n     *\n     * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n     *         It only checks whether the source has played at all or not.\n     *\n     * @return {TimeRange}\n     *         - A single time range if this video has played\n     *         - An empty set of ranges if not.\n     */\n    played() {\n      if (this.hasStarted_) {\n        return createTimeRanges$1(0, 0);\n      }\n      return createTimeRanges$1();\n    }\n\n    /**\n     * Start playback\n     *\n     * @abstract\n     *\n     * @see {Html5#play}\n     */\n    play() {}\n\n    /**\n     * Set whether we are scrubbing or not\n     *\n     * @abstract\n     *\n     * @see {Html5#setScrubbing}\n     */\n    setScrubbing() {}\n\n    /**\n     * Get whether we are scrubbing or not\n     *\n     * @abstract\n     *\n     * @see {Html5#scrubbing}\n     */\n    scrubbing() {}\n\n    /**\n     * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n     * previously called.\n     *\n     * @fires Tech#timeupdate\n     */\n    setCurrentTime() {\n      // improve the accuracy of manual timeupdates\n      if (this.manualTimeUpdates) {\n        /**\n         * A manual `timeupdate` event.\n         *\n         * @event Tech#timeupdate\n         * @type {EventTarget~Event}\n         */\n        this.trigger({\n          type: 'timeupdate',\n          target: this,\n          manuallyTriggered: true\n        });\n      }\n    }\n\n    /**\n     * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n     * {@link TextTrackList} events.\n     *\n     * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n     *\n     * @fires Tech#audiotrackchange\n     * @fires Tech#videotrackchange\n     * @fires Tech#texttrackchange\n     */\n    initTrackListeners() {\n      /**\n        * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n        *\n        * @event Tech#audiotrackchange\n        * @type {EventTarget~Event}\n        */\n\n      /**\n        * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n        *\n        * @event Tech#videotrackchange\n        * @type {EventTarget~Event}\n        */\n\n      /**\n        * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n        *\n        * @event Tech#texttrackchange\n        * @type {EventTarget~Event}\n        */\n      NORMAL.names.forEach(name => {\n        const props = NORMAL[name];\n        const trackListChanges = () => {\n          this.trigger(`${name}trackchange`);\n        };\n        const tracks = this[props.getterName]();\n        tracks.addEventListener('removetrack', trackListChanges);\n        tracks.addEventListener('addtrack', trackListChanges);\n        this.on('dispose', () => {\n          tracks.removeEventListener('removetrack', trackListChanges);\n          tracks.removeEventListener('addtrack', trackListChanges);\n        });\n      });\n    }\n\n    /**\n     * Emulate TextTracks using vtt.js if necessary\n     *\n     * @fires Tech#vttjsloaded\n     * @fires Tech#vttjserror\n     */\n    addWebVttScript_() {\n      if (window.WebVTT) {\n        return;\n      }\n\n      // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n      // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n      // before inserting the WebVTT script\n      if (document.body.contains(this.el())) {\n        // load via require if available and vtt.js script location was not passed in\n        // as an option. novtt builds will turn the above require call into an empty object\n        // which will cause this if check to always fail.\n        if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {\n          this.trigger('vttjsloaded');\n          return;\n        }\n\n        // load vtt.js via the script location option or the cdn of no location was\n        // passed in\n        const script = document.createElement('script');\n        script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';\n        script.onload = () => {\n          /**\n           * Fired when vtt.js is loaded.\n           *\n           * @event Tech#vttjsloaded\n           * @type {EventTarget~Event}\n           */\n          this.trigger('vttjsloaded');\n        };\n        script.onerror = () => {\n          /**\n           * Fired when vtt.js was not loaded due to an error\n           *\n           * @event Tech#vttjsloaded\n           * @type {EventTarget~Event}\n           */\n          this.trigger('vttjserror');\n        };\n        this.on('dispose', () => {\n          script.onload = null;\n          script.onerror = null;\n        });\n        // but have not loaded yet and we set it to true before the inject so that\n        // we don't overwrite the injected window.WebVTT if it loads right away\n        window.WebVTT = true;\n        this.el().parentNode.appendChild(script);\n      } else {\n        this.ready(this.addWebVttScript_);\n      }\n    }\n\n    /**\n     * Emulate texttracks\n     *\n     */\n    emulateTextTracks() {\n      const tracks = this.textTracks();\n      const remoteTracks = this.remoteTextTracks();\n      const handleAddTrack = e => tracks.addTrack(e.track);\n      const handleRemoveTrack = e => tracks.removeTrack(e.track);\n      remoteTracks.on('addtrack', handleAddTrack);\n      remoteTracks.on('removetrack', handleRemoveTrack);\n      this.addWebVttScript_();\n      const updateDisplay = () => this.trigger('texttrackchange');\n      const textTracksChanges = () => {\n        updateDisplay();\n        for (let i = 0; i < tracks.length; i++) {\n          const track = tracks[i];\n          track.removeEventListener('cuechange', updateDisplay);\n          if (track.mode === 'showing') {\n            track.addEventListener('cuechange', updateDisplay);\n          }\n        }\n      };\n      textTracksChanges();\n      tracks.addEventListener('change', textTracksChanges);\n      tracks.addEventListener('addtrack', textTracksChanges);\n      tracks.addEventListener('removetrack', textTracksChanges);\n      this.on('dispose', function () {\n        remoteTracks.off('addtrack', handleAddTrack);\n        remoteTracks.off('removetrack', handleRemoveTrack);\n        tracks.removeEventListener('change', textTracksChanges);\n        tracks.removeEventListener('addtrack', textTracksChanges);\n        tracks.removeEventListener('removetrack', textTracksChanges);\n        for (let i = 0; i < tracks.length; i++) {\n          const track = tracks[i];\n          track.removeEventListener('cuechange', updateDisplay);\n        }\n      });\n    }\n\n    /**\n     * Create and returns a remote {@link TextTrack} object.\n     *\n     * @param {string} kind\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n     *\n     * @param {string} [label]\n     *        Label to identify the text track\n     *\n     * @param {string} [language]\n     *        Two letter language abbreviation\n     *\n     * @return {TextTrack}\n     *         The TextTrack that gets created.\n     */\n    addTextTrack(kind, label, language) {\n      if (!kind) {\n        throw new Error('TextTrack kind is required but was not provided');\n      }\n      return createTrackHelper(this, kind, label, language);\n    }\n\n    /**\n     * Create an emulated TextTrack for use by addRemoteTextTrack\n     *\n     * This is intended to be overridden by classes that inherit from\n     * Tech in order to create native or custom TextTracks.\n     *\n     * @param {Object} options\n     *        The object should contain the options to initialize the TextTrack with.\n     *\n     * @param {string} [options.kind]\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n     *\n     * @param {string} [options.label].\n     *        Label to identify the text track\n     *\n     * @param {string} [options.language]\n     *        Two letter language abbreviation.\n     *\n     * @return {HTMLTrackElement}\n     *         The track element that gets created.\n     */\n    createRemoteTextTrack(options) {\n      const track = merge$2(options, {\n        tech: this\n      });\n      return new REMOTE.remoteTextEl.TrackClass(track);\n    }\n\n    /**\n     * Creates a remote text track object and returns an html track element.\n     *\n     * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n     *\n     * @param {Object} options\n     *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n     *\n     * @param {boolean} [manualCleanup=false]\n     *        - When false: the TextTrack will be automatically removed from the video\n     *          element whenever the source changes\n     *        - When True: The TextTrack will have to be cleaned up manually\n     *\n     * @return {HTMLTrackElement}\n     *         An Html Track Element.\n     *\n     */\n    addRemoteTextTrack(options = {}, manualCleanup) {\n      const htmlTrackElement = this.createRemoteTextTrack(options);\n      if (typeof manualCleanup !== 'boolean') {\n        manualCleanup = false;\n      }\n\n      // store HTMLTrackElement and TextTrack to remote list\n      this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n      this.remoteTextTracks().addTrack(htmlTrackElement.track);\n      if (manualCleanup === false) {\n        // create the TextTrackList if it doesn't exist\n        this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));\n      }\n      return htmlTrackElement;\n    }\n\n    /**\n     * Remove a remote text track from the remote `TextTrackList`.\n     *\n     * @param {TextTrack} track\n     *        `TextTrack` to remove from the `TextTrackList`\n     */\n    removeRemoteTextTrack(track) {\n      const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\n\n      // remove HTMLTrackElement and TextTrack from remote list\n      this.remoteTextTrackEls().removeTrackElement_(trackElement);\n      this.remoteTextTracks().removeTrack(track);\n      this.autoRemoteTextTracks_.removeTrack(track);\n    }\n\n    /**\n     * Gets available media playback quality metrics as specified by the W3C's Media\n     * Playback Quality API.\n     *\n     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n     *\n     * @return {Object}\n     *         An object with supported media playback quality metrics\n     *\n     * @abstract\n     */\n    getVideoPlaybackQuality() {\n      return {};\n    }\n\n    /**\n     * Attempt to create a floating video window always on top of other windows\n     * so that users may continue consuming media while they interact with other\n     * content sites, or applications on their device.\n     *\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n     *\n     * @return {Promise|undefined}\n     *         A promise with a Picture-in-Picture window if the browser supports\n     *         Promises (or one was passed in as an option). It returns undefined\n     *         otherwise.\n     *\n     * @abstract\n     */\n    requestPictureInPicture() {\n      return Promise.reject();\n    }\n\n    /**\n     * A method to check for the value of the 'disablePictureInPicture' <video> property.\n     * Defaults to true, as it should be considered disabled if the tech does not support pip\n     *\n     * @abstract\n     */\n    disablePictureInPicture() {\n      return true;\n    }\n\n    /**\n     * A method to set or unset the 'disablePictureInPicture' <video> property.\n     *\n     * @abstract\n     */\n    setDisablePictureInPicture() {}\n\n    /**\n     * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame\n     *\n     * @param {function} cb\n     * @return {number} request id\n     */\n    requestVideoFrameCallback(cb) {\n      const id = newGUID();\n      if (!this.isReady_ || this.paused()) {\n        this.queuedHanders_.add(id);\n        this.one('playing', () => {\n          if (this.queuedHanders_.has(id)) {\n            this.queuedHanders_.delete(id);\n            cb();\n          }\n        });\n      } else {\n        this.requestNamedAnimationFrame(id, cb);\n      }\n      return id;\n    }\n\n    /**\n     * A fallback implementation of cancelVideoFrameCallback\n     *\n     * @param {number} id id of callback to be cancelled\n     */\n    cancelVideoFrameCallback(id) {\n      if (this.queuedHanders_.has(id)) {\n        this.queuedHanders_.delete(id);\n      } else {\n        this.cancelNamedAnimationFrame(id);\n      }\n    }\n\n    /**\n     * A method to set a poster from a `Tech`.\n     *\n     * @abstract\n     */\n    setPoster() {}\n\n    /**\n     * A method to check for the presence of the 'playsinline' <video> attribute.\n     *\n     * @abstract\n     */\n    playsinline() {}\n\n    /**\n     * A method to set or unset the 'playsinline' <video> attribute.\n     *\n     * @abstract\n     */\n    setPlaysinline() {}\n\n    /**\n     * Attempt to force override of native audio tracks.\n     *\n     * @param {boolean} override - If set to true native audio will be overridden,\n     * otherwise native audio will potentially be used.\n     *\n     * @abstract\n     */\n    overrideNativeAudioTracks() {}\n\n    /**\n     * Attempt to force override of native video tracks.\n     *\n     * @param {boolean} override - If set to true native video will be overridden,\n     * otherwise native video will potentially be used.\n     *\n     * @abstract\n     */\n    overrideNativeVideoTracks() {}\n\n    /*\n     * Check if the tech can support the given mime-type.\n     *\n     * The base tech does not support any type, but source handlers might\n     * overwrite this.\n     *\n     * @param  {string} type\n     *         The mimetype to check for support\n     *\n     * @return {string}\n     *         'probably', 'maybe', or empty string\n     *\n     * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n     *\n     * @abstract\n     */\n    canPlayType() {\n      return '';\n    }\n\n    /**\n     * Check if the type is supported by this tech.\n     *\n     * The base tech does not support any type, but source handlers might\n     * overwrite this.\n     *\n     * @param {string} type\n     *        The media type to check\n     * @return {string} Returns the native video element's response\n     */\n    static canPlayType() {\n      return '';\n    }\n\n    /**\n     * Check if the tech can support the given source\n     *\n     * @param {Object} srcObj\n     *        The source object\n     * @param {Object} options\n     *        The options passed to the tech\n     * @return {string} 'probably', 'maybe', or '' (empty string)\n     */\n    static canPlaySource(srcObj, options) {\n      return Tech.canPlayType(srcObj.type);\n    }\n\n    /*\n     * Return whether the argument is a Tech or not.\n     * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n     *\n     * @param {Object} component\n     *        The item to check\n     *\n     * @return {boolean}\n     *         Whether it is a tech or not\n     *         - True if it is a tech\n     *         - False if it is not\n     */\n    static isTech(component) {\n      return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n    }\n\n    /**\n     * Registers a `Tech` into a shared list for videojs.\n     *\n     * @param {string} name\n     *        Name of the `Tech` to register.\n     *\n     * @param {Object} tech\n     *        The `Tech` class to register.\n     */\n    static registerTech(name, tech) {\n      if (!Tech.techs_) {\n        Tech.techs_ = {};\n      }\n      if (!Tech.isTech(tech)) {\n        throw new Error(`Tech ${name} must be a Tech`);\n      }\n      if (!Tech.canPlayType) {\n        throw new Error('Techs must have a static canPlayType method on them');\n      }\n      if (!Tech.canPlaySource) {\n        throw new Error('Techs must have a static canPlaySource method on them');\n      }\n      name = toTitleCase$1(name);\n      Tech.techs_[name] = tech;\n      Tech.techs_[toLowerCase(name)] = tech;\n      if (name !== 'Tech') {\n        // camel case the techName for use in techOrder\n        Tech.defaultTechOrder_.push(name);\n      }\n      return tech;\n    }\n\n    /**\n     * Get a `Tech` from the shared list by name.\n     *\n     * @param {string} name\n     *        `camelCase` or `TitleCase` name of the Tech to get\n     *\n     * @return {Tech|undefined}\n     *         The `Tech` or undefined if there was no tech with the name requested.\n     */\n    static getTech(name) {\n      if (!name) {\n        return;\n      }\n      if (Tech.techs_ && Tech.techs_[name]) {\n        return Tech.techs_[name];\n      }\n      name = toTitleCase$1(name);\n      if (window && window.videojs && window.videojs[name]) {\n        log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);\n        return window.videojs[name];\n      }\n    }\n  }\n\n  /**\n   * Get the {@link VideoTrackList}\n   *\n   * @returns {VideoTrackList}\n   * @method Tech.prototype.videoTracks\n   */\n\n  /**\n   * Get the {@link AudioTrackList}\n   *\n   * @returns {AudioTrackList}\n   * @method Tech.prototype.audioTracks\n   */\n\n  /**\n   * Get the {@link TextTrackList}\n   *\n   * @returns {TextTrackList}\n   * @method Tech.prototype.textTracks\n   */\n\n  /**\n   * Get the remote element {@link TextTrackList}\n   *\n   * @returns {TextTrackList}\n   * @method Tech.prototype.remoteTextTracks\n   */\n\n  /**\n   * Get the remote element {@link HtmlTrackElementList}\n   *\n   * @returns {HtmlTrackElementList}\n   * @method Tech.prototype.remoteTextTrackEls\n   */\n\n  ALL.names.forEach(function (name) {\n    const props = ALL[name];\n    Tech.prototype[props.getterName] = function () {\n      this[props.privateName] = this[props.privateName] || new props.ListClass();\n      return this[props.privateName];\n    };\n  });\n\n  /**\n   * List of associated text tracks\n   *\n   * @type {TextTrackList}\n   * @private\n   * @property Tech#textTracks_\n   */\n\n  /**\n   * List of associated audio tracks.\n   *\n   * @type {AudioTrackList}\n   * @private\n   * @property Tech#audioTracks_\n   */\n\n  /**\n   * List of associated video tracks.\n   *\n   * @type {VideoTrackList}\n   * @private\n   * @property Tech#videoTracks_\n   */\n\n  /**\n   * Boolean indicating whether the `Tech` supports volume control.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresVolumeControl = true;\n\n  /**\n   * Boolean indicating whether the `Tech` supports muting volume.\n   *\n   * @type {bolean}\n   * @default\n   */\n  Tech.prototype.featuresMuteControl = true;\n\n  /**\n   * Boolean indicating whether the `Tech` supports fullscreen resize control.\n   * Resizing plugins using request fullscreen reloads the plugin\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresFullscreenResize = false;\n\n  /**\n   * Boolean indicating whether the `Tech` supports changing the speed at which the video\n   * plays. Examples:\n   *   - Set player to play 2x (twice) as fast\n   *   - Set player to play 0.5x (half) as fast\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresPlaybackRate = false;\n\n  /**\n   * Boolean indicating whether the `Tech` supports the `progress` event.\n   * This will be used to determine if {@link Tech#manualProgressOn} should be called.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresProgressEvents = false;\n\n  /**\n   * Boolean indicating whether the `Tech` supports the `sourceset` event.\n   *\n   * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\n   * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\n   * a new source.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresSourceset = false;\n\n  /**\n   * Boolean indicating whether the `Tech` supports the `timeupdate` event.\n   * This will be used to determine if {@link Tech#manualTimeUpdates} should be called.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresTimeupdateEvents = false;\n\n  /**\n   * Boolean indicating whether the `Tech` supports the native `TextTrack`s.\n   * This will help us integrate with native `TextTrack`s if the browser supports them.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresNativeTextTracks = false;\n\n  /**\n   * Boolean indicating whether the `Tech` supports `requestVideoFrameCallback`.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Tech.prototype.featuresVideoFrameCallback = false;\n\n  /**\n   * A functional mixin for techs that want to use the Source Handler pattern.\n   * Source handlers are scripts for handling specific formats.\n   * The source handler pattern is used for adaptive formats (HLS, DASH) that\n   * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n   * Example: `Tech.withSourceHandlers.call(MyTech);`\n   *\n   * @param {Tech} _Tech\n   *        The tech to add source handler functions to.\n   *\n   * @mixes Tech~SourceHandlerAdditions\n   */\n  Tech.withSourceHandlers = function (_Tech) {\n    /**\n     * Register a source handler\n     *\n     * @param {Function} handler\n     *        The source handler class\n     *\n     * @param {number} [index]\n     *        Register it at the following index\n     */\n    _Tech.registerSourceHandler = function (handler, index) {\n      let handlers = _Tech.sourceHandlers;\n      if (!handlers) {\n        handlers = _Tech.sourceHandlers = [];\n      }\n      if (index === undefined) {\n        // add to the end of the list\n        index = handlers.length;\n      }\n      handlers.splice(index, 0, handler);\n    };\n\n    /**\n     * Check if the tech can support the given type. Also checks the\n     * Techs sourceHandlers.\n     *\n     * @param {string} type\n     *         The mimetype to check.\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string)\n     */\n    _Tech.canPlayType = function (type) {\n      const handlers = _Tech.sourceHandlers || [];\n      let can;\n      for (let i = 0; i < handlers.length; i++) {\n        can = handlers[i].canPlayType(type);\n        if (can) {\n          return can;\n        }\n      }\n      return '';\n    };\n\n    /**\n     * Returns the first source handler that supports the source.\n     *\n     * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n     *\n     * @param {Tech~SourceObject} source\n     *        The source object\n     *\n     * @param {Object} options\n     *        The options passed to the tech\n     *\n     * @return {SourceHandler|null}\n     *          The first source handler that supports the source or null if\n     *          no SourceHandler supports the source\n     */\n    _Tech.selectSourceHandler = function (source, options) {\n      const handlers = _Tech.sourceHandlers || [];\n      let can;\n      for (let i = 0; i < handlers.length; i++) {\n        can = handlers[i].canHandleSource(source, options);\n        if (can) {\n          return handlers[i];\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Check if the tech can support the given source.\n     *\n     * @param {Tech~SourceObject} srcObj\n     *        The source object\n     *\n     * @param {Object} options\n     *        The options passed to the tech\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string)\n     */\n    _Tech.canPlaySource = function (srcObj, options) {\n      const sh = _Tech.selectSourceHandler(srcObj, options);\n      if (sh) {\n        return sh.canHandleSource(srcObj, options);\n      }\n      return '';\n    };\n\n    /**\n     * When using a source handler, prefer its implementation of\n     * any function normally provided by the tech.\n     */\n    const deferrable = ['seekable', 'seeking', 'duration'];\n\n    /**\n     * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n     * function if it exists, with a fallback to the Techs seekable function.\n     *\n     * @method _Tech.seekable\n     */\n\n    /**\n     * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n     * function if it exists, otherwise it will fallback to the techs duration function.\n     *\n     * @method _Tech.duration\n     */\n\n    deferrable.forEach(function (fnName) {\n      const originalFn = this[fnName];\n      if (typeof originalFn !== 'function') {\n        return;\n      }\n      this[fnName] = function () {\n        if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n          return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n        }\n        return originalFn.apply(this, arguments);\n      };\n    }, _Tech.prototype);\n\n    /**\n     * Create a function for setting the source using a source object\n     * and source handlers.\n     * Should never be called unless a source handler was found.\n     *\n     * @param {Tech~SourceObject} source\n     *        A source object with src and type keys\n     */\n    _Tech.prototype.setSource = function (source) {\n      let sh = _Tech.selectSourceHandler(source, this.options_);\n      if (!sh) {\n        // Fall back to a native source hander when unsupported sources are\n        // deliberately set\n        if (_Tech.nativeSourceHandler) {\n          sh = _Tech.nativeSourceHandler;\n        } else {\n          log$1.error('No source handler found for the current source.');\n        }\n      }\n\n      // Dispose any existing source handler\n      this.disposeSourceHandler();\n      this.off('dispose', this.disposeSourceHandler_);\n      if (sh !== _Tech.nativeSourceHandler) {\n        this.currentSource_ = source;\n      }\n      this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n      this.one('dispose', this.disposeSourceHandler_);\n    };\n\n    /**\n     * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n     *\n     * @listens Tech#dispose\n     */\n    _Tech.prototype.disposeSourceHandler = function () {\n      // if we have a source and get another one\n      // then we are loading something new\n      // than clear all of our current tracks\n      if (this.currentSource_) {\n        this.clearTracks(['audio', 'video']);\n        this.currentSource_ = null;\n      }\n\n      // always clean up auto-text tracks\n      this.cleanupAutoTextTracks();\n      if (this.sourceHandler_) {\n        if (this.sourceHandler_.dispose) {\n          this.sourceHandler_.dispose();\n        }\n        this.sourceHandler_ = null;\n      }\n    };\n  };\n\n  // The base Tech class needs to be registered as a Component. It is the only\n  // Tech that can be registered as a Component.\n  Component$1.registerComponent('Tech', Tech);\n  Tech.registerTech('Tech', Tech);\n\n  /**\n   * A list of techs that should be added to techOrder on Players\n   *\n   * @private\n   */\n  Tech.defaultTechOrder_ = [];\n\n  /**\n   * @file middleware.js\n   * @module middleware\n   */\n  const middlewares = {};\n  const middlewareInstances = {};\n  const TERMINATOR = {};\n\n  /**\n   * A middleware object is a plain JavaScript object that has methods that\n   * match the {@link Tech} methods found in the lists of allowed\n   * {@link module:middleware.allowedGetters|getters},\n   * {@link module:middleware.allowedSetters|setters}, and\n   * {@link module:middleware.allowedMediators|mediators}.\n   *\n   * @typedef {Object} MiddlewareObject\n   */\n\n  /**\n   * A middleware factory function that should return a\n   * {@link module:middleware~MiddlewareObject|MiddlewareObject}.\n   *\n   * This factory will be called for each player when needed, with the player\n   * passed in as an argument.\n   *\n   * @callback MiddlewareFactory\n   * @param {Player} player\n   *        A Video.js player.\n   */\n\n  /**\n   * Define a middleware that the player should use by way of a factory function\n   * that returns a middleware object.\n   *\n   * @param  {string} type\n   *         The MIME type to match or `\"*\"` for all MIME types.\n   *\n   * @param  {MiddlewareFactory} middleware\n   *         A middleware factory function that will be executed for\n   *         matching types.\n   */\n  function use(type, middleware) {\n    middlewares[type] = middlewares[type] || [];\n    middlewares[type].push(middleware);\n  }\n\n  /**\n   * Asynchronously sets a source using middleware by recursing through any\n   * matching middlewares and calling `setSource` on each, passing along the\n   * previous returned value each time.\n   *\n   * @param  {Player} player\n   *         A {@link Player} instance.\n   *\n   * @param  {Tech~SourceObject} src\n   *         A source object.\n   *\n   * @param  {Function}\n   *         The next middleware to run.\n   */\n  function setSource(player, src, next) {\n    player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);\n  }\n\n  /**\n   * When the tech is set, passes the tech to each middleware's `setTech` method.\n   *\n   * @param {Object[]} middleware\n   *        An array of middleware instances.\n   *\n   * @param {Tech} tech\n   *        A Video.js tech.\n   */\n  function setTech(middleware, tech) {\n    middleware.forEach(mw => mw.setTech && mw.setTech(tech));\n  }\n\n  /**\n   * Calls a getter on the tech first, through each middleware\n   * from right to left to the player.\n   *\n   * @param  {Object[]} middleware\n   *         An array of middleware instances.\n   *\n   * @param  {Tech} tech\n   *         The current tech.\n   *\n   * @param  {string} method\n   *         A method name.\n   *\n   * @return {Mixed}\n   *         The final value from the tech after middleware has intercepted it.\n   */\n  function get(middleware, tech, method) {\n    return middleware.reduceRight(middlewareIterator(method), tech[method]());\n  }\n\n  /**\n   * Takes the argument given to the player and calls the setter method on each\n   * middleware from left to right to the tech.\n   *\n   * @param  {Object[]} middleware\n   *         An array of middleware instances.\n   *\n   * @param  {Tech} tech\n   *         The current tech.\n   *\n   * @param  {string} method\n   *         A method name.\n   *\n   * @param  {Mixed} arg\n   *         The value to set on the tech.\n   *\n   * @return {Mixed}\n   *         The return value of the `method` of the `tech`.\n   */\n  function set(middleware, tech, method, arg) {\n    return tech[method](middleware.reduce(middlewareIterator(method), arg));\n  }\n\n  /**\n   * Takes the argument given to the player and calls the `call` version of the\n   * method on each middleware from left to right.\n   *\n   * Then, call the passed in method on the tech and return the result unchanged\n   * back to the player, through middleware, this time from right to left.\n   *\n   * @param  {Object[]} middleware\n   *         An array of middleware instances.\n   *\n   * @param  {Tech} tech\n   *         The current tech.\n   *\n   * @param  {string} method\n   *         A method name.\n   *\n   * @param  {Mixed} arg\n   *         The value to set on the tech.\n   *\n   * @return {Mixed}\n   *         The return value of the `method` of the `tech`, regardless of the\n   *         return values of middlewares.\n   */\n  function mediate(middleware, tech, method, arg = null) {\n    const callMethod = 'call' + toTitleCase$1(method);\n    const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\n    const terminated = middlewareValue === TERMINATOR;\n    // deprecated. The `null` return value should instead return TERMINATOR to\n    // prevent confusion if a techs method actually returns null.\n    const returnValue = terminated ? null : tech[method](middlewareValue);\n    executeRight(middleware, method, returnValue, terminated);\n    return returnValue;\n  }\n\n  /**\n   * Enumeration of allowed getters where the keys are method names.\n   *\n   * @type {Object}\n   */\n  const allowedGetters = {\n    buffered: 1,\n    currentTime: 1,\n    duration: 1,\n    muted: 1,\n    played: 1,\n    paused: 1,\n    seekable: 1,\n    volume: 1,\n    ended: 1\n  };\n\n  /**\n   * Enumeration of allowed setters where the keys are method names.\n   *\n   * @type {Object}\n   */\n  const allowedSetters = {\n    setCurrentTime: 1,\n    setMuted: 1,\n    setVolume: 1\n  };\n\n  /**\n   * Enumeration of allowed mediators where the keys are method names.\n   *\n   * @type {Object}\n   */\n  const allowedMediators = {\n    play: 1,\n    pause: 1\n  };\n  function middlewareIterator(method) {\n    return (value, mw) => {\n      // if the previous middleware terminated, pass along the termination\n      if (value === TERMINATOR) {\n        return TERMINATOR;\n      }\n      if (mw[method]) {\n        return mw[method](value);\n      }\n      return value;\n    };\n  }\n  function executeRight(mws, method, value, terminated) {\n    for (let i = mws.length - 1; i >= 0; i--) {\n      const mw = mws[i];\n      if (mw[method]) {\n        mw[method](terminated, value);\n      }\n    }\n  }\n\n  /**\n   * Clear the middleware cache for a player.\n   *\n   * @param  {Player} player\n   *         A {@link Player} instance.\n   */\n  function clearCacheForPlayer(player) {\n    middlewareInstances[player.id()] = null;\n  }\n\n  /**\n   * {\n   *  [playerId]: [[mwFactory, mwInstance], ...]\n   * }\n   *\n   * @private\n   */\n  function getOrCreateFactory(player, mwFactory) {\n    const mws = middlewareInstances[player.id()];\n    let mw = null;\n    if (mws === undefined || mws === null) {\n      mw = mwFactory(player);\n      middlewareInstances[player.id()] = [[mwFactory, mw]];\n      return mw;\n    }\n    for (let i = 0; i < mws.length; i++) {\n      const [mwf, mwi] = mws[i];\n      if (mwf !== mwFactory) {\n        continue;\n      }\n      mw = mwi;\n    }\n    if (mw === null) {\n      mw = mwFactory(player);\n      mws.push([mwFactory, mw]);\n    }\n    return mw;\n  }\n  function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {\n    const [mwFactory, ...mwrest] = middleware;\n\n    // if mwFactory is a string, then we're at a fork in the road\n    if (typeof mwFactory === 'string') {\n      setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);\n\n      // if we have an mwFactory, call it with the player to get the mw,\n      // then call the mw's setSource method\n    } else if (mwFactory) {\n      const mw = getOrCreateFactory(player, mwFactory);\n\n      // if setSource isn't present, implicitly select this middleware\n      if (!mw.setSource) {\n        acc.push(mw);\n        return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n      }\n      mw.setSource(Object.assign({}, src), function (err, _src) {\n        // something happened, try the next middleware on the current level\n        // make sure to use the old src\n        if (err) {\n          return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n        }\n\n        // we've succeeded, now we need to go deeper\n        acc.push(mw);\n\n        // if it's the same type, continue down the current chain\n        // otherwise, we want to go down the new chain\n        setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n      });\n    } else if (mwrest.length) {\n      setSourceHelper(src, mwrest, next, player, acc, lastRun);\n    } else if (lastRun) {\n      next(src, acc);\n    } else {\n      setSourceHelper(src, middlewares['*'], next, player, acc, true);\n    }\n  }\n\n  /**\n   * Mimetypes\n   *\n   * @see https://www.iana.org/assignments/media-types/media-types.xhtml\n   * @typedef Mimetypes~Kind\n   * @enum\n   */\n  const MimetypesKind = {\n    opus: 'video/ogg',\n    ogv: 'video/ogg',\n    mp4: 'video/mp4',\n    mov: 'video/mp4',\n    m4v: 'video/mp4',\n    mkv: 'video/x-matroska',\n    m4a: 'audio/mp4',\n    mp3: 'audio/mpeg',\n    aac: 'audio/aac',\n    caf: 'audio/x-caf',\n    flac: 'audio/flac',\n    oga: 'audio/ogg',\n    wav: 'audio/wav',\n    m3u8: 'application/x-mpegURL',\n    mpd: 'application/dash+xml',\n    jpg: 'image/jpeg',\n    jpeg: 'image/jpeg',\n    gif: 'image/gif',\n    png: 'image/png',\n    svg: 'image/svg+xml',\n    webp: 'image/webp'\n  };\n\n  /**\n   * Get the mimetype of a given src url if possible\n   *\n   * @param {string} src\n   *        The url to the src\n   *\n   * @return {string}\n   *         return the mimetype if it was known or empty string otherwise\n   */\n  const getMimetype = function (src = '') {\n    const ext = getFileExtension(src);\n    const mimetype = MimetypesKind[ext.toLowerCase()];\n    return mimetype || '';\n  };\n\n  /**\n   * Find the mime type of a given source string if possible. Uses the player\n   * source cache.\n   *\n   * @param {Player} player\n   *        The player object\n   *\n   * @param {string} src\n   *        The source string\n   *\n   * @return {string}\n   *         The type that was found\n   */\n  const findMimetype = (player, src) => {\n    if (!src) {\n      return '';\n    }\n\n    // 1. check for the type in the `source` cache\n    if (player.cache_.source.src === src && player.cache_.source.type) {\n      return player.cache_.source.type;\n    }\n\n    // 2. see if we have this source in our `currentSources` cache\n    const matchingSources = player.cache_.sources.filter(s => s.src === src);\n    if (matchingSources.length) {\n      return matchingSources[0].type;\n    }\n\n    // 3. look for the src url in source elements and use the type there\n    const sources = player.$$('source');\n    for (let i = 0; i < sources.length; i++) {\n      const s = sources[i];\n      if (s.type && s.src && s.src === src) {\n        return s.type;\n      }\n    }\n\n    // 4. finally fallback to our list of mime types based on src url extension\n    return getMimetype(src);\n  };\n\n  /**\n   * @module filter-source\n   */\n\n  /**\n   * Filter out single bad source objects or multiple source objects in an\n   * array. Also flattens nested source object arrays into a 1 dimensional\n   * array of source objects.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]} src\n   *        The src object to filter\n   *\n   * @return {Tech~SourceObject[]}\n   *         An array of sourceobjects containing only valid sources\n   *\n   * @private\n   */\n  const filterSource = function (src) {\n    // traverse array\n    if (Array.isArray(src)) {\n      let newsrc = [];\n      src.forEach(function (srcobj) {\n        srcobj = filterSource(srcobj);\n        if (Array.isArray(srcobj)) {\n          newsrc = newsrc.concat(srcobj);\n        } else if (isObject$1(srcobj)) {\n          newsrc.push(srcobj);\n        }\n      });\n      src = newsrc;\n    } else if (typeof src === 'string' && src.trim()) {\n      // convert string into object\n      src = [fixSource({\n        src\n      })];\n    } else if (isObject$1(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n      // src is already valid\n      src = [fixSource(src)];\n    } else {\n      // invalid source, turn it into an empty array\n      src = [];\n    }\n    return src;\n  };\n\n  /**\n   * Checks src mimetype, adding it when possible\n   *\n   * @param {Tech~SourceObject} src\n   *        The src object to check\n   * @return {Tech~SourceObject}\n   *        src Object with known type\n   */\n  function fixSource(src) {\n    if (!src.type) {\n      const mimetype = getMimetype(src.src);\n      if (mimetype) {\n        src.type = mimetype;\n      }\n    }\n    return src;\n  }\n\n  /**\n   * @file loader.js\n   */\n\n  /**\n   * The `MediaLoader` is the `Component` that decides which playback technology to load\n   * when a player is initialized.\n   *\n   * @extends Component\n   */\n  class MediaLoader extends Component$1 {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should attach to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        The function that is run when this component is ready.\n     */\n    constructor(player, options, ready) {\n      // MediaLoader has no element\n      const options_ = merge$2({\n        createEl: false\n      }, options);\n      super(player, options_, ready);\n\n      // If there are no sources when the player is initialized,\n      // load the first supported playback technology.\n\n      if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n        for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n          const techName = toTitleCase$1(j[i]);\n          let tech = Tech.getTech(techName);\n\n          // Support old behavior of techs being registered as components.\n          // Remove once that deprecated behavior is removed.\n          if (!techName) {\n            tech = Component$1.getComponent(techName);\n          }\n\n          // Check if the browser supports this technology\n          if (tech && tech.isSupported()) {\n            player.loadTech_(techName);\n            break;\n          }\n        }\n      } else {\n        // Loop through playback technologies (e.g. HTML5) and check for support.\n        // Then load the best source.\n        // A few assumptions here:\n        //   All playback technologies respect preload false.\n        player.src(options.playerOptions.sources);\n      }\n    }\n  }\n  Component$1.registerComponent('MediaLoader', MediaLoader);\n\n  /**\n   * @file clickable-component.js\n   */\n\n  /**\n   * Component which is clickable or keyboard actionable, but is not a\n   * native HTML button.\n   *\n   * @extends Component\n   */\n  class ClickableComponent extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param  {Player} player\n     *         The `Player` that this class should be attached to.\n     *\n     * @param  {Object} [options]\n     *         The key/value store of component options.\n     *\n     * @param  {function} [options.clickHandler]\n     *         The function to call when the button is clicked / activated\n     *\n     * @param  {string} [options.controlText]\n     *         The text to set on the button\n     *\n     * @param  {string} [options.className]\n     *         A class or space separated list of classes to add the component\n     *\n     */\n    constructor(player, options) {\n      super(player, options);\n      if (this.options_.controlText) {\n        this.controlText(this.options_.controlText);\n      }\n      this.handleMouseOver_ = e => this.handleMouseOver(e);\n      this.handleMouseOut_ = e => this.handleMouseOut(e);\n      this.handleClick_ = e => this.handleClick(e);\n      this.handleKeyDown_ = e => this.handleKeyDown(e);\n      this.emitTapEvents();\n      this.enable();\n    }\n\n    /**\n     * Create the `ClickableComponent`s DOM element.\n     *\n     * @param {string} [tag=div]\n     *        The element's node type.\n     *\n     * @param {Object} [props={}]\n     *        An object of properties that should be set on the element.\n     *\n     * @param {Object} [attributes={}]\n     *        An object of attributes that should be set on the element.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl(tag = 'div', props = {}, attributes = {}) {\n      props = Object.assign({\n        className: this.buildCSSClass(),\n        tabIndex: 0\n      }, props);\n      if (tag === 'button') {\n        log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);\n      }\n\n      // Add ARIA attributes for clickable element which is not a native HTML button\n      attributes = Object.assign({\n        role: 'button'\n      }, attributes);\n      this.tabIndex_ = props.tabIndex;\n      const el = createEl(tag, props, attributes);\n      el.appendChild(createEl('span', {\n        className: 'vjs-icon-placeholder'\n      }, {\n        'aria-hidden': true\n      }));\n      this.createControlTextEl(el);\n      return el;\n    }\n    dispose() {\n      // remove controlTextEl_ on dispose\n      this.controlTextEl_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Create a control text element on this `ClickableComponent`\n     *\n     * @param {Element} [el]\n     *        Parent element for the control text.\n     *\n     * @return {Element}\n     *         The control text element that gets created.\n     */\n    createControlTextEl(el) {\n      this.controlTextEl_ = createEl('span', {\n        className: 'vjs-control-text'\n      }, {\n        // let the screen reader user know that the text of the element may change\n        'aria-live': 'polite'\n      });\n      if (el) {\n        el.appendChild(this.controlTextEl_);\n      }\n      this.controlText(this.controlText_, el);\n      return this.controlTextEl_;\n    }\n\n    /**\n     * Get or set the localize text to use for the controls on the `ClickableComponent`.\n     *\n     * @param {string} [text]\n     *        Control text for element.\n     *\n     * @param {Element} [el=this.el()]\n     *        Element to set the title on.\n     *\n     * @return {string}\n     *         - The control text when getting\n     */\n    controlText(text, el = this.el()) {\n      if (text === undefined) {\n        return this.controlText_ || 'Need Text';\n      }\n      const localizedText = this.localize(text);\n\n      /** @protected */\n      this.controlText_ = text;\n      textContent(this.controlTextEl_, localizedText);\n      if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {\n        // Set title attribute if only an icon is shown\n        el.setAttribute('title', localizedText);\n      }\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-control vjs-button ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Enable this `ClickableComponent`\n     */\n    enable() {\n      if (!this.enabled_) {\n        this.enabled_ = true;\n        this.removeClass('vjs-disabled');\n        this.el_.setAttribute('aria-disabled', 'false');\n        if (typeof this.tabIndex_ !== 'undefined') {\n          this.el_.setAttribute('tabIndex', this.tabIndex_);\n        }\n        this.on(['tap', 'click'], this.handleClick_);\n        this.on('keydown', this.handleKeyDown_);\n      }\n    }\n\n    /**\n     * Disable this `ClickableComponent`\n     */\n    disable() {\n      this.enabled_ = false;\n      this.addClass('vjs-disabled');\n      this.el_.setAttribute('aria-disabled', 'true');\n      if (typeof this.tabIndex_ !== 'undefined') {\n        this.el_.removeAttribute('tabIndex');\n      }\n      this.off('mouseover', this.handleMouseOver_);\n      this.off('mouseout', this.handleMouseOut_);\n      this.off(['tap', 'click'], this.handleClick_);\n      this.off('keydown', this.handleKeyDown_);\n    }\n\n    /**\n     * Handles language change in ClickableComponent for the player in components\n     *\n     *\n     */\n    handleLanguagechange() {\n      this.controlText(this.controlText_);\n    }\n\n    /**\n     * Event handler that is called when a `ClickableComponent` receives a\n     * `click` or `tap` event.\n     *\n     * @param {EventTarget~Event} event\n     *        The `tap` or `click` event that caused this function to be called.\n     *\n     * @listens tap\n     * @listens click\n     * @abstract\n     */\n    handleClick(event) {\n      if (this.options_.clickHandler) {\n        this.options_.clickHandler.call(this, arguments);\n      }\n    }\n\n    /**\n     * Event handler that is called when a `ClickableComponent` receives a\n     * `keydown` event.\n     *\n     * By default, if the key is Space or Enter, it will trigger a `click` event.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Support Space or Enter key operation to fire a click event. Also,\n      // prevent the event from propagating through the DOM and triggering\n      // Player hotkeys.\n      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.trigger('click');\n      } else {\n        // Pass keypress handling up for unsupported keys\n        super.handleKeyDown(event);\n      }\n    }\n  }\n  Component$1.registerComponent('ClickableComponent', ClickableComponent);\n\n  /**\n   * @file poster-image.js\n   */\n\n  /**\n   * A `ClickableComponent` that handles showing the poster image for the player.\n   *\n   * @extends ClickableComponent\n   */\n  class PosterImage extends ClickableComponent {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should attach to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.update();\n      this.update_ = e => this.update(e);\n      player.on('posterchange', this.update_);\n    }\n\n    /**\n     * Clean up and dispose of the `PosterImage`.\n     */\n    dispose() {\n      this.player().off('posterchange', this.update_);\n      super.dispose();\n    }\n\n    /**\n     * Create the `PosterImage`s DOM element.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl() {\n      const el = createEl('picture', {\n        className: 'vjs-poster',\n        // Don't want poster to be tabbable.\n        tabIndex: -1\n      }, {}, createEl('img', {\n        loading: 'lazy',\n        crossOrigin: this.crossOrigin()\n      }, {\n        alt: ''\n      }));\n      return el;\n    }\n\n    /**\n     * Get or set the `PosterImage`'s crossOrigin option.\n     *\n     * @param {string|null} [value]\n     *        The value to set the crossOrigin to. If an argument is\n     *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.\n     *\n     * @return {string|null}\n     *         - The current crossOrigin value of the `Player` when getting.\n     *         - undefined when setting\n     */\n    crossOrigin(value) {\n      // `null` can be set to unset a value\n      if (typeof value === 'undefined') {\n        if (this.el_) {\n          // If the poster's element exists, give its value\n          return this.el_.querySelector('img').crossOrigin;\n        } else if (this.player_.tech_ && this.player_.tech_.isReady_) {\n          // If not but the tech is ready, query the tech\n          return this.player_.crossOrigin();\n        }\n        // Otherwise check options as the  poster is usually set before the state of crossorigin\n        // can be retrieved by the getter\n        return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;\n      }\n      if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {\n        this.player_.log.warn(`crossOrigin must be null,  \"anonymous\" or \"use-credentials\", given \"${value}\"`);\n        return;\n      }\n      this.el_.querySelector('img').crossOrigin = value;\n      return;\n    }\n\n    /**\n     * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n     *\n     * @listens Player#posterchange\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `Player#posterchange` event that triggered this function.\n     */\n    update(event) {\n      const url = this.player().poster();\n      this.setSrc(url);\n\n      // If there's no poster source we should display:none on this component\n      // so it's not still clickable or right-clickable\n      if (url) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    }\n\n    /**\n     * Set the source of the `PosterImage` depending on the display method.\n     *\n     * @param {string} url\n     *        The URL to the source for the `PosterImage`.\n     */\n    setSrc(url) {\n      this.el_.querySelector('img').src = url;\n    }\n\n    /**\n     * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n     * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n     *\n     * @listens tap\n     * @listens click\n     * @listens keydown\n     *\n     * @param {EventTarget~Event} event\n     +        The `click`, `tap` or `keydown` event that caused this function to be called.\n     */\n    handleClick(event) {\n      // We don't want a click to trigger playback when controls are disabled\n      if (!this.player_.controls()) {\n        return;\n      }\n      if (this.player_.tech(true)) {\n        this.player_.tech(true).focus();\n      }\n      if (this.player_.paused()) {\n        silencePromise(this.player_.play());\n      } else {\n        this.player_.pause();\n      }\n    }\n  }\n\n  /**\n   * Get or set the `PosterImage`'s crossorigin option. For the HTML5 player, this\n   * sets the `crossOrigin` property on the `<img>` tag to control the CORS\n   * behavior.\n   *\n   * @param {string|null} [value]\n   *        The value to set the `PosterImages`'s crossorigin to. If an argument is\n   *        given, must be one of `anonymous` or `use-credentials`.\n   *\n   * @return {string|null|undefined}\n   *         - The current crossorigin value of the `Player` when getting.\n   *         - undefined when setting\n   */\n  PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;\n  Component$1.registerComponent('PosterImage', PosterImage);\n\n  /**\n   * @file text-track-display.js\n   */\n  const darkGray = '#222';\n  const lightGray = '#ccc';\n  const fontMap = {\n    monospace: 'monospace',\n    sansSerif: 'sans-serif',\n    serif: 'serif',\n    monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n    monospaceSerif: '\"Courier New\", monospace',\n    proportionalSansSerif: 'sans-serif',\n    proportionalSerif: 'serif',\n    casual: '\"Comic Sans MS\", Impact, fantasy',\n    script: '\"Monotype Corsiva\", cursive',\n    smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n  };\n\n  /**\n   * Construct an rgba color from a given hex color code.\n   *\n   * @param {number} color\n   *        Hex number for color, like #f0e or #f604e2.\n   *\n   * @param {number} opacity\n   *        Value for opacity, 0.0 - 1.0.\n   *\n   * @return {string}\n   *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n   */\n  function constructColor(color, opacity) {\n    let hex;\n    if (color.length === 4) {\n      // color looks like \"#f0e\"\n      hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\n    } else if (color.length === 7) {\n      // color looks like \"#f604e2\"\n      hex = color.slice(1);\n    } else {\n      throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\n    }\n    return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\n  }\n\n  /**\n   * Try to update the style of a DOM element. Some style changes will throw an error,\n   * particularly in IE8. Those should be noops.\n   *\n   * @param {Element} el\n   *        The DOM element to be styled.\n   *\n   * @param {string} style\n   *        The CSS property on the element that should be styled.\n   *\n   * @param {string} rule\n   *        The style rule that should be applied to the property.\n   *\n   * @private\n   */\n  function tryUpdateStyle(el, style, rule) {\n    try {\n      el.style[style] = rule;\n    } catch (e) {\n      // Satisfies linter.\n      return;\n    }\n  }\n\n  /**\n   * The component for displaying text track cues.\n   *\n   * @extends Component\n   */\n  class TextTrackDisplay extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        The function to call when `TextTrackDisplay` is ready.\n     */\n    constructor(player, options, ready) {\n      super(player, options, ready);\n      const updateDisplayHandler = e => this.updateDisplay(e);\n      player.on('loadstart', e => this.toggleDisplay(e));\n      player.on('texttrackchange', updateDisplayHandler);\n      player.on('loadedmetadata', e => this.preselectTrack(e));\n\n      // This used to be called during player init, but was causing an error\n      // if a track should show by default and the display hadn't loaded yet.\n      // Should probably be moved to an external track loader when we support\n      // tracks that don't need a display.\n      player.ready(bind_(this, function () {\n        if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n          this.hide();\n          return;\n        }\n        player.on('fullscreenchange', updateDisplayHandler);\n        player.on('playerresize', updateDisplayHandler);\n        const screenOrientation = window.screen.orientation || window;\n        const changeOrientationEvent = window.screen.orientation ? 'change' : 'orientationchange';\n        screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);\n        player.on('dispose', () => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler));\n        const tracks = this.options_.playerOptions.tracks || [];\n        for (let i = 0; i < tracks.length; i++) {\n          this.player_.addRemoteTextTrack(tracks[i], true);\n        }\n        this.preselectTrack();\n      }));\n    }\n\n    /**\n    * Preselect a track following this precedence:\n    * - matches the previously selected {@link TextTrack}'s language and kind\n    * - matches the previously selected {@link TextTrack}'s language only\n    * - is the first default captions track\n    * - is the first default descriptions track\n    *\n    * @listens Player#loadstart\n    */\n    preselectTrack() {\n      const modes = {\n        captions: 1,\n        subtitles: 1\n      };\n      const trackList = this.player_.textTracks();\n      const userPref = this.player_.cache_.selectedLanguage;\n      let firstDesc;\n      let firstCaptions;\n      let preferredTrack;\n      for (let i = 0; i < trackList.length; i++) {\n        const track = trackList[i];\n        if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {\n          // Always choose the track that matches both language and kind\n          if (track.kind === userPref.kind) {\n            preferredTrack = track;\n            // or choose the first track that matches language\n          } else if (!preferredTrack) {\n            preferredTrack = track;\n          }\n\n          // clear everything if offTextTrackMenuItem was clicked\n        } else if (userPref && !userPref.enabled) {\n          preferredTrack = null;\n          firstDesc = null;\n          firstCaptions = null;\n        } else if (track.default) {\n          if (track.kind === 'descriptions' && !firstDesc) {\n            firstDesc = track;\n          } else if (track.kind in modes && !firstCaptions) {\n            firstCaptions = track;\n          }\n        }\n      }\n\n      // The preferredTrack matches the user preference and takes\n      // precedence over all the other tracks.\n      // So, display the preferredTrack before the first default track\n      // and the subtitles/captions track before the descriptions track\n      if (preferredTrack) {\n        preferredTrack.mode = 'showing';\n      } else if (firstCaptions) {\n        firstCaptions.mode = 'showing';\n      } else if (firstDesc) {\n        firstDesc.mode = 'showing';\n      }\n    }\n\n    /**\n     * Turn display of {@link TextTrack}'s from the current state into the other state.\n     * There are only two states:\n     * - 'shown'\n     * - 'hidden'\n     *\n     * @listens Player#loadstart\n     */\n    toggleDisplay() {\n      if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    /**\n     * Create the {@link Component}'s DOM element.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-text-track-display'\n      }, {\n        'translate': 'yes',\n        'aria-live': 'off',\n        'aria-atomic': 'true'\n      });\n    }\n\n    /**\n     * Clear all displayed {@link TextTrack}s.\n     */\n    clearDisplay() {\n      if (typeof window.WebVTT === 'function') {\n        window.WebVTT.processCues(window, [], this.el_);\n      }\n    }\n\n    /**\n     * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n     * a {@link Player#fullscreenchange} is fired.\n     *\n     * @listens Player#texttrackchange\n     * @listens Player#fullscreenchange\n     */\n    updateDisplay() {\n      const tracks = this.player_.textTracks();\n      const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;\n      this.clearDisplay();\n      if (allowMultipleShowingTracks) {\n        const showingTracks = [];\n        for (let i = 0; i < tracks.length; ++i) {\n          const track = tracks[i];\n          if (track.mode !== 'showing') {\n            continue;\n          }\n          showingTracks.push(track);\n        }\n        this.updateForTrack(showingTracks);\n        return;\n      }\n\n      //  Track display prioritization model: if multiple tracks are 'showing',\n      //  display the first 'subtitles' or 'captions' track which is 'showing',\n      //  otherwise display the first 'descriptions' track which is 'showing'\n\n      let descriptionsTrack = null;\n      let captionsSubtitlesTrack = null;\n      let i = tracks.length;\n      while (i--) {\n        const track = tracks[i];\n        if (track.mode === 'showing') {\n          if (track.kind === 'descriptions') {\n            descriptionsTrack = track;\n          } else {\n            captionsSubtitlesTrack = track;\n          }\n        }\n      }\n      if (captionsSubtitlesTrack) {\n        if (this.getAttribute('aria-live') !== 'off') {\n          this.setAttribute('aria-live', 'off');\n        }\n        this.updateForTrack(captionsSubtitlesTrack);\n      } else if (descriptionsTrack) {\n        if (this.getAttribute('aria-live') !== 'assertive') {\n          this.setAttribute('aria-live', 'assertive');\n        }\n        this.updateForTrack(descriptionsTrack);\n      }\n    }\n\n    /**\n     * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.\n     *\n     * @param {TextTrack} track\n     *        Text track object containing active cues to style.\n     */\n    updateDisplayState(track) {\n      const overrides = this.player_.textTrackSettings.getValues();\n      const cues = track.activeCues;\n      let i = cues.length;\n      while (i--) {\n        const cue = cues[i];\n        if (!cue) {\n          continue;\n        }\n        const cueDiv = cue.displayState;\n        if (overrides.color) {\n          cueDiv.firstChild.style.color = overrides.color;\n        }\n        if (overrides.textOpacity) {\n          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n        }\n        if (overrides.backgroundColor) {\n          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n        }\n        if (overrides.backgroundOpacity) {\n          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n        }\n        if (overrides.windowColor) {\n          if (overrides.windowOpacity) {\n            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n          } else {\n            cueDiv.style.backgroundColor = overrides.windowColor;\n          }\n        }\n        if (overrides.edgeStyle) {\n          if (overrides.edgeStyle === 'dropshadow') {\n            cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`;\n          } else if (overrides.edgeStyle === 'raised') {\n            cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`;\n          } else if (overrides.edgeStyle === 'depressed') {\n            cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`;\n          } else if (overrides.edgeStyle === 'uniform') {\n            cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;\n          }\n        }\n        if (overrides.fontPercent && overrides.fontPercent !== 1) {\n          const fontSize = window.parseFloat(cueDiv.style.fontSize);\n          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n          cueDiv.style.height = 'auto';\n          cueDiv.style.top = 'auto';\n        }\n        if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n          if (overrides.fontFamily === 'small-caps') {\n            cueDiv.firstChild.style.fontVariant = 'small-caps';\n          } else {\n            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n          }\n        }\n      }\n    }\n\n    /**\n     * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.\n     *\n     * @param {TextTrack|TextTrack[]} tracks\n     *        Text track object or text track array to be added to the list.\n     */\n    updateForTrack(tracks) {\n      if (!Array.isArray(tracks)) {\n        tracks = [tracks];\n      }\n      if (typeof window.WebVTT !== 'function' || tracks.every(track => {\n        return !track.activeCues;\n      })) {\n        return;\n      }\n      const cues = [];\n\n      // push all active track cues\n      for (let i = 0; i < tracks.length; ++i) {\n        const track = tracks[i];\n        for (let j = 0; j < track.activeCues.length; ++j) {\n          cues.push(track.activeCues[j]);\n        }\n      }\n\n      // removes all cues before it processes new ones\n      window.WebVTT.processCues(window, cues, this.el_);\n\n      // add unique class to each language text track & add settings styling if necessary\n      for (let i = 0; i < tracks.length; ++i) {\n        const track = tracks[i];\n        for (let j = 0; j < track.activeCues.length; ++j) {\n          const cueEl = track.activeCues[j].displayState;\n          addClass(cueEl, 'vjs-text-track-cue', 'vjs-text-track-cue-' + (track.language ? track.language : i));\n          if (track.language) {\n            setAttribute(cueEl, 'lang', track.language);\n          }\n        }\n        if (this.player_.textTrackSettings) {\n          this.updateDisplayState(track);\n        }\n      }\n    }\n  }\n  Component$1.registerComponent('TextTrackDisplay', TextTrackDisplay);\n\n  /**\n   * @file loading-spinner.js\n   */\n\n  /**\n   * A loading spinner for use during waiting/loading events.\n   *\n   * @extends Component\n   */\n  class LoadingSpinner extends Component$1 {\n    /**\n     * Create the `LoadingSpinner`s DOM element.\n     *\n     * @return {Element}\n     *         The dom element that gets created.\n     */\n    createEl() {\n      const isAudio = this.player_.isAudio();\n      const playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\n      const controlText = createEl('span', {\n        className: 'vjs-control-text',\n        textContent: this.localize('{1} is loading.', [playerType])\n      });\n      const el = super.createEl('div', {\n        className: 'vjs-loading-spinner',\n        dir: 'ltr'\n      });\n      el.appendChild(controlText);\n      return el;\n    }\n  }\n  Component$1.registerComponent('LoadingSpinner', LoadingSpinner);\n\n  /**\n   * @file button.js\n   */\n\n  /**\n   * Base class for all buttons.\n   *\n   * @extends ClickableComponent\n   */\n  class Button extends ClickableComponent {\n    /**\n     * Create the `Button`s DOM element.\n     *\n     * @param {string} [tag=\"button\"]\n     *        The element's node type. This argument is IGNORED: no matter what\n     *        is passed, it will always create a `button` element.\n     *\n     * @param {Object} [props={}]\n     *        An object of properties that should be set on the element.\n     *\n     * @param {Object} [attributes={}]\n     *        An object of attributes that should be set on the element.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl(tag, props = {}, attributes = {}) {\n      tag = 'button';\n      props = Object.assign({\n        className: this.buildCSSClass()\n      }, props);\n\n      // Add attributes for button element\n      attributes = Object.assign({\n        // Necessary since the default button type is \"submit\"\n        type: 'button'\n      }, attributes);\n      const el = createEl(tag, props, attributes);\n      el.appendChild(createEl('span', {\n        className: 'vjs-icon-placeholder'\n      }, {\n        'aria-hidden': true\n      }));\n      this.createControlTextEl(el);\n      return el;\n    }\n\n    /**\n     * Add a child `Component` inside of this `Button`.\n     *\n     * @param {string|Component} child\n     *        The name or instance of a child to add.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of options that will get passed to children of\n     *        the child.\n     *\n     * @return {Component}\n     *         The `Component` that gets added as a child. When using a string the\n     *         `Component` will get created by this process.\n     *\n     * @deprecated since version 5\n     */\n    addChild(child, options = {}) {\n      const className = this.constructor.name;\n      log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);\n\n      // Avoid the error message generated by ClickableComponent's addChild method\n      return Component$1.prototype.addChild.call(this, child, options);\n    }\n\n    /**\n     * Enable the `Button` element so that it can be activated or clicked. Use this with\n     * {@link Button#disable}.\n     */\n    enable() {\n      super.enable();\n      this.el_.removeAttribute('disabled');\n    }\n\n    /**\n     * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n     * {@link Button#enable}.\n     */\n    disable() {\n      super.disable();\n      this.el_.setAttribute('disabled', 'disabled');\n    }\n\n    /**\n     * This gets called when a `Button` has focus and `keydown` is triggered via a key\n     * press.\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to get called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Ignore Space or Enter key operation, which is handled by the browser for\n      // a button - though not for its super class, ClickableComponent. Also,\n      // prevent the event from propagating through the DOM and triggering Player\n      // hotkeys. We do not preventDefault here because we _want_ the browser to\n      // handle it.\n      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n        event.stopPropagation();\n        return;\n      }\n\n      // Pass keypress handling up for unsupported keys\n      super.handleKeyDown(event);\n    }\n  }\n  Component$1.registerComponent('Button', Button);\n\n  /**\n   * @file big-play-button.js\n   */\n\n  /**\n   * The initial play button that shows before the video has played. The hiding of the\n   * `BigPlayButton` get done via CSS and `Player` states.\n   *\n   * @extends Button\n   */\n  class BigPlayButton extends Button {\n    constructor(player, options) {\n      super(player, options);\n      this.mouseused_ = false;\n      this.on('mousedown', e => this.handleMouseDown(e));\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n     */\n    buildCSSClass() {\n      return 'vjs-big-play-button';\n    }\n\n    /**\n     * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n     * for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      const playPromise = this.player_.play();\n\n      // exit early if clicked via the mouse\n      if (this.mouseused_ && event.clientX && event.clientY) {\n        silencePromise(playPromise);\n        if (this.player_.tech(true)) {\n          this.player_.tech(true).focus();\n        }\n        return;\n      }\n      const cb = this.player_.getChild('controlBar');\n      const playToggle = cb && cb.getChild('playToggle');\n      if (!playToggle) {\n        this.player_.tech(true).focus();\n        return;\n      }\n      const playFocus = () => playToggle.focus();\n      if (isPromise(playPromise)) {\n        playPromise.then(playFocus, () => {});\n      } else {\n        this.setTimeout(playFocus, 1);\n      }\n    }\n    handleKeyDown(event) {\n      this.mouseused_ = false;\n      super.handleKeyDown(event);\n    }\n    handleMouseDown(event) {\n      this.mouseused_ = true;\n    }\n  }\n\n  /**\n   * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  BigPlayButton.prototype.controlText_ = 'Play Video';\n  Component$1.registerComponent('BigPlayButton', BigPlayButton);\n\n  /**\n   * @file close-button.js\n   */\n\n  /**\n   * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n   * it gets clicked.\n   *\n   * @extends Button\n   */\n  class CloseButton extends Button {\n    /**\n    * Creates an instance of the this class.\n    *\n    * @param  {Player} player\n    *         The `Player` that this class should be attached to.\n    *\n    * @param  {Object} [options]\n    *         The key/value store of player options.\n    */\n    constructor(player, options) {\n      super(player, options);\n      this.controlText(options && options.controlText || this.localize('Close'));\n    }\n\n    /**\n    * Builds the default DOM `className`.\n    *\n    * @return {string}\n    *         The DOM `className` for this object.\n    */\n    buildCSSClass() {\n      return `vjs-close-button ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * This gets called when a `CloseButton` gets clicked. See\n     * {@link ClickableComponent#handleClick} for more information on when\n     * this will be triggered\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     * @fires CloseButton#close\n     */\n    handleClick(event) {\n      /**\n       * Triggered when the a `CloseButton` is clicked.\n       *\n       * @event CloseButton#close\n       * @type {EventTarget~Event}\n       *\n       * @property {boolean} [bubbles=false]\n       *           set to false so that the close event does not\n       *           bubble up to parents if there is no listener\n       */\n      this.trigger({\n        type: 'close',\n        bubbles: false\n      });\n    }\n    /**\n     * Event handler that is called when a `CloseButton` receives a\n     * `keydown` event.\n     *\n     * By default, if the key is Esc, it will trigger a `click` event.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Esc button will trigger `click` event\n      if (keycode.isEventKey(event, 'Esc')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.trigger('click');\n      } else {\n        // Pass keypress handling up for unsupported keys\n        super.handleKeyDown(event);\n      }\n    }\n  }\n  Component$1.registerComponent('CloseButton', CloseButton);\n\n  /**\n   * @file play-toggle.js\n   */\n\n  /**\n   * Button to toggle between play and pause.\n   *\n   * @extends Button\n   */\n  class PlayToggle extends Button {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     */\n    constructor(player, options = {}) {\n      super(player, options);\n\n      // show or hide replay icon\n      options.replay = options.replay === undefined || options.replay;\n      this.on(player, 'play', e => this.handlePlay(e));\n      this.on(player, 'pause', e => this.handlePause(e));\n      if (options.replay) {\n        this.on(player, 'ended', e => this.handleEnded(e));\n      }\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-play-control ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * This gets called when an `PlayToggle` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      if (this.player_.paused()) {\n        silencePromise(this.player_.play());\n      } else {\n        this.player_.pause();\n      }\n    }\n\n    /**\n     * This gets called once after the video has ended and the user seeks so that\n     * we can change the replay button back to a play button.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#seeked\n     */\n    handleSeeked(event) {\n      this.removeClass('vjs-ended');\n      if (this.player_.paused()) {\n        this.handlePause(event);\n      } else {\n        this.handlePlay(event);\n      }\n    }\n\n    /**\n     * Add the vjs-playing class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#play\n     */\n    handlePlay(event) {\n      this.removeClass('vjs-ended', 'vjs-paused');\n      this.addClass('vjs-playing');\n      // change the button text to \"Pause\"\n      this.controlText('Pause');\n    }\n\n    /**\n     * Add the vjs-paused class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#pause\n     */\n    handlePause(event) {\n      this.removeClass('vjs-playing');\n      this.addClass('vjs-paused');\n      // change the button text to \"Play\"\n      this.controlText('Play');\n    }\n\n    /**\n     * Add the vjs-ended class to the element so it can change appearance\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#ended\n     */\n    handleEnded(event) {\n      this.removeClass('vjs-playing');\n      this.addClass('vjs-ended');\n      // change the button text to \"Replay\"\n      this.controlText('Replay');\n\n      // on the next seek remove the replay button\n      this.one(this.player_, 'seeked', e => this.handleSeeked(e));\n    }\n  }\n\n  /**\n   * The text that should display over the `PlayToggle`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  PlayToggle.prototype.controlText_ = 'Play';\n  Component$1.registerComponent('PlayToggle', PlayToggle);\n\n  /**\n   * @file time-display.js\n   */\n\n  /**\n   * Displays time information about the video\n   *\n   * @extends Component\n   */\n  class TimeDisplay extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.on(player, ['timeupdate', 'ended'], e => this.updateContent(e));\n      this.updateTextNode_();\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const className = this.buildCSSClass();\n      const el = super.createEl('div', {\n        className: `${className} vjs-time-control vjs-control`\n      });\n      const span = createEl('span', {\n        className: 'vjs-control-text',\n        textContent: `${this.localize(this.labelText_)}\\u00a0`\n      }, {\n        role: 'presentation'\n      });\n      el.appendChild(span);\n      this.contentEl_ = createEl('span', {\n        className: `${className}-display`\n      }, {\n        // tell screen readers not to automatically read the time as it changes\n        'aria-live': 'off',\n        // span elements have no implicit role, but some screen readers (notably VoiceOver)\n        // treat them as a break between items in the DOM when using arrow keys\n        // (or left-to-right swipes on iOS) to read contents of a page. Using\n        // role='presentation' causes VoiceOver to NOT treat this span as a break.\n        'role': 'presentation'\n      });\n      el.appendChild(this.contentEl_);\n      return el;\n    }\n    dispose() {\n      this.contentEl_ = null;\n      this.textNode_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Updates the time display text node with a new time\n     *\n     * @param {number} [time=0] the time to update to\n     *\n     * @private\n     */\n    updateTextNode_(time = 0) {\n      time = formatTime(time);\n      if (this.formattedTime_ === time) {\n        return;\n      }\n      this.formattedTime_ = time;\n      this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', () => {\n        if (!this.contentEl_) {\n          return;\n        }\n        let oldNode = this.textNode_;\n        if (oldNode && this.contentEl_.firstChild !== oldNode) {\n          oldNode = null;\n          log$1.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');\n        }\n        this.textNode_ = document.createTextNode(this.formattedTime_);\n        if (!this.textNode_) {\n          return;\n        }\n        if (oldNode) {\n          this.contentEl_.replaceChild(this.textNode_, oldNode);\n        } else {\n          this.contentEl_.appendChild(this.textNode_);\n        }\n      });\n    }\n\n    /**\n     * To be filled out in the child class, should update the displayed time\n     * in accordance with the fact that the current time has changed.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `timeupdate`  event that caused this to run.\n     *\n     * @listens Player#timeupdate\n     */\n    updateContent(event) {}\n  }\n\n  /**\n   * The text that is added to the `TimeDisplay` for screen reader users.\n   *\n   * @type {string}\n   * @private\n   */\n  TimeDisplay.prototype.labelText_ = 'Time';\n\n  /**\n   * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n   *\n   * @type {string}\n   * @protected\n   *\n   * @deprecated in v7; controlText_ is not used in non-active display Components\n   */\n  TimeDisplay.prototype.controlText_ = 'Time';\n  Component$1.registerComponent('TimeDisplay', TimeDisplay);\n\n  /**\n   * @file current-time-display.js\n   */\n\n  /**\n   * Displays the current time\n   *\n   * @extends Component\n   */\n  class CurrentTimeDisplay extends TimeDisplay {\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return 'vjs-current-time';\n    }\n\n    /**\n     * Update current time display\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `timeupdate` event that caused this function to run.\n     *\n     * @listens Player#timeupdate\n     */\n    updateContent(event) {\n      // Allows for smooth scrubbing, when player can't keep up.\n      let time;\n      if (this.player_.ended()) {\n        time = this.player_.duration();\n      } else {\n        time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n      }\n      this.updateTextNode_(time);\n    }\n  }\n\n  /**\n   * The text that is added to the `CurrentTimeDisplay` for screen reader users.\n   *\n   * @type {string}\n   * @private\n   */\n  CurrentTimeDisplay.prototype.labelText_ = 'Current Time';\n\n  /**\n   * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n   *\n   * @type {string}\n   * @protected\n   *\n   * @deprecated in v7; controlText_ is not used in non-active display Components\n   */\n  CurrentTimeDisplay.prototype.controlText_ = 'Current Time';\n  Component$1.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n\n  /**\n   * @file duration-display.js\n   */\n\n  /**\n   * Displays the duration\n   *\n   * @extends Component\n   */\n  class DurationDisplay extends TimeDisplay {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      const updateContent = e => this.updateContent(e);\n\n      // we do not want to/need to throttle duration changes,\n      // as they should always display the changed duration as\n      // it has changed\n      this.on(player, 'durationchange', updateContent);\n\n      // Listen to loadstart because the player duration is reset when a new media element is loaded,\n      // but the durationchange on the user agent will not fire.\n      // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n      this.on(player, 'loadstart', updateContent);\n\n      // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n      // listeners could have broken dependent applications/libraries. These\n      // can likely be removed for 7.0.\n      this.on(player, 'loadedmetadata', updateContent);\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return 'vjs-duration';\n    }\n\n    /**\n     * Update duration time display.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n     *        this function to be called.\n     *\n     * @listens Player#durationchange\n     * @listens Player#timeupdate\n     * @listens Player#loadedmetadata\n     */\n    updateContent(event) {\n      const duration = this.player_.duration();\n      this.updateTextNode_(duration);\n    }\n  }\n\n  /**\n   * The text that is added to the `DurationDisplay` for screen reader users.\n   *\n   * @type {string}\n   * @private\n   */\n  DurationDisplay.prototype.labelText_ = 'Duration';\n\n  /**\n   * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n   *\n   * @type {string}\n   * @protected\n   *\n   * @deprecated in v7; controlText_ is not used in non-active display Components\n   */\n  DurationDisplay.prototype.controlText_ = 'Duration';\n  Component$1.registerComponent('DurationDisplay', DurationDisplay);\n\n  /**\n   * @file time-divider.js\n   */\n\n  /**\n   * The separator between the current time and duration.\n   * Can be hidden if it's not needed in the design.\n   *\n   * @extends Component\n   */\n  class TimeDivider extends Component$1 {\n    /**\n     * Create the component's DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl('div', {\n        className: 'vjs-time-control vjs-time-divider'\n      }, {\n        // this element and its contents can be hidden from assistive techs since\n        // it is made extraneous by the announcement of the control text\n        // for the current time and duration displays\n        'aria-hidden': true\n      });\n      const div = super.createEl('div');\n      const span = super.createEl('span', {\n        textContent: '/'\n      });\n      div.appendChild(span);\n      el.appendChild(div);\n      return el;\n    }\n  }\n  Component$1.registerComponent('TimeDivider', TimeDivider);\n\n  /**\n   * @file remaining-time-display.js\n   */\n\n  /**\n   * Displays the time left in the video\n   *\n   * @extends Component\n   */\n  class RemainingTimeDisplay extends TimeDisplay {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.on(player, 'durationchange', e => this.updateContent(e));\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return 'vjs-remaining-time';\n    }\n\n    /**\n     * Create the `Component`'s DOM element with the \"minus\" characted prepend to the time\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl();\n      if (this.options_.displayNegative !== false) {\n        el.insertBefore(createEl('span', {}, {\n          'aria-hidden': true\n        }, '-'), this.contentEl_);\n      }\n      return el;\n    }\n\n    /**\n     * Update remaining time display.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `timeupdate` or `durationchange` event that caused this to run.\n     *\n     * @listens Player#timeupdate\n     * @listens Player#durationchange\n     */\n    updateContent(event) {\n      if (typeof this.player_.duration() !== 'number') {\n        return;\n      }\n      let time;\n\n      // @deprecated We should only use remainingTimeDisplay\n      // as of video.js 7\n      if (this.player_.ended()) {\n        time = 0;\n      } else if (this.player_.remainingTimeDisplay) {\n        time = this.player_.remainingTimeDisplay();\n      } else {\n        time = this.player_.remainingTime();\n      }\n      this.updateTextNode_(time);\n    }\n  }\n\n  /**\n   * The text that is added to the `RemainingTimeDisplay` for screen reader users.\n   *\n   * @type {string}\n   * @private\n   */\n  RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\n\n  /**\n   * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n   *\n   * @type {string}\n   * @protected\n   *\n   * @deprecated in v7; controlText_ is not used in non-active display Components\n   */\n  RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\n  Component$1.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n\n  /**\n   * @file live-display.js\n   */\n\n  // TODO - Future make it click to snap to live\n\n  /**\n   * Displays the live indicator when duration is Infinity.\n   *\n   * @extends Component\n   */\n  class LiveDisplay extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.updateShowing();\n      this.on(this.player(), 'durationchange', e => this.updateShowing(e));\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl('div', {\n        className: 'vjs-live-control vjs-control'\n      });\n      this.contentEl_ = createEl('div', {\n        className: 'vjs-live-display'\n      }, {\n        'aria-live': 'off'\n      });\n      this.contentEl_.appendChild(createEl('span', {\n        className: 'vjs-control-text',\n        textContent: `${this.localize('Stream Type')}\\u00a0`\n      }));\n      this.contentEl_.appendChild(document.createTextNode(this.localize('LIVE')));\n      el.appendChild(this.contentEl_);\n      return el;\n    }\n    dispose() {\n      this.contentEl_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n     * it accordingly\n     *\n     * @param {EventTarget~Event} [event]\n     *        The {@link Player#durationchange} event that caused this function to run.\n     *\n     * @listens Player#durationchange\n     */\n    updateShowing(event) {\n      if (this.player().duration() === Infinity) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    }\n  }\n  Component$1.registerComponent('LiveDisplay', LiveDisplay);\n\n  /**\n   * @file seek-to-live.js\n   */\n\n  /**\n   * Displays the live indicator when duration is Infinity.\n   *\n   * @extends Component\n   */\n  class SeekToLive extends Button {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.updateLiveEdgeStatus();\n      if (this.player_.liveTracker) {\n        this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e);\n        this.on(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\n      }\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl('button', {\n        className: 'vjs-seek-to-live-control vjs-control'\n      });\n      this.textEl_ = createEl('span', {\n        className: 'vjs-seek-to-live-text',\n        textContent: this.localize('LIVE')\n      }, {\n        'aria-hidden': 'true'\n      });\n      el.appendChild(this.textEl_);\n      return el;\n    }\n\n    /**\n     * Update the state of this button if we are at the live edge\n     * or not\n     */\n    updateLiveEdgeStatus() {\n      // default to live edge\n      if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {\n        this.setAttribute('aria-disabled', true);\n        this.addClass('vjs-at-live-edge');\n        this.controlText('Seek to live, currently playing live');\n      } else {\n        this.setAttribute('aria-disabled', false);\n        this.removeClass('vjs-at-live-edge');\n        this.controlText('Seek to live, currently behind live');\n      }\n    }\n\n    /**\n     * On click bring us as near to the live point as possible.\n     * This requires that we wait for the next `live-seekable-change`\n     * event which will happen every segment length seconds.\n     */\n    handleClick() {\n      this.player_.liveTracker.seekToLiveEdge();\n    }\n\n    /**\n     * Dispose of the element and stop tracking\n     */\n    dispose() {\n      if (this.player_.liveTracker) {\n        this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\n      }\n      this.textEl_ = null;\n      super.dispose();\n    }\n  }\n  /**\n   * The text that should display over the `SeekToLive`s control. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';\n  Component$1.registerComponent('SeekToLive', SeekToLive);\n\n  /**\n   * @file num.js\n   * @module num\n   */\n\n  /**\n   * Keep a number between a min and a max value\n   *\n   * @param {number} number\n   *        The number to clamp\n   *\n   * @param {number} min\n   *        The minimum value\n   * @param {number} max\n   *        The maximum value\n   *\n   * @return {number}\n   *         the clamped number\n   */\n  function clamp(number, min, max) {\n    number = Number(number);\n    return Math.min(max, Math.max(min, isNaN(number) ? min : number));\n  }\n\n  var Num = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    clamp: clamp\n  });\n\n  /**\n   * @file slider.js\n   */\n\n  /**\n   * The base functionality for a slider. Can be vertical or horizontal.\n   * For instance the volume bar or the seek bar on a video is a slider.\n   *\n   * @extends Component\n   */\n  class Slider extends Component$1 {\n    /**\n    * Create an instance of this class\n    *\n    * @param {Player} player\n    *        The `Player` that this class should be attached to.\n    *\n    * @param {Object} [options]\n    *        The key/value store of player options.\n    */\n    constructor(player, options) {\n      super(player, options);\n      this.handleMouseDown_ = e => this.handleMouseDown(e);\n      this.handleMouseUp_ = e => this.handleMouseUp(e);\n      this.handleKeyDown_ = e => this.handleKeyDown(e);\n      this.handleClick_ = e => this.handleClick(e);\n      this.handleMouseMove_ = e => this.handleMouseMove(e);\n      this.update_ = e => this.update(e);\n\n      // Set property names to bar to match with the child Slider class is looking for\n      this.bar = this.getChild(this.options_.barName);\n\n      // Set a horizontal or vertical class on the slider depending on the slider type\n      this.vertical(!!this.options_.vertical);\n      this.enable();\n    }\n\n    /**\n     * Are controls are currently enabled for this slider or not.\n     *\n     * @return {boolean}\n     *         true if controls are enabled, false otherwise\n     */\n    enabled() {\n      return this.enabled_;\n    }\n\n    /**\n     * Enable controls for this slider if they are disabled\n     */\n    enable() {\n      if (this.enabled()) {\n        return;\n      }\n      this.on('mousedown', this.handleMouseDown_);\n      this.on('touchstart', this.handleMouseDown_);\n      this.on('keydown', this.handleKeyDown_);\n      this.on('click', this.handleClick_);\n\n      // TODO: deprecated, controlsvisible does not seem to be fired\n      this.on(this.player_, 'controlsvisible', this.update);\n      if (this.playerEvent) {\n        this.on(this.player_, this.playerEvent, this.update);\n      }\n      this.removeClass('disabled');\n      this.setAttribute('tabindex', 0);\n      this.enabled_ = true;\n    }\n\n    /**\n     * Disable controls for this slider if they are enabled\n     */\n    disable() {\n      if (!this.enabled()) {\n        return;\n      }\n      const doc = this.bar.el_.ownerDocument;\n      this.off('mousedown', this.handleMouseDown_);\n      this.off('touchstart', this.handleMouseDown_);\n      this.off('keydown', this.handleKeyDown_);\n      this.off('click', this.handleClick_);\n      this.off(this.player_, 'controlsvisible', this.update_);\n      this.off(doc, 'mousemove', this.handleMouseMove_);\n      this.off(doc, 'mouseup', this.handleMouseUp_);\n      this.off(doc, 'touchmove', this.handleMouseMove_);\n      this.off(doc, 'touchend', this.handleMouseUp_);\n      this.removeAttribute('tabindex');\n      this.addClass('disabled');\n      if (this.playerEvent) {\n        this.off(this.player_, this.playerEvent, this.update);\n      }\n      this.enabled_ = false;\n    }\n\n    /**\n     * Create the `Slider`s DOM element.\n     *\n     * @param {string} type\n     *        Type of element to create.\n     *\n     * @param {Object} [props={}]\n     *        List of properties in Object form.\n     *\n     * @param {Object} [attributes={}]\n     *        list of attributes in Object form.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl(type, props = {}, attributes = {}) {\n      // Add the slider element class to all sub classes\n      props.className = props.className + ' vjs-slider';\n      props = Object.assign({\n        tabIndex: 0\n      }, props);\n      attributes = Object.assign({\n        'role': 'slider',\n        'aria-valuenow': 0,\n        'aria-valuemin': 0,\n        'aria-valuemax': 100\n      }, attributes);\n      return super.createEl(type, props, attributes);\n    }\n\n    /**\n     * Handle `mousedown` or `touchstart` events on the `Slider`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mousedown` or `touchstart` event that triggered this function\n     *\n     * @listens mousedown\n     * @listens touchstart\n     * @fires Slider#slideractive\n     */\n    handleMouseDown(event) {\n      const doc = this.bar.el_.ownerDocument;\n      if (event.type === 'mousedown') {\n        event.preventDefault();\n      }\n      // Do not call preventDefault() on touchstart in Chrome\n      // to avoid console warnings. Use a 'touch-action: none' style\n      // instead to prevent unintented scrolling.\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n      if (event.type === 'touchstart' && !IS_CHROME) {\n        event.preventDefault();\n      }\n      blockTextSelection();\n      this.addClass('vjs-sliding');\n      /**\n       * Triggered when the slider is in an active state\n       *\n       * @event Slider#slideractive\n       * @type {EventTarget~Event}\n       */\n      this.trigger('slideractive');\n      this.on(doc, 'mousemove', this.handleMouseMove_);\n      this.on(doc, 'mouseup', this.handleMouseUp_);\n      this.on(doc, 'touchmove', this.handleMouseMove_);\n      this.on(doc, 'touchend', this.handleMouseUp_);\n      this.handleMouseMove(event, true);\n    }\n\n    /**\n     * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n     * The `mousemove` and `touchmove` events will only only trigger this function during\n     * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n     * {@link Slider#handleMouseUp}.\n     *\n     * @param {EventTarget~Event} event\n     *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n     *        this function\n     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.\n     *\n     * @listens mousemove\n     * @listens touchmove\n     */\n    handleMouseMove(event) {}\n\n    /**\n     * Handle `mouseup` or `touchend` events on the `Slider`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mouseup` or `touchend` event that triggered this function.\n     *\n     * @listens touchend\n     * @listens mouseup\n     * @fires Slider#sliderinactive\n     */\n    handleMouseUp() {\n      const doc = this.bar.el_.ownerDocument;\n      unblockTextSelection();\n      this.removeClass('vjs-sliding');\n      /**\n       * Triggered when the slider is no longer in an active state.\n       *\n       * @event Slider#sliderinactive\n       * @type {EventTarget~Event}\n       */\n      this.trigger('sliderinactive');\n      this.off(doc, 'mousemove', this.handleMouseMove_);\n      this.off(doc, 'mouseup', this.handleMouseUp_);\n      this.off(doc, 'touchmove', this.handleMouseMove_);\n      this.off(doc, 'touchend', this.handleMouseUp_);\n      this.update();\n    }\n\n    /**\n     * Update the progress bar of the `Slider`.\n     *\n     * @return {number}\n     *          The percentage of progress the progress bar represents as a\n     *          number from 0 to 1.\n     */\n    update() {\n      // In VolumeBar init we have a setTimeout for update that pops and update\n      // to the end of the execution stack. The player is destroyed before then\n      // update will cause an error\n      // If there's no bar...\n      if (!this.el_ || !this.bar) {\n        return;\n      }\n\n      // clamp progress between 0 and 1\n      // and only round to four decimal places, as we round to two below\n      const progress = this.getProgress();\n      if (progress === this.progress_) {\n        return progress;\n      }\n      this.progress_ = progress;\n      this.requestNamedAnimationFrame('Slider#update', () => {\n        // Set the new bar width or height\n        const sizeKey = this.vertical() ? 'height' : 'width';\n\n        // Convert to a percentage for css value\n        this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';\n      });\n      return progress;\n    }\n\n    /**\n     * Get the percentage of the bar that should be filled\n     * but clamped and rounded.\n     *\n     * @return {number}\n     *         percentage filled that the slider is\n     */\n    getProgress() {\n      return Number(clamp(this.getPercent(), 0, 1).toFixed(4));\n    }\n\n    /**\n     * Calculate distance for slider\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to run.\n     *\n     * @return {number}\n     *         The current position of the Slider.\n     *         - position.x for vertical `Slider`s\n     *         - position.y for horizontal `Slider`s\n     */\n    calculateDistance(event) {\n      const position = getPointerPosition(this.el_, event);\n      if (this.vertical()) {\n        return position.y;\n      }\n      return position.x;\n    }\n\n    /**\n     * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n     * arrow keys. This function will only be called when the slider has focus. See\n     * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n     *\n     * @param {EventTarget~Event} event\n     *        the `keydown` event that caused this function to run.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Left and Down Arrows\n      if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.stepBack();\n\n        // Up and Right Arrows\n      } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.stepForward();\n      } else {\n        // Pass keydown handling up for unsupported keys\n        super.handleKeyDown(event);\n      }\n    }\n\n    /**\n     * Listener for click events on slider, used to prevent clicks\n     *   from bubbling up to parent elements like button menus.\n     *\n     * @param {Object} event\n     *        Event that caused this object to run\n     */\n    handleClick(event) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n\n    /**\n     * Get/set if slider is horizontal for vertical\n     *\n     * @param {boolean} [bool]\n     *        - true if slider is vertical,\n     *        - false is horizontal\n     *\n     * @return {boolean}\n     *         - true if slider is vertical, and getting\n     *         - false if the slider is horizontal, and getting\n     */\n    vertical(bool) {\n      if (bool === undefined) {\n        return this.vertical_ || false;\n      }\n      this.vertical_ = !!bool;\n      if (this.vertical_) {\n        this.addClass('vjs-slider-vertical');\n      } else {\n        this.addClass('vjs-slider-horizontal');\n      }\n    }\n  }\n  Component$1.registerComponent('Slider', Slider);\n\n  /**\n   * @file load-progress-bar.js\n   */\n\n  // get the percent width of a time compared to the total end\n  const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + '%';\n\n  /**\n   * Shows loading progress\n   *\n   * @extends Component\n   */\n  class LoadProgressBar extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.partEls_ = [];\n      this.on(player, 'progress', e => this.update(e));\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl('div', {\n        className: 'vjs-load-progress'\n      });\n      const wrapper = createEl('span', {\n        className: 'vjs-control-text'\n      });\n      const loadedText = createEl('span', {\n        textContent: this.localize('Loaded')\n      });\n      const separator = document.createTextNode(': ');\n      this.percentageEl_ = createEl('span', {\n        className: 'vjs-control-text-loaded-percentage',\n        textContent: '0%'\n      });\n      el.appendChild(wrapper);\n      wrapper.appendChild(loadedText);\n      wrapper.appendChild(separator);\n      wrapper.appendChild(this.percentageEl_);\n      return el;\n    }\n    dispose() {\n      this.partEls_ = null;\n      this.percentageEl_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Update progress bar\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `progress` event that caused this function to run.\n     *\n     * @listens Player#progress\n     */\n    update(event) {\n      this.requestNamedAnimationFrame('LoadProgressBar#update', () => {\n        const liveTracker = this.player_.liveTracker;\n        const buffered = this.player_.buffered();\n        const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();\n        const bufferedEnd = this.player_.bufferedEnd();\n        const children = this.partEls_;\n        const percent = percentify(bufferedEnd, duration);\n        if (this.percent_ !== percent) {\n          // update the width of the progress bar\n          this.el_.style.width = percent;\n          // update the control-text\n          textContent(this.percentageEl_, percent);\n          this.percent_ = percent;\n        }\n\n        // add child elements to represent the individual buffered time ranges\n        for (let i = 0; i < buffered.length; i++) {\n          const start = buffered.start(i);\n          const end = buffered.end(i);\n          let part = children[i];\n          if (!part) {\n            part = this.el_.appendChild(createEl());\n            children[i] = part;\n          }\n\n          //  only update if changed\n          if (part.dataset.start === start && part.dataset.end === end) {\n            continue;\n          }\n          part.dataset.start = start;\n          part.dataset.end = end;\n\n          // set the percent based on the width of the progress bar (bufferedEnd)\n          part.style.left = percentify(start, bufferedEnd);\n          part.style.width = percentify(end - start, bufferedEnd);\n        }\n\n        // remove unused buffered range elements\n        for (let i = children.length; i > buffered.length; i--) {\n          this.el_.removeChild(children[i - 1]);\n        }\n        children.length = buffered.length;\n      });\n    }\n  }\n  Component$1.registerComponent('LoadProgressBar', LoadProgressBar);\n\n  /**\n   * @file time-tooltip.js\n   */\n\n  /**\n   * Time tooltips display a time above the progress bar.\n   *\n   * @extends Component\n   */\n  class TimeTooltip extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The {@link Player} that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n    }\n\n    /**\n     * Create the time tooltip DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-time-tooltip'\n      }, {\n        'aria-hidden': 'true'\n      });\n    }\n\n    /**\n     * Updates the position of the time tooltip relative to the `SeekBar`.\n     *\n     * @param {Object} seekBarRect\n     *        The `ClientRect` for the {@link SeekBar} element.\n     *\n     * @param {number} seekBarPoint\n     *        A number from 0 to 1, representing a horizontal reference point\n     *        from the left edge of the {@link SeekBar}\n     */\n    update(seekBarRect, seekBarPoint, content) {\n      const tooltipRect = findPosition(this.el_);\n      const playerRect = getBoundingClientRect(this.player_.el());\n      const seekBarPointPx = seekBarRect.width * seekBarPoint;\n\n      // do nothing if either rect isn't available\n      // for example, if the player isn't in the DOM for testing\n      if (!playerRect || !tooltipRect) {\n        return;\n      }\n\n      // This is the space left of the `seekBarPoint` available within the bounds\n      // of the player. We calculate any gap between the left edge of the player\n      // and the left edge of the `SeekBar` and add the number of pixels in the\n      // `SeekBar` before hitting the `seekBarPoint`\n      const spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;\n\n      // This is the space right of the `seekBarPoint` available within the bounds\n      // of the player. We calculate the number of pixels from the `seekBarPoint`\n      // to the right edge of the `SeekBar` and add to that any gap between the\n      // right edge of the `SeekBar` and the player.\n      const spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);\n\n      // This is the number of pixels by which the tooltip will need to be pulled\n      // further to the right to center it over the `seekBarPoint`.\n      let pullTooltipBy = tooltipRect.width / 2;\n\n      // Adjust the `pullTooltipBy` distance to the left or right depending on\n      // the results of the space calculations above.\n      if (spaceLeftOfPoint < pullTooltipBy) {\n        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n      } else if (spaceRightOfPoint < pullTooltipBy) {\n        pullTooltipBy = spaceRightOfPoint;\n      }\n\n      // Due to the imprecision of decimal/ratio based calculations and varying\n      // rounding behaviors, there are cases where the spacing adjustment is off\n      // by a pixel or two. This adds insurance to these calculations.\n      if (pullTooltipBy < 0) {\n        pullTooltipBy = 0;\n      } else if (pullTooltipBy > tooltipRect.width) {\n        pullTooltipBy = tooltipRect.width;\n      }\n\n      // prevent small width fluctuations within 0.4px from\n      // changing the value below.\n      // This really helps for live to prevent the play\n      // progress time tooltip from jittering\n      pullTooltipBy = Math.round(pullTooltipBy);\n      this.el_.style.right = `-${pullTooltipBy}px`;\n      this.write(content);\n    }\n\n    /**\n     * Write the time to the tooltip DOM element.\n     *\n     * @param {string} content\n     *        The formatted time for the tooltip.\n     */\n    write(content) {\n      textContent(this.el_, content);\n    }\n\n    /**\n     * Updates the position of the time tooltip relative to the `SeekBar`.\n     *\n     * @param {Object} seekBarRect\n     *        The `ClientRect` for the {@link SeekBar} element.\n     *\n     * @param {number} seekBarPoint\n     *        A number from 0 to 1, representing a horizontal reference point\n     *        from the left edge of the {@link SeekBar}\n     *\n     * @param {number} time\n     *        The time to update the tooltip to, not used during live playback\n     *\n     * @param {Function} cb\n     *        A function that will be called during the request animation frame\n     *        for tooltips that need to do additional animations from the default\n     */\n    updateTime(seekBarRect, seekBarPoint, time, cb) {\n      this.requestNamedAnimationFrame('TimeTooltip#updateTime', () => {\n        let content;\n        const duration = this.player_.duration();\n        if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\n          const liveWindow = this.player_.liveTracker.liveWindow();\n          const secondsBehind = liveWindow - seekBarPoint * liveWindow;\n          content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);\n        } else {\n          content = formatTime(time, duration);\n        }\n        this.update(seekBarRect, seekBarPoint, content);\n        if (cb) {\n          cb();\n        }\n      });\n    }\n  }\n  Component$1.registerComponent('TimeTooltip', TimeTooltip);\n\n  /**\n   * @file play-progress-bar.js\n   */\n\n  /**\n   * Used by {@link SeekBar} to display media playback progress as part of the\n   * {@link ProgressControl}.\n   *\n   * @extends Component\n   */\n  class PlayProgressBar extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The {@link Player} that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n    }\n\n    /**\n     * Create the the DOM element for this class.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-play-progress vjs-slider-bar'\n      }, {\n        'aria-hidden': 'true'\n      });\n    }\n\n    /**\n     * Enqueues updates to its own DOM as well as the DOM of its\n     * {@link TimeTooltip} child.\n     *\n     * @param {Object} seekBarRect\n     *        The `ClientRect` for the {@link SeekBar} element.\n     *\n     * @param {number} seekBarPoint\n     *        A number from 0 to 1, representing a horizontal reference point\n     *        from the left edge of the {@link SeekBar}\n     */\n    update(seekBarRect, seekBarPoint) {\n      const timeTooltip = this.getChild('timeTooltip');\n      if (!timeTooltip) {\n        return;\n      }\n      const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n      timeTooltip.updateTime(seekBarRect, seekBarPoint, time);\n    }\n  }\n\n  /**\n   * Default options for {@link PlayProgressBar}.\n   *\n   * @type {Object}\n   * @private\n   */\n  PlayProgressBar.prototype.options_ = {\n    children: []\n  };\n\n  // Time tooltips should not be added to a player on mobile devices\n  if (!IS_IOS && !IS_ANDROID) {\n    PlayProgressBar.prototype.options_.children.push('timeTooltip');\n  }\n  Component$1.registerComponent('PlayProgressBar', PlayProgressBar);\n\n  /**\n   * @file mouse-time-display.js\n   */\n\n  /**\n   * The {@link MouseTimeDisplay} component tracks mouse movement over the\n   * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n   * indicating the time which is represented by a given point in the\n   * {@link ProgressControl}.\n   *\n   * @extends Component\n   */\n  class MouseTimeDisplay extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The {@link Player} that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n    }\n\n    /**\n     * Create the DOM element for this class.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-mouse-display'\n      });\n    }\n\n    /**\n     * Enqueues updates to its own DOM as well as the DOM of its\n     * {@link TimeTooltip} child.\n     *\n     * @param {Object} seekBarRect\n     *        The `ClientRect` for the {@link SeekBar} element.\n     *\n     * @param {number} seekBarPoint\n     *        A number from 0 to 1, representing a horizontal reference point\n     *        from the left edge of the {@link SeekBar}\n     */\n    update(seekBarRect, seekBarPoint) {\n      const time = seekBarPoint * this.player_.duration();\n      this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, () => {\n        this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;\n      });\n    }\n  }\n\n  /**\n   * Default options for `MouseTimeDisplay`\n   *\n   * @type {Object}\n   * @private\n   */\n  MouseTimeDisplay.prototype.options_ = {\n    children: ['timeTooltip']\n  };\n  Component$1.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\n\n  /**\n   * @file seek-bar.js\n   */\n\n  // The number of seconds the `step*` functions move the timeline.\n  const STEP_SECONDS = 5;\n\n  // The multiplier of STEP_SECONDS that PgUp/PgDown move the timeline.\n  const PAGE_KEY_MULTIPLIER = 12;\n\n  /**\n   * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n   * as its `bar`.\n   *\n   * @extends Slider\n   */\n  class SeekBar extends Slider {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.setEventHandlers_();\n    }\n\n    /**\n     * Sets the event handlers\n     *\n     * @private\n     */\n    setEventHandlers_() {\n      this.update_ = bind_(this, this.update);\n      this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);\n      this.on(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n      if (this.player_.liveTracker) {\n        this.on(this.player_.liveTracker, 'liveedgechange', this.update);\n      }\n\n      // when playing, let's ensure we smoothly update the play progress bar\n      // via an interval\n      this.updateInterval = null;\n      this.enableIntervalHandler_ = e => this.enableInterval_(e);\n      this.disableIntervalHandler_ = e => this.disableInterval_(e);\n      this.on(this.player_, ['playing'], this.enableIntervalHandler_);\n      this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);\n\n      // we don't need to update the play progress if the document is hidden,\n      // also, this causes the CPU to spike and eventually crash the page on IE11.\n      if ('hidden' in document && 'visibilityState' in document) {\n        this.on(document, 'visibilitychange', this.toggleVisibility_);\n      }\n    }\n    toggleVisibility_(e) {\n      if (document.visibilityState === 'hidden') {\n        this.cancelNamedAnimationFrame('SeekBar#update');\n        this.cancelNamedAnimationFrame('Slider#update');\n        this.disableInterval_(e);\n      } else {\n        if (!this.player_.ended() && !this.player_.paused()) {\n          this.enableInterval_();\n        }\n\n        // we just switched back to the page and someone may be looking, so, update ASAP\n        this.update();\n      }\n    }\n    enableInterval_() {\n      if (this.updateInterval) {\n        return;\n      }\n      this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);\n    }\n    disableInterval_(e) {\n      if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {\n        return;\n      }\n      if (!this.updateInterval) {\n        return;\n      }\n      this.clearInterval(this.updateInterval);\n      this.updateInterval = null;\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-progress-holder'\n      }, {\n        'aria-label': this.localize('Progress Bar')\n      });\n    }\n\n    /**\n     * This function updates the play progress bar and accessibility\n     * attributes to whatever is passed in.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `timeupdate` or `ended` event that caused this to run.\n     *\n     * @listens Player#timeupdate\n     *\n     * @return {number}\n     *          The current percent at a number from 0-1\n     */\n    update(event) {\n      // ignore updates while the tab is hidden\n      if (document.visibilityState === 'hidden') {\n        return;\n      }\n      const percent = super.update();\n      this.requestNamedAnimationFrame('SeekBar#update', () => {\n        const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();\n        const liveTracker = this.player_.liveTracker;\n        let duration = this.player_.duration();\n        if (liveTracker && liveTracker.isLive()) {\n          duration = this.player_.liveTracker.liveCurrentTime();\n        }\n        if (this.percent_ !== percent) {\n          // machine readable value of progress bar (percentage complete)\n          this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n          this.percent_ = percent;\n        }\n        if (this.currentTime_ !== currentTime || this.duration_ !== duration) {\n          // human readable value of progress bar (time complete)\n          this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n          this.currentTime_ = currentTime;\n          this.duration_ = duration;\n        }\n\n        // update the progress bar time tooltip with the current time\n        if (this.bar) {\n          this.bar.update(getBoundingClientRect(this.el()), this.getProgress());\n        }\n      });\n      return percent;\n    }\n\n    /**\n     * Prevent liveThreshold from causing seeks to seem like they\n     * are not happening from a user perspective.\n     *\n     * @param {number} ct\n     *        current time to seek to\n     */\n    userSeek_(ct) {\n      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\n        this.player_.liveTracker.nextSeekedFromUser();\n      }\n      this.player_.currentTime(ct);\n    }\n\n    /**\n     * Get the value of current time but allows for smooth scrubbing,\n     * when player can't keep up.\n     *\n     * @return {number}\n     *         The current time value to display\n     *\n     * @private\n     */\n    getCurrentTime_() {\n      return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n    }\n\n    /**\n     * Get the percentage of media played so far.\n     *\n     * @return {number}\n     *         The percentage of media played so far (0 to 1).\n     */\n    getPercent() {\n      const currentTime = this.getCurrentTime_();\n      let percent;\n      const liveTracker = this.player_.liveTracker;\n      if (liveTracker && liveTracker.isLive()) {\n        percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();\n\n        // prevent the percent from changing at the live edge\n        if (liveTracker.atLiveEdge()) {\n          percent = 1;\n        }\n      } else {\n        percent = currentTime / this.player_.duration();\n      }\n      return percent;\n    }\n\n    /**\n     * Handle mouse down on seek bar\n     *\n     * @param {EventTarget~Event} event\n     *        The `mousedown` event that caused this to run.\n     *\n     * @listens mousedown\n     */\n    handleMouseDown(event) {\n      if (!isSingleLeftClick(event)) {\n        return;\n      }\n\n      // Stop event propagation to prevent double fire in progress-control.js\n      event.stopPropagation();\n      this.videoWasPlaying = !this.player_.paused();\n      this.player_.pause();\n      super.handleMouseDown(event);\n    }\n\n    /**\n     * Handle mouse move on seek bar\n     *\n     * @param {EventTarget~Event} event\n     *        The `mousemove` event that caused this to run.\n     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false\n     *\n     * @listens mousemove\n     */\n    handleMouseMove(event, mouseDown = false) {\n      if (!isSingleLeftClick(event)) {\n        return;\n      }\n      if (!mouseDown && !this.player_.scrubbing()) {\n        this.player_.scrubbing(true);\n      }\n      let newTime;\n      const distance = this.calculateDistance(event);\n      const liveTracker = this.player_.liveTracker;\n      if (!liveTracker || !liveTracker.isLive()) {\n        newTime = distance * this.player_.duration();\n\n        // Don't let video end while scrubbing.\n        if (newTime === this.player_.duration()) {\n          newTime = newTime - 0.1;\n        }\n      } else {\n        if (distance >= 0.99) {\n          liveTracker.seekToLiveEdge();\n          return;\n        }\n        const seekableStart = liveTracker.seekableStart();\n        const seekableEnd = liveTracker.liveCurrentTime();\n        newTime = seekableStart + distance * liveTracker.liveWindow();\n\n        // Don't let video end while scrubbing.\n        if (newTime >= seekableEnd) {\n          newTime = seekableEnd;\n        }\n\n        // Compensate for precision differences so that currentTime is not less\n        // than seekable start\n        if (newTime <= seekableStart) {\n          newTime = seekableStart + 0.1;\n        }\n\n        // On android seekableEnd can be Infinity sometimes,\n        // this will cause newTime to be Infinity, which is\n        // not a valid currentTime.\n        if (newTime === Infinity) {\n          return;\n        }\n      }\n\n      // Set new time (tell player to seek to new time)\n      this.userSeek_(newTime);\n    }\n    enable() {\n      super.enable();\n      const mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n      if (!mouseTimeDisplay) {\n        return;\n      }\n      mouseTimeDisplay.show();\n    }\n    disable() {\n      super.disable();\n      const mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n      if (!mouseTimeDisplay) {\n        return;\n      }\n      mouseTimeDisplay.hide();\n    }\n\n    /**\n     * Handle mouse up on seek bar\n     *\n     * @param {EventTarget~Event} event\n     *        The `mouseup` event that caused this to run.\n     *\n     * @listens mouseup\n     */\n    handleMouseUp(event) {\n      super.handleMouseUp(event);\n\n      // Stop event propagation to prevent double fire in progress-control.js\n      if (event) {\n        event.stopPropagation();\n      }\n      this.player_.scrubbing(false);\n\n      /**\n       * Trigger timeupdate because we're done seeking and the time has changed.\n       * This is particularly useful for if the player is paused to time the time displays.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.player_.trigger({\n        type: 'timeupdate',\n        target: this,\n        manuallyTriggered: true\n      });\n      if (this.videoWasPlaying) {\n        silencePromise(this.player_.play());\n      } else {\n        // We're done seeking and the time has changed.\n        // If the player is paused, make sure we display the correct time on the seek bar.\n        this.update_();\n      }\n    }\n\n    /**\n     * Move more quickly fast forward for keyboard-only users\n     */\n    stepForward() {\n      this.userSeek_(this.player_.currentTime() + STEP_SECONDS);\n    }\n\n    /**\n     * Move more quickly rewind for keyboard-only users\n     */\n    stepBack() {\n      this.userSeek_(this.player_.currentTime() - STEP_SECONDS);\n    }\n\n    /**\n     * Toggles the playback state of the player\n     * This gets called when enter or space is used on the seekbar\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called\n     *\n     */\n    handleAction(event) {\n      if (this.player_.paused()) {\n        this.player_.play();\n      } else {\n        this.player_.pause();\n      }\n    }\n\n    /**\n     * Called when this SeekBar has focus and a key gets pressed down.\n     * Supports the following keys:\n     *\n     *   Space or Enter key fire a click event\n     *   Home key moves to start of the timeline\n     *   End key moves to end of the timeline\n     *   Digit \"0\" through \"9\" keys move to 0%, 10% ... 80%, 90% of the timeline\n     *   PageDown key moves back a larger step than ArrowDown\n     *   PageUp key moves forward a large step\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      const liveTracker = this.player_.liveTracker;\n      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.handleAction(event);\n      } else if (keycode.isEventKey(event, 'Home')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.userSeek_(0);\n      } else if (keycode.isEventKey(event, 'End')) {\n        event.preventDefault();\n        event.stopPropagation();\n        if (liveTracker && liveTracker.isLive()) {\n          this.userSeek_(liveTracker.liveCurrentTime());\n        } else {\n          this.userSeek_(this.player_.duration());\n        }\n      } else if (/^[0-9]$/.test(keycode(event))) {\n        event.preventDefault();\n        event.stopPropagation();\n        const gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10.0 / 100.0;\n        if (liveTracker && liveTracker.isLive()) {\n          this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);\n        } else {\n          this.userSeek_(this.player_.duration() * gotoFraction);\n        }\n      } else if (keycode.isEventKey(event, 'PgDn')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n      } else if (keycode.isEventKey(event, 'PgUp')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n      } else {\n        // Pass keydown handling up for unsupported keys\n        super.handleKeyDown(event);\n      }\n    }\n    dispose() {\n      this.disableInterval_();\n      this.off(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n      if (this.player_.liveTracker) {\n        this.off(this.player_.liveTracker, 'liveedgechange', this.update);\n      }\n      this.off(this.player_, ['playing'], this.enableIntervalHandler_);\n      this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);\n\n      // we don't need to update the play progress if the document is hidden,\n      // also, this causes the CPU to spike and eventually crash the page on IE11.\n      if ('hidden' in document && 'visibilityState' in document) {\n        this.off(document, 'visibilitychange', this.toggleVisibility_);\n      }\n      super.dispose();\n    }\n  }\n\n  /**\n   * Default options for the `SeekBar`\n   *\n   * @type {Object}\n   * @private\n   */\n  SeekBar.prototype.options_ = {\n    children: ['loadProgressBar', 'playProgressBar'],\n    barName: 'playProgressBar'\n  };\n\n  // MouseTimeDisplay tooltips should not be added to a player on mobile devices\n  if (!IS_IOS && !IS_ANDROID) {\n    SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n  }\n  Component$1.registerComponent('SeekBar', SeekBar);\n\n  /**\n   * @file progress-control.js\n   */\n\n  /**\n   * The Progress Control component contains the seek bar, load progress,\n   * and play progress.\n   *\n   * @extends Component\n   */\n  class ProgressControl extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n      this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);\n      this.handleMouseUpHandler_ = e => this.handleMouseUp(e);\n      this.handleMouseDownHandler_ = e => this.handleMouseDown(e);\n      this.enable();\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-progress-control vjs-control'\n      });\n    }\n\n    /**\n     * When the mouse moves over the `ProgressControl`, the pointer position\n     * gets passed down to the `MouseTimeDisplay` component.\n     *\n     * @param {EventTarget~Event} event\n     *        The `mousemove` event that caused this function to run.\n     *\n     * @listen mousemove\n     */\n    handleMouseMove(event) {\n      const seekBar = this.getChild('seekBar');\n      if (!seekBar) {\n        return;\n      }\n      const playProgressBar = seekBar.getChild('playProgressBar');\n      const mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n      if (!playProgressBar && !mouseTimeDisplay) {\n        return;\n      }\n      const seekBarEl = seekBar.el();\n      const seekBarRect = findPosition(seekBarEl);\n      let seekBarPoint = getPointerPosition(seekBarEl, event).x;\n\n      // The default skin has a gap on either side of the `SeekBar`. This means\n      // that it's possible to trigger this behavior outside the boundaries of\n      // the `SeekBar`. This ensures we stay within it at all times.\n      seekBarPoint = clamp(seekBarPoint, 0, 1);\n      if (mouseTimeDisplay) {\n        mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n      }\n      if (playProgressBar) {\n        playProgressBar.update(seekBarRect, seekBar.getProgress());\n      }\n    }\n\n    /**\n     * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n     *\n     * @method ProgressControl#throttledHandleMouseSeek\n     * @param {EventTarget~Event} event\n     *        The `mousemove` event that caused this function to run.\n     *\n     * @listen mousemove\n     * @listen touchmove\n     */\n\n    /**\n     * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mousedown` or `touchstart` event that triggered this function\n     *\n     * @listens mousemove\n     * @listens touchmove\n     */\n    handleMouseSeek(event) {\n      const seekBar = this.getChild('seekBar');\n      if (seekBar) {\n        seekBar.handleMouseMove(event);\n      }\n    }\n\n    /**\n     * Are controls are currently enabled for this progress control.\n     *\n     * @return {boolean}\n     *         true if controls are enabled, false otherwise\n     */\n    enabled() {\n      return this.enabled_;\n    }\n\n    /**\n     * Disable all controls on the progress control and its children\n     */\n    disable() {\n      this.children().forEach(child => child.disable && child.disable());\n      if (!this.enabled()) {\n        return;\n      }\n      this.off(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\n      this.off(this.el_, 'mousemove', this.handleMouseMove);\n      this.removeListenersAddedOnMousedownAndTouchstart();\n      this.addClass('disabled');\n      this.enabled_ = false;\n\n      // Restore normal playback state if controls are disabled while scrubbing\n      if (this.player_.scrubbing()) {\n        const seekBar = this.getChild('seekBar');\n        this.player_.scrubbing(false);\n        if (seekBar.videoWasPlaying) {\n          silencePromise(this.player_.play());\n        }\n      }\n    }\n\n    /**\n     * Enable all controls on the progress control and its children\n     */\n    enable() {\n      this.children().forEach(child => child.enable && child.enable());\n      if (this.enabled()) {\n        return;\n      }\n      this.on(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\n      this.on(this.el_, 'mousemove', this.handleMouseMove);\n      this.removeClass('disabled');\n      this.enabled_ = true;\n    }\n\n    /**\n     * Cleanup listeners after the user finishes interacting with the progress controls\n     */\n    removeListenersAddedOnMousedownAndTouchstart() {\n      const doc = this.el_.ownerDocument;\n      this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n      this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n      this.off(doc, 'mouseup', this.handleMouseUpHandler_);\n      this.off(doc, 'touchend', this.handleMouseUpHandler_);\n    }\n\n    /**\n     * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mousedown` or `touchstart` event that triggered this function\n     *\n     * @listens mousedown\n     * @listens touchstart\n     */\n    handleMouseDown(event) {\n      const doc = this.el_.ownerDocument;\n      const seekBar = this.getChild('seekBar');\n      if (seekBar) {\n        seekBar.handleMouseDown(event);\n      }\n      this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n      this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n      this.on(doc, 'mouseup', this.handleMouseUpHandler_);\n      this.on(doc, 'touchend', this.handleMouseUpHandler_);\n    }\n\n    /**\n     * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mouseup` or `touchend` event that triggered this function.\n     *\n     * @listens touchend\n     * @listens mouseup\n     */\n    handleMouseUp(event) {\n      const seekBar = this.getChild('seekBar');\n      if (seekBar) {\n        seekBar.handleMouseUp(event);\n      }\n      this.removeListenersAddedOnMousedownAndTouchstart();\n    }\n  }\n\n  /**\n   * Default options for `ProgressControl`\n   *\n   * @type {Object}\n   * @private\n   */\n  ProgressControl.prototype.options_ = {\n    children: ['seekBar']\n  };\n  Component$1.registerComponent('ProgressControl', ProgressControl);\n\n  /**\n   * @file picture-in-picture-toggle.js\n   */\n\n  /**\n   * Toggle Picture-in-Picture mode\n   *\n   * @extends Button\n   */\n  class PictureInPictureToggle extends Button {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @listens Player#enterpictureinpicture\n     * @listens Player#leavepictureinpicture\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], e => this.handlePictureInPictureChange(e));\n      this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], e => this.handlePictureInPictureEnabledChange(e));\n      this.on(player, ['loadedmetadata', 'audioonlymodechange', 'audiopostermodechange'], () => {\n        // This audio detection will not detect HLS or DASH audio-only streams because there was no reliable way to detect them at the time\n        const isSourceAudio = player.currentType().substring(0, 5) === 'audio';\n        if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {\n          if (player.isInPictureInPicture()) {\n            player.exitPictureInPicture();\n          }\n          this.hide();\n        } else {\n          this.show();\n        }\n      });\n\n      // TODO: Deactivate button on player emptied event.\n      this.disable();\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-picture-in-picture-control ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Enables or disables button based on document.pictureInPictureEnabled property value\n     * or on value returned by player.disablePictureInPicture() method.\n     */\n    handlePictureInPictureEnabledChange() {\n      if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n\n    /**\n     * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be\n     *        called.\n     *\n     * @listens Player#enterpictureinpicture\n     * @listens Player#leavepictureinpicture\n     */\n    handlePictureInPictureChange(event) {\n      if (this.player_.isInPictureInPicture()) {\n        this.controlText('Exit Picture-in-Picture');\n      } else {\n        this.controlText('Picture-in-Picture');\n      }\n      this.handlePictureInPictureEnabledChange();\n    }\n\n    /**\n     * This gets called when an `PictureInPictureToggle` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      if (!this.player_.isInPictureInPicture()) {\n        this.player_.requestPictureInPicture();\n      } else {\n        this.player_.exitPictureInPicture();\n      }\n    }\n  }\n\n  /**\n   * The text that should display over the `PictureInPictureToggle`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';\n  Component$1.registerComponent('PictureInPictureToggle', PictureInPictureToggle);\n\n  /**\n   * @file fullscreen-toggle.js\n   */\n\n  /**\n   * Toggle fullscreen video\n   *\n   * @extends Button\n   */\n  class FullscreenToggle extends Button {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.on(player, 'fullscreenchange', e => this.handleFullscreenChange(e));\n      if (document[player.fsApi_.fullscreenEnabled] === false) {\n        this.disable();\n      }\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-fullscreen-control ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Handles fullscreenchange on the player and change control text accordingly.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The {@link Player#fullscreenchange} event that caused this function to be\n     *        called.\n     *\n     * @listens Player#fullscreenchange\n     */\n    handleFullscreenChange(event) {\n      if (this.player_.isFullscreen()) {\n        this.controlText('Exit Fullscreen');\n      } else {\n        this.controlText('Fullscreen');\n      }\n    }\n\n    /**\n     * This gets called when an `FullscreenToggle` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      if (!this.player_.isFullscreen()) {\n        this.player_.requestFullscreen();\n      } else {\n        this.player_.exitFullscreen();\n      }\n    }\n  }\n\n  /**\n   * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  FullscreenToggle.prototype.controlText_ = 'Fullscreen';\n  Component$1.registerComponent('FullscreenToggle', FullscreenToggle);\n\n  /**\n   * Check if volume control is supported and if it isn't hide the\n   * `Component` that was passed  using the `vjs-hidden` class.\n   *\n   * @param {Component} self\n   *        The component that should be hidden if volume is unsupported\n   *\n   * @param {Player} player\n   *        A reference to the player\n   *\n   * @private\n   */\n  const checkVolumeSupport = function (self, player) {\n    // hide volume controls when they're not supported by the current tech\n    if (player.tech_ && !player.tech_.featuresVolumeControl) {\n      self.addClass('vjs-hidden');\n    }\n    self.on(player, 'loadstart', function () {\n      if (!player.tech_.featuresVolumeControl) {\n        self.addClass('vjs-hidden');\n      } else {\n        self.removeClass('vjs-hidden');\n      }\n    });\n  };\n\n  /**\n   * @file volume-level.js\n   */\n\n  /**\n   * Shows volume level\n   *\n   * @extends Component\n   */\n  class VolumeLevel extends Component$1 {\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl('div', {\n        className: 'vjs-volume-level'\n      });\n      el.appendChild(super.createEl('span', {\n        className: 'vjs-control-text'\n      }));\n      return el;\n    }\n  }\n  Component$1.registerComponent('VolumeLevel', VolumeLevel);\n\n  /**\n   * @file volume-level-tooltip.js\n   */\n\n  /**\n   * Volume level tooltips display a volume above or side by side the volume bar.\n   *\n   * @extends Component\n   */\n  class VolumeLevelTooltip extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The {@link Player} that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n    }\n\n    /**\n     * Create the volume tooltip DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-volume-tooltip'\n      }, {\n        'aria-hidden': 'true'\n      });\n    }\n\n    /**\n     * Updates the position of the tooltip relative to the `VolumeBar` and\n     * its content text.\n     *\n     * @param {Object} rangeBarRect\n     *        The `ClientRect` for the {@link VolumeBar} element.\n     *\n     * @param {number} rangeBarPoint\n     *        A number from 0 to 1, representing a horizontal/vertical reference point\n     *        from the left edge of the {@link VolumeBar}\n     *\n     * @param {boolean} vertical\n     *        Referees to the Volume control position\n     *        in the control bar{@link VolumeControl}\n     *\n     */\n    update(rangeBarRect, rangeBarPoint, vertical, content) {\n      if (!vertical) {\n        const tooltipRect = getBoundingClientRect(this.el_);\n        const playerRect = getBoundingClientRect(this.player_.el());\n        const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;\n        if (!playerRect || !tooltipRect) {\n          return;\n        }\n        const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;\n        const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);\n        let pullTooltipBy = tooltipRect.width / 2;\n        if (spaceLeftOfPoint < pullTooltipBy) {\n          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n        } else if (spaceRightOfPoint < pullTooltipBy) {\n          pullTooltipBy = spaceRightOfPoint;\n        }\n        if (pullTooltipBy < 0) {\n          pullTooltipBy = 0;\n        } else if (pullTooltipBy > tooltipRect.width) {\n          pullTooltipBy = tooltipRect.width;\n        }\n        this.el_.style.right = `-${pullTooltipBy}px`;\n      }\n      this.write(`${content}%`);\n    }\n\n    /**\n     * Write the volume to the tooltip DOM element.\n     *\n     * @param {string} content\n     *        The formatted volume for the tooltip.\n     */\n    write(content) {\n      textContent(this.el_, content);\n    }\n\n    /**\n     * Updates the position of the volume tooltip relative to the `VolumeBar`.\n     *\n     * @param {Object} rangeBarRect\n     *        The `ClientRect` for the {@link VolumeBar} element.\n     *\n     * @param {number} rangeBarPoint\n     *        A number from 0 to 1, representing a horizontal/vertical reference point\n     *        from the left edge of the {@link VolumeBar}\n     *\n     * @param {boolean} vertical\n     *        Referees to the Volume control position\n     *        in the control bar{@link VolumeControl}\n     *\n     * @param {number} volume\n     *        The volume level to update the tooltip to\n     *\n     * @param {Function} cb\n     *        A function that will be called during the request animation frame\n     *        for tooltips that need to do additional animations from the default\n     */\n    updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {\n      this.requestNamedAnimationFrame('VolumeLevelTooltip#updateVolume', () => {\n        this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));\n        if (cb) {\n          cb();\n        }\n      });\n    }\n  }\n  Component$1.registerComponent('VolumeLevelTooltip', VolumeLevelTooltip);\n\n  /**\n   * @file mouse-volume-level-display.js\n   */\n\n  /**\n   * The {@link MouseVolumeLevelDisplay} component tracks mouse movement over the\n   * {@link VolumeControl}. It displays an indicator and a {@link VolumeLevelTooltip}\n   * indicating the volume level which is represented by a given point in the\n   * {@link VolumeBar}.\n   *\n   * @extends Component\n   */\n  class MouseVolumeLevelDisplay extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The {@link Player} that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n    }\n\n    /**\n     * Create the DOM element for this class.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-mouse-display'\n      });\n    }\n\n    /**\n     * Enquires updates to its own DOM as well as the DOM of its\n     * {@link VolumeLevelTooltip} child.\n     *\n     * @param {Object} rangeBarRect\n     *        The `ClientRect` for the {@link VolumeBar} element.\n     *\n     * @param {number} rangeBarPoint\n     *        A number from 0 to 1, representing a horizontal/vertical reference point\n     *        from the left edge of the {@link VolumeBar}\n     *\n     * @param {boolean} vertical\n     *        Referees to the Volume control position\n     *        in the control bar{@link VolumeControl}\n     *\n     */\n    update(rangeBarRect, rangeBarPoint, vertical) {\n      const volume = 100 * rangeBarPoint;\n      this.getChild('volumeLevelTooltip').updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, () => {\n        if (vertical) {\n          this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`;\n        } else {\n          this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;\n        }\n      });\n    }\n  }\n\n  /**\n   * Default options for `MouseVolumeLevelDisplay`\n   *\n   * @type {Object}\n   * @private\n   */\n  MouseVolumeLevelDisplay.prototype.options_ = {\n    children: ['volumeLevelTooltip']\n  };\n  Component$1.registerComponent('MouseVolumeLevelDisplay', MouseVolumeLevelDisplay);\n\n  /**\n   * @file volume-bar.js\n   */\n\n  /**\n   * The bar that contains the volume level and can be clicked on to adjust the level\n   *\n   * @extends Slider\n   */\n  class VolumeBar extends Slider {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.on('slideractive', e => this.updateLastVolume_(e));\n      this.on(player, 'volumechange', e => this.updateARIAAttributes(e));\n      player.ready(() => this.updateARIAAttributes());\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-volume-bar vjs-slider-bar'\n      }, {\n        'aria-label': this.localize('Volume Level'),\n        'aria-live': 'polite'\n      });\n    }\n\n    /**\n     * Handle mouse down on volume bar\n     *\n     * @param {EventTarget~Event} event\n     *        The `mousedown` event that caused this to run.\n     *\n     * @listens mousedown\n     */\n    handleMouseDown(event) {\n      if (!isSingleLeftClick(event)) {\n        return;\n      }\n      super.handleMouseDown(event);\n    }\n\n    /**\n     * Handle movement events on the {@link VolumeMenuButton}.\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to run.\n     *\n     * @listens mousemove\n     */\n    handleMouseMove(event) {\n      const mouseVolumeLevelDisplay = this.getChild('mouseVolumeLevelDisplay');\n      if (mouseVolumeLevelDisplay) {\n        const volumeBarEl = this.el();\n        const volumeBarRect = getBoundingClientRect(volumeBarEl);\n        const vertical = this.vertical();\n        let volumeBarPoint = getPointerPosition(volumeBarEl, event);\n        volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;\n        // The default skin has a gap on either side of the `VolumeBar`. This means\n        // that it's possible to trigger this behavior outside the boundaries of\n        // the `VolumeBar`. This ensures we stay within it at all times.\n        volumeBarPoint = clamp(volumeBarPoint, 0, 1);\n        mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);\n      }\n      if (!isSingleLeftClick(event)) {\n        return;\n      }\n      this.checkMuted();\n      this.player_.volume(this.calculateDistance(event));\n    }\n\n    /**\n     * If the player is muted unmute it.\n     */\n    checkMuted() {\n      if (this.player_.muted()) {\n        this.player_.muted(false);\n      }\n    }\n\n    /**\n     * Get percent of volume level\n     *\n     * @return {number}\n     *         Volume level percent as a decimal number.\n     */\n    getPercent() {\n      if (this.player_.muted()) {\n        return 0;\n      }\n      return this.player_.volume();\n    }\n\n    /**\n     * Increase volume level for keyboard users\n     */\n    stepForward() {\n      this.checkMuted();\n      this.player_.volume(this.player_.volume() + 0.1);\n    }\n\n    /**\n     * Decrease volume level for keyboard users\n     */\n    stepBack() {\n      this.checkMuted();\n      this.player_.volume(this.player_.volume() - 0.1);\n    }\n\n    /**\n     * Update ARIA accessibility attributes\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `volumechange` event that caused this function to run.\n     *\n     * @listens Player#volumechange\n     */\n    updateARIAAttributes(event) {\n      const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n      this.el_.setAttribute('aria-valuenow', ariaValue);\n      this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n    }\n\n    /**\n     * Returns the current value of the player volume as a percentage\n     *\n     * @private\n     */\n    volumeAsPercentage_() {\n      return Math.round(this.player_.volume() * 100);\n    }\n\n    /**\n     * When user starts dragging the VolumeBar, store the volume and listen for\n     * the end of the drag. When the drag ends, if the volume was set to zero,\n     * set lastVolume to the stored volume.\n     *\n     * @listens slideractive\n     * @private\n     */\n    updateLastVolume_() {\n      const volumeBeforeDrag = this.player_.volume();\n      this.one('sliderinactive', () => {\n        if (this.player_.volume() === 0) {\n          this.player_.lastVolume_(volumeBeforeDrag);\n        }\n      });\n    }\n  }\n\n  /**\n   * Default options for the `VolumeBar`\n   *\n   * @type {Object}\n   * @private\n   */\n  VolumeBar.prototype.options_ = {\n    children: ['volumeLevel'],\n    barName: 'volumeLevel'\n  };\n\n  // MouseVolumeLevelDisplay tooltip should not be added to a player on mobile devices\n  if (!IS_IOS && !IS_ANDROID) {\n    VolumeBar.prototype.options_.children.splice(0, 0, 'mouseVolumeLevelDisplay');\n  }\n\n  /**\n   * Call the update event for this Slider when this event happens on the player.\n   *\n   * @type {string}\n   */\n  VolumeBar.prototype.playerEvent = 'volumechange';\n  Component$1.registerComponent('VolumeBar', VolumeBar);\n\n  /**\n   * @file volume-control.js\n   */\n\n  /**\n   * The component for controlling the volume level\n   *\n   * @extends Component\n   */\n  class VolumeControl extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     */\n    constructor(player, options = {}) {\n      options.vertical = options.vertical || false;\n\n      // Pass the vertical option down to the VolumeBar if\n      // the VolumeBar is turned on.\n      if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n        options.volumeBar = options.volumeBar || {};\n        options.volumeBar.vertical = options.vertical;\n      }\n      super(player, options);\n\n      // hide this control if volume support is missing\n      checkVolumeSupport(this, player);\n      this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n      this.handleMouseUpHandler_ = e => this.handleMouseUp(e);\n      this.on('mousedown', e => this.handleMouseDown(e));\n      this.on('touchstart', e => this.handleMouseDown(e));\n      this.on('mousemove', e => this.handleMouseMove(e));\n\n      // while the slider is active (the mouse has been pressed down and\n      // is dragging) or in focus we do not want to hide the VolumeBar\n      this.on(this.volumeBar, ['focus', 'slideractive'], () => {\n        this.volumeBar.addClass('vjs-slider-active');\n        this.addClass('vjs-slider-active');\n        this.trigger('slideractive');\n      });\n      this.on(this.volumeBar, ['blur', 'sliderinactive'], () => {\n        this.volumeBar.removeClass('vjs-slider-active');\n        this.removeClass('vjs-slider-active');\n        this.trigger('sliderinactive');\n      });\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      let orientationClass = 'vjs-volume-horizontal';\n      if (this.options_.vertical) {\n        orientationClass = 'vjs-volume-vertical';\n      }\n      return super.createEl('div', {\n        className: `vjs-volume-control vjs-control ${orientationClass}`\n      });\n    }\n\n    /**\n     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mousedown` or `touchstart` event that triggered this function\n     *\n     * @listens mousedown\n     * @listens touchstart\n     */\n    handleMouseDown(event) {\n      const doc = this.el_.ownerDocument;\n      this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n      this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n      this.on(doc, 'mouseup', this.handleMouseUpHandler_);\n      this.on(doc, 'touchend', this.handleMouseUpHandler_);\n    }\n\n    /**\n     * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mouseup` or `touchend` event that triggered this function.\n     *\n     * @listens touchend\n     * @listens mouseup\n     */\n    handleMouseUp(event) {\n      const doc = this.el_.ownerDocument;\n      this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n      this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n      this.off(doc, 'mouseup', this.handleMouseUpHandler_);\n      this.off(doc, 'touchend', this.handleMouseUpHandler_);\n    }\n\n    /**\n     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        `mousedown` or `touchstart` event that triggered this function\n     *\n     * @listens mousedown\n     * @listens touchstart\n     */\n    handleMouseMove(event) {\n      this.volumeBar.handleMouseMove(event);\n    }\n  }\n\n  /**\n   * Default options for the `VolumeControl`\n   *\n   * @type {Object}\n   * @private\n   */\n  VolumeControl.prototype.options_ = {\n    children: ['volumeBar']\n  };\n  Component$1.registerComponent('VolumeControl', VolumeControl);\n\n  /**\n   * Check if muting volume is supported and if it isn't hide the mute toggle\n   * button.\n   *\n   * @param {Component} self\n   *        A reference to the mute toggle button\n   *\n   * @param {Player} player\n   *        A reference to the player\n   *\n   * @private\n   */\n  const checkMuteSupport = function (self, player) {\n    // hide mute toggle button if it's not supported by the current tech\n    if (player.tech_ && !player.tech_.featuresMuteControl) {\n      self.addClass('vjs-hidden');\n    }\n    self.on(player, 'loadstart', function () {\n      if (!player.tech_.featuresMuteControl) {\n        self.addClass('vjs-hidden');\n      } else {\n        self.removeClass('vjs-hidden');\n      }\n    });\n  };\n\n  /**\n   * @file mute-toggle.js\n   */\n\n  /**\n   * A button component for muting the audio.\n   *\n   * @extends Button\n   */\n  class MuteToggle extends Button {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n\n      // hide this control if volume support is missing\n      checkMuteSupport(this, player);\n      this.on(player, ['loadstart', 'volumechange'], e => this.update(e));\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-mute-control ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * This gets called when an `MuteToggle` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      const vol = this.player_.volume();\n      const lastVolume = this.player_.lastVolume_();\n      if (vol === 0) {\n        const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n        this.player_.volume(volumeToSet);\n        this.player_.muted(false);\n      } else {\n        this.player_.muted(this.player_.muted() ? false : true);\n      }\n    }\n\n    /**\n     * Update the `MuteToggle` button based on the state of `volume` and `muted`\n     * on the player.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The {@link Player#loadstart} event if this function was called\n     *        through an event.\n     *\n     * @listens Player#loadstart\n     * @listens Player#volumechange\n     */\n    update(event) {\n      this.updateIcon_();\n      this.updateControlText_();\n    }\n\n    /**\n     * Update the appearance of the `MuteToggle` icon.\n     *\n     * Possible states (given `level` variable below):\n     * - 0: crossed out\n     * - 1: zero bars of volume\n     * - 2: one bar of volume\n     * - 3: two bars of volume\n     *\n     * @private\n     */\n    updateIcon_() {\n      const vol = this.player_.volume();\n      let level = 3;\n\n      // in iOS when a player is loaded with muted attribute\n      // and volume is changed with a native mute button\n      // we want to make sure muted state is updated\n      if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {\n        this.player_.muted(this.player_.tech_.el_.muted);\n      }\n      if (vol === 0 || this.player_.muted()) {\n        level = 0;\n      } else if (vol < 0.33) {\n        level = 1;\n      } else if (vol < 0.67) {\n        level = 2;\n      }\n      removeClass(this.el_, [0, 1, 2, 3].reduce((str, i) => str + `${i ? ' ' : ''}vjs-vol-${i}`, ''));\n      addClass(this.el_, `vjs-vol-${level}`);\n    }\n\n    /**\n     * If `muted` has changed on the player, update the control text\n     * (`title` attribute on `vjs-mute-control` element and content of\n     * `vjs-control-text` element).\n     *\n     * @private\n     */\n    updateControlText_() {\n      const soundOff = this.player_.muted() || this.player_.volume() === 0;\n      const text = soundOff ? 'Unmute' : 'Mute';\n      if (this.controlText() !== text) {\n        this.controlText(text);\n      }\n    }\n  }\n\n  /**\n   * The text that should display over the `MuteToggle`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  MuteToggle.prototype.controlText_ = 'Mute';\n  Component$1.registerComponent('MuteToggle', MuteToggle);\n\n  /**\n   * @file volume-control.js\n   */\n\n  /**\n   * A Component to contain the MuteToggle and VolumeControl so that\n   * they can work together.\n   *\n   * @extends Component\n   */\n  class VolumePanel extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     */\n    constructor(player, options = {}) {\n      if (typeof options.inline !== 'undefined') {\n        options.inline = options.inline;\n      } else {\n        options.inline = true;\n      }\n\n      // pass the inline option down to the VolumeControl as vertical if\n      // the VolumeControl is on.\n      if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n        options.volumeControl = options.volumeControl || {};\n        options.volumeControl.vertical = !options.inline;\n      }\n      super(player, options);\n\n      // this handler is used by mouse handler methods below\n      this.handleKeyPressHandler_ = e => this.handleKeyPress(e);\n      this.on(player, ['loadstart'], e => this.volumePanelState_(e));\n      this.on(this.muteToggle, 'keyup', e => this.handleKeyPress(e));\n      this.on(this.volumeControl, 'keyup', e => this.handleVolumeControlKeyUp(e));\n      this.on('keydown', e => this.handleKeyPress(e));\n      this.on('mouseover', e => this.handleMouseOver(e));\n      this.on('mouseout', e => this.handleMouseOut(e));\n\n      // while the slider is active (the mouse has been pressed down and\n      // is dragging) we do not want to hide the VolumeBar\n      this.on(this.volumeControl, ['slideractive'], this.sliderActive_);\n      this.on(this.volumeControl, ['sliderinactive'], this.sliderInactive_);\n    }\n\n    /**\n     * Add vjs-slider-active class to the VolumePanel\n     *\n     * @listens VolumeControl#slideractive\n     * @private\n     */\n    sliderActive_() {\n      this.addClass('vjs-slider-active');\n    }\n\n    /**\n     * Removes vjs-slider-active class to the VolumePanel\n     *\n     * @listens VolumeControl#sliderinactive\n     * @private\n     */\n    sliderInactive_() {\n      this.removeClass('vjs-slider-active');\n    }\n\n    /**\n     * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\n     * depending on MuteToggle and VolumeControl state\n     *\n     * @listens Player#loadstart\n     * @private\n     */\n    volumePanelState_() {\n      // hide volume panel if neither volume control or mute toggle\n      // are displayed\n      if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\n        this.addClass('vjs-hidden');\n      }\n\n      // if only mute toggle is visible we don't want\n      // volume panel expanding when hovered or active\n      if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\n        this.addClass('vjs-mute-toggle-only');\n      }\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      let orientationClass = 'vjs-volume-panel-horizontal';\n      if (!this.options_.inline) {\n        orientationClass = 'vjs-volume-panel-vertical';\n      }\n      return super.createEl('div', {\n        className: `vjs-volume-panel vjs-control ${orientationClass}`\n      });\n    }\n\n    /**\n     * Dispose of the `volume-panel` and all child components.\n     */\n    dispose() {\n      this.handleMouseOut();\n      super.dispose();\n    }\n\n    /**\n     * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes\n     * the volume panel and sets focus on `MuteToggle`.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keyup` event that caused this function to be called.\n     *\n     * @listens keyup\n     */\n    handleVolumeControlKeyUp(event) {\n      if (keycode.isEventKey(event, 'Esc')) {\n        this.muteToggle.focus();\n      }\n    }\n\n    /**\n     * This gets called when a `VolumePanel` gains hover via a `mouseover` event.\n     * Turns on listening for `mouseover` event. When they happen it\n     * calls `this.handleMouseOver`.\n     *\n     * @param {EventTarget~Event} event\n     *        The `mouseover` event that caused this function to be called.\n     *\n     * @listens mouseover\n     */\n    handleMouseOver(event) {\n      this.addClass('vjs-hover');\n      on(document, 'keyup', this.handleKeyPressHandler_);\n    }\n\n    /**\n     * This gets called when a `VolumePanel` gains hover via a `mouseout` event.\n     * Turns on listening for `mouseout` event. When they happen it\n     * calls `this.handleMouseOut`.\n     *\n     * @param {EventTarget~Event} event\n     *        The `mouseout` event that caused this function to be called.\n     *\n     * @listens mouseout\n     */\n    handleMouseOut(event) {\n      this.removeClass('vjs-hover');\n      off(document, 'keyup', this.handleKeyPressHandler_);\n    }\n\n    /**\n     * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,\n     * looking for ESC, which hides the `VolumeControl`.\n     *\n     * @param {EventTarget~Event} event\n     *        The keypress that triggered this event.\n     *\n     * @listens keydown | keyup\n     */\n    handleKeyPress(event) {\n      if (keycode.isEventKey(event, 'Esc')) {\n        this.handleMouseOut();\n      }\n    }\n  }\n\n  /**\n   * Default options for the `VolumeControl`\n   *\n   * @type {Object}\n   * @private\n   */\n  VolumePanel.prototype.options_ = {\n    children: ['muteToggle', 'volumeControl']\n  };\n  Component$1.registerComponent('VolumePanel', VolumePanel);\n\n  /**\n   * @file menu.js\n   */\n\n  /**\n   * The Menu component is used to build popup menus, including subtitle and\n   * captions selection menus.\n   *\n   * @extends Component\n   */\n  class Menu extends Component$1 {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Player} player\n     *        the player that this component should attach to\n     *\n     * @param {Object} [options]\n     *        Object of option names and values\n     *\n     */\n    constructor(player, options) {\n      super(player, options);\n      if (options) {\n        this.menuButton_ = options.menuButton;\n      }\n      this.focusedChild_ = -1;\n      this.on('keydown', e => this.handleKeyDown(e));\n\n      // All the menu item instances share the same blur handler provided by the menu container.\n      this.boundHandleBlur_ = e => this.handleBlur(e);\n      this.boundHandleTapClick_ = e => this.handleTapClick(e);\n    }\n\n    /**\n     * Add event listeners to the {@link MenuItem}.\n     *\n     * @param {Object} component\n     *        The instance of the `MenuItem` to add listeners to.\n     *\n     */\n    addEventListenerForItem(component) {\n      if (!(component instanceof Component$1)) {\n        return;\n      }\n      this.on(component, 'blur', this.boundHandleBlur_);\n      this.on(component, ['tap', 'click'], this.boundHandleTapClick_);\n    }\n\n    /**\n     * Remove event listeners from the {@link MenuItem}.\n     *\n     * @param {Object} component\n     *        The instance of the `MenuItem` to remove listeners.\n     *\n     */\n    removeEventListenerForItem(component) {\n      if (!(component instanceof Component$1)) {\n        return;\n      }\n      this.off(component, 'blur', this.boundHandleBlur_);\n      this.off(component, ['tap', 'click'], this.boundHandleTapClick_);\n    }\n\n    /**\n     * This method will be called indirectly when the component has been added\n     * before the component adds to the new menu instance by `addItem`.\n     * In this case, the original menu instance will remove the component\n     * by calling `removeChild`.\n     *\n     * @param {Object} component\n     *        The instance of the `MenuItem`\n     */\n    removeChild(component) {\n      if (typeof component === 'string') {\n        component = this.getChild(component);\n      }\n      this.removeEventListenerForItem(component);\n      super.removeChild(component);\n    }\n\n    /**\n     * Add a {@link MenuItem} to the menu.\n     *\n     * @param {Object|string} component\n     *        The name or instance of the `MenuItem` to add.\n     *\n     */\n    addItem(component) {\n      const childComponent = this.addChild(component);\n      if (childComponent) {\n        this.addEventListenerForItem(childComponent);\n      }\n    }\n\n    /**\n     * Create the `Menu`s DOM element.\n     *\n     * @return {Element}\n     *         the element that was created\n     */\n    createEl() {\n      const contentElType = this.options_.contentElType || 'ul';\n      this.contentEl_ = createEl(contentElType, {\n        className: 'vjs-menu-content'\n      });\n      this.contentEl_.setAttribute('role', 'menu');\n      const el = super.createEl('div', {\n        append: this.contentEl_,\n        className: 'vjs-menu'\n      });\n      el.appendChild(this.contentEl_);\n\n      // Prevent clicks from bubbling up. Needed for Menu Buttons,\n      // where a click on the parent is significant\n      on(el, 'click', function (event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n      });\n      return el;\n    }\n    dispose() {\n      this.contentEl_ = null;\n      this.boundHandleBlur_ = null;\n      this.boundHandleTapClick_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Called when a `MenuItem` loses focus.\n     *\n     * @param {EventTarget~Event} event\n     *        The `blur` event that caused this function to be called.\n     *\n     * @listens blur\n     */\n    handleBlur(event) {\n      const relatedTarget = event.relatedTarget || document.activeElement;\n\n      // Close menu popup when a user clicks outside the menu\n      if (!this.children().some(element => {\n        return element.el() === relatedTarget;\n      })) {\n        const btn = this.menuButton_;\n        if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {\n          btn.unpressButton();\n        }\n      }\n    }\n\n    /**\n     * Called when a `MenuItem` gets clicked or tapped.\n     *\n     * @param {EventTarget~Event} event\n     *        The `click` or `tap` event that caused this function to be called.\n     *\n     * @listens click,tap\n     */\n    handleTapClick(event) {\n      // Unpress the associated MenuButton, and move focus back to it\n      if (this.menuButton_) {\n        this.menuButton_.unpressButton();\n        const childComponents = this.children();\n        if (!Array.isArray(childComponents)) {\n          return;\n        }\n        const foundComponent = childComponents.filter(component => component.el() === event.target)[0];\n        if (!foundComponent) {\n          return;\n        }\n\n        // don't focus menu button if item is a caption settings item\n        // because focus will move elsewhere\n        if (foundComponent.name() !== 'CaptionSettingsMenuItem') {\n          this.menuButton_.focus();\n        }\n      }\n    }\n\n    /**\n     * Handle a `keydown` event on this menu. This listener is added in the constructor.\n     *\n     * @param {EventTarget~Event} event\n     *        A `keydown` event that happened on the menu.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Left and Down Arrows\n      if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.stepForward();\n\n        // Up and Right Arrows\n      } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.stepBack();\n      }\n    }\n\n    /**\n     * Move to next (lower) menu item for keyboard users.\n     */\n    stepForward() {\n      let stepChild = 0;\n      if (this.focusedChild_ !== undefined) {\n        stepChild = this.focusedChild_ + 1;\n      }\n      this.focus(stepChild);\n    }\n\n    /**\n     * Move to previous (higher) menu item for keyboard users.\n     */\n    stepBack() {\n      let stepChild = 0;\n      if (this.focusedChild_ !== undefined) {\n        stepChild = this.focusedChild_ - 1;\n      }\n      this.focus(stepChild);\n    }\n\n    /**\n     * Set focus on a {@link MenuItem} in the `Menu`.\n     *\n     * @param {Object|string} [item=0]\n     *        Index of child item set focus on.\n     */\n    focus(item = 0) {\n      const children = this.children().slice();\n      const haveTitle = children.length && children[0].hasClass('vjs-menu-title');\n      if (haveTitle) {\n        children.shift();\n      }\n      if (children.length > 0) {\n        if (item < 0) {\n          item = 0;\n        } else if (item >= children.length) {\n          item = children.length - 1;\n        }\n        this.focusedChild_ = item;\n        children[item].el_.focus();\n      }\n    }\n  }\n  Component$1.registerComponent('Menu', Menu);\n\n  /**\n   * @file menu-button.js\n   */\n\n  /**\n   * A `MenuButton` class for any popup {@link Menu}.\n   *\n   * @extends Component\n   */\n  class MenuButton extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     */\n    constructor(player, options = {}) {\n      super(player, options);\n      this.menuButton_ = new Button(player, options);\n      this.menuButton_.controlText(this.controlText_);\n      this.menuButton_.el_.setAttribute('aria-haspopup', 'true');\n\n      // Add buildCSSClass values to the button, not the wrapper\n      const buttonClass = Button.prototype.buildCSSClass();\n      this.menuButton_.el_.className = this.buildCSSClass() + ' ' + buttonClass;\n      this.menuButton_.removeClass('vjs-control');\n      this.addChild(this.menuButton_);\n      this.update();\n      this.enabled_ = true;\n      const handleClick = e => this.handleClick(e);\n      this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e);\n      this.on(this.menuButton_, 'tap', handleClick);\n      this.on(this.menuButton_, 'click', handleClick);\n      this.on(this.menuButton_, 'keydown', e => this.handleKeyDown(e));\n      this.on(this.menuButton_, 'mouseenter', () => {\n        this.addClass('vjs-hover');\n        this.menu.show();\n        on(document, 'keyup', this.handleMenuKeyUp_);\n      });\n      this.on('mouseleave', e => this.handleMouseLeave(e));\n      this.on('keydown', e => this.handleSubmenuKeyDown(e));\n    }\n\n    /**\n     * Update the menu based on the current state of its items.\n     */\n    update() {\n      const menu = this.createMenu();\n      if (this.menu) {\n        this.menu.dispose();\n        this.removeChild(this.menu);\n      }\n      this.menu = menu;\n      this.addChild(menu);\n\n      /**\n       * Track the state of the menu button\n       *\n       * @type {Boolean}\n       * @private\n       */\n      this.buttonPressed_ = false;\n      this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n      if (this.items && this.items.length <= this.hideThreshold_) {\n        this.hide();\n        this.menu.contentEl_.removeAttribute('role');\n      } else {\n        this.show();\n        this.menu.contentEl_.setAttribute('role', 'menu');\n      }\n    }\n\n    /**\n     * Create the menu and add all items to it.\n     *\n     * @return {Menu}\n     *         The constructed menu\n     */\n    createMenu() {\n      const menu = new Menu(this.player_, {\n        menuButton: this\n      });\n\n      /**\n       * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n       * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n       * it here because every time we run `createMenu` we need to reset the value.\n       *\n       * @protected\n       * @type {Number}\n       */\n      this.hideThreshold_ = 0;\n\n      // Add a title list item to the top\n      if (this.options_.title) {\n        const titleEl = createEl('li', {\n          className: 'vjs-menu-title',\n          textContent: toTitleCase$1(this.options_.title),\n          tabIndex: -1\n        });\n        const titleComponent = new Component$1(this.player_, {\n          el: titleEl\n        });\n        menu.addItem(titleComponent);\n      }\n      this.items = this.createItems();\n      if (this.items) {\n        // Add menu items to the menu\n        for (let i = 0; i < this.items.length; i++) {\n          menu.addItem(this.items[i]);\n        }\n      }\n      return menu;\n    }\n\n    /**\n     * Create the list of menu items. Specific to each subclass.\n     *\n     * @abstract\n     */\n    createItems() {}\n\n    /**\n     * Create the `MenuButtons`s DOM element.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: this.buildWrapperCSSClass()\n      }, {});\n    }\n\n    /**\n     * Allow sub components to stack CSS class names for the wrapper element\n     *\n     * @return {string}\n     *         The constructed wrapper DOM `className`\n     */\n    buildWrapperCSSClass() {\n      let menuButtonClass = 'vjs-menu-button';\n\n      // If the inline option is passed, we want to use different styles altogether.\n      if (this.options_.inline === true) {\n        menuButtonClass += '-inline';\n      } else {\n        menuButtonClass += '-popup';\n      }\n\n      // TODO: Fix the CSS so that this isn't necessary\n      const buttonClass = Button.prototype.buildCSSClass();\n      return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      let menuButtonClass = 'vjs-menu-button';\n\n      // If the inline option is passed, we want to use different styles altogether.\n      if (this.options_.inline === true) {\n        menuButtonClass += '-inline';\n      } else {\n        menuButtonClass += '-popup';\n      }\n      return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Get or set the localized control text that will be used for accessibility.\n     *\n     * > NOTE: This will come from the internal `menuButton_` element.\n     *\n     * @param {string} [text]\n     *        Control text for element.\n     *\n     * @param {Element} [el=this.menuButton_.el()]\n     *        Element to set the title on.\n     *\n     * @return {string}\n     *         - The control text when getting\n     */\n    controlText(text, el = this.menuButton_.el()) {\n      return this.menuButton_.controlText(text, el);\n    }\n\n    /**\n     * Dispose of the `menu-button` and all child components.\n     */\n    dispose() {\n      this.handleMouseLeave();\n      super.dispose();\n    }\n\n    /**\n     * Handle a click on a `MenuButton`.\n     * See {@link ClickableComponent#handleClick} for instances where this is called.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      } else {\n        this.pressButton();\n      }\n    }\n\n    /**\n     * Handle `mouseleave` for `MenuButton`.\n     *\n     * @param {EventTarget~Event} event\n     *        The `mouseleave` event that caused this function to be called.\n     *\n     * @listens mouseleave\n     */\n    handleMouseLeave(event) {\n      this.removeClass('vjs-hover');\n      off(document, 'keyup', this.handleMenuKeyUp_);\n    }\n\n    /**\n     * Set the focus to the actual button, not to this element\n     */\n    focus() {\n      this.menuButton_.focus();\n    }\n\n    /**\n     * Remove the focus from the actual button, not this element\n     */\n    blur() {\n      this.menuButton_.blur();\n    }\n\n    /**\n     * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n     * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      // Escape or Tab unpress the 'button'\n      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n        if (this.buttonPressed_) {\n          this.unpressButton();\n        }\n\n        // Don't preventDefault for Tab key - we still want to lose focus\n        if (!keycode.isEventKey(event, 'Tab')) {\n          event.preventDefault();\n          // Set focus back to the menu button's button\n          this.menuButton_.focus();\n        }\n        // Up Arrow or Down Arrow also 'press' the button to open the menu\n      } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {\n        if (!this.buttonPressed_) {\n          event.preventDefault();\n          this.pressButton();\n        }\n      }\n    }\n\n    /**\n     * Handle a `keyup` event on a `MenuButton`. The listener for this is added in\n     * the constructor.\n     *\n     * @param {EventTarget~Event} event\n     *        Key press event\n     *\n     * @listens keyup\n     */\n    handleMenuKeyUp(event) {\n      // Escape hides popup menu\n      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n        this.removeClass('vjs-hover');\n      }\n    }\n\n    /**\n     * This method name now delegates to `handleSubmenuKeyDown`. This means\n     * anyone calling `handleSubmenuKeyPress` will not see their method calls\n     * stop working.\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to be called.\n     */\n    handleSubmenuKeyPress(event) {\n      this.handleSubmenuKeyDown(event);\n    }\n\n    /**\n     * Handle a `keydown` event on a sub-menu. The listener for this is added in\n     * the constructor.\n     *\n     * @param {EventTarget~Event} event\n     *        Key press event\n     *\n     * @listens keydown\n     */\n    handleSubmenuKeyDown(event) {\n      // Escape or Tab unpress the 'button'\n      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n        if (this.buttonPressed_) {\n          this.unpressButton();\n        }\n        // Don't preventDefault for Tab key - we still want to lose focus\n        if (!keycode.isEventKey(event, 'Tab')) {\n          event.preventDefault();\n          // Set focus back to the menu button's button\n          this.menuButton_.focus();\n        }\n      }\n    }\n\n    /**\n     * Put the current `MenuButton` into a pressed state.\n     */\n    pressButton() {\n      if (this.enabled_) {\n        this.buttonPressed_ = true;\n        this.menu.show();\n        this.menu.lockShowing();\n        this.menuButton_.el_.setAttribute('aria-expanded', 'true');\n\n        // set the focus into the submenu, except on iOS where it is resulting in\n        // undesired scrolling behavior when the player is in an iframe\n        if (IS_IOS && isInFrame()) {\n          // Return early so that the menu isn't focused\n          return;\n        }\n        this.menu.focus();\n      }\n    }\n\n    /**\n     * Take the current `MenuButton` out of a pressed state.\n     */\n    unpressButton() {\n      if (this.enabled_) {\n        this.buttonPressed_ = false;\n        this.menu.unlockShowing();\n        this.menu.hide();\n        this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n      }\n    }\n\n    /**\n     * Disable the `MenuButton`. Don't allow it to be clicked.\n     */\n    disable() {\n      this.unpressButton();\n      this.enabled_ = false;\n      this.addClass('vjs-disabled');\n      this.menuButton_.disable();\n    }\n\n    /**\n     * Enable the `MenuButton`. Allow it to be clicked.\n     */\n    enable() {\n      this.enabled_ = true;\n      this.removeClass('vjs-disabled');\n      this.menuButton_.enable();\n    }\n  }\n  Component$1.registerComponent('MenuButton', MenuButton);\n\n  /**\n   * @file track-button.js\n   */\n\n  /**\n   * The base class for buttons that toggle specific  track types (e.g. subtitles).\n   *\n   * @extends MenuButton\n   */\n  class TrackButton extends MenuButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      const tracks = options.tracks;\n      super(player, options);\n      if (this.items.length <= 1) {\n        this.hide();\n      }\n      if (!tracks) {\n        return;\n      }\n      const updateHandler = bind_(this, this.update);\n      tracks.addEventListener('removetrack', updateHandler);\n      tracks.addEventListener('addtrack', updateHandler);\n      tracks.addEventListener('labelchange', updateHandler);\n      this.player_.on('ready', updateHandler);\n      this.player_.on('dispose', function () {\n        tracks.removeEventListener('removetrack', updateHandler);\n        tracks.removeEventListener('addtrack', updateHandler);\n        tracks.removeEventListener('labelchange', updateHandler);\n      });\n    }\n  }\n  Component$1.registerComponent('TrackButton', TrackButton);\n\n  /**\n   * @file menu-keys.js\n   */\n\n  /**\n    * All keys used for operation of a menu (`MenuButton`, `Menu`, and `MenuItem`)\n    * Note that 'Enter' and 'Space' are not included here (otherwise they would\n    * prevent the `MenuButton` and `MenuItem` from being keyboard-clickable)\n   *\n    * @typedef MenuKeys\n    * @array\n    */\n  const MenuKeys = ['Tab', 'Esc', 'Up', 'Down', 'Right', 'Left'];\n\n  /**\n   * @file menu-item.js\n   */\n\n  /**\n   * The component for a menu item. `<li>`\n   *\n   * @extends ClickableComponent\n   */\n  class MenuItem extends ClickableComponent {\n    /**\n     * Creates an instance of the this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     *\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.selectable = options.selectable;\n      this.isSelected_ = options.selected || false;\n      this.multiSelectable = options.multiSelectable;\n      this.selected(this.isSelected_);\n      if (this.selectable) {\n        if (this.multiSelectable) {\n          this.el_.setAttribute('role', 'menuitemcheckbox');\n        } else {\n          this.el_.setAttribute('role', 'menuitemradio');\n        }\n      } else {\n        this.el_.setAttribute('role', 'menuitem');\n      }\n    }\n\n    /**\n     * Create the `MenuItem's DOM element\n     *\n     * @param {string} [type=li]\n     *        Element's node type, not actually used, always set to `li`.\n     *\n     * @param {Object} [props={}]\n     *        An object of properties that should be set on the element\n     *\n     * @param {Object} [attrs={}]\n     *        An object of attributes that should be set on the element\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl(type, props, attrs) {\n      // The control is textual, not just an icon\n      this.nonIconControl = true;\n      const el = super.createEl('li', Object.assign({\n        className: 'vjs-menu-item',\n        tabIndex: -1\n      }, props), attrs);\n\n      // swap icon with menu item text.\n      el.replaceChild(createEl('span', {\n        className: 'vjs-menu-item-text',\n        textContent: this.localize(this.options_.label)\n      }), el.querySelector('.vjs-icon-placeholder'));\n      return el;\n    }\n\n    /**\n     * Ignore keys which are used by the menu, but pass any other ones up. See\n     * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      if (!MenuKeys.some(key => keycode.isEventKey(event, key))) {\n        // Pass keydown handling up for unused keys\n        super.handleKeyDown(event);\n      }\n    }\n\n    /**\n     * Any click on a `MenuItem` puts it into the selected state.\n     * See {@link ClickableComponent#handleClick} for instances where this is called.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      this.selected(true);\n    }\n\n    /**\n     * Set the state for this menu item as selected or not.\n     *\n     * @param {boolean} selected\n     *        if the menu item is selected or not\n     */\n    selected(selected) {\n      if (this.selectable) {\n        if (selected) {\n          this.addClass('vjs-selected');\n          this.el_.setAttribute('aria-checked', 'true');\n          // aria-checked isn't fully supported by browsers/screen readers,\n          // so indicate selected state to screen reader in the control text.\n          this.controlText(', selected');\n          this.isSelected_ = true;\n        } else {\n          this.removeClass('vjs-selected');\n          this.el_.setAttribute('aria-checked', 'false');\n          // Indicate un-selected state to screen reader\n          this.controlText('');\n          this.isSelected_ = false;\n        }\n      }\n    }\n  }\n  Component$1.registerComponent('MenuItem', MenuItem);\n\n  /**\n   * @file text-track-menu-item.js\n   */\n\n  /**\n   * The specific menu item type for selecting a language within a text track kind\n   *\n   * @extends MenuItem\n   */\n  class TextTrackMenuItem extends MenuItem {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      const track = options.track;\n      const tracks = player.textTracks();\n\n      // Modify options for parent MenuItem class's init.\n      options.label = track.label || track.language || 'Unknown';\n      options.selected = track.mode === 'showing';\n      super(player, options);\n      this.track = track;\n      // Determine the relevant kind(s) of tracks for this component and filter\n      // out empty kinds.\n      this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);\n      const changeHandler = (...args) => {\n        this.handleTracksChange.apply(this, args);\n      };\n      const selectedLanguageChangeHandler = (...args) => {\n        this.handleSelectedLanguageChange.apply(this, args);\n      };\n      player.on(['loadstart', 'texttrackchange'], changeHandler);\n      tracks.addEventListener('change', changeHandler);\n      tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n      this.on('dispose', function () {\n        player.off(['loadstart', 'texttrackchange'], changeHandler);\n        tracks.removeEventListener('change', changeHandler);\n        tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n      });\n\n      // iOS7 doesn't dispatch change events to TextTrackLists when an\n      // associated track's mode changes. Without something like\n      // Object.observe() (also not present on iOS7), it's not\n      // possible to detect changes to the mode attribute and polyfill\n      // the change event. As a poor substitute, we manually dispatch\n      // change events whenever the controls modify the mode.\n      if (tracks.onchange === undefined) {\n        let event;\n        this.on(['tap', 'click'], function () {\n          if (typeof window.Event !== 'object') {\n            // Android 2.3 throws an Illegal Constructor error for window.Event\n            try {\n              event = new window.Event('change');\n            } catch (err) {\n              // continue regardless of error\n            }\n          }\n          if (!event) {\n            event = document.createEvent('Event');\n            event.initEvent('change', true, true);\n          }\n          tracks.dispatchEvent(event);\n        });\n      }\n\n      // set the default state based on current tracks\n      this.handleTracksChange();\n    }\n\n    /**\n     * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      const referenceTrack = this.track;\n      const tracks = this.player_.textTracks();\n      super.handleClick(event);\n      if (!tracks) {\n        return;\n      }\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n\n        // If the track from the text tracks list is not of the right kind,\n        // skip it. We do not want to affect tracks of incompatible kind(s).\n        if (this.kinds.indexOf(track.kind) === -1) {\n          continue;\n        }\n\n        // If this text track is the component's track and it is not showing,\n        // set it to showing.\n        if (track === referenceTrack) {\n          if (track.mode !== 'showing') {\n            track.mode = 'showing';\n          }\n\n          // If this text track is not the component's track and it is not\n          // disabled, set it to disabled.\n        } else if (track.mode !== 'disabled') {\n          track.mode = 'disabled';\n        }\n      }\n    }\n\n    /**\n     * Handle text track list change\n     *\n     * @param {EventTarget~Event} event\n     *        The `change` event that caused this function to be called.\n     *\n     * @listens TextTrackList#change\n     */\n    handleTracksChange(event) {\n      const shouldBeSelected = this.track.mode === 'showing';\n\n      // Prevent redundant selected() calls because they may cause\n      // screen readers to read the appended control text unnecessarily\n      if (shouldBeSelected !== this.isSelected_) {\n        this.selected(shouldBeSelected);\n      }\n    }\n    handleSelectedLanguageChange(event) {\n      if (this.track.mode === 'showing') {\n        const selectedLanguage = this.player_.cache_.selectedLanguage;\n\n        // Don't replace the kind of track across the same language\n        if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n          return;\n        }\n        this.player_.cache_.selectedLanguage = {\n          enabled: true,\n          language: this.track.language,\n          kind: this.track.kind\n        };\n      }\n    }\n    dispose() {\n      // remove reference to track object on dispose\n      this.track = null;\n      super.dispose();\n    }\n  }\n  Component$1.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n\n  /**\n   * @file off-text-track-menu-item.js\n   */\n\n  /**\n   * A special menu item for turning of a specific type of text track\n   *\n   * @extends TextTrackMenuItem\n   */\n  class OffTextTrackMenuItem extends TextTrackMenuItem {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      // Create pseudo track info\n      // Requires options['kind']\n      options.track = {\n        player,\n        // it is no longer necessary to store `kind` or `kinds` on the track itself\n        // since they are now stored in the `kinds` property of all instances of\n        // TextTrackMenuItem, but this will remain for backwards compatibility\n        kind: options.kind,\n        kinds: options.kinds,\n        default: false,\n        mode: 'disabled'\n      };\n      if (!options.kinds) {\n        options.kinds = [options.kind];\n      }\n      if (options.label) {\n        options.track.label = options.label;\n      } else {\n        options.track.label = options.kinds.join(' and ') + ' off';\n      }\n\n      // MenuItem is selectable\n      options.selectable = true;\n      // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n      options.multiSelectable = false;\n      super(player, options);\n    }\n\n    /**\n     * Handle text track change\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to run\n     */\n    handleTracksChange(event) {\n      const tracks = this.player().textTracks();\n      let shouldBeSelected = true;\n      for (let i = 0, l = tracks.length; i < l; i++) {\n        const track = tracks[i];\n        if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n          shouldBeSelected = false;\n          break;\n        }\n      }\n\n      // Prevent redundant selected() calls because they may cause\n      // screen readers to read the appended control text unnecessarily\n      if (shouldBeSelected !== this.isSelected_) {\n        this.selected(shouldBeSelected);\n      }\n    }\n    handleSelectedLanguageChange(event) {\n      const tracks = this.player().textTracks();\n      let allHidden = true;\n      for (let i = 0, l = tracks.length; i < l; i++) {\n        const track = tracks[i];\n        if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n          allHidden = false;\n          break;\n        }\n      }\n      if (allHidden) {\n        this.player_.cache_.selectedLanguage = {\n          enabled: false\n        };\n      }\n    }\n  }\n  Component$1.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n\n  /**\n   * @file text-track-button.js\n   */\n\n  /**\n   * The base class for buttons that toggle specific text track types (e.g. subtitles)\n   *\n   * @extends MenuButton\n   */\n  class TextTrackButton extends TrackButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     */\n    constructor(player, options = {}) {\n      options.tracks = player.textTracks();\n      super(player, options);\n    }\n\n    /**\n     * Create a menu item for each text track\n     *\n     * @param {TextTrackMenuItem[]} [items=[]]\n     *        Existing array of items to use during creation\n     *\n     * @return {TextTrackMenuItem[]}\n     *         Array of menu items that were created\n     */\n    createItems(items = [], TrackMenuItem = TextTrackMenuItem) {\n      // Label is an override for the [track] off label\n      // USed to localise captions/subtitles\n      let label;\n      if (this.label_) {\n        label = `${this.label_} off`;\n      }\n      // Add an OFF menu item to turn all tracks off\n      items.push(new OffTextTrackMenuItem(this.player_, {\n        kinds: this.kinds_,\n        kind: this.kind_,\n        label\n      }));\n      this.hideThreshold_ += 1;\n      const tracks = this.player_.textTracks();\n      if (!Array.isArray(this.kinds_)) {\n        this.kinds_ = [this.kind_];\n      }\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n\n        // only add tracks that are of an appropriate kind and have a label\n        if (this.kinds_.indexOf(track.kind) > -1) {\n          const item = new TrackMenuItem(this.player_, {\n            track,\n            kinds: this.kinds_,\n            kind: this.kind_,\n            // MenuItem is selectable\n            selectable: true,\n            // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n            multiSelectable: false\n          });\n          item.addClass(`vjs-${track.kind}-menu-item`);\n          items.push(item);\n        }\n      }\n      return items;\n    }\n  }\n  Component$1.registerComponent('TextTrackButton', TextTrackButton);\n\n  /**\n   * @file chapters-track-menu-item.js\n   */\n\n  /**\n   * The chapter track menu item\n   *\n   * @extends MenuItem\n   */\n  class ChaptersTrackMenuItem extends MenuItem {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      const track = options.track;\n      const cue = options.cue;\n      const currentTime = player.currentTime();\n\n      // Modify options for parent MenuItem class's init.\n      options.selectable = true;\n      options.multiSelectable = false;\n      options.label = cue.text;\n      options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n      super(player, options);\n      this.track = track;\n      this.cue = cue;\n    }\n\n    /**\n     * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      super.handleClick();\n      this.player_.currentTime(this.cue.startTime);\n    }\n  }\n  Component$1.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n\n  /**\n   * @file chapters-button.js\n   */\n\n  /**\n   * The button component for toggling and selecting chapters\n   * Chapters act much differently than other text tracks\n   * Cues are navigation vs. other tracks of alternative languages\n   *\n   * @extends TextTrackButton\n   */\n  class ChaptersButton extends TextTrackButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        The function to call when this function is ready.\n     */\n    constructor(player, options, ready) {\n      super(player, options, ready);\n      this.selectCurrentItem_ = () => {\n        this.items.forEach(item => {\n          item.selected(this.track_.activeCues[0] === item.cue);\n        });\n      };\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-chapters-button ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;\n    }\n\n    /**\n     * Update the menu based on the current state of its items.\n     *\n     * @param {EventTarget~Event} [event]\n     *        An event that triggered this function to run.\n     *\n     * @listens TextTrackList#addtrack\n     * @listens TextTrackList#removetrack\n     * @listens TextTrackList#change\n     */\n    update(event) {\n      if (event && event.track && event.track.kind !== 'chapters') {\n        return;\n      }\n      const track = this.findChaptersTrack();\n      if (track !== this.track_) {\n        this.setTrack(track);\n        super.update();\n      } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {\n        // Update the menu initially or if the number of cues has changed since set\n        super.update();\n      }\n    }\n\n    /**\n     * Set the currently selected track for the chapters button.\n     *\n     * @param {TextTrack} track\n     *        The new track to select. Nothing will change if this is the currently selected\n     *        track.\n     */\n    setTrack(track) {\n      if (this.track_ === track) {\n        return;\n      }\n      if (!this.updateHandler_) {\n        this.updateHandler_ = this.update.bind(this);\n      }\n\n      // here this.track_ refers to the old track instance\n      if (this.track_) {\n        const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n        if (remoteTextTrackEl) {\n          remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n        }\n        this.track_.removeEventListener('cuechange', this.selectCurrentItem_);\n        this.track_ = null;\n      }\n      this.track_ = track;\n\n      // here this.track_ refers to the new track instance\n      if (this.track_) {\n        this.track_.mode = 'hidden';\n        const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n        if (remoteTextTrackEl) {\n          remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n        }\n        this.track_.addEventListener('cuechange', this.selectCurrentItem_);\n      }\n    }\n\n    /**\n     * Find the track object that is currently in use by this ChaptersButton\n     *\n     * @return {TextTrack|undefined}\n     *         The current track or undefined if none was found.\n     */\n    findChaptersTrack() {\n      const tracks = this.player_.textTracks() || [];\n      for (let i = tracks.length - 1; i >= 0; i--) {\n        // We will always choose the last track as our chaptersTrack\n        const track = tracks[i];\n        if (track.kind === this.kind_) {\n          return track;\n        }\n      }\n    }\n\n    /**\n     * Get the caption for the ChaptersButton based on the track label. This will also\n     * use the current tracks localized kind as a fallback if a label does not exist.\n     *\n     * @return {string}\n     *         The tracks current label or the localized track kind.\n     */\n    getMenuCaption() {\n      if (this.track_ && this.track_.label) {\n        return this.track_.label;\n      }\n      return this.localize(toTitleCase$1(this.kind_));\n    }\n\n    /**\n     * Create menu from chapter track\n     *\n     * @return {Menu}\n     *         New menu for the chapter buttons\n     */\n    createMenu() {\n      this.options_.title = this.getMenuCaption();\n      return super.createMenu();\n    }\n\n    /**\n     * Create a menu item for each text track\n     *\n     * @return {TextTrackMenuItem[]}\n     *         Array of menu items\n     */\n    createItems() {\n      const items = [];\n      if (!this.track_) {\n        return items;\n      }\n      const cues = this.track_.cues;\n      if (!cues) {\n        return items;\n      }\n      for (let i = 0, l = cues.length; i < l; i++) {\n        const cue = cues[i];\n        const mi = new ChaptersTrackMenuItem(this.player_, {\n          track: this.track_,\n          cue\n        });\n        items.push(mi);\n      }\n      return items;\n    }\n  }\n\n  /**\n   * `kind` of TextTrack to look for to associate it with this menu.\n   *\n   * @type {string}\n   * @private\n   */\n  ChaptersButton.prototype.kind_ = 'chapters';\n\n  /**\n   * The text that should display over the `ChaptersButton`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  ChaptersButton.prototype.controlText_ = 'Chapters';\n  Component$1.registerComponent('ChaptersButton', ChaptersButton);\n\n  /**\n   * @file descriptions-button.js\n   */\n\n  /**\n   * The button component for toggling and selecting descriptions\n   *\n   * @extends TextTrackButton\n   */\n  class DescriptionsButton extends TextTrackButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        The function to call when this component is ready.\n     */\n    constructor(player, options, ready) {\n      super(player, options, ready);\n      const tracks = player.textTracks();\n      const changeHandler = bind_(this, this.handleTracksChange);\n      tracks.addEventListener('change', changeHandler);\n      this.on('dispose', function () {\n        tracks.removeEventListener('change', changeHandler);\n      });\n    }\n\n    /**\n     * Handle text track change\n     *\n     * @param {EventTarget~Event} event\n     *        The event that caused this function to run\n     *\n     * @listens TextTrackList#change\n     */\n    handleTracksChange(event) {\n      const tracks = this.player().textTracks();\n      let disabled = false;\n\n      // Check whether a track of a different kind is showing\n      for (let i = 0, l = tracks.length; i < l; i++) {\n        const track = tracks[i];\n        if (track.kind !== this.kind_ && track.mode === 'showing') {\n          disabled = true;\n          break;\n        }\n      }\n\n      // If another track is showing, disable this menu button\n      if (disabled) {\n        this.disable();\n      } else {\n        this.enable();\n      }\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-descriptions-button ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;\n    }\n  }\n\n  /**\n   * `kind` of TextTrack to look for to associate it with this menu.\n   *\n   * @type {string}\n   * @private\n   */\n  DescriptionsButton.prototype.kind_ = 'descriptions';\n\n  /**\n   * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  DescriptionsButton.prototype.controlText_ = 'Descriptions';\n  Component$1.registerComponent('DescriptionsButton', DescriptionsButton);\n\n  /**\n   * @file subtitles-button.js\n   */\n\n  /**\n   * The button component for toggling and selecting subtitles\n   *\n   * @extends TextTrackButton\n   */\n  class SubtitlesButton extends TextTrackButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        The function to call when this component is ready.\n     */\n    constructor(player, options, ready) {\n      super(player, options, ready);\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-subtitles-button ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;\n    }\n  }\n\n  /**\n   * `kind` of TextTrack to look for to associate it with this menu.\n   *\n   * @type {string}\n   * @private\n   */\n  SubtitlesButton.prototype.kind_ = 'subtitles';\n\n  /**\n   * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  SubtitlesButton.prototype.controlText_ = 'Subtitles';\n  Component$1.registerComponent('SubtitlesButton', SubtitlesButton);\n\n  /**\n   * @file caption-settings-menu-item.js\n   */\n\n  /**\n   * The menu item for caption track settings menu\n   *\n   * @extends TextTrackMenuItem\n   */\n  class CaptionSettingsMenuItem extends TextTrackMenuItem {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      options.track = {\n        player,\n        kind: options.kind,\n        label: options.kind + ' settings',\n        selectable: false,\n        default: false,\n        mode: 'disabled'\n      };\n\n      // CaptionSettingsMenuItem has no concept of 'selected'\n      options.selectable = false;\n      options.name = 'CaptionSettingsMenuItem';\n      super(player, options);\n      this.addClass('vjs-texttrack-settings');\n      this.controlText(', opens ' + options.kind + ' settings dialog');\n    }\n\n    /**\n     * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      this.player().getChild('textTrackSettings').open();\n    }\n  }\n  Component$1.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n\n  /**\n   * @file captions-button.js\n   */\n\n  /**\n   * The button component for toggling and selecting captions\n   *\n   * @extends TextTrackButton\n   */\n  class CaptionsButton extends TextTrackButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        The function to call when this component is ready.\n     */\n    constructor(player, options, ready) {\n      super(player, options, ready);\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-captions-button ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-captions-button ${super.buildWrapperCSSClass()}`;\n    }\n\n    /**\n     * Create caption menu items\n     *\n     * @return {CaptionSettingsMenuItem[]}\n     *         The array of current menu items.\n     */\n    createItems() {\n      const items = [];\n      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n        items.push(new CaptionSettingsMenuItem(this.player_, {\n          kind: this.kind_\n        }));\n        this.hideThreshold_ += 1;\n      }\n      return super.createItems(items);\n    }\n  }\n\n  /**\n   * `kind` of TextTrack to look for to associate it with this menu.\n   *\n   * @type {string}\n   * @private\n   */\n  CaptionsButton.prototype.kind_ = 'captions';\n\n  /**\n   * The text that should display over the `CaptionsButton`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  CaptionsButton.prototype.controlText_ = 'Captions';\n  Component$1.registerComponent('CaptionsButton', CaptionsButton);\n\n  /**\n   * @file subs-caps-menu-item.js\n   */\n\n  /**\n   * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n   * in the SubsCapsMenu.\n   *\n   * @extends TextTrackMenuItem\n   */\n  class SubsCapsMenuItem extends TextTrackMenuItem {\n    createEl(type, props, attrs) {\n      const el = super.createEl(type, props, attrs);\n      const parentSpan = el.querySelector('.vjs-menu-item-text');\n      if (this.options_.track.kind === 'captions') {\n        parentSpan.appendChild(createEl('span', {\n          className: 'vjs-icon-placeholder'\n        }, {\n          'aria-hidden': true\n        }));\n        parentSpan.appendChild(createEl('span', {\n          className: 'vjs-control-text',\n          // space added as the text will visually flow with the\n          // label\n          textContent: ` ${this.localize('Captions')}`\n        }));\n      }\n      return el;\n    }\n  }\n  Component$1.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n\n  /**\n   * @file sub-caps-button.js\n   */\n  /**\n   * The button component for toggling and selecting captions and/or subtitles\n   *\n   * @extends TextTrackButton\n   */\n  class SubsCapsButton extends TextTrackButton {\n    constructor(player, options = {}) {\n      super(player, options);\n\n      // Although North America uses \"captions\" in most cases for\n      // \"captions and subtitles\" other locales use \"subtitles\"\n      this.label_ = 'subtitles';\n      if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(this.player_.language_) > -1) {\n        this.label_ = 'captions';\n      }\n      this.menuButton_.controlText(toTitleCase$1(this.label_));\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-subs-caps-button ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;\n    }\n\n    /**\n     * Create caption/subtitles menu items\n     *\n     * @return {CaptionSettingsMenuItem[]}\n     *         The array of current menu items.\n     */\n    createItems() {\n      let items = [];\n      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n        items.push(new CaptionSettingsMenuItem(this.player_, {\n          kind: this.label_\n        }));\n        this.hideThreshold_ += 1;\n      }\n      items = super.createItems(items, SubsCapsMenuItem);\n      return items;\n    }\n  }\n\n  /**\n   * `kind`s of TextTrack to look for to associate it with this menu.\n   *\n   * @type {array}\n   * @private\n   */\n  SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n\n  /**\n   * The text that should display over the `SubsCapsButton`s controls.\n   *\n   *\n   * @type {string}\n   * @protected\n   */\n  SubsCapsButton.prototype.controlText_ = 'Subtitles';\n  Component$1.registerComponent('SubsCapsButton', SubsCapsButton);\n\n  /**\n   * @file audio-track-menu-item.js\n   */\n\n  /**\n   * An {@link AudioTrack} {@link MenuItem}\n   *\n   * @extends MenuItem\n   */\n  class AudioTrackMenuItem extends MenuItem {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      const track = options.track;\n      const tracks = player.audioTracks();\n\n      // Modify options for parent MenuItem class's init.\n      options.label = track.label || track.language || 'Unknown';\n      options.selected = track.enabled;\n      super(player, options);\n      this.track = track;\n      this.addClass(`vjs-${track.kind}-menu-item`);\n      const changeHandler = (...args) => {\n        this.handleTracksChange.apply(this, args);\n      };\n      tracks.addEventListener('change', changeHandler);\n      this.on('dispose', () => {\n        tracks.removeEventListener('change', changeHandler);\n      });\n    }\n    createEl(type, props, attrs) {\n      const el = super.createEl(type, props, attrs);\n      const parentSpan = el.querySelector('.vjs-menu-item-text');\n      if (this.options_.track.kind === 'main-desc') {\n        parentSpan.appendChild(createEl('span', {\n          className: 'vjs-icon-placeholder'\n        }, {\n          'aria-hidden': true\n        }));\n        parentSpan.appendChild(createEl('span', {\n          className: 'vjs-control-text',\n          textContent: ' ' + this.localize('Descriptions')\n        }));\n      }\n      return el;\n    }\n\n    /**\n     * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n     * for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      super.handleClick(event);\n\n      // the audio track list will automatically toggle other tracks\n      // off for us.\n      this.track.enabled = true;\n\n      // when native audio tracks are used, we want to make sure that other tracks are turned off\n      if (this.player_.tech_.featuresNativeAudioTracks) {\n        const tracks = this.player_.audioTracks();\n        for (let i = 0; i < tracks.length; i++) {\n          const track = tracks[i];\n\n          // skip the current track since we enabled it above\n          if (track === this.track) {\n            continue;\n          }\n          track.enabled = track === this.track;\n        }\n      }\n    }\n\n    /**\n     * Handle any {@link AudioTrack} change.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The {@link AudioTrackList#change} event that caused this to run.\n     *\n     * @listens AudioTrackList#change\n     */\n    handleTracksChange(event) {\n      this.selected(this.track.enabled);\n    }\n  }\n  Component$1.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n\n  /**\n   * @file audio-track-button.js\n   */\n\n  /**\n   * The base class for buttons that toggle specific {@link AudioTrack} types.\n   *\n   * @extends TrackButton\n   */\n  class AudioTrackButton extends TrackButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options={}]\n     *        The key/value store of player options.\n     */\n    constructor(player, options = {}) {\n      options.tracks = player.audioTracks();\n      super(player, options);\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-audio-button ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-audio-button ${super.buildWrapperCSSClass()}`;\n    }\n\n    /**\n     * Create a menu item for each audio track\n     *\n     * @param {AudioTrackMenuItem[]} [items=[]]\n     *        An array of existing menu items to use.\n     *\n     * @return {AudioTrackMenuItem[]}\n     *         An array of menu items\n     */\n    createItems(items = []) {\n      // if there's only one audio track, there no point in showing it\n      this.hideThreshold_ = 1;\n      const tracks = this.player_.audioTracks();\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        items.push(new AudioTrackMenuItem(this.player_, {\n          track,\n          // MenuItem is selectable\n          selectable: true,\n          // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n          multiSelectable: false\n        }));\n      }\n      return items;\n    }\n  }\n\n  /**\n   * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  AudioTrackButton.prototype.controlText_ = 'Audio Track';\n  Component$1.registerComponent('AudioTrackButton', AudioTrackButton);\n\n  /**\n   * @file playback-rate-menu-item.js\n   */\n\n  /**\n   * The specific menu item type for selecting a playback rate.\n   *\n   * @extends MenuItem\n   */\n  class PlaybackRateMenuItem extends MenuItem {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      const label = options.rate;\n      const rate = parseFloat(label, 10);\n\n      // Modify options for parent MenuItem class's init.\n      options.label = label;\n      options.selected = rate === player.playbackRate();\n      options.selectable = true;\n      options.multiSelectable = false;\n      super(player, options);\n      this.label = label;\n      this.rate = rate;\n      this.on(player, 'ratechange', e => this.update(e));\n    }\n\n    /**\n     * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n     * {@link ClickableComponent} for more detailed information on what a click can be.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n      super.handleClick();\n      this.player().playbackRate(this.rate);\n    }\n\n    /**\n     * Update the PlaybackRateMenuItem when the playbackrate changes.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The `ratechange` event that caused this function to run.\n     *\n     * @listens Player#ratechange\n     */\n    update(event) {\n      this.selected(this.player().playbackRate() === this.rate);\n    }\n  }\n\n  /**\n   * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n   *\n   * @type {string}\n   * @private\n   */\n  PlaybackRateMenuItem.prototype.contentElType = 'button';\n  Component$1.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n\n  /**\n   * @file playback-rate-menu-button.js\n   */\n\n  /**\n   * The component for controlling the playback rate.\n   *\n   * @extends MenuButton\n   */\n  class PlaybackRateMenuButton extends MenuButton {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.menuButton_.el_.setAttribute('aria-describedby', this.labelElId_);\n      this.updateVisibility();\n      this.updateLabel();\n      this.on(player, 'loadstart', e => this.updateVisibility(e));\n      this.on(player, 'ratechange', e => this.updateLabel(e));\n      this.on(player, 'playbackrateschange', e => this.handlePlaybackRateschange(e));\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      const el = super.createEl();\n      this.labelElId_ = 'vjs-playback-rate-value-label-' + this.id_;\n      this.labelEl_ = createEl('div', {\n        className: 'vjs-playback-rate-value',\n        id: this.labelElId_,\n        textContent: '1x'\n      });\n      el.appendChild(this.labelEl_);\n      return el;\n    }\n    dispose() {\n      this.labelEl_ = null;\n      super.dispose();\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-playback-rate ${super.buildCSSClass()}`;\n    }\n    buildWrapperCSSClass() {\n      return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;\n    }\n\n    /**\n     * Create the list of menu items. Specific to each subclass.\n     *\n     */\n    createItems() {\n      const rates = this.playbackRates();\n      const items = [];\n      for (let i = rates.length - 1; i >= 0; i--) {\n        items.push(new PlaybackRateMenuItem(this.player(), {\n          rate: rates[i] + 'x'\n        }));\n      }\n      return items;\n    }\n\n    /**\n     * On playbackrateschange, update the menu to account for the new items.\n     *\n     * @listens Player#playbackrateschange\n     */\n    handlePlaybackRateschange(event) {\n      this.update();\n    }\n\n    /**\n     * Get possible playback rates\n     *\n     * @return {Array}\n     *         All possible playback rates\n     */\n    playbackRates() {\n      const player = this.player();\n      return player.playbackRates && player.playbackRates() || [];\n    }\n\n    /**\n     * Get whether playback rates is supported by the tech\n     * and an array of playback rates exists\n     *\n     * @return {boolean}\n     *         Whether changing playback rate is supported\n     */\n    playbackRateSupported() {\n      return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n    }\n\n    /**\n     * Hide playback rate controls when they're no playback rate options to select\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#loadstart\n     */\n    updateVisibility(event) {\n      if (this.playbackRateSupported()) {\n        this.removeClass('vjs-hidden');\n      } else {\n        this.addClass('vjs-hidden');\n      }\n    }\n\n    /**\n     * Update button label when rate changed\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#ratechange\n     */\n    updateLabel(event) {\n      if (this.playbackRateSupported()) {\n        this.labelEl_.textContent = this.player().playbackRate() + 'x';\n      }\n    }\n  }\n\n  /**\n   * The text that should display over the `PlaybackRateMenuButton`s controls.\n   *\n   * Added for localization.\n   *\n   * @type {string}\n   * @protected\n   */\n  PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\n  Component$1.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n\n  /**\n   * @file spacer.js\n   */\n\n  /**\n   * Just an empty spacer element that can be used as an append point for plugins, etc.\n   * Also can be used to create space between elements when necessary.\n   *\n   * @extends Component\n   */\n  class Spacer extends Component$1 {\n    /**\n    * Builds the default DOM `className`.\n    *\n    * @return {string}\n    *         The DOM `className` for this object.\n    */\n    buildCSSClass() {\n      return `vjs-spacer ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl(tag = 'div', props = {}, attributes = {}) {\n      if (!props.className) {\n        props.className = this.buildCSSClass();\n      }\n      return super.createEl(tag, props, attributes);\n    }\n  }\n  Component$1.registerComponent('Spacer', Spacer);\n\n  /**\n   * @file custom-control-spacer.js\n   */\n\n  /**\n   * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n   *\n   * @extends Spacer\n   */\n  class CustomControlSpacer extends Spacer {\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n      return `vjs-custom-control-spacer ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: this.buildCSSClass(),\n        // No-flex/table-cell mode requires there be some content\n        // in the cell to fill the remaining space of the table.\n        textContent: '\\u00a0'\n      });\n    }\n  }\n  Component$1.registerComponent('CustomControlSpacer', CustomControlSpacer);\n\n  /**\n   * @file control-bar.js\n   */\n\n  /**\n   * Container of main controls.\n   *\n   * @extends Component\n   */\n  class ControlBar extends Component$1 {\n    /**\n     * Create the `Component`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      return super.createEl('div', {\n        className: 'vjs-control-bar',\n        dir: 'ltr'\n      });\n    }\n  }\n\n  /**\n   * Default options for `ControlBar`\n   *\n   * @type {Object}\n   * @private\n   */\n  ControlBar.prototype.options_ = {\n    children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n  };\n  if ('exitPictureInPicture' in document) {\n    ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, 'pictureInPictureToggle');\n  }\n  Component$1.registerComponent('ControlBar', ControlBar);\n\n  /**\n   * @file error-display.js\n   */\n\n  /**\n   * A display that indicates an error has occurred. This means that the video\n   * is unplayable.\n   *\n   * @extends ModalDialog\n   */\n  class ErrorDisplay extends ModalDialog {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param  {Player} player\n     *         The `Player` that this class should be attached to.\n     *\n     * @param  {Object} [options]\n     *         The key/value store of player options.\n     */\n    constructor(player, options) {\n      super(player, options);\n      this.on(player, 'error', e => this.open(e));\n    }\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     *\n     * @deprecated Since version 5.\n     */\n    buildCSSClass() {\n      return `vjs-error-display ${super.buildCSSClass()}`;\n    }\n\n    /**\n     * Gets the localized error message based on the `Player`s error.\n     *\n     * @return {string}\n     *         The `Player`s error message localized or an empty string.\n     */\n    content() {\n      const error = this.player().error();\n      return error ? this.localize(error.message) : '';\n    }\n  }\n\n  /**\n   * The default options for an `ErrorDisplay`.\n   *\n   * @private\n   */\n  ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {\n    pauseOnOpen: false,\n    fillAlways: true,\n    temporary: false,\n    uncloseable: true\n  });\n  Component$1.registerComponent('ErrorDisplay', ErrorDisplay);\n\n  /**\n   * @file text-track-settings.js\n   */\n  const LOCAL_STORAGE_KEY$1 = 'vjs-text-track-settings';\n  const COLOR_BLACK = ['#000', 'Black'];\n  const COLOR_BLUE = ['#00F', 'Blue'];\n  const COLOR_CYAN = ['#0FF', 'Cyan'];\n  const COLOR_GREEN = ['#0F0', 'Green'];\n  const COLOR_MAGENTA = ['#F0F', 'Magenta'];\n  const COLOR_RED = ['#F00', 'Red'];\n  const COLOR_WHITE = ['#FFF', 'White'];\n  const COLOR_YELLOW = ['#FF0', 'Yellow'];\n  const OPACITY_OPAQUE = ['1', 'Opaque'];\n  const OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\n  const OPACITY_TRANS = ['0', 'Transparent'];\n\n  // Configuration for the various <select> elements in the DOM of this component.\n  //\n  // Possible keys include:\n  //\n  // `default`:\n  //   The default option index. Only needs to be provided if not zero.\n  // `parser`:\n  //   A function which is used to parse the value from the selected option in\n  //   a customized way.\n  // `selector`:\n  //   The selector used to find the associated <select> element.\n  const selectConfigs = {\n    backgroundColor: {\n      selector: '.vjs-bg-color > select',\n      id: 'captions-background-color-%s',\n      label: 'Color',\n      options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n    },\n    backgroundOpacity: {\n      selector: '.vjs-bg-opacity > select',\n      id: 'captions-background-opacity-%s',\n      label: 'Transparency',\n      options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n    },\n    color: {\n      selector: '.vjs-fg-color > select',\n      id: 'captions-foreground-color-%s',\n      label: 'Color',\n      options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n    },\n    edgeStyle: {\n      selector: '.vjs-edge-style > select',\n      id: '%s',\n      label: 'Text Edge Style',\n      options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\n    },\n    fontFamily: {\n      selector: '.vjs-font-family > select',\n      id: 'captions-font-family-%s',\n      label: 'Font Family',\n      options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n    },\n    fontPercent: {\n      selector: '.vjs-font-percent > select',\n      id: 'captions-font-size-%s',\n      label: 'Font Size',\n      options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n      default: 2,\n      parser: v => v === '1.00' ? null : Number(v)\n    },\n    textOpacity: {\n      selector: '.vjs-text-opacity > select',\n      id: 'captions-foreground-opacity-%s',\n      label: 'Transparency',\n      options: [OPACITY_OPAQUE, OPACITY_SEMI]\n    },\n    // Options for this object are defined below.\n    windowColor: {\n      selector: '.vjs-window-color > select',\n      id: 'captions-window-color-%s',\n      label: 'Color'\n    },\n    // Options for this object are defined below.\n    windowOpacity: {\n      selector: '.vjs-window-opacity > select',\n      id: 'captions-window-opacity-%s',\n      label: 'Transparency',\n      options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n    }\n  };\n  selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n\n  /**\n   * Get the actual value of an option.\n   *\n   * @param  {string} value\n   *         The value to get\n   *\n   * @param  {Function} [parser]\n   *         Optional function to adjust the value.\n   *\n   * @return {Mixed}\n   *         - Will be `undefined` if no value exists\n   *         - Will be `undefined` if the given value is \"none\".\n   *         - Will be the actual value otherwise.\n   *\n   * @private\n   */\n  function parseOptionValue(value, parser) {\n    if (parser) {\n      value = parser(value);\n    }\n    if (value && value !== 'none') {\n      return value;\n    }\n  }\n\n  /**\n   * Gets the value of the selected <option> element within a <select> element.\n   *\n   * @param  {Element} el\n   *         the element to look in\n   *\n   * @param  {Function} [parser]\n   *         Optional function to adjust the value.\n   *\n   * @return {Mixed}\n   *         - Will be `undefined` if no value exists\n   *         - Will be `undefined` if the given value is \"none\".\n   *         - Will be the actual value otherwise.\n   *\n   * @private\n   */\n  function getSelectedOptionValue(el, parser) {\n    const value = el.options[el.options.selectedIndex].value;\n    return parseOptionValue(value, parser);\n  }\n\n  /**\n   * Sets the selected <option> element within a <select> element based on a\n   * given value.\n   *\n   * @param {Element} el\n   *        The element to look in.\n   *\n   * @param {string} value\n   *        the property to look on.\n   *\n   * @param {Function} [parser]\n   *        Optional function to adjust the value before comparing.\n   *\n   * @private\n   */\n  function setSelectedOption(el, value, parser) {\n    if (!value) {\n      return;\n    }\n    for (let i = 0; i < el.options.length; i++) {\n      if (parseOptionValue(el.options[i].value, parser) === value) {\n        el.selectedIndex = i;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Manipulate Text Tracks settings.\n   *\n   * @extends ModalDialog\n   */\n  class TextTrackSettings extends ModalDialog {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *         The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *         The key/value store of player options.\n     */\n    constructor(player, options) {\n      options.temporary = false;\n      super(player, options);\n      this.updateDisplay = this.updateDisplay.bind(this);\n\n      // fill the modal and pretend we have opened it\n      this.fill();\n      this.hasBeenOpened_ = this.hasBeenFilled_ = true;\n      this.endDialog = createEl('p', {\n        className: 'vjs-control-text',\n        textContent: this.localize('End of dialog window.')\n      });\n      this.el().appendChild(this.endDialog);\n      this.setDefaults();\n\n      // Grab `persistTextTrackSettings` from the player options if not passed in child options\n      if (options.persistTextTrackSettings === undefined) {\n        this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;\n      }\n      this.on(this.$('.vjs-done-button'), 'click', () => {\n        this.saveSettings();\n        this.close();\n      });\n      this.on(this.$('.vjs-default-button'), 'click', () => {\n        this.setDefaults();\n        this.updateDisplay();\n      });\n      each(selectConfigs, config => {\n        this.on(this.$(config.selector), 'change', this.updateDisplay);\n      });\n      if (this.options_.persistTextTrackSettings) {\n        this.restoreSettings();\n      }\n    }\n    dispose() {\n      this.endDialog = null;\n      super.dispose();\n    }\n\n    /**\n     * Create a <select> element with configured options.\n     *\n     * @param {string} key\n     *        Configuration key to use during creation.\n     *\n     * @return {string}\n     *         An HTML string.\n     *\n     * @private\n     */\n    createElSelect_(key, legendId = '', type = 'label') {\n      const config = selectConfigs[key];\n      const id = config.id.replace('%s', this.id_);\n      const selectLabelledbyIds = [legendId, id].join(' ').trim();\n      return [`<${type} id=\"${id}\" class=\"${type === 'label' ? 'vjs-label' : ''}\">`, this.localize(config.label), `</${type}>`, `<select aria-labelledby=\"${selectLabelledbyIds}\">`].concat(config.options.map(o => {\n        const optionId = id + '-' + o[1].replace(/\\W+/g, '');\n        return [`<option id=\"${optionId}\" value=\"${o[0]}\" `, `aria-labelledby=\"${selectLabelledbyIds} ${optionId}\">`, this.localize(o[1]), '</option>'].join('');\n      })).concat('</select>').join('');\n    }\n\n    /**\n     * Create foreground color element for the component\n     *\n     * @return {string}\n     *         An HTML string.\n     *\n     * @private\n     */\n    createElFgColor_() {\n      const legendId = `captions-text-legend-${this.id_}`;\n      return ['<fieldset class=\"vjs-fg-color vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n    }\n\n    /**\n     * Create background color element for the component\n     *\n     * @return {string}\n     *         An HTML string.\n     *\n     * @private\n     */\n    createElBgColor_() {\n      const legendId = `captions-background-${this.id_}`;\n      return ['<fieldset class=\"vjs-bg-color vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n    }\n\n    /**\n     * Create window color element for the component\n     *\n     * @return {string}\n     *         An HTML string.\n     *\n     * @private\n     */\n    createElWinColor_() {\n      const legendId = `captions-window-${this.id_}`;\n      return ['<fieldset class=\"vjs-window-color vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n    }\n\n    /**\n     * Create color elements for the component\n     *\n     * @return {Element}\n     *         The element that was created\n     *\n     * @private\n     */\n    createElColors_() {\n      return createEl('div', {\n        className: 'vjs-track-settings-colors',\n        innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n      });\n    }\n\n    /**\n     * Create font elements for the component\n     *\n     * @return {Element}\n     *         The element that was created.\n     *\n     * @private\n     */\n    createElFont_() {\n      return createEl('div', {\n        className: 'vjs-track-settings-font',\n        innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n      });\n    }\n\n    /**\n     * Create controls for the component\n     *\n     * @return {Element}\n     *         The element that was created.\n     *\n     * @private\n     */\n    createElControls_() {\n      const defaultsDescription = this.localize('restore all settings to the default values');\n      return createEl('div', {\n        className: 'vjs-track-settings-controls',\n        innerHTML: [`<button type=\"button\" class=\"vjs-default-button\" title=\"${defaultsDescription}\">`, this.localize('Reset'), `<span class=\"vjs-control-text\"> ${defaultsDescription}</span>`, '</button>', `<button type=\"button\" class=\"vjs-done-button\">${this.localize('Done')}</button>`].join('')\n      });\n    }\n    content() {\n      return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n    }\n    label() {\n      return this.localize('Caption Settings Dialog');\n    }\n    description() {\n      return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n    }\n    buildCSSClass() {\n      return super.buildCSSClass() + ' vjs-text-track-settings';\n    }\n\n    /**\n     * Gets an object of text track settings (or null).\n     *\n     * @return {Object}\n     *         An object with config values parsed from the DOM or localStorage.\n     */\n    getValues() {\n      return reduce(selectConfigs, (accum, config, key) => {\n        const value = getSelectedOptionValue(this.$(config.selector), config.parser);\n        if (value !== undefined) {\n          accum[key] = value;\n        }\n        return accum;\n      }, {});\n    }\n\n    /**\n     * Sets text track settings from an object of values.\n     *\n     * @param {Object} values\n     *        An object with config values parsed from the DOM or localStorage.\n     */\n    setValues(values) {\n      each(selectConfigs, (config, key) => {\n        setSelectedOption(this.$(config.selector), values[key], config.parser);\n      });\n    }\n\n    /**\n     * Sets all `<select>` elements to their default values.\n     */\n    setDefaults() {\n      each(selectConfigs, config => {\n        const index = config.hasOwnProperty('default') ? config.default : 0;\n        this.$(config.selector).selectedIndex = index;\n      });\n    }\n\n    /**\n     * Restore texttrack settings from localStorage\n     */\n    restoreSettings() {\n      let values;\n      try {\n        values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY$1));\n      } catch (err) {\n        log$1.warn(err);\n      }\n      if (values) {\n        this.setValues(values);\n      }\n    }\n\n    /**\n     * Save text track settings to localStorage\n     */\n    saveSettings() {\n      if (!this.options_.persistTextTrackSettings) {\n        return;\n      }\n      const values = this.getValues();\n      try {\n        if (Object.keys(values).length) {\n          window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values));\n        } else {\n          window.localStorage.removeItem(LOCAL_STORAGE_KEY$1);\n        }\n      } catch (err) {\n        log$1.warn(err);\n      }\n    }\n\n    /**\n     * Update display of text track settings\n     */\n    updateDisplay() {\n      const ttDisplay = this.player_.getChild('textTrackDisplay');\n      if (ttDisplay) {\n        ttDisplay.updateDisplay();\n      }\n    }\n\n    /**\n     * conditionally blur the element and refocus the captions button\n     *\n     * @private\n     */\n    conditionalBlur_() {\n      this.previouslyActiveEl_ = null;\n      const cb = this.player_.controlBar;\n      const subsCapsBtn = cb && cb.subsCapsButton;\n      const ccBtn = cb && cb.captionsButton;\n      if (subsCapsBtn) {\n        subsCapsBtn.focus();\n      } else if (ccBtn) {\n        ccBtn.focus();\n      }\n    }\n  }\n  Component$1.registerComponent('TextTrackSettings', TextTrackSettings);\n\n  /**\n   * @file resize-manager.js\n   */\n\n  /**\n   * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\n   *\n   * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\n   *\n   * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\n   * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\n   *\n   * @example <caption>How to disable the resize manager</caption>\n   * const player = videojs('#vid', {\n   *   resizeManager: false\n   * });\n   *\n   * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\n   *\n   * @extends Component\n   */\n  class ResizeManager extends Component$1 {\n    /**\n     * Create the ResizeManager.\n     *\n     * @param {Object} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of ResizeManager options.\n     *\n     * @param {Object} [options.ResizeObserver]\n     *        A polyfill for ResizeObserver can be passed in here.\n     *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\n     */\n    constructor(player, options) {\n      let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;\n\n      // if `null` was passed, we want to disable the ResizeObserver\n      if (options.ResizeObserver === null) {\n        RESIZE_OBSERVER_AVAILABLE = false;\n      }\n\n      // Only create an element when ResizeObserver isn't available\n      const options_ = merge$2({\n        createEl: !RESIZE_OBSERVER_AVAILABLE,\n        reportTouchActivity: false\n      }, options);\n      super(player, options_);\n      this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;\n      this.loadListener_ = null;\n      this.resizeObserver_ = null;\n      this.debouncedHandler_ = debounce(() => {\n        this.resizeHandler();\n      }, 100, false, this);\n      if (RESIZE_OBSERVER_AVAILABLE) {\n        this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);\n        this.resizeObserver_.observe(player.el());\n      } else {\n        this.loadListener_ = () => {\n          if (!this.el_ || !this.el_.contentWindow) {\n            return;\n          }\n          const debouncedHandler_ = this.debouncedHandler_;\n          let unloadListener_ = this.unloadListener_ = function () {\n            off(this, 'resize', debouncedHandler_);\n            off(this, 'unload', unloadListener_);\n            unloadListener_ = null;\n          };\n\n          // safari and edge can unload the iframe before resizemanager dispose\n          // we have to dispose of event handlers correctly before that happens\n          on(this.el_.contentWindow, 'unload', unloadListener_);\n          on(this.el_.contentWindow, 'resize', debouncedHandler_);\n        };\n        this.one('load', this.loadListener_);\n      }\n    }\n    createEl() {\n      return super.createEl('iframe', {\n        className: 'vjs-resize-manager',\n        tabIndex: -1,\n        title: this.localize('No content')\n      }, {\n        'aria-hidden': 'true'\n      });\n    }\n\n    /**\n     * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\n     *\n     * @fires Player#playerresize\n     */\n    resizeHandler() {\n      /**\n       * Called when the player size has changed\n       *\n       * @event Player#playerresize\n       * @type {EventTarget~Event}\n       */\n      // make sure player is still around to trigger\n      // prevents this from causing an error after dispose\n      if (!this.player_ || !this.player_.trigger) {\n        return;\n      }\n      this.player_.trigger('playerresize');\n    }\n    dispose() {\n      if (this.debouncedHandler_) {\n        this.debouncedHandler_.cancel();\n      }\n      if (this.resizeObserver_) {\n        if (this.player_.el()) {\n          this.resizeObserver_.unobserve(this.player_.el());\n        }\n        this.resizeObserver_.disconnect();\n      }\n      if (this.loadListener_) {\n        this.off('load', this.loadListener_);\n      }\n      if (this.el_ && this.el_.contentWindow && this.unloadListener_) {\n        this.unloadListener_.call(this.el_.contentWindow);\n      }\n      this.ResizeObserver = null;\n      this.resizeObserver = null;\n      this.debouncedHandler_ = null;\n      this.loadListener_ = null;\n      super.dispose();\n    }\n  }\n  Component$1.registerComponent('ResizeManager', ResizeManager);\n\n  const defaults = {\n    trackingThreshold: 20,\n    liveTolerance: 15\n  };\n\n  /*\n    track when we are at the live edge, and other helpers for live playback */\n\n  /**\n   * A class for checking live current time and determining when the player\n   * is at or behind the live edge.\n   */\n  class LiveTracker extends Component$1 {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param {Player} player\n     *        The `Player` that this class should be attached to.\n     *\n     * @param {Object} [options]\n     *        The key/value store of player options.\n     *\n     * @param {number} [options.trackingThreshold=20]\n     *        Number of seconds of live window (seekableEnd - seekableStart) that\n     *        media needs to have before the liveui will be shown.\n     *\n     * @param {number} [options.liveTolerance=15]\n     *        Number of seconds behind live that we have to be\n     *        before we will be considered non-live. Note that this will only\n     *        be used when playing at the live edge. This allows large seekable end\n     *        changes to not effect wether we are live or not.\n     */\n    constructor(player, options) {\n      // LiveTracker does not need an element\n      const options_ = merge$2(defaults, options, {\n        createEl: false\n      });\n      super(player, options_);\n      this.trackLiveHandler_ = () => this.trackLive_();\n      this.handlePlay_ = e => this.handlePlay(e);\n      this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e);\n      this.handleSeeked_ = e => this.handleSeeked(e);\n      this.seekToLiveEdge_ = e => this.seekToLiveEdge(e);\n      this.reset_();\n      this.on(this.player_, 'durationchange', e => this.handleDurationchange(e));\n      // we should try to toggle tracking on canplay as native playback engines, like Safari\n      // may not have the proper values for things like seekableEnd until then\n      this.on(this.player_, 'canplay', () => this.toggleTracking());\n    }\n\n    /**\n     * all the functionality for tracking when seek end changes\n     * and for tracking how far past seek end we should be\n     */\n    trackLive_() {\n      const seekable = this.player_.seekable();\n\n      // skip undefined seekable\n      if (!seekable || !seekable.length) {\n        return;\n      }\n      const newTime = Number(window.performance.now().toFixed(4));\n      const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;\n      this.lastTime_ = newTime;\n      this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;\n      const liveCurrentTime = this.liveCurrentTime();\n      const currentTime = this.player_.currentTime();\n\n      // we are behind live if any are true\n      // 1. the player is paused\n      // 2. the user seeked to a location 2 seconds away from live\n      // 3. the difference between live and current time is greater\n      //    liveTolerance which defaults to 15s\n      let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;\n\n      // we cannot be behind if\n      // 1. until we have not seen a timeupdate yet\n      // 2. liveCurrentTime is Infinity, which happens on Android and Native Safari\n      if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {\n        isBehind = false;\n      }\n      if (isBehind !== this.behindLiveEdge_) {\n        this.behindLiveEdge_ = isBehind;\n        this.trigger('liveedgechange');\n      }\n    }\n\n    /**\n     * handle a durationchange event on the player\n     * and start/stop tracking accordingly.\n     */\n    handleDurationchange() {\n      this.toggleTracking();\n    }\n\n    /**\n     * start/stop tracking\n     */\n    toggleTracking() {\n      if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {\n        if (this.player_.options_.liveui) {\n          this.player_.addClass('vjs-liveui');\n        }\n        this.startTracking();\n      } else {\n        this.player_.removeClass('vjs-liveui');\n        this.stopTracking();\n      }\n    }\n\n    /**\n     * start tracking live playback\n     */\n    startTracking() {\n      if (this.isTracking()) {\n        return;\n      }\n\n      // If we haven't seen a timeupdate, we need to check whether playback\n      // began before this component started tracking. This can happen commonly\n      // when using autoplay.\n      if (!this.timeupdateSeen_) {\n        this.timeupdateSeen_ = this.player_.hasStarted();\n      }\n      this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);\n      this.trackLive_();\n      this.on(this.player_, ['play', 'pause'], this.trackLiveHandler_);\n      if (!this.timeupdateSeen_) {\n        this.one(this.player_, 'play', this.handlePlay_);\n        this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\n      } else {\n        this.on(this.player_, 'seeked', this.handleSeeked_);\n      }\n    }\n\n    /**\n     * handle the first timeupdate on the player if it wasn't already playing\n     * when live tracker started tracking.\n     */\n    handleFirstTimeupdate() {\n      this.timeupdateSeen_ = true;\n      this.on(this.player_, 'seeked', this.handleSeeked_);\n    }\n\n    /**\n     * Keep track of what time a seek starts, and listen for seeked\n     * to find where a seek ends.\n     */\n    handleSeeked() {\n      const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());\n      this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;\n      this.nextSeekedFromUser_ = false;\n      this.trackLive_();\n    }\n\n    /**\n     * handle the first play on the player, and make sure that we seek\n     * right to the live edge.\n     */\n    handlePlay() {\n      this.one(this.player_, 'timeupdate', this.seekToLiveEdge_);\n    }\n\n    /**\n     * Stop tracking, and set all internal variables to\n     * their initial value.\n     */\n    reset_() {\n      this.lastTime_ = -1;\n      this.pastSeekEnd_ = 0;\n      this.lastSeekEnd_ = -1;\n      this.behindLiveEdge_ = true;\n      this.timeupdateSeen_ = false;\n      this.seekedBehindLive_ = false;\n      this.nextSeekedFromUser_ = false;\n      this.clearInterval(this.trackingInterval_);\n      this.trackingInterval_ = null;\n      this.off(this.player_, ['play', 'pause'], this.trackLiveHandler_);\n      this.off(this.player_, 'seeked', this.handleSeeked_);\n      this.off(this.player_, 'play', this.handlePlay_);\n      this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\n      this.off(this.player_, 'timeupdate', this.seekToLiveEdge_);\n    }\n\n    /**\n     * The next seeked event is from the user. Meaning that any seek\n     * > 2s behind live will be considered behind live for real and\n     * liveTolerance will be ignored.\n     */\n    nextSeekedFromUser() {\n      this.nextSeekedFromUser_ = true;\n    }\n\n    /**\n     * stop tracking live playback\n     */\n    stopTracking() {\n      if (!this.isTracking()) {\n        return;\n      }\n      this.reset_();\n      this.trigger('liveedgechange');\n    }\n\n    /**\n     * A helper to get the player seekable end\n     * so that we don't have to null check everywhere\n     *\n     * @return {number}\n     *         The furthest seekable end or Infinity.\n     */\n    seekableEnd() {\n      const seekable = this.player_.seekable();\n      const seekableEnds = [];\n      let i = seekable ? seekable.length : 0;\n      while (i--) {\n        seekableEnds.push(seekable.end(i));\n      }\n\n      // grab the furthest seekable end after sorting, or if there are none\n      // default to Infinity\n      return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;\n    }\n\n    /**\n     * A helper to get the player seekable start\n     * so that we don't have to null check everywhere\n     *\n     * @return {number}\n     *         The earliest seekable start or 0.\n     */\n    seekableStart() {\n      const seekable = this.player_.seekable();\n      const seekableStarts = [];\n      let i = seekable ? seekable.length : 0;\n      while (i--) {\n        seekableStarts.push(seekable.start(i));\n      }\n\n      // grab the first seekable start after sorting, or if there are none\n      // default to 0\n      return seekableStarts.length ? seekableStarts.sort()[0] : 0;\n    }\n\n    /**\n     * Get the live time window aka\n     * the amount of time between seekable start and\n     * live current time.\n     *\n     * @return {number}\n     *         The amount of seconds that are seekable in\n     *         the live video.\n     */\n    liveWindow() {\n      const liveCurrentTime = this.liveCurrentTime();\n\n      // if liveCurrenTime is Infinity then we don't have a liveWindow at all\n      if (liveCurrentTime === Infinity) {\n        return 0;\n      }\n      return liveCurrentTime - this.seekableStart();\n    }\n\n    /**\n     * Determines if the player is live, only checks if this component\n     * is tracking live playback or not\n     *\n     * @return {boolean}\n     *         Wether liveTracker is tracking\n     */\n    isLive() {\n      return this.isTracking();\n    }\n\n    /**\n     * Determines if currentTime is at the live edge and won't fall behind\n     * on each seekableendchange\n     *\n     * @return {boolean}\n     *         Wether playback is at the live edge\n     */\n    atLiveEdge() {\n      return !this.behindLiveEdge();\n    }\n\n    /**\n     * get what we expect the live current time to be\n     *\n     * @return {number}\n     *         The expected live current time\n     */\n    liveCurrentTime() {\n      return this.pastSeekEnd() + this.seekableEnd();\n    }\n\n    /**\n     * The number of seconds that have occured after seekable end\n     * changed. This will be reset to 0 once seekable end changes.\n     *\n     * @return {number}\n     *         Seconds past the current seekable end\n     */\n    pastSeekEnd() {\n      const seekableEnd = this.seekableEnd();\n      if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {\n        this.pastSeekEnd_ = 0;\n      }\n      this.lastSeekEnd_ = seekableEnd;\n      return this.pastSeekEnd_;\n    }\n\n    /**\n     * If we are currently behind the live edge, aka currentTime will be\n     * behind on a seekableendchange\n     *\n     * @return {boolean}\n     *         If we are behind the live edge\n     */\n    behindLiveEdge() {\n      return this.behindLiveEdge_;\n    }\n\n    /**\n     * Wether live tracker is currently tracking or not.\n     */\n    isTracking() {\n      return typeof this.trackingInterval_ === 'number';\n    }\n\n    /**\n     * Seek to the live edge if we are behind the live edge\n     */\n    seekToLiveEdge() {\n      this.seekedBehindLive_ = false;\n      if (this.atLiveEdge()) {\n        return;\n      }\n      this.nextSeekedFromUser_ = false;\n      this.player_.currentTime(this.liveCurrentTime());\n    }\n\n    /**\n     * Dispose of liveTracker\n     */\n    dispose() {\n      this.stopTracking();\n      super.dispose();\n    }\n  }\n  Component$1.registerComponent('LiveTracker', LiveTracker);\n\n  /**\n   * Displays an element over the player which contains an optional title and\n   * description for the current content.\n   *\n   * Much of the code for this component originated in the now obsolete\n   * videojs-dock plugin: https://github.com/brightcove/videojs-dock/\n   *\n   * @extends Component\n   */\n  class TitleBar extends Component$1 {\n    constructor(player, options) {\n      super(player, options);\n      this.on('statechanged', e => this.updateDom_());\n      this.updateDom_();\n    }\n\n    /**\n     * Create the `TitleBar`'s DOM element\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    createEl() {\n      this.els = {\n        title: createEl('div', {\n          className: 'vjs-title-bar-title',\n          id: `vjs-title-bar-title-${newGUID()}`\n        }),\n        description: createEl('div', {\n          className: 'vjs-title-bar-description',\n          id: `vjs-title-bar-description-${newGUID()}`\n        })\n      };\n      return createEl('div', {\n        className: 'vjs-title-bar'\n      }, {}, Object.values(this.els));\n    }\n\n    /**\n     * Updates the DOM based on the component's state object.\n     */\n    updateDom_() {\n      const tech = this.player_.tech_;\n      const techEl = tech && tech.el_;\n      const techAriaAttrs = {\n        title: 'aria-labelledby',\n        description: 'aria-describedby'\n      };\n      ['title', 'description'].forEach(k => {\n        const value = this.state[k];\n        const el = this.els[k];\n        const techAriaAttr = techAriaAttrs[k];\n        emptyEl(el);\n        if (value) {\n          textContent(el, value);\n        }\n\n        // If there is a tech element available, update its ARIA attributes\n        // according to whether a title and/or description have been provided.\n        if (techEl) {\n          techEl.removeAttribute(techAriaAttr);\n          if (value) {\n            techEl.setAttribute(techAriaAttr, el.id);\n          }\n        }\n      });\n      if (this.state.title || this.state.description) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    }\n\n    /**\n     * Update the contents of the title bar component with new title and\n     * description text.\n     *\n     * If both title and description are missing, the title bar will be hidden.\n     *\n     * If either title or description are present, the title bar will be visible.\n     *\n     * NOTE: Any previously set value will be preserved. To unset a previously\n     * set value, you must pass an empty string or null.\n     *\n     * For example:\n     *\n     * ```\n     * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'\n     * update({description: 'bar2'}) // title: 'foo', description: 'bar2'\n     * update({title: ''}) // title: '', description: 'bar2'\n     * update({title: 'foo', description: null}) // title: 'foo', description: null\n     * ```\n     *\n     * @param  {Object} [options={}]\n     *         An options object. When empty, the title bar will be hidden.\n     *\n     * @param  {string} [options.title]\n     *         A title to display in the title bar.\n     *\n     * @param  {string} [options.description]\n     *         A description to display in the title bar.\n     */\n    update(options) {\n      this.setState(options);\n    }\n\n    /**\n     * Dispose the component.\n     */\n    dispose() {\n      const tech = this.player_.tech_;\n      const techEl = tech && tech.el_;\n      if (techEl) {\n        techEl.removeAttribute('aria-labelledby');\n        techEl.removeAttribute('aria-describedby');\n      }\n      super.dispose();\n      this.els = null;\n    }\n  }\n  Component$1.registerComponent('TitleBar', TitleBar);\n\n  /**\n   * This function is used to fire a sourceset when there is something\n   * similar to `mediaEl.load()` being called. It will try to find the source via\n   * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\n   * with the source that was found or empty string if we cannot know. If it cannot\n   * find a source then `sourceset` will not be fired.\n   *\n   * @param {Html5} tech\n   *        The tech object that sourceset was setup on\n   *\n   * @return {boolean}\n   *         returns false if the sourceset was not fired and true otherwise.\n   */\n  const sourcesetLoad = tech => {\n    const el = tech.el();\n\n    // if `el.src` is set, that source will be loaded.\n    if (el.hasAttribute('src')) {\n      tech.triggerSourceset(el.src);\n      return true;\n    }\n\n    /**\n     * Since there isn't a src property on the media element, source elements will be used for\n     * implementing the source selection algorithm. This happens asynchronously and\n     * for most cases were there is more than one source we cannot tell what source will\n     * be loaded, without re-implementing the source selection algorithm. At this time we are not\n     * going to do that. There are three special cases that we do handle here though:\n     *\n     * 1. If there are no sources, do not fire `sourceset`.\n     * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\n     * 3. If there is more than one `<source>` but all of them have the same `src` url.\n     *    That will be our src.\n     */\n    const sources = tech.$$('source');\n    const srcUrls = [];\n    let src = '';\n\n    // if there are no sources, do not fire sourceset\n    if (!sources.length) {\n      return false;\n    }\n\n    // only count valid/non-duplicate source elements\n    for (let i = 0; i < sources.length; i++) {\n      const url = sources[i].src;\n      if (url && srcUrls.indexOf(url) === -1) {\n        srcUrls.push(url);\n      }\n    }\n\n    // there were no valid sources\n    if (!srcUrls.length) {\n      return false;\n    }\n\n    // there is only one valid source element url\n    // use that\n    if (srcUrls.length === 1) {\n      src = srcUrls[0];\n    }\n    tech.triggerSourceset(src);\n    return true;\n  };\n\n  /**\n   * our implementation of an `innerHTML` descriptor for browsers\n   * that do not have one.\n   */\n  const innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\n    get() {\n      return this.cloneNode(true).innerHTML;\n    },\n    set(v) {\n      // make a dummy node to use innerHTML on\n      const dummy = document.createElement(this.nodeName.toLowerCase());\n\n      // set innerHTML to the value provided\n      dummy.innerHTML = v;\n\n      // make a document fragment to hold the nodes from dummy\n      const docFrag = document.createDocumentFragment();\n\n      // copy all of the nodes created by the innerHTML on dummy\n      // to the document fragment\n      while (dummy.childNodes.length) {\n        docFrag.appendChild(dummy.childNodes[0]);\n      }\n\n      // remove content\n      this.innerText = '';\n\n      // now we add all of that html in one by appending the\n      // document fragment. This is how innerHTML does it.\n      window.Element.prototype.appendChild.call(this, docFrag);\n\n      // then return the result that innerHTML's setter would\n      return this.innerHTML;\n    }\n  });\n\n  /**\n   * Get a property descriptor given a list of priorities and the\n   * property to get.\n   */\n  const getDescriptor = (priority, prop) => {\n    let descriptor = {};\n    for (let i = 0; i < priority.length; i++) {\n      descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\n      if (descriptor && descriptor.set && descriptor.get) {\n        break;\n      }\n    }\n    descriptor.enumerable = true;\n    descriptor.configurable = true;\n    return descriptor;\n  };\n  const getInnerHTMLDescriptor = tech => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\n\n  /**\n   * Patches browser internal functions so that we can tell synchronously\n   * if a `<source>` was appended to the media element. For some reason this\n   * causes a `sourceset` if the the media element is ready and has no source.\n   * This happens when:\n   * - The page has just loaded and the media element does not have a source.\n   * - The media element was emptied of all sources, then `load()` was called.\n   *\n   * It does this by patching the following functions/properties when they are supported:\n   *\n   * - `append()` - can be used to add a `<source>` element to the media element\n   * - `appendChild()` - can be used to add a `<source>` element to the media element\n   * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\n   * - `innerHTML` -  can be used to add a `<source>` element to the media element\n   *\n   * @param {Html5} tech\n   *        The tech object that sourceset is being setup on.\n   */\n  const firstSourceWatch = function (tech) {\n    const el = tech.el();\n\n    // make sure firstSourceWatch isn't setup twice.\n    if (el.resetSourceWatch_) {\n      return;\n    }\n    const old = {};\n    const innerDescriptor = getInnerHTMLDescriptor(tech);\n    const appendWrapper = appendFn => (...args) => {\n      const retval = appendFn.apply(el, args);\n      sourcesetLoad(tech);\n      return retval;\n    };\n    ['append', 'appendChild', 'insertAdjacentHTML'].forEach(k => {\n      if (!el[k]) {\n        return;\n      }\n\n      // store the old function\n      old[k] = el[k];\n\n      // call the old function with a sourceset if a source\n      // was loaded\n      el[k] = appendWrapper(old[k]);\n    });\n    Object.defineProperty(el, 'innerHTML', merge$2(innerDescriptor, {\n      set: appendWrapper(innerDescriptor.set)\n    }));\n    el.resetSourceWatch_ = () => {\n      el.resetSourceWatch_ = null;\n      Object.keys(old).forEach(k => {\n        el[k] = old[k];\n      });\n      Object.defineProperty(el, 'innerHTML', innerDescriptor);\n    };\n\n    // on the first sourceset, we need to revert our changes\n    tech.one('sourceset', el.resetSourceWatch_);\n  };\n\n  /**\n   * our implementation of a `src` descriptor for browsers\n   * that do not have one\n   */\n  const srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\n    get() {\n      if (this.hasAttribute('src')) {\n        return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));\n      }\n      return '';\n    },\n    set(v) {\n      window.Element.prototype.setAttribute.call(this, 'src', v);\n      return v;\n    }\n  });\n  const getSrcDescriptor = tech => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\n\n  /**\n   * setup `sourceset` handling on the `Html5` tech. This function\n   * patches the following element properties/functions:\n   *\n   * - `src` - to determine when `src` is set\n   * - `setAttribute()` - to determine when `src` is set\n   * - `load()` - this re-triggers the source selection algorithm, and can\n   *              cause a sourceset.\n   *\n   * If there is no source when we are adding `sourceset` support or during a `load()`\n   * we also patch the functions listed in `firstSourceWatch`.\n   *\n   * @param {Html5} tech\n   *        The tech to patch\n   */\n  const setupSourceset = function (tech) {\n    if (!tech.featuresSourceset) {\n      return;\n    }\n    const el = tech.el();\n\n    // make sure sourceset isn't setup twice.\n    if (el.resetSourceset_) {\n      return;\n    }\n    const srcDescriptor = getSrcDescriptor(tech);\n    const oldSetAttribute = el.setAttribute;\n    const oldLoad = el.load;\n    Object.defineProperty(el, 'src', merge$2(srcDescriptor, {\n      set: v => {\n        const retval = srcDescriptor.set.call(el, v);\n\n        // we use the getter here to get the actual value set on src\n        tech.triggerSourceset(el.src);\n        return retval;\n      }\n    }));\n    el.setAttribute = (n, v) => {\n      const retval = oldSetAttribute.call(el, n, v);\n      if (/src/i.test(n)) {\n        tech.triggerSourceset(el.src);\n      }\n      return retval;\n    };\n    el.load = () => {\n      const retval = oldLoad.call(el);\n\n      // if load was called, but there was no source to fire\n      // sourceset on. We have to watch for a source append\n      // as that can trigger a `sourceset` when the media element\n      // has no source\n      if (!sourcesetLoad(tech)) {\n        tech.triggerSourceset('');\n        firstSourceWatch(tech);\n      }\n      return retval;\n    };\n    if (el.currentSrc) {\n      tech.triggerSourceset(el.currentSrc);\n    } else if (!sourcesetLoad(tech)) {\n      firstSourceWatch(tech);\n    }\n    el.resetSourceset_ = () => {\n      el.resetSourceset_ = null;\n      el.load = oldLoad;\n      el.setAttribute = oldSetAttribute;\n      Object.defineProperty(el, 'src', srcDescriptor);\n      if (el.resetSourceWatch_) {\n        el.resetSourceWatch_();\n      }\n    };\n  };\n\n  /**\n   * @file html5.js\n   */\n\n  /**\n   * HTML5 Media Controller - Wrapper for HTML5 Media API\n   *\n   * @mixes Tech~SourceHandlerAdditions\n   * @extends Tech\n   */\n  class Html5 extends Tech {\n    /**\n    * Create an instance of this Tech.\n    *\n    * @param {Object} [options]\n    *        The key/value store of player options.\n    *\n    * @param {Component~ReadyCallback} [ready]\n    *        Callback function to call when the `HTML5` Tech is ready.\n    */\n    constructor(options, ready) {\n      super(options, ready);\n      const source = options.source;\n      let crossoriginTracks = false;\n      this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === 'VIDEO';\n\n      // Set the source if one is provided\n      // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n      // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n      // anyway so the error gets fired.\n      if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n        this.setSource(source);\n      } else {\n        this.handleLateInit_(this.el_);\n      }\n\n      // setup sourceset after late sourceset/init\n      if (options.enableSourceset) {\n        this.setupSourcesetHandling_();\n      }\n      this.isScrubbing_ = false;\n      if (this.el_.hasChildNodes()) {\n        const nodes = this.el_.childNodes;\n        let nodesLength = nodes.length;\n        const removeNodes = [];\n        while (nodesLength--) {\n          const node = nodes[nodesLength];\n          const nodeName = node.nodeName.toLowerCase();\n          if (nodeName === 'track') {\n            if (!this.featuresNativeTextTracks) {\n              // Empty video tag tracks so the built-in player doesn't use them also.\n              // This may not be fast enough to stop HTML5 browsers from reading the tags\n              // so we'll need to turn off any default tracks if we're manually doing\n              // captions and subtitles. videoElement.textTracks\n              removeNodes.push(node);\n            } else {\n              // store HTMLTrackElement and TextTrack to remote list\n              this.remoteTextTrackEls().addTrackElement_(node);\n              this.remoteTextTracks().addTrack(node.track);\n              this.textTracks().addTrack(node.track);\n              if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n                crossoriginTracks = true;\n              }\n            }\n          }\n        }\n        for (let i = 0; i < removeNodes.length; i++) {\n          this.el_.removeChild(removeNodes[i]);\n        }\n      }\n      this.proxyNativeTracks_();\n      if (this.featuresNativeTextTracks && crossoriginTracks) {\n        log$1.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n' + 'This may prevent text tracks from loading.');\n      }\n\n      // prevent iOS Safari from disabling metadata text tracks during native playback\n      this.restoreMetadataTracksInIOSNativePlayer_();\n\n      // Determine if native controls should be used\n      // Our goal should be to get the custom controls on mobile solid everywhere\n      // so we can remove this all together. Right now this will block custom\n      // controls on touch enabled laptops like the Chrome Pixel\n      if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) {\n        this.setControls(true);\n      }\n\n      // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n      // into a `fullscreenchange` event\n      this.proxyWebkitFullscreen_();\n      this.triggerReady();\n    }\n\n    /**\n     * Dispose of `HTML5` media element and remove all tracks.\n     */\n    dispose() {\n      if (this.el_ && this.el_.resetSourceset_) {\n        this.el_.resetSourceset_();\n      }\n      Html5.disposeMediaElement(this.el_);\n      this.options_ = null;\n\n      // tech will handle clearing of the emulated track list\n      super.dispose();\n    }\n\n    /**\n     * Modify the media element so that we can detect when\n     * the source is changed. Fires `sourceset` just after the source has changed\n     */\n    setupSourcesetHandling_() {\n      setupSourceset(this);\n    }\n\n    /**\n     * When a captions track is enabled in the iOS Safari native player, all other\n     * tracks are disabled (including metadata tracks), which nulls all of their\n     * associated cue points. This will restore metadata tracks to their pre-fullscreen\n     * state in those cases so that cue points are not needlessly lost.\n     *\n     * @private\n     */\n    restoreMetadataTracksInIOSNativePlayer_() {\n      const textTracks = this.textTracks();\n      let metadataTracksPreFullscreenState;\n\n      // captures a snapshot of every metadata track's current state\n      const takeMetadataTrackSnapshot = () => {\n        metadataTracksPreFullscreenState = [];\n        for (let i = 0; i < textTracks.length; i++) {\n          const track = textTracks[i];\n          if (track.kind === 'metadata') {\n            metadataTracksPreFullscreenState.push({\n              track,\n              storedMode: track.mode\n            });\n          }\n        }\n      };\n\n      // snapshot each metadata track's initial state, and update the snapshot\n      // each time there is a track 'change' event\n      takeMetadataTrackSnapshot();\n      textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n      this.on('dispose', () => textTracks.removeEventListener('change', takeMetadataTrackSnapshot));\n      const restoreTrackMode = () => {\n        for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n          const storedTrack = metadataTracksPreFullscreenState[i];\n          if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n            storedTrack.track.mode = storedTrack.storedMode;\n          }\n        }\n        // we only want this handler to be executed on the first 'change' event\n        textTracks.removeEventListener('change', restoreTrackMode);\n      };\n\n      // when we enter fullscreen playback, stop updating the snapshot and\n      // restore all track modes to their pre-fullscreen state\n      this.on('webkitbeginfullscreen', () => {\n        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n\n        // remove the listener before adding it just in case it wasn't previously removed\n        textTracks.removeEventListener('change', restoreTrackMode);\n        textTracks.addEventListener('change', restoreTrackMode);\n      });\n\n      // start updating the snapshot again after leaving fullscreen\n      this.on('webkitendfullscreen', () => {\n        // remove the listener before adding it just in case it wasn't previously removed\n        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n        textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n        // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n        textTracks.removeEventListener('change', restoreTrackMode);\n      });\n    }\n\n    /**\n     * Attempt to force override of tracks for the given type\n     *\n     * @param {string} type - Track type to override, possible values include 'Audio',\n     * 'Video', and 'Text'.\n     * @param {boolean} override - If set to true native audio/video will be overridden,\n     * otherwise native audio/video will potentially be used.\n     * @private\n     */\n    overrideNative_(type, override) {\n      // If there is no behavioral change don't add/remove listeners\n      if (override !== this[`featuresNative${type}Tracks`]) {\n        return;\n      }\n      const lowerCaseType = type.toLowerCase();\n      if (this[`${lowerCaseType}TracksListeners_`]) {\n        Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach(eventName => {\n          const elTracks = this.el()[`${lowerCaseType}Tracks`];\n          elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);\n        });\n      }\n      this[`featuresNative${type}Tracks`] = !override;\n      this[`${lowerCaseType}TracksListeners_`] = null;\n      this.proxyNativeTracksForType_(lowerCaseType);\n    }\n\n    /**\n     * Attempt to force override of native audio tracks.\n     *\n     * @param {boolean} override - If set to true native audio will be overridden,\n     * otherwise native audio will potentially be used.\n     */\n    overrideNativeAudioTracks(override) {\n      this.overrideNative_('Audio', override);\n    }\n\n    /**\n     * Attempt to force override of native video tracks.\n     *\n     * @param {boolean} override - If set to true native video will be overridden,\n     * otherwise native video will potentially be used.\n     */\n    overrideNativeVideoTracks(override) {\n      this.overrideNative_('Video', override);\n    }\n\n    /**\n     * Proxy native track list events for the given type to our track\n     * lists if the browser we are playing in supports that type of track list.\n     *\n     * @param {string} name - Track type; values include 'audio', 'video', and 'text'\n     * @private\n     */\n    proxyNativeTracksForType_(name) {\n      const props = NORMAL[name];\n      const elTracks = this.el()[props.getterName];\n      const techTracks = this[props.getterName]();\n      if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) {\n        return;\n      }\n      const listeners = {\n        change: e => {\n          const event = {\n            type: 'change',\n            target: techTracks,\n            currentTarget: techTracks,\n            srcElement: techTracks\n          };\n          techTracks.trigger(event);\n\n          // if we are a text track change event, we should also notify the\n          // remote text track list. This can potentially cause a false positive\n          // if we were to get a change event on a non-remote track and\n          // we triggered the event on the remote text track list which doesn't\n          // contain that track. However, best practices mean looping through the\n          // list of tracks and searching for the appropriate mode value, so,\n          // this shouldn't pose an issue\n          if (name === 'text') {\n            this[REMOTE.remoteText.getterName]().trigger(event);\n          }\n        },\n        addtrack(e) {\n          techTracks.addTrack(e.track);\n        },\n        removetrack(e) {\n          techTracks.removeTrack(e.track);\n        }\n      };\n      const removeOldTracks = function () {\n        const removeTracks = [];\n        for (let i = 0; i < techTracks.length; i++) {\n          let found = false;\n          for (let j = 0; j < elTracks.length; j++) {\n            if (elTracks[j] === techTracks[i]) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            removeTracks.push(techTracks[i]);\n          }\n        }\n        while (removeTracks.length) {\n          techTracks.removeTrack(removeTracks.shift());\n        }\n      };\n      this[props.getterName + 'Listeners_'] = listeners;\n      Object.keys(listeners).forEach(eventName => {\n        const listener = listeners[eventName];\n        elTracks.addEventListener(eventName, listener);\n        this.on('dispose', e => elTracks.removeEventListener(eventName, listener));\n      });\n\n      // Remove (native) tracks that are not used anymore\n      this.on('loadstart', removeOldTracks);\n      this.on('dispose', e => this.off('loadstart', removeOldTracks));\n    }\n\n    /**\n     * Proxy all native track list events to our track lists if the browser we are playing\n     * in supports that type of track list.\n     *\n     * @private\n     */\n    proxyNativeTracks_() {\n      NORMAL.names.forEach(name => {\n        this.proxyNativeTracksForType_(name);\n      });\n    }\n\n    /**\n     * Create the `Html5` Tech's DOM element.\n     *\n     * @return {Element}\n     *         The element that gets created.\n     */\n    createEl() {\n      let el = this.options_.tag;\n\n      // Check if this browser supports moving the element into the box.\n      // On the iPhone video will break if you move the element,\n      // So we have to create a brand new element.\n      // If we ingested the player div, we do not need to move the media element.\n      if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n        // If the original tag is still there, clone and remove it.\n        if (el) {\n          const clone = el.cloneNode(true);\n          if (el.parentNode) {\n            el.parentNode.insertBefore(clone, el);\n          }\n          Html5.disposeMediaElement(el);\n          el = clone;\n        } else {\n          el = document.createElement('video');\n\n          // determine if native controls should be used\n          const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n          const attributes = merge$2({}, tagAttributes);\n          if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n            delete attributes.controls;\n          }\n          setAttributes(el, Object.assign(attributes, {\n            id: this.options_.techId,\n            class: 'vjs-tech'\n          }));\n        }\n        el.playerId = this.options_.playerId;\n      }\n      if (typeof this.options_.preload !== 'undefined') {\n        setAttribute(el, 'preload', this.options_.preload);\n      }\n      if (this.options_.disablePictureInPicture !== undefined) {\n        el.disablePictureInPicture = this.options_.disablePictureInPicture;\n      }\n\n      // Update specific tag settings, in case they were overridden\n      // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n      // when iOS/Safari or other browsers attempt to autoplay.\n      const settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n      for (let i = 0; i < settingsAttrs.length; i++) {\n        const attr = settingsAttrs[i];\n        const value = this.options_[attr];\n        if (typeof value !== 'undefined') {\n          if (value) {\n            setAttribute(el, attr, attr);\n          } else {\n            removeAttribute(el, attr);\n          }\n          el[attr] = value;\n        }\n      }\n      return el;\n    }\n\n    /**\n     * This will be triggered if the loadstart event has already fired, before videojs was\n     * ready. Two known examples of when this can happen are:\n     * 1. If we're loading the playback object after it has started loading\n     * 2. The media is already playing the (often with autoplay on) then\n     *\n     * This function will fire another loadstart so that videojs can catchup.\n     *\n     * @fires Tech#loadstart\n     *\n     * @return {undefined}\n     *         returns nothing.\n     */\n    handleLateInit_(el) {\n      if (el.networkState === 0 || el.networkState === 3) {\n        // The video element hasn't started loading the source yet\n        // or didn't find a source\n        return;\n      }\n      if (el.readyState === 0) {\n        // NetworkState is set synchronously BUT loadstart is fired at the\n        // end of the current stack, usually before setInterval(fn, 0).\n        // So at this point we know loadstart may have already fired or is\n        // about to fire, and either way the player hasn't seen it yet.\n        // We don't want to fire loadstart prematurely here and cause a\n        // double loadstart so we'll wait and see if it happens between now\n        // and the next loop, and fire it if not.\n        // HOWEVER, we also want to make sure it fires before loadedmetadata\n        // which could also happen between now and the next loop, so we'll\n        // watch for that also.\n        let loadstartFired = false;\n        const setLoadstartFired = function () {\n          loadstartFired = true;\n        };\n        this.on('loadstart', setLoadstartFired);\n        const triggerLoadstart = function () {\n          // We did miss the original loadstart. Make sure the player\n          // sees loadstart before loadedmetadata\n          if (!loadstartFired) {\n            this.trigger('loadstart');\n          }\n        };\n        this.on('loadedmetadata', triggerLoadstart);\n        this.ready(function () {\n          this.off('loadstart', setLoadstartFired);\n          this.off('loadedmetadata', triggerLoadstart);\n          if (!loadstartFired) {\n            // We did miss the original native loadstart. Fire it now.\n            this.trigger('loadstart');\n          }\n        });\n        return;\n      }\n\n      // From here on we know that loadstart already fired and we missed it.\n      // The other readyState events aren't as much of a problem if we double\n      // them, so not going to go to as much trouble as loadstart to prevent\n      // that unless we find reason to.\n      const eventsToTrigger = ['loadstart'];\n\n      // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n      eventsToTrigger.push('loadedmetadata');\n\n      // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n      if (el.readyState >= 2) {\n        eventsToTrigger.push('loadeddata');\n      }\n\n      // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n      if (el.readyState >= 3) {\n        eventsToTrigger.push('canplay');\n      }\n\n      // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n      if (el.readyState >= 4) {\n        eventsToTrigger.push('canplaythrough');\n      }\n\n      // We still need to give the player time to add event listeners\n      this.ready(function () {\n        eventsToTrigger.forEach(function (type) {\n          this.trigger(type);\n        }, this);\n      });\n    }\n\n    /**\n     * Set whether we are scrubbing or not.\n     * This is used to decide whether we should use `fastSeek` or not.\n     * `fastSeek` is used to provide trick play on Safari browsers.\n     *\n     * @param {boolean} isScrubbing\n     *                  - true for we are currently scrubbing\n     *                  - false for we are no longer scrubbing\n     */\n    setScrubbing(isScrubbing) {\n      this.isScrubbing_ = isScrubbing;\n    }\n\n    /**\n     * Get whether we are scrubbing or not.\n     *\n     * @return {boolean} isScrubbing\n     *                  - true for we are currently scrubbing\n     *                  - false for we are no longer scrubbing\n     */\n    scrubbing() {\n      return this.isScrubbing_;\n    }\n\n    /**\n     * Set current time for the `HTML5` tech.\n     *\n     * @param {number} seconds\n     *        Set the current time of the media to this.\n     */\n    setCurrentTime(seconds) {\n      try {\n        if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {\n          this.el_.fastSeek(seconds);\n        } else {\n          this.el_.currentTime = seconds;\n        }\n      } catch (e) {\n        log$1(e, 'Video is not ready. (Video.js)');\n        // this.warning(VideoJS.warnings.videoNotReady);\n      }\n    }\n\n    /**\n     * Get the current duration of the HTML5 media element.\n     *\n     * @return {number}\n     *         The duration of the media or 0 if there is no duration.\n     */\n    duration() {\n      // Android Chrome will report duration as Infinity for VOD HLS until after\n      // playback has started, which triggers the live display erroneously.\n      // Return NaN if playback has not started and trigger a durationupdate once\n      // the duration can be reliably known.\n      if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n        // Wait for the first `timeupdate` with currentTime > 0 - there may be\n        // several with 0\n        const checkProgress = () => {\n          if (this.el_.currentTime > 0) {\n            // Trigger durationchange for genuinely live video\n            if (this.el_.duration === Infinity) {\n              this.trigger('durationchange');\n            }\n            this.off('timeupdate', checkProgress);\n          }\n        };\n        this.on('timeupdate', checkProgress);\n        return NaN;\n      }\n      return this.el_.duration || NaN;\n    }\n\n    /**\n     * Get the current width of the HTML5 media element.\n     *\n     * @return {number}\n     *         The width of the HTML5 media element.\n     */\n    width() {\n      return this.el_.offsetWidth;\n    }\n\n    /**\n     * Get the current height of the HTML5 media element.\n     *\n     * @return {number}\n     *         The height of the HTML5 media element.\n     */\n    height() {\n      return this.el_.offsetHeight;\n    }\n\n    /**\n     * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n     * `fullscreenchange` event.\n     *\n     * @private\n     * @fires fullscreenchange\n     * @listens webkitendfullscreen\n     * @listens webkitbeginfullscreen\n     * @listens webkitbeginfullscreen\n     */\n    proxyWebkitFullscreen_() {\n      if (!('webkitDisplayingFullscreen' in this.el_)) {\n        return;\n      }\n      const endFn = function () {\n        this.trigger('fullscreenchange', {\n          isFullscreen: false\n        });\n        // Safari will sometimes set contols on the videoelement when existing fullscreen.\n        if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {\n          this.el_.controls = false;\n        }\n      };\n      const beginFn = function () {\n        if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n          this.one('webkitendfullscreen', endFn);\n          this.trigger('fullscreenchange', {\n            isFullscreen: true,\n            // set a flag in case another tech triggers fullscreenchange\n            nativeIOSFullscreen: true\n          });\n        }\n      };\n      this.on('webkitbeginfullscreen', beginFn);\n      this.on('dispose', () => {\n        this.off('webkitbeginfullscreen', beginFn);\n        this.off('webkitendfullscreen', endFn);\n      });\n    }\n\n    /**\n     * Check if fullscreen is supported on the video el.\n     *\n     * @return {boolean}\n     *         - True if fullscreen is supported.\n     *         - False if fullscreen is not supported.\n     */\n    supportsFullScreen() {\n      return typeof this.el_.webkitEnterFullScreen === 'function';\n    }\n\n    /**\n     * Request that the `HTML5` Tech enter fullscreen.\n     */\n    enterFullScreen() {\n      const video = this.el_;\n      if (video.paused && video.networkState <= video.HAVE_METADATA) {\n        // attempt to prime the video element for programmatic access\n        // this isn't necessary on the desktop but shouldn't hurt\n        silencePromise(this.el_.play());\n\n        // playing and pausing synchronously during the transition to fullscreen\n        // can get iOS ~6.1 devices into a play/pause loop\n        this.setTimeout(function () {\n          video.pause();\n          try {\n            video.webkitEnterFullScreen();\n          } catch (e) {\n            this.trigger('fullscreenerror', e);\n          }\n        }, 0);\n      } else {\n        try {\n          video.webkitEnterFullScreen();\n        } catch (e) {\n          this.trigger('fullscreenerror', e);\n        }\n      }\n    }\n\n    /**\n     * Request that the `HTML5` Tech exit fullscreen.\n     */\n    exitFullScreen() {\n      if (!this.el_.webkitDisplayingFullscreen) {\n        this.trigger('fullscreenerror', new Error('The video is not fullscreen'));\n        return;\n      }\n      this.el_.webkitExitFullScreen();\n    }\n\n    /**\n     * Create a floating video window always on top of other windows so that users may\n     * continue consuming media while they interact with other content sites, or\n     * applications on their device.\n     *\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n     *\n     * @return {Promise}\n     *         A promise with a Picture-in-Picture window.\n     */\n    requestPictureInPicture() {\n      return this.el_.requestPictureInPicture();\n    }\n\n    /**\n     * Native requestVideoFrameCallback if supported by browser/tech, or fallback\n     * Don't use rVCF on Safari when DRM is playing, as it doesn't fire\n     * Needs to be checked later than the constructor\n     * This will be a false positive for clear sources loaded after a Fairplay source\n     *\n     * @param {function} cb function to call\n     * @return {number} id of request\n     */\n    requestVideoFrameCallback(cb) {\n      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\n        return this.el_.requestVideoFrameCallback(cb);\n      }\n      return super.requestVideoFrameCallback(cb);\n    }\n\n    /**\n     * Native or fallback requestVideoFrameCallback\n     *\n     * @param {number} id request id to cancel\n     */\n    cancelVideoFrameCallback(id) {\n      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\n        this.el_.cancelVideoFrameCallback(id);\n      } else {\n        super.cancelVideoFrameCallback(id);\n      }\n    }\n\n    /**\n     * A getter/setter for the `Html5` Tech's source object.\n     * > Note: Please use {@link Html5#setSource}\n     *\n     * @param {Tech~SourceObject} [src]\n     *        The source object you want to set on the `HTML5` techs element.\n     *\n     * @return {Tech~SourceObject|undefined}\n     *         - The current source object when a source is not passed in.\n     *         - undefined when setting\n     *\n     * @deprecated Since version 5.\n     */\n    src(src) {\n      if (src === undefined) {\n        return this.el_.src;\n      }\n\n      // Setting src through `src` instead of `setSrc` will be deprecated\n      this.setSrc(src);\n    }\n\n    /**\n     * Reset the tech by removing all sources and then calling\n     * {@link Html5.resetMediaElement}.\n     */\n    reset() {\n      Html5.resetMediaElement(this.el_);\n    }\n\n    /**\n     * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n     * the HTML5 media element.\n     *\n     * @return {Tech~SourceObject}\n     *         The current source object from the HTML5 tech. With a fallback to the\n     *         elements source.\n     */\n    currentSrc() {\n      if (this.currentSource_) {\n        return this.currentSource_.src;\n      }\n      return this.el_.currentSrc;\n    }\n\n    /**\n     * Set controls attribute for the HTML5 media Element.\n     *\n     * @param {string} val\n     *        Value to set the controls attribute to\n     */\n    setControls(val) {\n      this.el_.controls = !!val;\n    }\n\n    /**\n     * Create and returns a remote {@link TextTrack} object.\n     *\n     * @param {string} kind\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n     *\n     * @param {string} [label]\n     *        Label to identify the text track\n     *\n     * @param {string} [language]\n     *        Two letter language abbreviation\n     *\n     * @return {TextTrack}\n     *         The TextTrack that gets created.\n     */\n    addTextTrack(kind, label, language) {\n      if (!this.featuresNativeTextTracks) {\n        return super.addTextTrack(kind, label, language);\n      }\n      return this.el_.addTextTrack(kind, label, language);\n    }\n\n    /**\n     * Creates either native TextTrack or an emulated TextTrack depending\n     * on the value of `featuresNativeTextTracks`\n     *\n     * @param {Object} options\n     *        The object should contain the options to initialize the TextTrack with.\n     *\n     * @param {string} [options.kind]\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n     *\n     * @param {string} [options.label]\n     *        Label to identify the text track\n     *\n     * @param {string} [options.language]\n     *        Two letter language abbreviation.\n     *\n     * @param {boolean} [options.default]\n     *        Default this track to on.\n     *\n     * @param {string} [options.id]\n     *        The internal id to assign this track.\n     *\n     * @param {string} [options.src]\n     *        A source url for the track.\n     *\n     * @return {HTMLTrackElement}\n     *         The track element that gets created.\n     */\n    createRemoteTextTrack(options) {\n      if (!this.featuresNativeTextTracks) {\n        return super.createRemoteTextTrack(options);\n      }\n      const htmlTrackElement = document.createElement('track');\n      if (options.kind) {\n        htmlTrackElement.kind = options.kind;\n      }\n      if (options.label) {\n        htmlTrackElement.label = options.label;\n      }\n      if (options.language || options.srclang) {\n        htmlTrackElement.srclang = options.language || options.srclang;\n      }\n      if (options.default) {\n        htmlTrackElement.default = options.default;\n      }\n      if (options.id) {\n        htmlTrackElement.id = options.id;\n      }\n      if (options.src) {\n        htmlTrackElement.src = options.src;\n      }\n      return htmlTrackElement;\n    }\n\n    /**\n     * Creates a remote text track object and returns an html track element.\n     *\n     * @param {Object} options The object should contain values for\n     * kind, language, label, and src (location of the WebVTT file)\n     * @param {boolean} [manualCleanup=false] if set to true, the TextTrack\n     * will not be removed from the TextTrackList and HtmlTrackElementList\n     * after a source change\n     * @return {HTMLTrackElement} An Html Track Element.\n     * This can be an emulated {@link HTMLTrackElement} or a native one.\n     *\n     */\n    addRemoteTextTrack(options, manualCleanup) {\n      const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);\n      if (this.featuresNativeTextTracks) {\n        this.el().appendChild(htmlTrackElement);\n      }\n      return htmlTrackElement;\n    }\n\n    /**\n     * Remove remote `TextTrack` from `TextTrackList` object\n     *\n     * @param {TextTrack} track\n     *        `TextTrack` object to remove\n     */\n    removeRemoteTextTrack(track) {\n      super.removeRemoteTextTrack(track);\n      if (this.featuresNativeTextTracks) {\n        const tracks = this.$$('track');\n        let i = tracks.length;\n        while (i--) {\n          if (track === tracks[i] || track === tracks[i].track) {\n            this.el().removeChild(tracks[i]);\n          }\n        }\n      }\n    }\n\n    /**\n     * Gets available media playback quality metrics as specified by the W3C's Media\n     * Playback Quality API.\n     *\n     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n     *\n     * @return {Object}\n     *         An object with supported media playback quality metrics\n     */\n    getVideoPlaybackQuality() {\n      if (typeof this.el().getVideoPlaybackQuality === 'function') {\n        return this.el().getVideoPlaybackQuality();\n      }\n      const videoPlaybackQuality = {};\n      if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n        videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n        videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n      }\n      if (window.performance) {\n        videoPlaybackQuality.creationTime = window.performance.now();\n      }\n      return videoPlaybackQuality;\n    }\n  }\n\n  /* HTML5 Support Testing ---------------------------------------------------- */\n\n  /**\n   * Element for testing browser HTML5 media capabilities\n   *\n   * @type {Element}\n   * @constant\n   * @private\n   */\n  defineLazyProperty(Html5, 'TEST_VID', function () {\n    if (!isReal()) {\n      return;\n    }\n    const video = document.createElement('video');\n    const track = document.createElement('track');\n    track.kind = 'captions';\n    track.srclang = 'en';\n    track.label = 'English';\n    video.appendChild(track);\n    return video;\n  });\n\n  /**\n   * Check if HTML5 media is supported by this browser/device.\n   *\n   * @return {boolean}\n   *         - True if HTML5 media is supported.\n   *         - False if HTML5 media is not supported.\n   */\n  Html5.isSupported = function () {\n    // IE with no Media Player is a LIAR! (#984)\n    try {\n      Html5.TEST_VID.volume = 0.5;\n    } catch (e) {\n      return false;\n    }\n    return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n  };\n\n  /**\n   * Check if the tech can support the given type\n   *\n   * @param {string} type\n   *        The mimetype to check\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */\n  Html5.canPlayType = function (type) {\n    return Html5.TEST_VID.canPlayType(type);\n  };\n\n  /**\n   * Check if the tech can support the given source\n   *\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */\n  Html5.canPlaySource = function (srcObj, options) {\n    return Html5.canPlayType(srcObj.type);\n  };\n\n  /**\n   * Check if the volume can be changed in this browser/device.\n   * Volume cannot be changed in a lot of mobile devices.\n   * Specifically, it can't be changed from 1 on iOS.\n   *\n   * @return {boolean}\n   *         - True if volume can be controlled\n   *         - False otherwise\n   */\n  Html5.canControlVolume = function () {\n    // IE will error if Windows Media Player not installed #3315\n    try {\n      const volume = Html5.TEST_VID.volume;\n      Html5.TEST_VID.volume = volume / 2 + 0.1;\n      const canControl = volume !== Html5.TEST_VID.volume;\n\n      // With the introduction of iOS 15, there are cases where the volume is read as\n      // changed but reverts back to its original state at the start of the next tick.\n      // To determine whether volume can be controlled on iOS,\n      // a timeout is set and the volume is checked asynchronously.\n      // Since `features` doesn't currently work asynchronously, the value is manually set.\n      if (canControl && IS_IOS) {\n        window.setTimeout(() => {\n          if (Html5 && Html5.prototype) {\n            Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;\n          }\n        });\n\n        // default iOS to false, which will be updated in the timeout above.\n        return false;\n      }\n      return canControl;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  /**\n   * Check if the volume can be muted in this browser/device.\n   * Some devices, e.g. iOS, don't allow changing volume\n   * but permits muting/unmuting.\n   *\n   * @return {bolean}\n   *      - True if volume can be muted\n   *      - False otherwise\n   */\n  Html5.canMuteVolume = function () {\n    try {\n      const muted = Html5.TEST_VID.muted;\n\n      // in some versions of iOS muted property doesn't always\n      // work, so we want to set both property and attribute\n      Html5.TEST_VID.muted = !muted;\n      if (Html5.TEST_VID.muted) {\n        setAttribute(Html5.TEST_VID, 'muted', 'muted');\n      } else {\n        removeAttribute(Html5.TEST_VID, 'muted', 'muted');\n      }\n      return muted !== Html5.TEST_VID.muted;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  /**\n   * Check if the playback rate can be changed in this browser/device.\n   *\n   * @return {boolean}\n   *         - True if playback rate can be controlled\n   *         - False otherwise\n   */\n  Html5.canControlPlaybackRate = function () {\n    // Playback rate API is implemented in Android Chrome, but doesn't do anything\n    // https://github.com/videojs/video.js/issues/3180\n    if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n      return false;\n    }\n    // IE will error if Windows Media Player not installed #3315\n    try {\n      const playbackRate = Html5.TEST_VID.playbackRate;\n      Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n      return playbackRate !== Html5.TEST_VID.playbackRate;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  /**\n   * Check if we can override a video/audio elements attributes, with\n   * Object.defineProperty.\n   *\n   * @return {boolean}\n   *         - True if builtin attributes can be overridden\n   *         - False otherwise\n   */\n  Html5.canOverrideAttributes = function () {\n    // if we cannot overwrite the src/innerHTML property, there is no support\n    // iOS 7 safari for instance cannot do this.\n    try {\n      const noop = () => {};\n      Object.defineProperty(document.createElement('video'), 'src', {\n        get: noop,\n        set: noop\n      });\n      Object.defineProperty(document.createElement('audio'), 'src', {\n        get: noop,\n        set: noop\n      });\n      Object.defineProperty(document.createElement('video'), 'innerHTML', {\n        get: noop,\n        set: noop\n      });\n      Object.defineProperty(document.createElement('audio'), 'innerHTML', {\n        get: noop,\n        set: noop\n      });\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n\n  /**\n   * Check to see if native `TextTrack`s are supported by this browser/device.\n   *\n   * @return {boolean}\n   *         - True if native `TextTrack`s are supported.\n   *         - False otherwise\n   */\n  Html5.supportsNativeTextTracks = function () {\n    return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\n  };\n\n  /**\n   * Check to see if native `VideoTrack`s are supported by this browser/device\n   *\n   * @return {boolean}\n   *        - True if native `VideoTrack`s are supported.\n   *        - False otherwise\n   */\n  Html5.supportsNativeVideoTracks = function () {\n    return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n  };\n\n  /**\n   * Check to see if native `AudioTrack`s are supported by this browser/device\n   *\n   * @return {boolean}\n   *        - True if native `AudioTrack`s are supported.\n   *        - False otherwise\n   */\n  Html5.supportsNativeAudioTracks = function () {\n    return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n  };\n\n  /**\n   * An array of events available on the Html5 tech.\n   *\n   * @private\n   * @type {Array}\n   */\n  Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n\n  /**\n   * Boolean indicating whether the `Tech` supports volume control.\n   *\n   * @type {boolean}\n   * @default {@link Html5.canControlVolume}\n   */\n  /**\n   * Boolean indicating whether the `Tech` supports muting volume.\n   *\n   * @type {bolean}\n   * @default {@link Html5.canMuteVolume}\n   */\n\n  /**\n   * Boolean indicating whether the `Tech` supports changing the speed at which the media\n   * plays. Examples:\n   *   - Set player to play 2x (twice) as fast\n   *   - Set player to play 0.5x (half) as fast\n   *\n   * @type {boolean}\n   * @default {@link Html5.canControlPlaybackRate}\n   */\n\n  /**\n   * Boolean indicating whether the `Tech` supports the `sourceset` event.\n   *\n   * @type {boolean}\n   * @default\n   */\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n   *\n   * @type {boolean}\n   * @default {@link Html5.supportsNativeTextTracks}\n   */\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n   *\n   * @type {boolean}\n   * @default {@link Html5.supportsNativeVideoTracks}\n   */\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n   *\n   * @type {boolean}\n   * @default {@link Html5.supportsNativeAudioTracks}\n   */\n  [['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function ([key, fn]) {\n    defineLazyProperty(Html5.prototype, key, () => Html5[fn](), true);\n  });\n  Html5.prototype.featuresVolumeControl = Html5.canControlVolume();\n\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports the media element\n   * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n   * false there. Everywhere else this should be true.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Html5.prototype.movingMediaElementInDOM = !IS_IOS;\n\n  // TODO: Previous comment: No longer appears to be used. Can probably be removed.\n  //       Is this true?\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n   * when going into fullscreen.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Html5.prototype.featuresFullscreenResize = true;\n\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n   * If this is false, manual `progress` events will be triggered instead.\n   *\n   * @type {boolean}\n   * @default\n   */\n  Html5.prototype.featuresProgressEvents = true;\n\n  /**\n   * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n   * If this is false, manual `timeupdate` events will be triggered instead.\n   *\n   * @default\n   */\n  Html5.prototype.featuresTimeupdateEvents = true;\n\n  /**\n   * Whether the HTML5 el supports `requestVideoFrameCallback`\n   *\n   * @type {boolean}\n   */\n  Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);\n  Html5.disposeMediaElement = function (el) {\n    if (!el) {\n      return;\n    }\n    if (el.parentNode) {\n      el.parentNode.removeChild(el);\n    }\n\n    // remove any child track or source nodes to prevent their loading\n    while (el.hasChildNodes()) {\n      el.removeChild(el.firstChild);\n    }\n\n    // remove any src reference. not setting `src=''` because that causes a warning\n    // in firefox\n    el.removeAttribute('src');\n\n    // force the media element to update its loading state by calling load()\n    // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n    if (typeof el.load === 'function') {\n      // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n      (function () {\n        try {\n          el.load();\n        } catch (e) {\n          // not supported\n        }\n      })();\n    }\n  };\n  Html5.resetMediaElement = function (el) {\n    if (!el) {\n      return;\n    }\n    const sources = el.querySelectorAll('source');\n    let i = sources.length;\n    while (i--) {\n      el.removeChild(sources[i]);\n    }\n\n    // remove any src reference.\n    // not setting `src=''` because that throws an error\n    el.removeAttribute('src');\n    if (typeof el.load === 'function') {\n      // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n      (function () {\n        try {\n          el.load();\n        } catch (e) {\n          // satisfy linter\n        }\n      })();\n    }\n  };\n\n  /* Native HTML5 element property wrapping ----------------------------------- */\n  // Wrap native boolean attributes with getters that check both property and attribute\n  // The list is as followed:\n  // muted, defaultMuted, autoplay, controls, loop, playsinline\n  [\n  /**\n   * Get the value of `muted` from the media element. `muted` indicates\n   * that the volume for the media should be set to silent. This does not actually change\n   * the `volume` attribute.\n   *\n   * @method Html5#muted\n   * @return {boolean}\n   *         - True if the value of `volume` should be ignored and the audio set to silent.\n   *         - False if the value of `volume` should be used.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n   */\n  'muted',\n  /**\n   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n   * whether the media should start muted or not. Only changes the default state of the\n   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n   * current state.\n   *\n   * @method Html5#defaultMuted\n   * @return {boolean}\n   *         - The value of `defaultMuted` from the media element.\n   *         - True indicates that the media should start muted.\n   *         - False indicates that the media should not start muted\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n   */\n  'defaultMuted',\n  /**\n   * Get the value of `autoplay` from the media element. `autoplay` indicates\n   * that the media should start to play as soon as the page is ready.\n   *\n   * @method Html5#autoplay\n   * @return {boolean}\n   *         - The value of `autoplay` from the media element.\n   *         - True indicates that the media should start as soon as the page loads.\n   *         - False indicates that the media should not start as soon as the page loads.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n   */\n  'autoplay',\n  /**\n   * Get the value of `controls` from the media element. `controls` indicates\n   * whether the native media controls should be shown or hidden.\n   *\n   * @method Html5#controls\n   * @return {boolean}\n   *         - The value of `controls` from the media element.\n   *         - True indicates that native controls should be showing.\n   *         - False indicates that native controls should be hidden.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n   */\n  'controls',\n  /**\n   * Get the value of `loop` from the media element. `loop` indicates\n   * that the media should return to the start of the media and continue playing once\n   * it reaches the end.\n   *\n   * @method Html5#loop\n   * @return {boolean}\n   *         - The value of `loop` from the media element.\n   *         - True indicates that playback should seek back to start once\n   *           the end of a media is reached.\n   *         - False indicates that playback should not loop back to the start when the\n   *           end of the media is reached.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n   */\n  'loop',\n  /**\n   * Get the value of `playsinline` from the media element. `playsinline` indicates\n   * to the browser that non-fullscreen playback is preferred when fullscreen\n   * playback is the native default, such as in iOS Safari.\n   *\n   * @method Html5#playsinline\n   * @return {boolean}\n   *         - The value of `playsinline` from the media element.\n   *         - True indicates that the media should play inline.\n   *         - False indicates that the media should not play inline.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */\n  'playsinline'].forEach(function (prop) {\n    Html5.prototype[prop] = function () {\n      return this.el_[prop] || this.el_.hasAttribute(prop);\n    };\n  });\n\n  // Wrap native boolean attributes with setters that set both property and attribute\n  // The list is as followed:\n  // setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n  // setControls is special-cased above\n  [\n  /**\n   * Set the value of `muted` on the media element. `muted` indicates that the current\n   * audio level should be silent.\n   *\n   * @method Html5#setMuted\n   * @param {boolean} muted\n   *        - True if the audio should be set to silent\n   *        - False otherwise\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n   */\n  'muted',\n  /**\n   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n   * audio level should be silent, but will only effect the muted level on initial playback..\n   *\n   * @method Html5.prototype.setDefaultMuted\n   * @param {boolean} defaultMuted\n   *        - True if the audio should be set to silent\n   *        - False otherwise\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n   */\n  'defaultMuted',\n  /**\n   * Set the value of `autoplay` on the media element. `autoplay` indicates\n   * that the media should start to play as soon as the page is ready.\n   *\n   * @method Html5#setAutoplay\n   * @param {boolean} autoplay\n   *         - True indicates that the media should start as soon as the page loads.\n   *         - False indicates that the media should not start as soon as the page loads.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n   */\n  'autoplay',\n  /**\n   * Set the value of `loop` on the media element. `loop` indicates\n   * that the media should return to the start of the media and continue playing once\n   * it reaches the end.\n   *\n   * @method Html5#setLoop\n   * @param {boolean} loop\n   *         - True indicates that playback should seek back to start once\n   *           the end of a media is reached.\n   *         - False indicates that playback should not loop back to the start when the\n   *           end of the media is reached.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n   */\n  'loop',\n  /**\n   * Set the value of `playsinline` from the media element. `playsinline` indicates\n   * to the browser that non-fullscreen playback is preferred when fullscreen\n   * playback is the native default, such as in iOS Safari.\n   *\n   * @method Html5#setPlaysinline\n   * @param {boolean} playsinline\n   *         - True indicates that the media should play inline.\n   *         - False indicates that the media should not play inline.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */\n  'playsinline'].forEach(function (prop) {\n    Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\n      this.el_[prop] = v;\n      if (v) {\n        this.el_.setAttribute(prop, prop);\n      } else {\n        this.el_.removeAttribute(prop);\n      }\n    };\n  });\n\n  // Wrap native properties with a getter\n  // The list is as followed\n  // paused, currentTime, buffered, volume, poster, preload, error, seeking\n  // seekable, ended, playbackRate, defaultPlaybackRate, disablePictureInPicture\n  // played, networkState, readyState, videoWidth, videoHeight, crossOrigin\n  [\n  /**\n   * Get the value of `paused` from the media element. `paused` indicates whether the media element\n   * is currently paused or not.\n   *\n   * @method Html5#paused\n   * @return {boolean}\n   *         The value of `paused` from the media element.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n   */\n  'paused',\n  /**\n   * Get the value of `currentTime` from the media element. `currentTime` indicates\n   * the current second that the media is at in playback.\n   *\n   * @method Html5#currentTime\n   * @return {number}\n   *         The value of `currentTime` from the media element.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n   */\n  'currentTime',\n  /**\n   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n   * object that represents the parts of the media that are already downloaded and\n   * available for playback.\n   *\n   * @method Html5#buffered\n   * @return {TimeRange}\n   *         The value of `buffered` from the media element.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n   */\n  'buffered',\n  /**\n   * Get the value of `volume` from the media element. `volume` indicates\n   * the current playback volume of audio for a media. `volume` will be a value from 0\n   * (silent) to 1 (loudest and default).\n   *\n   * @method Html5#volume\n   * @return {number}\n   *         The value of `volume` from the media element. Value will be between 0-1.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n   */\n  'volume',\n  /**\n   * Get the value of `poster` from the media element. `poster` indicates\n   * that the url of an image file that can/will be shown when no media data is available.\n   *\n   * @method Html5#poster\n   * @return {string}\n   *         The value of `poster` from the media element. Value will be a url to an\n   *         image.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n   */\n  'poster',\n  /**\n   * Get the value of `preload` from the media element. `preload` indicates\n   * what should download before the media is interacted with. It can have the following\n   * values:\n   * - none: nothing should be downloaded\n   * - metadata: poster and the first few frames of the media may be downloaded to get\n   *   media dimensions and other metadata\n   * - auto: allow the media and metadata for the media to be downloaded before\n   *    interaction\n   *\n   * @method Html5#preload\n   * @return {string}\n   *         The value of `preload` from the media element. Will be 'none', 'metadata',\n   *         or 'auto'.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n   */\n  'preload',\n  /**\n   * Get the value of the `error` from the media element. `error` indicates any\n   * MediaError that may have occurred during playback. If error returns null there is no\n   * current error.\n   *\n   * @method Html5#error\n   * @return {MediaError|null}\n   *         The value of `error` from the media element. Will be `MediaError` if there\n   *         is a current error and null otherwise.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n   */\n  'error',\n  /**\n   * Get the value of `seeking` from the media element. `seeking` indicates whether the\n   * media is currently seeking to a new position or not.\n   *\n   * @method Html5#seeking\n   * @return {boolean}\n   *         - The value of `seeking` from the media element.\n   *         - True indicates that the media is currently seeking to a new position.\n   *         - False indicates that the media is not seeking to a new position at this time.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n   */\n  'seeking',\n  /**\n   * Get the value of `seekable` from the media element. `seekable` returns a\n   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n   *\n   * @method Html5#seekable\n   * @return {TimeRange}\n   *         The value of `seekable` from the media element. A `TimeRange` object\n   *         indicating the current ranges of time that can be seeked to.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n   */\n  'seekable',\n  /**\n   * Get the value of `ended` from the media element. `ended` indicates whether\n   * the media has reached the end or not.\n   *\n   * @method Html5#ended\n   * @return {boolean}\n   *         - The value of `ended` from the media element.\n   *         - True indicates that the media has ended.\n   *         - False indicates that the media has not ended.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n   */\n  'ended',\n  /**\n   * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n   * the rate at which the media is currently playing back. Examples:\n   *   - if playbackRate is set to 2, media will play twice as fast.\n   *   - if playbackRate is set to 0.5, media will play half as fast.\n   *\n   * @method Html5#playbackRate\n   * @return {number}\n   *         The value of `playbackRate` from the media element. A number indicating\n   *         the current playback speed of the media, where 1 is normal speed.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n   */\n  'playbackRate',\n  /**\n   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n   * the rate at which the media is currently playing back. This value will not indicate the current\n   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n   *\n   * Examples:\n   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n   *\n   * @method Html5.prototype.defaultPlaybackRate\n   * @return {number}\n   *         The value of `defaultPlaybackRate` from the media element. A number indicating\n   *         the current playback speed of the media, where 1 is normal speed.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n   */\n  'defaultPlaybackRate',\n  /**\n   * Get the value of 'disablePictureInPicture' from the video element.\n   *\n   * @method Html5#disablePictureInPicture\n   * @return {boolean} value\n   *         - The value of `disablePictureInPicture` from the video element.\n   *         - True indicates that the video can't be played in Picture-In-Picture mode\n   *         - False indicates that the video can be played in Picture-In-Picture mode\n   *\n   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n   */\n  'disablePictureInPicture',\n  /**\n   * Get the value of `played` from the media element. `played` returns a `TimeRange`\n   * object representing points in the media timeline that have been played.\n   *\n   * @method Html5#played\n   * @return {TimeRange}\n   *         The value of `played` from the media element. A `TimeRange` object indicating\n   *         the ranges of time that have been played.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n   */\n  'played',\n  /**\n   * Get the value of `networkState` from the media element. `networkState` indicates\n   * the current network state. It returns an enumeration from the following list:\n   * - 0: NETWORK_EMPTY\n   * - 1: NETWORK_IDLE\n   * - 2: NETWORK_LOADING\n   * - 3: NETWORK_NO_SOURCE\n   *\n   * @method Html5#networkState\n   * @return {number}\n   *         The value of `networkState` from the media element. This will be a number\n   *         from the list in the description.\n   *\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n   */\n  'networkState',\n  /**\n   * Get the value of `readyState` from the media element. `readyState` indicates\n   * the current state of the media element. It returns an enumeration from the\n   * following list:\n   * - 0: HAVE_NOTHING\n   * - 1: HAVE_METADATA\n   * - 2: HAVE_CURRENT_DATA\n   * - 3: HAVE_FUTURE_DATA\n   * - 4: HAVE_ENOUGH_DATA\n   *\n   * @method Html5#readyState\n   * @return {number}\n   *         The value of `readyState` from the media element. This will be a number\n   *         from the list in the description.\n   *\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n   */\n  'readyState',\n  /**\n   * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n   * the current width of the video in css pixels.\n   *\n   * @method Html5#videoWidth\n   * @return {number}\n   *         The value of `videoWidth` from the video element. This will be a number\n   *         in css pixels.\n   *\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n   */\n  'videoWidth',\n  /**\n   * Get the value of `videoHeight` from the video element. `videoHeight` indicates\n   * the current height of the video in css pixels.\n   *\n   * @method Html5#videoHeight\n   * @return {number}\n   *         The value of `videoHeight` from the video element. This will be a number\n   *         in css pixels.\n   *\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n   */\n  'videoHeight',\n  /**\n   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates\n   * to the browser that should sent the cookies along with the requests for the\n   * different assets/playlists\n   *\n   * @method Html5#crossOrigin\n   * @return {string}\n   *         - anonymous indicates that the media should not sent cookies.\n   *         - use-credentials indicates that the media should sent cookies along the requests.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n   */\n  'crossOrigin'].forEach(function (prop) {\n    Html5.prototype[prop] = function () {\n      return this.el_[prop];\n    };\n  });\n\n  // Wrap native properties with a setter in this format:\n  // set + toTitleCase(name)\n  // The list is as follows:\n  // setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate,\n  // setDisablePictureInPicture, setCrossOrigin\n  [\n  /**\n   * Set the value of `volume` on the media element. `volume` indicates the current\n   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n   * so on.\n   *\n   * @method Html5#setVolume\n   * @param {number} percentAsDecimal\n   *        The volume percent as a decimal. Valid range is from 0-1.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n   */\n  'volume',\n  /**\n   * Set the value of `src` on the media element. `src` indicates the current\n   * {@link Tech~SourceObject} for the media.\n   *\n   * @method Html5#setSrc\n   * @param {Tech~SourceObject} src\n   *        The source object to set as the current source.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n   */\n  'src',\n  /**\n   * Set the value of `poster` on the media element. `poster` is the url to\n   * an image file that can/will be shown when no media data is available.\n   *\n   * @method Html5#setPoster\n   * @param {string} poster\n   *        The url to an image that should be used as the `poster` for the media\n   *        element.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n   */\n  'poster',\n  /**\n   * Set the value of `preload` on the media element. `preload` indicates\n   * what should download before the media is interacted with. It can have the following\n   * values:\n   * - none: nothing should be downloaded\n   * - metadata: poster and the first few frames of the media may be downloaded to get\n   *   media dimensions and other metadata\n   * - auto: allow the media and metadata for the media to be downloaded before\n   *    interaction\n   *\n   * @method Html5#setPreload\n   * @param {string} preload\n   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n   *         or 'auto'.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n   */\n  'preload',\n  /**\n   * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n   * the rate at which the media should play back. Examples:\n   *   - if playbackRate is set to 2, media will play twice as fast.\n   *   - if playbackRate is set to 0.5, media will play half as fast.\n   *\n   * @method Html5#setPlaybackRate\n   * @return {number}\n   *         The value of `playbackRate` from the media element. A number indicating\n   *         the current playback speed of the media, where 1 is normal speed.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n   */\n  'playbackRate',\n  /**\n   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n   * the rate at which the media should play back upon initial startup. Changing this value\n   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n   *\n   * Example Values:\n   *   - if playbackRate is set to 2, media will play twice as fast.\n   *   - if playbackRate is set to 0.5, media will play half as fast.\n   *\n   * @method Html5.prototype.setDefaultPlaybackRate\n   * @return {number}\n   *         The value of `defaultPlaybackRate` from the media element. A number indicating\n   *         the current playback speed of the media, where 1 is normal speed.\n   *\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n   */\n  'defaultPlaybackRate',\n  /**\n   * Prevents the browser from suggesting a Picture-in-Picture context menu\n   * or to request Picture-in-Picture automatically in some cases.\n   *\n   * @method Html5#setDisablePictureInPicture\n   * @param {boolean} value\n   *         The true value will disable Picture-in-Picture mode.\n   *\n   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n   */\n  'disablePictureInPicture',\n  /**\n   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates\n   * to the browser that should sent the cookies along with the requests for the\n   * different assets/playlists\n   *\n   * @method Html5#setCrossOrigin\n   * @param {string} crossOrigin\n   *         - anonymous indicates that the media should not sent cookies.\n   *         - use-credentials indicates that the media should sent cookies along the requests.\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n   */\n  'crossOrigin'].forEach(function (prop) {\n    Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\n      this.el_[prop] = v;\n    };\n  });\n\n  // wrap native functions with a function\n  // The list is as follows:\n  // pause, load, play\n  [\n  /**\n   * A wrapper around the media elements `pause` function. This will call the `HTML5`\n   * media elements `pause` function.\n   *\n   * @method Html5#pause\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n   */\n  'pause',\n  /**\n   * A wrapper around the media elements `load` function. This will call the `HTML5`s\n   * media element `load` function.\n   *\n   * @method Html5#load\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n   */\n  'load',\n  /**\n   * A wrapper around the media elements `play` function. This will call the `HTML5`s\n   * media element `play` function.\n   *\n   * @method Html5#play\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n   */\n  'play'].forEach(function (prop) {\n    Html5.prototype[prop] = function () {\n      return this.el_[prop]();\n    };\n  });\n  Tech.withSourceHandlers(Html5);\n\n  /**\n   * Native source handler for Html5, simply passes the source to the media element.\n   *\n   * @property {Tech~SourceObject} source\n   *        The source object\n   *\n   * @property {Html5} tech\n   *        The instance of the HTML5 tech.\n   */\n  Html5.nativeSourceHandler = {};\n\n  /**\n   * Check if the media element can play the given mime type.\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  Html5.nativeSourceHandler.canPlayType = function (type) {\n    // IE without MediaPlayer throws an error (#519)\n    try {\n      return Html5.TEST_VID.canPlayType(type);\n    } catch (e) {\n      return '';\n    }\n  };\n\n  /**\n   * Check if the media element can handle a source natively.\n   *\n   * @param {Tech~SourceObject} source\n   *         The source object\n   *\n   * @param {Object} [options]\n   *         Options to be passed to the tech.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string).\n   */\n  Html5.nativeSourceHandler.canHandleSource = function (source, options) {\n    // If a type was provided we should rely on that\n    if (source.type) {\n      return Html5.nativeSourceHandler.canPlayType(source.type);\n\n      // If no type, fall back to checking 'video/[EXTENSION]'\n    } else if (source.src) {\n      const ext = getFileExtension(source.src);\n      return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);\n    }\n    return '';\n  };\n\n  /**\n   * Pass the source to the native media element.\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Html5} tech\n   *        The instance of the Html5 tech\n   *\n   * @param {Object} [options]\n   *        The options to pass to the source\n   */\n  Html5.nativeSourceHandler.handleSource = function (source, tech, options) {\n    tech.setSrc(source.src);\n  };\n\n  /**\n   * A noop for the native dispose function, as cleanup is not needed.\n   */\n  Html5.nativeSourceHandler.dispose = function () {};\n\n  // Register the native source handler\n  Html5.registerSourceHandler(Html5.nativeSourceHandler);\n  Tech.registerTech('Html5', Html5);\n\n  /**\n   * @file player.js\n   */\n\n  // The following tech events are simply re-triggered\n  // on the player when they happen\n  const TECH_EVENTS_RETRIGGER = [\n  /**\n   * Fired while the user agent is downloading media data.\n   *\n   * @event Player#progress\n   * @type {EventTarget~Event}\n   */\n  /**\n   * Retrigger the `progress` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechProgress_\n   * @fires Player#progress\n   * @listens Tech#progress\n   */\n  'progress',\n  /**\n   * Fires when the loading of an audio/video is aborted.\n   *\n   * @event Player#abort\n   * @type {EventTarget~Event}\n   */\n  /**\n   * Retrigger the `abort` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechAbort_\n   * @fires Player#abort\n   * @listens Tech#abort\n   */\n  'abort',\n  /**\n   * Fires when the browser is intentionally not getting media data.\n   *\n   * @event Player#suspend\n   * @type {EventTarget~Event}\n   */\n  /**\n   * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechSuspend_\n   * @fires Player#suspend\n   * @listens Tech#suspend\n   */\n  'suspend',\n  /**\n   * Fires when the current playlist is empty.\n   *\n   * @event Player#emptied\n   * @type {EventTarget~Event}\n   */\n  /**\n   * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechEmptied_\n   * @fires Player#emptied\n   * @listens Tech#emptied\n   */\n  'emptied',\n  /**\n   * Fires when the browser is trying to get media data, but data is not available.\n   *\n   * @event Player#stalled\n   * @type {EventTarget~Event}\n   */\n  /**\n   * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechStalled_\n   * @fires Player#stalled\n   * @listens Tech#stalled\n   */\n  'stalled',\n  /**\n   * Fires when the browser has loaded meta data for the audio/video.\n   *\n   * @event Player#loadedmetadata\n   * @type {EventTarget~Event}\n   */\n  /**\n   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechLoadedmetadata_\n   * @fires Player#loadedmetadata\n   * @listens Tech#loadedmetadata\n   */\n  'loadedmetadata',\n  /**\n   * Fires when the browser has loaded the current frame of the audio/video.\n   *\n   * @event Player#loadeddata\n   * @type {event}\n   */\n  /**\n   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechLoaddeddata_\n   * @fires Player#loadeddata\n   * @listens Tech#loadeddata\n   */\n  'loadeddata',\n  /**\n   * Fires when the current playback position has changed.\n   *\n   * @event Player#timeupdate\n   * @type {event}\n   */\n  /**\n   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechTimeUpdate_\n   * @fires Player#timeupdate\n   * @listens Tech#timeupdate\n   */\n  'timeupdate',\n  /**\n   * Fires when the video's intrinsic dimensions change\n   *\n   * @event Player#resize\n   * @type {event}\n   */\n  /**\n   * Retrigger the `resize` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechResize_\n   * @fires Player#resize\n   * @listens Tech#resize\n   */\n  'resize',\n  /**\n   * Fires when the volume has been changed\n   *\n   * @event Player#volumechange\n   * @type {event}\n   */\n  /**\n   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechVolumechange_\n   * @fires Player#volumechange\n   * @listens Tech#volumechange\n   */\n  'volumechange',\n  /**\n   * Fires when the text track has been changed\n   *\n   * @event Player#texttrackchange\n   * @type {event}\n   */\n  /**\n   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n   *\n   * @private\n   * @method Player#handleTechTexttrackchange_\n   * @fires Player#texttrackchange\n   * @listens Tech#texttrackchange\n   */\n  'texttrackchange'];\n\n  // events to queue when playback rate is zero\n  // this is a hash for the sole purpose of mapping non-camel-cased event names\n  // to camel-cased function names\n  const TECH_EVENTS_QUEUE = {\n    canplay: 'CanPlay',\n    canplaythrough: 'CanPlayThrough',\n    playing: 'Playing',\n    seeked: 'Seeked'\n  };\n  const BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];\n  const BREAKPOINT_CLASSES = {};\n\n  // grep: vjs-layout-tiny\n  // grep: vjs-layout-x-small\n  // grep: vjs-layout-small\n  // grep: vjs-layout-medium\n  // grep: vjs-layout-large\n  // grep: vjs-layout-x-large\n  // grep: vjs-layout-huge\n  BREAKPOINT_ORDER.forEach(k => {\n    const v = k.charAt(0) === 'x' ? `x-${k.substring(1)}` : k;\n    BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;\n  });\n  const DEFAULT_BREAKPOINTS = {\n    tiny: 210,\n    xsmall: 320,\n    small: 425,\n    medium: 768,\n    large: 1440,\n    xlarge: 2560,\n    huge: Infinity\n  };\n\n  /**\n   * An instance of the `Player` class is created when any of the Video.js setup methods\n   * are used to initialize a video.\n   *\n   * After an instance has been created it can be accessed globally in two ways:\n   * 1. By calling `videojs('example_video_1');`\n   * 2. By using it directly via  `videojs.players.example_video_1;`\n   *\n   * @extends Component\n   */\n  class Player extends Component$1 {\n    /**\n     * Create an instance of this class.\n     *\n     * @param {Element} tag\n     *        The original video DOM element used for configuring options.\n     *\n     * @param {Object} [options]\n     *        Object of option names and values.\n     *\n     * @param {Component~ReadyCallback} [ready]\n     *        Ready callback function.\n     */\n    constructor(tag, options, ready) {\n      // Make sure tag ID exists\n      tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;\n\n      // Set Options\n      // The options argument overrides options set in the video tag\n      // which overrides globally set options.\n      // This latter part coincides with the load order\n      // (tag must exist before Player)\n      options = Object.assign(Player.getTagSettings(tag), options);\n\n      // Delay the initialization of children because we need to set up\n      // player properties first, and can't use `this` before `super()`\n      options.initChildren = false;\n\n      // Same with creating the element\n      options.createEl = false;\n\n      // don't auto mixin the evented mixin\n      options.evented = false;\n\n      // we don't want the player to report touch activity on itself\n      // see enableTouchActivity in Component\n      options.reportTouchActivity = false;\n\n      // If language is not set, get the closest lang attribute\n      if (!options.language) {\n        const closest = tag.closest('[lang]');\n        if (closest) {\n          options.language = closest.getAttribute('lang');\n        }\n      }\n\n      // Run base component initializing with new options\n      super(null, options, ready);\n\n      // Create bound methods for document listeners.\n      this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);\n      this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);\n      this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e);\n      this.boundApplyInitTime_ = e => this.applyInitTime_(e);\n      this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e);\n      this.boundHandleTechClick_ = e => this.handleTechClick_(e);\n      this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e);\n      this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e);\n      this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e);\n      this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e);\n      this.boundHandleTechTap_ = e => this.handleTechTap_(e);\n\n      // default isFullscreen_ to false\n      this.isFullscreen_ = false;\n\n      // create logger\n      this.log = createLogger(this.id_);\n\n      // Hold our own reference to fullscreen api so it can be mocked in tests\n      this.fsApi_ = FullscreenApi;\n\n      // Tracks when a tech changes the poster\n      this.isPosterFromTech_ = false;\n\n      // Holds callback info that gets queued when playback rate is zero\n      // and a seek is happening\n      this.queuedCallbacks_ = [];\n\n      // Turn off API access because we're loading a new tech that might load asynchronously\n      this.isReady_ = false;\n\n      // Init state hasStarted_\n      this.hasStarted_ = false;\n\n      // Init state userActive_\n      this.userActive_ = false;\n\n      // Init debugEnabled_\n      this.debugEnabled_ = false;\n\n      // Init state audioOnlyMode_\n      this.audioOnlyMode_ = false;\n\n      // Init state audioPosterMode_\n      this.audioPosterMode_ = false;\n\n      // Init state audioOnlyCache_\n      this.audioOnlyCache_ = {\n        playerHeight: null,\n        hiddenChildren: []\n      };\n\n      // if the global option object was accidentally blown away by\n      // someone, bail early with an informative error\n      if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {\n        throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n      }\n\n      // Store the original tag used to set options\n      this.tag = tag;\n\n      // Store the tag attributes used to restore html5 element\n      this.tagAttributes = tag && getAttributes(tag);\n\n      // Update current language\n      this.language(this.options_.language);\n\n      // Update Supported Languages\n      if (options.languages) {\n        // Normalise player option languages to lowercase\n        const languagesToLower = {};\n        Object.getOwnPropertyNames(options.languages).forEach(function (name) {\n          languagesToLower[name.toLowerCase()] = options.languages[name];\n        });\n        this.languages_ = languagesToLower;\n      } else {\n        this.languages_ = Player.prototype.options_.languages;\n      }\n      this.resetCache_();\n\n      // Set poster\n      this.poster_ = options.poster || '';\n\n      // Set controls\n      this.controls_ = !!options.controls;\n\n      // Original tag settings stored in options\n      // now remove immediately so native controls don't flash.\n      // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n      tag.controls = false;\n      tag.removeAttribute('controls');\n      this.changingSrc_ = false;\n      this.playCallbacks_ = [];\n      this.playTerminatedQueue_ = [];\n\n      // the attribute overrides the option\n      if (tag.hasAttribute('autoplay')) {\n        this.autoplay(true);\n      } else {\n        // otherwise use the setter to validate and\n        // set the correct value.\n        this.autoplay(this.options_.autoplay);\n      }\n\n      // check plugins\n      if (options.plugins) {\n        Object.keys(options.plugins).forEach(name => {\n          if (typeof this[name] !== 'function') {\n            throw new Error(`plugin \"${name}\" does not exist`);\n          }\n        });\n      }\n\n      /*\n       * Store the internal state of scrubbing\n       *\n       * @private\n       * @return {Boolean} True if the user is scrubbing\n       */\n      this.scrubbing_ = false;\n      this.el_ = this.createEl();\n\n      // Make this an evented object and use `el_` as its event bus.\n      evented(this, {\n        eventBusKey: 'el_'\n      });\n\n      // listen to document and player fullscreenchange handlers so we receive those events\n      // before a user can receive them so we can update isFullscreen appropriately.\n      // make sure that we listen to fullscreenchange events before everything else to make sure that\n      // our isFullscreen method is updated properly for internal components as well as external.\n      if (this.fsApi_.requestFullscreen) {\n        on(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n        this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n      }\n      if (this.fluid_) {\n        this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n      }\n      // We also want to pass the original player options to each component and plugin\n      // as well so they don't need to reach back into the player for options later.\n      // We also need to do another copy of this.options_ so we don't end up with\n      // an infinite loop.\n      const playerOptionsCopy = merge$2(this.options_);\n\n      // Load plugins\n      if (options.plugins) {\n        Object.keys(options.plugins).forEach(name => {\n          this[name](options.plugins[name]);\n        });\n      }\n\n      // Enable debug mode to fire debugon event for all plugins.\n      if (options.debug) {\n        this.debug(true);\n      }\n      this.options_.playerOptions = playerOptionsCopy;\n      this.middleware_ = [];\n      this.playbackRates(options.playbackRates);\n      this.initChildren();\n\n      // Set isAudio based on whether or not an audio tag was used\n      this.isAudio(tag.nodeName.toLowerCase() === 'audio');\n\n      // Update controls className. Can't do this when the controls are initially\n      // set because the element doesn't exist yet.\n      if (this.controls()) {\n        this.addClass('vjs-controls-enabled');\n      } else {\n        this.addClass('vjs-controls-disabled');\n      }\n\n      // Set ARIA label and region role depending on player type\n      this.el_.setAttribute('role', 'region');\n      if (this.isAudio()) {\n        this.el_.setAttribute('aria-label', this.localize('Audio Player'));\n      } else {\n        this.el_.setAttribute('aria-label', this.localize('Video Player'));\n      }\n      if (this.isAudio()) {\n        this.addClass('vjs-audio');\n      }\n\n      // TODO: Make this smarter. Toggle user state between touching/mousing\n      // using events, since devices can have both touch and mouse events.\n      // TODO: Make this check be performed again when the window switches between monitors\n      // (See https://github.com/videojs/video.js/issues/5683)\n      if (TOUCH_ENABLED) {\n        this.addClass('vjs-touch-enabled');\n      }\n\n      // iOS Safari has broken hover handling\n      if (!IS_IOS) {\n        this.addClass('vjs-workinghover');\n      }\n\n      // Make player easily findable by ID\n      Player.players[this.id_] = this;\n\n      // Add a major version class to aid css in plugins\n      const majorVersion = version$5.split('.')[0];\n      this.addClass(`vjs-v${majorVersion}`);\n\n      // When the player is first initialized, trigger activity so components\n      // like the control bar show themselves if needed\n      this.userActive(true);\n      this.reportUserActivity();\n      this.one('play', e => this.listenForUserActivity_(e));\n      this.on('keydown', e => this.handleKeyDown(e));\n      this.on('languagechange', e => this.handleLanguagechange(e));\n      this.breakpoints(this.options_.breakpoints);\n      this.responsive(this.options_.responsive);\n\n      // Calling both the audio mode methods after the player is fully\n      // setup to be able to listen to the events triggered by them\n      this.on('ready', () => {\n        // Calling the audioPosterMode method first so that\n        // the audioOnlyMode can take precedence when both options are set to true\n        this.audioPosterMode(this.options_.audioPosterMode);\n        this.audioOnlyMode(this.options_.audioOnlyMode);\n      });\n    }\n\n    /**\n     * Destroys the video player and does any necessary cleanup.\n     *\n     * This is especially helpful if you are dynamically adding and removing videos\n     * to/from the DOM.\n     *\n     * @fires Player#dispose\n     */\n    dispose() {\n      /**\n       * Called when the player is being disposed of.\n       *\n       * @event Player#dispose\n       * @type {EventTarget~Event}\n       */\n      this.trigger('dispose');\n      // prevent dispose from being called twice\n      this.off('dispose');\n\n      // Make sure all player-specific document listeners are unbound. This is\n      off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n      off(document, 'keydown', this.boundFullWindowOnEscKey_);\n      if (this.styleEl_ && this.styleEl_.parentNode) {\n        this.styleEl_.parentNode.removeChild(this.styleEl_);\n        this.styleEl_ = null;\n      }\n\n      // Kill reference to this player\n      Player.players[this.id_] = null;\n      if (this.tag && this.tag.player) {\n        this.tag.player = null;\n      }\n      if (this.el_ && this.el_.player) {\n        this.el_.player = null;\n      }\n      if (this.tech_) {\n        this.tech_.dispose();\n        this.isPosterFromTech_ = false;\n        this.poster_ = '';\n      }\n      if (this.playerElIngest_) {\n        this.playerElIngest_ = null;\n      }\n      if (this.tag) {\n        this.tag = null;\n      }\n      clearCacheForPlayer(this);\n\n      // remove all event handlers for track lists\n      // all tracks and track listeners are removed on\n      // tech dispose\n      ALL.names.forEach(name => {\n        const props = ALL[name];\n        const list = this[props.getterName]();\n\n        // if it is not a native list\n        // we have to manually remove event listeners\n        if (list && list.off) {\n          list.off();\n        }\n      });\n\n      // the actual .el_ is removed here, or replaced if\n      super.dispose({\n        restoreEl: this.options_.restoreEl\n      });\n    }\n\n    /**\n     * Create the `Player`'s DOM element.\n     *\n     * @return {Element}\n     *         The DOM element that gets created.\n     */\n    createEl() {\n      let tag = this.tag;\n      let el;\n      let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n      const divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n      if (playerElIngest) {\n        el = this.el_ = tag.parentNode;\n      } else if (!divEmbed) {\n        el = this.el_ = super.createEl('div');\n      }\n\n      // Copy over all the attributes from the tag, including ID and class\n      // ID will now reference player box, not the video tag\n      const attrs = getAttributes(tag);\n      if (divEmbed) {\n        el = this.el_ = tag;\n        tag = this.tag = document.createElement('video');\n        while (el.children.length) {\n          tag.appendChild(el.firstChild);\n        }\n        if (!hasClass(el, 'video-js')) {\n          addClass(el, 'video-js');\n        }\n        el.appendChild(tag);\n        playerElIngest = this.playerElIngest_ = el;\n        // move properties over from our custom `video-js` element\n        // to our new `video` element. This will move things like\n        // `src` or `controls` that were set via js before the player\n        // was initialized.\n        Object.keys(el).forEach(k => {\n          try {\n            tag[k] = el[k];\n          } catch (e) {\n            // we got a a property like outerHTML which we can't actually copy, ignore it\n          }\n        });\n      }\n\n      // set tabindex to -1 to remove the video element from the focus order\n      tag.setAttribute('tabindex', '-1');\n      attrs.tabindex = '-1';\n\n      // Workaround for #4583 on Chrome (on Windows) with JAWS.\n      // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\n      // Note that we can't detect if JAWS is being used, but this ARIA attribute\n      // doesn't change behavior of Chrome if JAWS is not being used\n      if (IS_CHROME && IS_WINDOWS) {\n        tag.setAttribute('role', 'application');\n        attrs.role = 'application';\n      }\n\n      // Remove width/height attrs from tag so CSS can make it 100% width/height\n      tag.removeAttribute('width');\n      tag.removeAttribute('height');\n      if ('width' in attrs) {\n        delete attrs.width;\n      }\n      if ('height' in attrs) {\n        delete attrs.height;\n      }\n      Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n        // don't copy over the class attribute to the player element when we're in a div embed\n        // the class is already set up properly in the divEmbed case\n        // and we want to make sure that the `video-js` class doesn't get lost\n        if (!(divEmbed && attr === 'class')) {\n          el.setAttribute(attr, attrs[attr]);\n        }\n        if (divEmbed) {\n          tag.setAttribute(attr, attrs[attr]);\n        }\n      });\n\n      // Update tag id/class for use as HTML5 playback tech\n      // Might think we should do this after embedding in container so .vjs-tech class\n      // doesn't flash 100% width/height, but class only applies with .video-js parent\n      tag.playerId = tag.id;\n      tag.id += '_html5_api';\n      tag.className = 'vjs-tech';\n\n      // Make player findable on elements\n      tag.player = el.player = this;\n      // Default state of video is paused\n      this.addClass('vjs-paused');\n\n      // Add a style element in the player that we'll use to set the width/height\n      // of the player in a way that's still overrideable by CSS, just like the\n      // video element\n      if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n        this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n        const defaultsStyleEl = $('.vjs-styles-defaults');\n        const head = $('head');\n        head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n      }\n      this.fill_ = false;\n      this.fluid_ = false;\n\n      // Pass in the width/height/aspectRatio options which will update the style el\n      this.width(this.options_.width);\n      this.height(this.options_.height);\n      this.fill(this.options_.fill);\n      this.fluid(this.options_.fluid);\n      this.aspectRatio(this.options_.aspectRatio);\n      // support both crossOrigin and crossorigin to reduce confusion and issues around the name\n      this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);\n\n      // Hide any links within the video/audio tag,\n      // because IE doesn't hide them completely from screen readers.\n      const links = tag.getElementsByTagName('a');\n      for (let i = 0; i < links.length; i++) {\n        const linkEl = links.item(i);\n        addClass(linkEl, 'vjs-hidden');\n        linkEl.setAttribute('hidden', 'hidden');\n      }\n\n      // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n      // keep track of the original for later so we can know if the source originally failed\n      tag.initNetworkState_ = tag.networkState;\n\n      // Wrap video tag in div (el/box) container\n      if (tag.parentNode && !playerElIngest) {\n        tag.parentNode.insertBefore(el, tag);\n      }\n\n      // insert the tag as the first child of the player element\n      // then manually add it to the children array so that this.addChild\n      // will work properly for other components\n      //\n      // Breaks iPhone, fixed in HTML5 setup.\n      prependTo(tag, el);\n      this.children_.unshift(tag);\n\n      // Set lang attr on player to ensure CSS :lang() in consistent with player\n      // if it's been set to something different to the doc\n      this.el_.setAttribute('lang', this.language_);\n      this.el_.setAttribute('translate', 'no');\n      this.el_ = el;\n      return el;\n    }\n\n    /**\n     * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this\n     * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n     * behavior.\n     *\n     * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n     *\n     * @param {string|null} [value]\n     *        The value to set the `Player`'s crossOrigin to. If an argument is\n     *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.\n     *\n     * @return {string|null|undefined}\n     *         - The current crossOrigin value of the `Player` when getting.\n     *         - undefined when setting\n     */\n    crossOrigin(value) {\n      // `null` can be set to unset a value\n      if (typeof value === 'undefined') {\n        return this.techGet_('crossOrigin');\n      }\n      if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {\n        log$1.warn(`crossOrigin must be null,  \"anonymous\" or \"use-credentials\", given \"${value}\"`);\n        return;\n      }\n      this.techCall_('setCrossOrigin', value);\n      if (this.posterImage) {\n        this.posterImage.crossOrigin(value);\n      }\n      return;\n    }\n\n    /**\n     * A getter/setter for the `Player`'s width. Returns the player's configured value.\n     * To get the current width use `currentWidth()`.\n     *\n     * @param {number} [value]\n     *        The value to set the `Player`'s width to.\n     *\n     * @return {number}\n     *         The current width of the `Player` when getting.\n     */\n    width(value) {\n      return this.dimension('width', value);\n    }\n\n    /**\n     * A getter/setter for the `Player`'s height. Returns the player's configured value.\n     * To get the current height use `currentheight()`.\n     *\n     * @param {number} [value]\n     *        The value to set the `Player`'s heigth to.\n     *\n     * @return {number}\n     *         The current height of the `Player` when getting.\n     */\n    height(value) {\n      return this.dimension('height', value);\n    }\n\n    /**\n     * A getter/setter for the `Player`'s width & height.\n     *\n     * @param {string} dimension\n     *        This string can be:\n     *        - 'width'\n     *        - 'height'\n     *\n     * @param {number} [value]\n     *        Value for dimension specified in the first argument.\n     *\n     * @return {number}\n     *         The dimension arguments value when getting (width/height).\n     */\n    dimension(dimension, value) {\n      const privDimension = dimension + '_';\n      if (value === undefined) {\n        return this[privDimension] || 0;\n      }\n      if (value === '' || value === 'auto') {\n        // If an empty string is given, reset the dimension to be automatic\n        this[privDimension] = undefined;\n        this.updateStyleEl_();\n        return;\n      }\n      const parsedVal = parseFloat(value);\n      if (isNaN(parsedVal)) {\n        log$1.error(`Improper value \"${value}\" supplied for for ${dimension}`);\n        return;\n      }\n      this[privDimension] = parsedVal;\n      this.updateStyleEl_();\n    }\n\n    /**\n     * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n     *\n     * Turning this on will turn off fill mode.\n     *\n     * @param {boolean} [bool]\n     *        - A value of true adds the class.\n     *        - A value of false removes the class.\n     *        - No value will be a getter.\n     *\n     * @return {boolean|undefined}\n     *         - The value of fluid when getting.\n     *         - `undefined` when setting.\n     */\n    fluid(bool) {\n      if (bool === undefined) {\n        return !!this.fluid_;\n      }\n      this.fluid_ = !!bool;\n      if (isEvented(this)) {\n        this.off(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n      }\n      if (bool) {\n        this.addClass('vjs-fluid');\n        this.fill(false);\n        addEventedCallback(this, () => {\n          this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n        });\n      } else {\n        this.removeClass('vjs-fluid');\n      }\n      this.updateStyleEl_();\n    }\n\n    /**\n     * A getter/setter/toggler for the vjs-fill `className` on the `Player`.\n     *\n     * Turning this on will turn off fluid mode.\n     *\n     * @param {boolean} [bool]\n     *        - A value of true adds the class.\n     *        - A value of false removes the class.\n     *        - No value will be a getter.\n     *\n     * @return {boolean|undefined}\n     *         - The value of fluid when getting.\n     *         - `undefined` when setting.\n     */\n    fill(bool) {\n      if (bool === undefined) {\n        return !!this.fill_;\n      }\n      this.fill_ = !!bool;\n      if (bool) {\n        this.addClass('vjs-fill');\n        this.fluid(false);\n      } else {\n        this.removeClass('vjs-fill');\n      }\n    }\n\n    /**\n     * Get/Set the aspect ratio\n     *\n     * @param {string} [ratio]\n     *        Aspect ratio for player\n     *\n     * @return {string|undefined}\n     *         returns the current aspect ratio when getting\n     */\n\n    /**\n     * A getter/setter for the `Player`'s aspect ratio.\n     *\n     * @param {string} [ratio]\n     *        The value to set the `Player`'s aspect ratio to.\n     *\n     * @return {string|undefined}\n     *         - The current aspect ratio of the `Player` when getting.\n     *         - undefined when setting\n     */\n    aspectRatio(ratio) {\n      if (ratio === undefined) {\n        return this.aspectRatio_;\n      }\n\n      // Check for width:height format\n      if (!/^\\d+\\:\\d+$/.test(ratio)) {\n        throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n      }\n      this.aspectRatio_ = ratio;\n\n      // We're assuming if you set an aspect ratio you want fluid mode,\n      // because in fixed mode you could calculate width and height yourself.\n      this.fluid(true);\n      this.updateStyleEl_();\n    }\n\n    /**\n     * Update styles of the `Player` element (height, width and aspect ratio).\n     *\n     * @private\n     * @listens Tech#loadedmetadata\n     */\n    updateStyleEl_() {\n      if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n        const width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n        const height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n        const techEl = this.tech_ && this.tech_.el();\n        if (techEl) {\n          if (width >= 0) {\n            techEl.width = width;\n          }\n          if (height >= 0) {\n            techEl.height = height;\n          }\n        }\n        return;\n      }\n      let width;\n      let height;\n      let aspectRatio;\n      let idClass;\n\n      // The aspect ratio is either used directly or to calculate width and height.\n      if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n        // Use any aspectRatio that's been specifically set\n        aspectRatio = this.aspectRatio_;\n      } else if (this.videoWidth() > 0) {\n        // Otherwise try to get the aspect ratio from the video metadata\n        aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n      } else {\n        // Or use a default. The video element's is 2:1, but 16:9 is more common.\n        aspectRatio = '16:9';\n      }\n\n      // Get the ratio as a decimal we can use to calculate dimensions\n      const ratioParts = aspectRatio.split(':');\n      const ratioMultiplier = ratioParts[1] / ratioParts[0];\n      if (this.width_ !== undefined) {\n        // Use any width that's been specifically set\n        width = this.width_;\n      } else if (this.height_ !== undefined) {\n        // Or calulate the width from the aspect ratio if a height has been set\n        width = this.height_ / ratioMultiplier;\n      } else {\n        // Or use the video's metadata, or use the video el's default of 300\n        width = this.videoWidth() || 300;\n      }\n      if (this.height_ !== undefined) {\n        // Use any height that's been specifically set\n        height = this.height_;\n      } else {\n        // Otherwise calculate the height from the ratio and the width\n        height = width * ratioMultiplier;\n      }\n\n      // Ensure the CSS class is valid by starting with an alpha character\n      if (/^[^a-zA-Z]/.test(this.id())) {\n        idClass = 'dimensions-' + this.id();\n      } else {\n        idClass = this.id() + '-dimensions';\n      }\n\n      // Ensure the right class is still on the player for the style element\n      this.addClass(idClass);\n      setTextContent(this.styleEl_, `\n      .${idClass} {\n        width: ${width}px;\n        height: ${height}px;\n      }\n\n      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ${ratioMultiplier * 100}%;\n      }\n    `);\n    }\n\n    /**\n     * Load/Create an instance of playback {@link Tech} including element\n     * and API methods. Then append the `Tech` element in `Player` as a child.\n     *\n     * @param {string} techName\n     *        name of the playback technology\n     *\n     * @param {string} source\n     *        video source\n     *\n     * @private\n     */\n    loadTech_(techName, source) {\n      // Pause and remove current playback technology\n      if (this.tech_) {\n        this.unloadTech_();\n      }\n      const titleTechName = toTitleCase$1(techName);\n      const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);\n\n      // get rid of the HTML5 video tag as soon as we are using another tech\n      if (titleTechName !== 'Html5' && this.tag) {\n        Tech.getTech('Html5').disposeMediaElement(this.tag);\n        this.tag.player = null;\n        this.tag = null;\n      }\n      this.techName_ = titleTechName;\n\n      // Turn off API access because we're loading a new tech that might load asynchronously\n      this.isReady_ = false;\n      let autoplay = this.autoplay();\n\n      // if autoplay is a string (or `true` with normalizeAutoplay: true) we pass false to the tech\n      // because the player is going to handle autoplay on `loadstart`\n      if (typeof this.autoplay() === 'string' || this.autoplay() === true && this.options_.normalizeAutoplay) {\n        autoplay = false;\n      }\n\n      // Grab tech-specific options from player options and add source and parent element to use.\n      const techOptions = {\n        source,\n        autoplay,\n        'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n        'playerId': this.id(),\n        'techId': `${this.id()}_${camelTechName}_api`,\n        'playsinline': this.options_.playsinline,\n        'preload': this.options_.preload,\n        'loop': this.options_.loop,\n        'disablePictureInPicture': this.options_.disablePictureInPicture,\n        'muted': this.options_.muted,\n        'poster': this.poster(),\n        'language': this.language(),\n        'playerElIngest': this.playerElIngest_ || false,\n        'vtt.js': this.options_['vtt.js'],\n        'canOverridePoster': !!this.options_.techCanOverridePoster,\n        'enableSourceset': this.options_.enableSourceset\n      };\n      ALL.names.forEach(name => {\n        const props = ALL[name];\n        techOptions[props.getterName] = this[props.privateName];\n      });\n      Object.assign(techOptions, this.options_[titleTechName]);\n      Object.assign(techOptions, this.options_[camelTechName]);\n      Object.assign(techOptions, this.options_[techName.toLowerCase()]);\n      if (this.tag) {\n        techOptions.tag = this.tag;\n      }\n      if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n        techOptions.startTime = this.cache_.currentTime;\n      }\n\n      // Initialize tech instance\n      const TechClass = Tech.getTech(techName);\n      if (!TechClass) {\n        throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);\n      }\n      this.tech_ = new TechClass(techOptions);\n\n      // player.triggerReady is always async, so don't need this to be async\n      this.tech_.ready(bind_(this, this.handleTechReady_), true);\n      textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\n\n      // Listen to all HTML5-defined events and trigger them on the player\n      TECH_EVENTS_RETRIGGER.forEach(event => {\n        this.on(this.tech_, event, e => this[`handleTech${toTitleCase$1(event)}_`](e));\n      });\n      Object.keys(TECH_EVENTS_QUEUE).forEach(event => {\n        this.on(this.tech_, event, eventObj => {\n          if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {\n            this.queuedCallbacks_.push({\n              callback: this[`handleTech${TECH_EVENTS_QUEUE[event]}_`].bind(this),\n              event: eventObj\n            });\n            return;\n          }\n          this[`handleTech${TECH_EVENTS_QUEUE[event]}_`](eventObj);\n        });\n      });\n      this.on(this.tech_, 'loadstart', e => this.handleTechLoadStart_(e));\n      this.on(this.tech_, 'sourceset', e => this.handleTechSourceset_(e));\n      this.on(this.tech_, 'waiting', e => this.handleTechWaiting_(e));\n      this.on(this.tech_, 'ended', e => this.handleTechEnded_(e));\n      this.on(this.tech_, 'seeking', e => this.handleTechSeeking_(e));\n      this.on(this.tech_, 'play', e => this.handleTechPlay_(e));\n      this.on(this.tech_, 'pause', e => this.handleTechPause_(e));\n      this.on(this.tech_, 'durationchange', e => this.handleTechDurationChange_(e));\n      this.on(this.tech_, 'fullscreenchange', (e, data) => this.handleTechFullscreenChange_(e, data));\n      this.on(this.tech_, 'fullscreenerror', (e, err) => this.handleTechFullscreenError_(e, err));\n      this.on(this.tech_, 'enterpictureinpicture', e => this.handleTechEnterPictureInPicture_(e));\n      this.on(this.tech_, 'leavepictureinpicture', e => this.handleTechLeavePictureInPicture_(e));\n      this.on(this.tech_, 'error', e => this.handleTechError_(e));\n      this.on(this.tech_, 'posterchange', e => this.handleTechPosterChange_(e));\n      this.on(this.tech_, 'textdata', e => this.handleTechTextData_(e));\n      this.on(this.tech_, 'ratechange', e => this.handleTechRateChange_(e));\n      this.on(this.tech_, 'loadedmetadata', this.boundUpdateStyleEl_);\n      this.usingNativeControls(this.techGet_('controls'));\n      if (this.controls() && !this.usingNativeControls()) {\n        this.addTechControlsListeners_();\n      }\n\n      // Add the tech element in the DOM if it was not already there\n      // Make sure to not insert the original video element if using Html5\n      if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n        prependTo(this.tech_.el(), this.el());\n      }\n\n      // Get rid of the original video tag reference after the first tech is loaded\n      if (this.tag) {\n        this.tag.player = null;\n        this.tag = null;\n      }\n    }\n\n    /**\n     * Unload and dispose of the current playback {@link Tech}.\n     *\n     * @private\n     */\n    unloadTech_() {\n      // Save the current text tracks so that we can reuse the same text tracks with the next tech\n      ALL.names.forEach(name => {\n        const props = ALL[name];\n        this[props.privateName] = this[props.getterName]();\n      });\n      this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n      this.isReady_ = false;\n      this.tech_.dispose();\n      this.tech_ = false;\n      if (this.isPosterFromTech_) {\n        this.poster_ = '';\n        this.trigger('posterchange');\n      }\n      this.isPosterFromTech_ = false;\n    }\n\n    /**\n     * Return a reference to the current {@link Tech}.\n     * It will print a warning by default about the danger of using the tech directly\n     * but any argument that is passed in will silence the warning.\n     *\n     * @param {*} [safety]\n     *        Anything passed in to silence the warning\n     *\n     * @return {Tech}\n     *         The Tech\n     */\n    tech(safety) {\n      if (safety === undefined) {\n        log$1.warn('Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\\n');\n      }\n      return this.tech_;\n    }\n\n    /**\n     * Set up click and touch listeners for the playback element\n     *\n     * - On desktops: a click on the video itself will toggle playback\n     * - On mobile devices: a click on the video toggles controls\n     *   which is done by toggling the user state between active and\n     *   inactive\n     * - A tap can signal that a user has become active or has become inactive\n     *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n     *   quick tap should hide them again (signaling the user is in an inactive\n     *   viewing state)\n     * - In addition to this, we still want the user to be considered inactive after\n     *   a few seconds of inactivity.\n     *\n     * > Note: the only part of iOS interaction we can't mimic with this setup\n     * is a touch and hold on the video element counting as activity in order to\n     * keep the controls showing, but that shouldn't be an issue. A touch and hold\n     * on any controls will still keep the user active\n     *\n     * @private\n     */\n    addTechControlsListeners_() {\n      // Make sure to remove all the previous listeners in case we are called multiple times.\n      this.removeTechControlsListeners_();\n      this.on(this.tech_, 'click', this.boundHandleTechClick_);\n      this.on(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\n\n      // If the controls were hidden we don't want that to change without a tap event\n      // so we'll check if the controls were already showing before reporting user\n      // activity\n      this.on(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\n      this.on(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\n      this.on(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\n\n      // The tap listener needs to come after the touchend listener because the tap\n      // listener cancels out any reportedUserActivity when setting userActive(false)\n      this.on(this.tech_, 'tap', this.boundHandleTechTap_);\n    }\n\n    /**\n     * Remove the listeners used for click and tap controls. This is needed for\n     * toggling to controls disabled, where a tap/touch should do nothing.\n     *\n     * @private\n     */\n    removeTechControlsListeners_() {\n      // We don't want to just use `this.off()` because there might be other needed\n      // listeners added by techs that extend this.\n      this.off(this.tech_, 'tap', this.boundHandleTechTap_);\n      this.off(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\n      this.off(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\n      this.off(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\n      this.off(this.tech_, 'click', this.boundHandleTechClick_);\n      this.off(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\n    }\n\n    /**\n     * Player waits for the tech to be ready\n     *\n     * @private\n     */\n    handleTechReady_() {\n      this.triggerReady();\n\n      // Keep the same volume as before\n      if (this.cache_.volume) {\n        this.techCall_('setVolume', this.cache_.volume);\n      }\n\n      // Look if the tech found a higher resolution poster while loading\n      this.handleTechPosterChange_();\n\n      // Update the duration if available\n      this.handleTechDurationChange_();\n    }\n\n    /**\n     * Retrigger the `loadstart` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#loadstart\n     * @listens Tech#loadstart\n     * @private\n     */\n    handleTechLoadStart_() {\n      // TODO: Update to use `emptied` event instead. See #1277.\n\n      this.removeClass('vjs-ended', 'vjs-seeking');\n\n      // reset the error state\n      this.error(null);\n\n      // Update the duration\n      this.handleTechDurationChange_();\n      if (!this.paused()) {\n        /**\n         * Fired when the user agent begins looking for media data\n         *\n         * @event Player#loadstart\n         * @type {EventTarget~Event}\n         */\n        this.trigger('loadstart');\n      } else {\n        // reset the hasStarted state\n        this.hasStarted(false);\n        this.trigger('loadstart');\n      }\n\n      // autoplay happens after loadstart for the browser,\n      // so we mimic that behavior\n      this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? 'play' : this.autoplay());\n    }\n\n    /**\n     * Handle autoplay string values, rather than the typical boolean\n     * values that should be handled by the tech. Note that this is not\n     * part of any specification. Valid values and what they do can be\n     * found on the autoplay getter at Player#autoplay()\n     */\n    manualAutoplay_(type) {\n      if (!this.tech_ || typeof type !== 'string') {\n        return;\n      }\n\n      // Save original muted() value, set muted to true, and attempt to play().\n      // On promise rejection, restore muted from saved value\n      const resolveMuted = () => {\n        const previouslyMuted = this.muted();\n        this.muted(true);\n        const restoreMuted = () => {\n          this.muted(previouslyMuted);\n        };\n\n        // restore muted on play terminatation\n        this.playTerminatedQueue_.push(restoreMuted);\n        const mutedPromise = this.play();\n        if (!isPromise(mutedPromise)) {\n          return;\n        }\n        return mutedPromise.catch(err => {\n          restoreMuted();\n          throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ''}`);\n        });\n      };\n      let promise;\n\n      // if muted defaults to true\n      // the only thing we can do is call play\n      if (type === 'any' && !this.muted()) {\n        promise = this.play();\n        if (isPromise(promise)) {\n          promise = promise.catch(resolveMuted);\n        }\n      } else if (type === 'muted' && !this.muted()) {\n        promise = resolveMuted();\n      } else {\n        promise = this.play();\n      }\n      if (!isPromise(promise)) {\n        return;\n      }\n      return promise.then(() => {\n        this.trigger({\n          type: 'autoplay-success',\n          autoplay: type\n        });\n      }).catch(() => {\n        this.trigger({\n          type: 'autoplay-failure',\n          autoplay: type\n        });\n      });\n    }\n\n    /**\n     * Update the internal source caches so that we return the correct source from\n     * `src()`, `currentSource()`, and `currentSources()`.\n     *\n     * > Note: `currentSources` will not be updated if the source that is passed in exists\n     *         in the current `currentSources` cache.\n     *\n     *\n     * @param {Tech~SourceObject} srcObj\n     *        A string or object source to update our caches to.\n     */\n    updateSourceCaches_(srcObj = '') {\n      let src = srcObj;\n      let type = '';\n      if (typeof src !== 'string') {\n        src = srcObj.src;\n        type = srcObj.type;\n      }\n\n      // make sure all the caches are set to default values\n      // to prevent null checking\n      this.cache_.source = this.cache_.source || {};\n      this.cache_.sources = this.cache_.sources || [];\n\n      // try to get the type of the src that was passed in\n      if (src && !type) {\n        type = findMimetype(this, src);\n      }\n\n      // update `currentSource` cache always\n      this.cache_.source = merge$2({}, srcObj, {\n        src,\n        type\n      });\n      const matchingSources = this.cache_.sources.filter(s => s.src && s.src === src);\n      const sourceElSources = [];\n      const sourceEls = this.$$('source');\n      const matchingSourceEls = [];\n      for (let i = 0; i < sourceEls.length; i++) {\n        const sourceObj = getAttributes(sourceEls[i]);\n        sourceElSources.push(sourceObj);\n        if (sourceObj.src && sourceObj.src === src) {\n          matchingSourceEls.push(sourceObj.src);\n        }\n      }\n\n      // if we have matching source els but not matching sources\n      // the current source cache is not up to date\n      if (matchingSourceEls.length && !matchingSources.length) {\n        this.cache_.sources = sourceElSources;\n        // if we don't have matching source or source els set the\n        // sources cache to the `currentSource` cache\n      } else if (!matchingSources.length) {\n        this.cache_.sources = [this.cache_.source];\n      }\n\n      // update the tech `src` cache\n      this.cache_.src = src;\n    }\n\n    /**\n     * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\n     * causing the media element to reload.\n     *\n     * It will fire for the initial source and each subsequent source.\n     * This event is a custom event from Video.js and is triggered by the {@link Tech}.\n     *\n     * The event object for this event contains a `src` property that will contain the source\n     * that was available when the event was triggered. This is generally only necessary if Video.js\n     * is switching techs while the source was being changed.\n     *\n     * It is also fired when `load` is called on the player (or media element)\n     * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\n     * says that the resource selection algorithm needs to be aborted and restarted.\n     * In this case, it is very likely that the `src` property will be set to the\n     * empty string `\"\"` to indicate we do not know what the source will be but\n     * that it is changing.\n     *\n     * *This event is currently still experimental and may change in minor releases.*\n     * __To use this, pass `enableSourceset` option to the player.__\n     *\n     * @event Player#sourceset\n     * @type {EventTarget~Event}\n     * @prop {string} src\n     *                The source url available when the `sourceset` was triggered.\n     *                It will be an empty string if we cannot know what the source is\n     *                but know that the source will change.\n     */\n    /**\n     * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#sourceset\n     * @listens Tech#sourceset\n     * @private\n     */\n    handleTechSourceset_(event) {\n      // only update the source cache when the source\n      // was not updated using the player api\n      if (!this.changingSrc_) {\n        let updateSourceCaches = src => this.updateSourceCaches_(src);\n        const playerSrc = this.currentSource().src;\n        const eventSrc = event.src;\n\n        // if we have a playerSrc that is not a blob, and a tech src that is a blob\n        if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {\n          // if both the tech source and the player source were updated we assume\n          // something like @videojs/http-streaming did the sourceset and skip updating the source cache.\n          if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {\n            updateSourceCaches = () => {};\n          }\n        }\n\n        // update the source to the initial source right away\n        // in some cases this will be empty string\n        updateSourceCaches(eventSrc);\n\n        // if the `sourceset` `src` was an empty string\n        // wait for a `loadstart` to update the cache to `currentSrc`.\n        // If a sourceset happens before a `loadstart`, we reset the state\n        if (!event.src) {\n          this.tech_.any(['sourceset', 'loadstart'], e => {\n            // if a sourceset happens before a `loadstart` there\n            // is nothing to do as this `handleTechSourceset_`\n            // will be called again and this will be handled there.\n            if (e.type === 'sourceset') {\n              return;\n            }\n            const techSrc = this.techGet('currentSrc');\n            this.lastSource_.tech = techSrc;\n            this.updateSourceCaches_(techSrc);\n          });\n        }\n      }\n      this.lastSource_ = {\n        player: this.currentSource().src,\n        tech: event.src\n      };\n      this.trigger({\n        src: event.src,\n        type: 'sourceset'\n      });\n    }\n\n    /**\n     * Add/remove the vjs-has-started class\n     *\n     *\n     * @param {boolean} request\n     *        - true: adds the class\n     *        - false: remove the class\n     *\n     * @return {boolean}\n     *         the boolean value of hasStarted_\n     */\n    hasStarted(request) {\n      if (request === undefined) {\n        // act as getter, if we have no request to change\n        return this.hasStarted_;\n      }\n      if (request === this.hasStarted_) {\n        return;\n      }\n      this.hasStarted_ = request;\n      if (this.hasStarted_) {\n        this.addClass('vjs-has-started');\n      } else {\n        this.removeClass('vjs-has-started');\n      }\n    }\n\n    /**\n     * Fired whenever the media begins or resumes playback\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n     * @fires Player#play\n     * @listens Tech#play\n     * @private\n     */\n    handleTechPlay_() {\n      this.removeClass('vjs-ended', 'vjs-paused');\n      this.addClass('vjs-playing');\n\n      // hide the poster when the user hits play\n      this.hasStarted(true);\n      /**\n       * Triggered whenever an {@link Tech#play} event happens. Indicates that\n       * playback has started or resumed.\n       *\n       * @event Player#play\n       * @type {EventTarget~Event}\n       */\n      this.trigger('play');\n    }\n\n    /**\n     * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n     *\n     * If there were any events queued while the playback rate was zero, fire\n     * those events now.\n     *\n     * @private\n     * @method Player#handleTechRateChange_\n     * @fires Player#ratechange\n     * @listens Tech#ratechange\n     */\n    handleTechRateChange_() {\n      if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\n        this.queuedCallbacks_.forEach(queued => queued.callback(queued.event));\n        this.queuedCallbacks_ = [];\n      }\n      this.cache_.lastPlaybackRate = this.tech_.playbackRate();\n      /**\n       * Fires when the playing speed of the audio/video is changed\n       *\n       * @event Player#ratechange\n       * @type {event}\n       */\n      this.trigger('ratechange');\n    }\n\n    /**\n     * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#waiting\n     * @listens Tech#waiting\n     * @private\n     */\n    handleTechWaiting_() {\n      this.addClass('vjs-waiting');\n      /**\n       * A readyState change on the DOM element has caused playback to stop.\n       *\n       * @event Player#waiting\n       * @type {EventTarget~Event}\n       */\n      this.trigger('waiting');\n\n      // Browsers may emit a timeupdate event after a waiting event. In order to prevent\n      // premature removal of the waiting class, wait for the time to change.\n      const timeWhenWaiting = this.currentTime();\n      const timeUpdateListener = () => {\n        if (timeWhenWaiting !== this.currentTime()) {\n          this.removeClass('vjs-waiting');\n          this.off('timeupdate', timeUpdateListener);\n        }\n      };\n      this.on('timeupdate', timeUpdateListener);\n    }\n\n    /**\n     * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n     * > Note: This is not consistent between browsers. See #1351\n     *\n     * @fires Player#canplay\n     * @listens Tech#canplay\n     * @private\n     */\n    handleTechCanPlay_() {\n      this.removeClass('vjs-waiting');\n      /**\n       * The media has a readyState of HAVE_FUTURE_DATA or greater.\n       *\n       * @event Player#canplay\n       * @type {EventTarget~Event}\n       */\n      this.trigger('canplay');\n    }\n\n    /**\n     * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#canplaythrough\n     * @listens Tech#canplaythrough\n     * @private\n     */\n    handleTechCanPlayThrough_() {\n      this.removeClass('vjs-waiting');\n      /**\n       * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n       * entire media file can be played without buffering.\n       *\n       * @event Player#canplaythrough\n       * @type {EventTarget~Event}\n       */\n      this.trigger('canplaythrough');\n    }\n\n    /**\n     * Retrigger the `playing` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#playing\n     * @listens Tech#playing\n     * @private\n     */\n    handleTechPlaying_() {\n      this.removeClass('vjs-waiting');\n      /**\n       * The media is no longer blocked from playback, and has started playing.\n       *\n       * @event Player#playing\n       * @type {EventTarget~Event}\n       */\n      this.trigger('playing');\n    }\n\n    /**\n     * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#seeking\n     * @listens Tech#seeking\n     * @private\n     */\n    handleTechSeeking_() {\n      this.addClass('vjs-seeking');\n      /**\n       * Fired whenever the player is jumping to a new time\n       *\n       * @event Player#seeking\n       * @type {EventTarget~Event}\n       */\n      this.trigger('seeking');\n    }\n\n    /**\n     * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#seeked\n     * @listens Tech#seeked\n     * @private\n     */\n    handleTechSeeked_() {\n      this.removeClass('vjs-seeking', 'vjs-ended');\n      /**\n       * Fired when the player has finished jumping to a new time\n       *\n       * @event Player#seeked\n       * @type {EventTarget~Event}\n       */\n      this.trigger('seeked');\n    }\n\n    /**\n     * Retrigger the `pause` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#pause\n     * @listens Tech#pause\n     * @private\n     */\n    handleTechPause_() {\n      this.removeClass('vjs-playing');\n      this.addClass('vjs-paused');\n      /**\n       * Fired whenever the media has been paused\n       *\n       * @event Player#pause\n       * @type {EventTarget~Event}\n       */\n      this.trigger('pause');\n    }\n\n    /**\n     * Retrigger the `ended` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#ended\n     * @listens Tech#ended\n     * @private\n     */\n    handleTechEnded_() {\n      this.addClass('vjs-ended');\n      this.removeClass('vjs-waiting');\n      if (this.options_.loop) {\n        this.currentTime(0);\n        this.play();\n      } else if (!this.paused()) {\n        this.pause();\n      }\n\n      /**\n       * Fired when the end of the media resource is reached (currentTime == duration)\n       *\n       * @event Player#ended\n       * @type {EventTarget~Event}\n       */\n      this.trigger('ended');\n    }\n\n    /**\n     * Fired when the duration of the media resource is first known or changed\n     *\n     * @listens Tech#durationchange\n     * @private\n     */\n    handleTechDurationChange_() {\n      this.duration(this.techGet_('duration'));\n    }\n\n    /**\n     * Handle a click on the media element to play/pause\n     *\n     * @param {EventTarget~Event} event\n     *        the event that caused this function to trigger\n     *\n     * @listens Tech#click\n     * @private\n     */\n    handleTechClick_(event) {\n      // When controls are disabled a click should not toggle playback because\n      // the click is considered a control\n      if (!this.controls_) {\n        return;\n      }\n      if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.click === undefined || this.options_.userActions.click !== false) {\n        if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.click === 'function') {\n          this.options_.userActions.click.call(this, event);\n        } else if (this.paused()) {\n          silencePromise(this.play());\n        } else {\n          this.pause();\n        }\n      }\n    }\n\n    /**\n     * Handle a double-click on the media element to enter/exit fullscreen\n     *\n     * @param {EventTarget~Event} event\n     *        the event that caused this function to trigger\n     *\n     * @listens Tech#dblclick\n     * @private\n     */\n    handleTechDoubleClick_(event) {\n      if (!this.controls_) {\n        return;\n      }\n\n      // we do not want to toggle fullscreen state\n      // when double-clicking inside a control bar or a modal\n      const inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), el => el.contains(event.target));\n      if (!inAllowedEls) {\n        /*\n         * options.userActions.doubleClick\n         *\n         * If `undefined` or `true`, double-click toggles fullscreen if controls are present\n         * Set to `false` to disable double-click handling\n         * Set to a function to substitute an external double-click handler\n         */\n        if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {\n          if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {\n            this.options_.userActions.doubleClick.call(this, event);\n          } else if (this.isFullscreen()) {\n            this.exitFullscreen();\n          } else {\n            this.requestFullscreen();\n          }\n        }\n      }\n    }\n\n    /**\n     * Handle a tap on the media element. It will toggle the user\n     * activity state, which hides and shows the controls.\n     *\n     * @listens Tech#tap\n     * @private\n     */\n    handleTechTap_() {\n      this.userActive(!this.userActive());\n    }\n\n    /**\n     * Handle touch to start\n     *\n     * @listens Tech#touchstart\n     * @private\n     */\n    handleTechTouchStart_() {\n      this.userWasActive = this.userActive();\n    }\n\n    /**\n     * Handle touch to move\n     *\n     * @listens Tech#touchmove\n     * @private\n     */\n    handleTechTouchMove_() {\n      if (this.userWasActive) {\n        this.reportUserActivity();\n      }\n    }\n\n    /**\n     * Handle touch to end\n     *\n     * @param {EventTarget~Event} event\n     *        the touchend event that triggered\n     *        this function\n     *\n     * @listens Tech#touchend\n     * @private\n     */\n    handleTechTouchEnd_(event) {\n      // Stop the mouse events from also happening\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * @private\n     */\n    toggleFullscreenClass_() {\n      if (this.isFullscreen()) {\n        this.addClass('vjs-fullscreen');\n      } else {\n        this.removeClass('vjs-fullscreen');\n      }\n    }\n\n    /**\n     * when the document fschange event triggers it calls this\n     */\n    documentFullscreenChange_(e) {\n      const targetPlayer = e.target.player;\n\n      // if another player was fullscreen\n      // do a null check for targetPlayer because older firefox's would put document as e.target\n      if (targetPlayer && targetPlayer !== this) {\n        return;\n      }\n      const el = this.el();\n      let isFs = document[this.fsApi_.fullscreenElement] === el;\n      if (!isFs && el.matches) {\n        isFs = el.matches(':' + this.fsApi_.fullscreen);\n      } else if (!isFs && el.msMatchesSelector) {\n        isFs = el.msMatchesSelector(':' + this.fsApi_.fullscreen);\n      }\n      this.isFullscreen(isFs);\n    }\n\n    /**\n     * Handle Tech Fullscreen Change\n     *\n     * @param {EventTarget~Event} event\n     *        the fullscreenchange event that triggered this function\n     *\n     * @param {Object} data\n     *        the data that was sent with the event\n     *\n     * @private\n     * @listens Tech#fullscreenchange\n     * @fires Player#fullscreenchange\n     */\n    handleTechFullscreenChange_(event, data) {\n      if (data) {\n        if (data.nativeIOSFullscreen) {\n          this.addClass('vjs-ios-native-fs');\n          this.tech_.one('webkitendfullscreen', () => {\n            this.removeClass('vjs-ios-native-fs');\n          });\n        }\n        this.isFullscreen(data.isFullscreen);\n      }\n    }\n    handleTechFullscreenError_(event, err) {\n      this.trigger('fullscreenerror', err);\n    }\n\n    /**\n     * @private\n     */\n    togglePictureInPictureClass_() {\n      if (this.isInPictureInPicture()) {\n        this.addClass('vjs-picture-in-picture');\n      } else {\n        this.removeClass('vjs-picture-in-picture');\n      }\n    }\n\n    /**\n     * Handle Tech Enter Picture-in-Picture.\n     *\n     * @param {EventTarget~Event} event\n     *        the enterpictureinpicture event that triggered this function\n     *\n     * @private\n     * @listens Tech#enterpictureinpicture\n     */\n    handleTechEnterPictureInPicture_(event) {\n      this.isInPictureInPicture(true);\n    }\n\n    /**\n     * Handle Tech Leave Picture-in-Picture.\n     *\n     * @param {EventTarget~Event} event\n     *        the leavepictureinpicture event that triggered this function\n     *\n     * @private\n     * @listens Tech#leavepictureinpicture\n     */\n    handleTechLeavePictureInPicture_(event) {\n      this.isInPictureInPicture(false);\n    }\n\n    /**\n     * Fires when an error occurred during the loading of an audio/video.\n     *\n     * @private\n     * @listens Tech#error\n     */\n    handleTechError_() {\n      const error = this.tech_.error();\n      this.error(error);\n    }\n\n    /**\n     * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n     *\n     * @fires Player#textdata\n     * @listens Tech#textdata\n     * @private\n     */\n    handleTechTextData_() {\n      let data = null;\n      if (arguments.length > 1) {\n        data = arguments[1];\n      }\n\n      /**\n       * Fires when we get a textdata event from tech\n       *\n       * @event Player#textdata\n       * @type {EventTarget~Event}\n       */\n      this.trigger('textdata', data);\n    }\n\n    /**\n     * Get object for cached values.\n     *\n     * @return {Object}\n     *         get the current object cache\n     */\n    getCache() {\n      return this.cache_;\n    }\n\n    /**\n     * Resets the internal cache object.\n     *\n     * Using this function outside the player constructor or reset method may\n     * have unintended side-effects.\n     *\n     * @private\n     */\n    resetCache_() {\n      this.cache_ = {\n        // Right now, the currentTime is not _really_ cached because it is always\n        // retrieved from the tech (see: currentTime). However, for completeness,\n        // we set it to zero here to ensure that if we do start actually caching\n        // it, we reset it along with everything else.\n        currentTime: 0,\n        initTime: 0,\n        inactivityTimeout: this.options_.inactivityTimeout,\n        duration: NaN,\n        lastVolume: 1,\n        lastPlaybackRate: this.defaultPlaybackRate(),\n        media: null,\n        src: '',\n        source: {},\n        sources: [],\n        playbackRates: [],\n        volume: 1\n      };\n    }\n\n    /**\n     * Pass values to the playback tech\n     *\n     * @param {string} [method]\n     *        the method to call\n     *\n     * @param {Object} arg\n     *        the argument to pass\n     *\n     * @private\n     */\n    techCall_(method, arg) {\n      // If it's not ready yet, call method when it is\n\n      this.ready(function () {\n        if (method in allowedSetters) {\n          return set(this.middleware_, this.tech_, method, arg);\n        } else if (method in allowedMediators) {\n          return mediate(this.middleware_, this.tech_, method, arg);\n        }\n        try {\n          if (this.tech_) {\n            this.tech_[method](arg);\n          }\n        } catch (e) {\n          log$1(e);\n          throw e;\n        }\n      }, true);\n    }\n\n    /**\n     * Mediate attempt to call playback tech method\n     * and return the value of the method called.\n     *\n     * @param {string} method\n     *        Tech method\n     *\n     * @return {*}\n     *         Value returned by the tech method called, undefined if tech\n     *         is not ready or tech method is not present\n     *\n     * @private\n     */\n    techGet_(method) {\n      if (!this.tech_ || !this.tech_.isReady_) {\n        return;\n      }\n      if (method in allowedGetters) {\n        return get(this.middleware_, this.tech_, method);\n      } else if (method in allowedMediators) {\n        return mediate(this.middleware_, this.tech_, method);\n      }\n\n      // Log error when playback tech object is present but method\n      // is undefined or unavailable\n      try {\n        return this.tech_[method]();\n      } catch (e) {\n        // When building additional tech libs, an expected method may not be defined yet\n        if (this.tech_[method] === undefined) {\n          log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);\n          throw e;\n        }\n\n        // When a method isn't available on the object it throws a TypeError\n        if (e.name === 'TypeError') {\n          log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);\n          this.tech_.isReady_ = false;\n          throw e;\n        }\n\n        // If error unknown, just log and throw\n        log$1(e);\n        throw e;\n      }\n    }\n\n    /**\n     * Attempt to begin playback at the first opportunity.\n     *\n     * @return {Promise|undefined}\n     *         Returns a promise if the browser supports Promises (or one\n     *         was passed in as an option). This promise will be resolved on\n     *         the return value of play. If this is undefined it will fulfill the\n     *         promise chain otherwise the promise chain will be fulfilled when\n     *         the promise from play is fulfilled.\n     */\n    play() {\n      return new Promise(resolve => {\n        this.play_(resolve);\n      });\n    }\n\n    /**\n     * The actual logic for play, takes a callback that will be resolved on the\n     * return value of play. This allows us to resolve to the play promise if there\n     * is one on modern browsers.\n     *\n     * @private\n     * @param {Function} [callback]\n     *        The callback that should be called when the techs play is actually called\n     */\n    play_(callback = silencePromise) {\n      this.playCallbacks_.push(callback);\n      const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));\n\n      // treat calls to play_ somewhat like the `one` event function\n      if (this.waitToPlay_) {\n        this.off(['ready', 'loadstart'], this.waitToPlay_);\n        this.waitToPlay_ = null;\n      }\n\n      // if the player/tech is not ready or the src itself is not ready\n      // queue up a call to play on `ready` or `loadstart`\n      if (!this.isReady_ || !isSrcReady) {\n        this.waitToPlay_ = e => {\n          this.play_();\n        };\n        this.one(['ready', 'loadstart'], this.waitToPlay_);\n\n        // if we are in Safari, there is a high chance that loadstart will trigger after the gesture timeperiod\n        // in that case, we need to prime the video element by calling load so it'll be ready in time\n        if (!isSrcReady && (IS_ANY_SAFARI || IS_IOS)) {\n          this.load();\n        }\n        return;\n      }\n\n      // If the player/tech is ready and we have a source, we can attempt playback.\n      const val = this.techGet_('play');\n\n      // play was terminated if the returned value is null\n      if (val === null) {\n        this.runPlayTerminatedQueue_();\n      } else {\n        this.runPlayCallbacks_(val);\n      }\n    }\n\n    /**\n     * These functions will be run when if play is terminated. If play\n     * runPlayCallbacks_ is run these function will not be run. This allows us\n     * to differenciate between a terminated play and an actual call to play.\n     */\n    runPlayTerminatedQueue_() {\n      const queue = this.playTerminatedQueue_.slice(0);\n      this.playTerminatedQueue_ = [];\n      queue.forEach(function (q) {\n        q();\n      });\n    }\n\n    /**\n     * When a callback to play is delayed we have to run these\n     * callbacks when play is actually called on the tech. This function\n     * runs the callbacks that were delayed and accepts the return value\n     * from the tech.\n     *\n     * @param {undefined|Promise} val\n     *        The return value from the tech.\n     */\n    runPlayCallbacks_(val) {\n      const callbacks = this.playCallbacks_.slice(0);\n      this.playCallbacks_ = [];\n      // clear play terminatedQueue since we finished a real play\n      this.playTerminatedQueue_ = [];\n      callbacks.forEach(function (cb) {\n        cb(val);\n      });\n    }\n\n    /**\n     * Pause the video playback\n     *\n     * @return {Player}\n     *         A reference to the player object this function was called on\n     */\n    pause() {\n      this.techCall_('pause');\n    }\n\n    /**\n     * Check if the player is paused or has yet to play\n     *\n     * @return {boolean}\n     *         - false: if the media is currently playing\n     *         - true: if media is not currently playing\n     */\n    paused() {\n      // The initial state of paused should be true (in Safari it's actually false)\n      return this.techGet_('paused') === false ? false : true;\n    }\n\n    /**\n     * Get a TimeRange object representing the current ranges of time that the user\n     * has played.\n     *\n     * @return {TimeRange}\n     *         A time range object that represents all the increments of time that have\n     *         been played.\n     */\n    played() {\n      return this.techGet_('played') || createTimeRanges$1(0, 0);\n    }\n\n    /**\n     * Returns whether or not the user is \"scrubbing\". Scrubbing is\n     * when the user has clicked the progress bar handle and is\n     * dragging it along the progress bar.\n     *\n     * @param {boolean} [isScrubbing]\n     *        whether the user is or is not scrubbing\n     *\n     * @return {boolean}\n     *         The value of scrubbing when getting\n     */\n    scrubbing(isScrubbing) {\n      if (typeof isScrubbing === 'undefined') {\n        return this.scrubbing_;\n      }\n      this.scrubbing_ = !!isScrubbing;\n      this.techCall_('setScrubbing', this.scrubbing_);\n      if (isScrubbing) {\n        this.addClass('vjs-scrubbing');\n      } else {\n        this.removeClass('vjs-scrubbing');\n      }\n    }\n\n    /**\n     * Get or set the current time (in seconds)\n     *\n     * @param {number|string} [seconds]\n     *        The time to seek to in seconds\n     *\n     * @return {number}\n     *         - the current time in seconds when getting\n     */\n    currentTime(seconds) {\n      if (typeof seconds !== 'undefined') {\n        if (seconds < 0) {\n          seconds = 0;\n        }\n        if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {\n          this.cache_.initTime = seconds;\n          this.off('canplay', this.boundApplyInitTime_);\n          this.one('canplay', this.boundApplyInitTime_);\n          return;\n        }\n        this.techCall_('setCurrentTime', seconds);\n        this.cache_.initTime = 0;\n        return;\n      }\n\n      // cache last currentTime and return. default to 0 seconds\n      //\n      // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n      // currentTime when scrubbing, but may not provide much performance benefit afterall.\n      // Should be tested. Also something has to read the actual current time or the cache will\n      // never get updated.\n      this.cache_.currentTime = this.techGet_('currentTime') || 0;\n      return this.cache_.currentTime;\n    }\n\n    /**\n     * Apply the value of initTime stored in cache as currentTime.\n     *\n     * @private\n     */\n    applyInitTime_() {\n      this.currentTime(this.cache_.initTime);\n    }\n\n    /**\n     * Normally gets the length in time of the video in seconds;\n     * in all but the rarest use cases an argument will NOT be passed to the method\n     *\n     * > **NOTE**: The video must have started loading before the duration can be\n     * known, and depending on preload behaviour may not be known until the video starts\n     * playing.\n     *\n     * @fires Player#durationchange\n     *\n     * @param {number} [seconds]\n     *        The duration of the video to set in seconds\n     *\n     * @return {number}\n     *         - The duration of the video in seconds when getting\n     */\n    duration(seconds) {\n      if (seconds === undefined) {\n        // return NaN if the duration is not known\n        return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n      }\n      seconds = parseFloat(seconds);\n\n      // Standardize on Infinity for signaling video is live\n      if (seconds < 0) {\n        seconds = Infinity;\n      }\n      if (seconds !== this.cache_.duration) {\n        // Cache the last set value for optimized scrubbing\n        this.cache_.duration = seconds;\n        if (seconds === Infinity) {\n          this.addClass('vjs-live');\n        } else {\n          this.removeClass('vjs-live');\n        }\n        if (!isNaN(seconds)) {\n          // Do not fire durationchange unless the duration value is known.\n          // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n\n          /**\n           * @event Player#durationchange\n           * @type {EventTarget~Event}\n           */\n          this.trigger('durationchange');\n        }\n      }\n    }\n\n    /**\n     * Calculates how much time is left in the video. Not part\n     * of the native video API.\n     *\n     * @return {number}\n     *         The time remaining in seconds\n     */\n    remainingTime() {\n      return this.duration() - this.currentTime();\n    }\n\n    /**\n     * A remaining time function that is intented to be used when\n     * the time is to be displayed directly to the user.\n     *\n     * @return {number}\n     *         The rounded time remaining in seconds\n     */\n    remainingTimeDisplay() {\n      return Math.floor(this.duration()) - Math.floor(this.currentTime());\n    }\n\n    //\n    // Kind of like an array of portions of the video that have been downloaded.\n\n    /**\n     * Get a TimeRange object with an array of the times of the video\n     * that have been downloaded. If you just want the percent of the\n     * video that's been downloaded, use bufferedPercent.\n     *\n     * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n     *\n     * @return {TimeRange}\n     *         A mock TimeRange object (following HTML spec)\n     */\n    buffered() {\n      let buffered = this.techGet_('buffered');\n      if (!buffered || !buffered.length) {\n        buffered = createTimeRanges$1(0, 0);\n      }\n      return buffered;\n    }\n\n    /**\n     * Get the percent (as a decimal) of the video that's been downloaded.\n     * This method is not a part of the native HTML video API.\n     *\n     * @return {number}\n     *         A decimal between 0 and 1 representing the percent\n     *         that is buffered 0 being 0% and 1 being 100%\n     */\n    bufferedPercent() {\n      return bufferedPercent(this.buffered(), this.duration());\n    }\n\n    /**\n     * Get the ending time of the last buffered time range\n     * This is used in the progress bar to encapsulate all time ranges.\n     *\n     * @return {number}\n     *         The end of the last buffered time range\n     */\n    bufferedEnd() {\n      const buffered = this.buffered();\n      const duration = this.duration();\n      let end = buffered.end(buffered.length - 1);\n      if (end > duration) {\n        end = duration;\n      }\n      return end;\n    }\n\n    /**\n     * Get or set the current volume of the media\n     *\n     * @param  {number} [percentAsDecimal]\n     *         The new volume as a decimal percent:\n     *         - 0 is muted/0%/off\n     *         - 1.0 is 100%/full\n     *         - 0.5 is half volume or 50%\n     *\n     * @return {number}\n     *         The current volume as a percent when getting\n     */\n    volume(percentAsDecimal) {\n      let vol;\n      if (percentAsDecimal !== undefined) {\n        // Force value to between 0 and 1\n        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\n        this.cache_.volume = vol;\n        this.techCall_('setVolume', vol);\n        if (vol > 0) {\n          this.lastVolume_(vol);\n        }\n        return;\n      }\n\n      // Default to 1 when returning current volume.\n      vol = parseFloat(this.techGet_('volume'));\n      return isNaN(vol) ? 1 : vol;\n    }\n\n    /**\n     * Get the current muted state, or turn mute on or off\n     *\n     * @param {boolean} [muted]\n     *        - true to mute\n     *        - false to unmute\n     *\n     * @return {boolean}\n     *         - true if mute is on and getting\n     *         - false if mute is off and getting\n     */\n    muted(muted) {\n      if (muted !== undefined) {\n        this.techCall_('setMuted', muted);\n        return;\n      }\n      return this.techGet_('muted') || false;\n    }\n\n    /**\n     * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n     * indicates the state of muted on initial playback.\n     *\n     * ```js\n     *   var myPlayer = videojs('some-player-id');\n     *\n     *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n     *\n     *   // get, should be false\n     *   console.log(myPlayer.defaultMuted());\n     *   // set to true\n     *   myPlayer.defaultMuted(true);\n     *   // get should be true\n     *   console.log(myPlayer.defaultMuted());\n     * ```\n     *\n     * @param {boolean} [defaultMuted]\n     *        - true to mute\n     *        - false to unmute\n     *\n     * @return {boolean|Player}\n     *         - true if defaultMuted is on and getting\n     *         - false if defaultMuted is off and getting\n     *         - A reference to the current player when setting\n     */\n    defaultMuted(defaultMuted) {\n      if (defaultMuted !== undefined) {\n        return this.techCall_('setDefaultMuted', defaultMuted);\n      }\n      return this.techGet_('defaultMuted') || false;\n    }\n\n    /**\n     * Get the last volume, or set it\n     *\n     * @param  {number} [percentAsDecimal]\n     *         The new last volume as a decimal percent:\n     *         - 0 is muted/0%/off\n     *         - 1.0 is 100%/full\n     *         - 0.5 is half volume or 50%\n     *\n     * @return {number}\n     *         the current value of lastVolume as a percent when getting\n     *\n     * @private\n     */\n    lastVolume_(percentAsDecimal) {\n      if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n        this.cache_.lastVolume = percentAsDecimal;\n        return;\n      }\n      return this.cache_.lastVolume;\n    }\n\n    /**\n     * Check if current tech can support native fullscreen\n     * (e.g. with built in controls like iOS)\n     *\n     * @return {boolean}\n     *         if native fullscreen is supported\n     */\n    supportsFullScreen() {\n      return this.techGet_('supportsFullScreen') || false;\n    }\n\n    /**\n     * Check if the player is in fullscreen mode or tell the player that it\n     * is or is not in fullscreen mode.\n     *\n     * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n     * property and instead document.fullscreenElement is used. But isFullscreen is\n     * still a valuable property for internal player workings.\n     *\n     * @param  {boolean} [isFS]\n     *         Set the players current fullscreen state\n     *\n     * @return {boolean}\n     *         - true if fullscreen is on and getting\n     *         - false if fullscreen is off and getting\n     */\n    isFullscreen(isFS) {\n      if (isFS !== undefined) {\n        const oldValue = this.isFullscreen_;\n        this.isFullscreen_ = Boolean(isFS);\n\n        // if we changed fullscreen state and we're in prefixed mode, trigger fullscreenchange\n        // this is the only place where we trigger fullscreenchange events for older browsers\n        // fullWindow mode is treated as a prefixed event and will get a fullscreenchange event as well\n        if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {\n          /**\n             * @event Player#fullscreenchange\n             * @type {EventTarget~Event}\n             */\n          this.trigger('fullscreenchange');\n        }\n        this.toggleFullscreenClass_();\n        return;\n      }\n      return this.isFullscreen_;\n    }\n\n    /**\n     * Increase the size of the video to full screen\n     * In some browsers, full screen is not supported natively, so it enters\n     * \"full window mode\", where the video fills the browser window.\n     * In browsers and devices that support native full screen, sometimes the\n     * browser's default controls will be shown, and not the Video.js custom skin.\n     * This includes most mobile devices (iOS, Android) and older versions of\n     * Safari.\n     *\n     * @param  {Object} [fullscreenOptions]\n     *         Override the player fullscreen options\n     *\n     * @fires Player#fullscreenchange\n     */\n    requestFullscreen(fullscreenOptions) {\n      if (this.isInPictureInPicture()) {\n        this.exitPictureInPicture();\n      }\n      const self = this;\n      return new Promise((resolve, reject) => {\n        function offHandler() {\n          self.off('fullscreenerror', errorHandler);\n          self.off('fullscreenchange', changeHandler);\n        }\n        function changeHandler() {\n          offHandler();\n          resolve();\n        }\n        function errorHandler(e, err) {\n          offHandler();\n          reject(err);\n        }\n        self.one('fullscreenchange', changeHandler);\n        self.one('fullscreenerror', errorHandler);\n        const promise = self.requestFullscreenHelper_(fullscreenOptions);\n        if (promise) {\n          promise.then(offHandler, offHandler);\n          promise.then(resolve, reject);\n        }\n      });\n    }\n    requestFullscreenHelper_(fullscreenOptions) {\n      let fsOptions;\n\n      // Only pass fullscreen options to requestFullscreen in spec-compliant browsers.\n      // Use defaults or player configured option unless passed directly to this method.\n      if (!this.fsApi_.prefixed) {\n        fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};\n        if (fullscreenOptions !== undefined) {\n          fsOptions = fullscreenOptions;\n        }\n      }\n\n      // This method works as follows:\n      // 1. if a fullscreen api is available, use it\n      //   1. call requestFullscreen with potential options\n      //   2. if we got a promise from above, use it to update isFullscreen()\n      // 2. otherwise, if the tech supports fullscreen, call `enterFullScreen` on it.\n      //   This is particularly used for iPhone, older iPads, and non-safari browser on iOS.\n      // 3. otherwise, use \"fullWindow\" mode\n      if (this.fsApi_.requestFullscreen) {\n        const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);\n\n        // Even on browsers with promise support this may not return a promise\n        if (promise) {\n          promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));\n        }\n        return promise;\n      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\n        // we can't take the video.js controls fullscreen but we can go fullscreen\n        // with native controls\n        this.techCall_('enterFullScreen');\n      } else {\n        // fullscreen isn't supported so we'll just stretch the video element to\n        // fill the viewport\n        this.enterFullWindow();\n      }\n    }\n\n    /**\n     * Return the video to its normal size after having been in full screen mode\n     *\n     * @fires Player#fullscreenchange\n     */\n    exitFullscreen() {\n      const self = this;\n      return new Promise((resolve, reject) => {\n        function offHandler() {\n          self.off('fullscreenerror', errorHandler);\n          self.off('fullscreenchange', changeHandler);\n        }\n        function changeHandler() {\n          offHandler();\n          resolve();\n        }\n        function errorHandler(e, err) {\n          offHandler();\n          reject(err);\n        }\n        self.one('fullscreenchange', changeHandler);\n        self.one('fullscreenerror', errorHandler);\n        const promise = self.exitFullscreenHelper_();\n        if (promise) {\n          promise.then(offHandler, offHandler);\n          // map the promise to our resolve/reject methods\n          promise.then(resolve, reject);\n        }\n      });\n    }\n    exitFullscreenHelper_() {\n      if (this.fsApi_.requestFullscreen) {\n        const promise = document[this.fsApi_.exitFullscreen]();\n\n        // Even on browsers with promise support this may not return a promise\n        if (promise) {\n          // we're splitting the promise here, so, we want to catch the\n          // potential error so that this chain doesn't have unhandled errors\n          silencePromise(promise.then(() => this.isFullscreen(false)));\n        }\n        return promise;\n      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\n        this.techCall_('exitFullScreen');\n      } else {\n        this.exitFullWindow();\n      }\n    }\n\n    /**\n     * When fullscreen isn't supported we can stretch the\n     * video container to as wide as the browser will let us.\n     *\n     * @fires Player#enterFullWindow\n     */\n    enterFullWindow() {\n      this.isFullscreen(true);\n      this.isFullWindow = true;\n\n      // Storing original doc overflow value to return to when fullscreen is off\n      this.docOrigOverflow = document.documentElement.style.overflow;\n\n      // Add listener for esc key to exit fullscreen\n      on(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n      // Hide any scroll bars\n      document.documentElement.style.overflow = 'hidden';\n\n      // Apply fullscreen styles\n      addClass(document.body, 'vjs-full-window');\n\n      /**\n       * @event Player#enterFullWindow\n       * @type {EventTarget~Event}\n       */\n      this.trigger('enterFullWindow');\n    }\n\n    /**\n     * Check for call to either exit full window or\n     * full screen on ESC key\n     *\n     * @param {string} event\n     *        Event to check for key press\n     */\n    fullWindowOnEscKey(event) {\n      if (keycode.isEventKey(event, 'Esc')) {\n        if (this.isFullscreen() === true) {\n          if (!this.isFullWindow) {\n            this.exitFullscreen();\n          } else {\n            this.exitFullWindow();\n          }\n        }\n      }\n    }\n\n    /**\n     * Exit full window\n     *\n     * @fires Player#exitFullWindow\n     */\n    exitFullWindow() {\n      this.isFullscreen(false);\n      this.isFullWindow = false;\n      off(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n      // Unhide scroll bars.\n      document.documentElement.style.overflow = this.docOrigOverflow;\n\n      // Remove fullscreen styles\n      removeClass(document.body, 'vjs-full-window');\n\n      // Resize the box, controller, and poster to original sizes\n      // this.positionAll();\n      /**\n       * @event Player#exitFullWindow\n       * @type {EventTarget~Event}\n       */\n      this.trigger('exitFullWindow');\n    }\n\n    /**\n     * Disable Picture-in-Picture mode.\n     *\n     * @param {boolean} value\n     *                  - true will disable Picture-in-Picture mode\n     *                  - false will enable Picture-in-Picture mode\n     */\n    disablePictureInPicture(value) {\n      if (value === undefined) {\n        return this.techGet_('disablePictureInPicture');\n      }\n      this.techCall_('setDisablePictureInPicture', value);\n      this.options_.disablePictureInPicture = value;\n      this.trigger('disablepictureinpicturechanged');\n    }\n\n    /**\n     * Check if the player is in Picture-in-Picture mode or tell the player that it\n     * is or is not in Picture-in-Picture mode.\n     *\n     * @param  {boolean} [isPiP]\n     *         Set the players current Picture-in-Picture state\n     *\n     * @return {boolean}\n     *         - true if Picture-in-Picture is on and getting\n     *         - false if Picture-in-Picture is off and getting\n     */\n    isInPictureInPicture(isPiP) {\n      if (isPiP !== undefined) {\n        this.isInPictureInPicture_ = !!isPiP;\n        this.togglePictureInPictureClass_();\n        return;\n      }\n      return !!this.isInPictureInPicture_;\n    }\n\n    /**\n     * Create a floating video window always on top of other windows so that users may\n     * continue consuming media while they interact with other content sites, or\n     * applications on their device.\n     *\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n     *\n     * @fires Player#enterpictureinpicture\n     *\n     * @return {Promise}\n     *         A promise with a Picture-in-Picture window.\n     */\n    requestPictureInPicture() {\n      if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {\n        /**\n         * This event fires when the player enters picture in picture mode\n         *\n         * @event Player#enterpictureinpicture\n         * @type {EventTarget~Event}\n         */\n        return this.techGet_('requestPictureInPicture');\n      }\n    }\n\n    /**\n     * Exit Picture-in-Picture mode.\n     *\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n     *\n     * @fires Player#leavepictureinpicture\n     *\n     * @return {Promise}\n     *         A promise.\n     */\n    exitPictureInPicture() {\n      if ('pictureInPictureEnabled' in document) {\n        /**\n         * This event fires when the player leaves picture in picture mode\n         *\n         * @event Player#leavepictureinpicture\n         * @type {EventTarget~Event}\n         */\n        return document.exitPictureInPicture();\n      }\n    }\n\n    /**\n     * Called when this Player has focus and a key gets pressed down, or when\n     * any Component of this player receives a key press that it doesn't handle.\n     * This allows player-wide hotkeys (either as defined below, or optionally\n     * by an external function).\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     *\n     * @listens keydown\n     */\n    handleKeyDown(event) {\n      const {\n        userActions\n      } = this.options_;\n\n      // Bail out if hotkeys are not configured.\n      if (!userActions || !userActions.hotkeys) {\n        return;\n      }\n\n      // Function that determines whether or not to exclude an element from\n      // hotkeys handling.\n      const excludeElement = el => {\n        const tagName = el.tagName.toLowerCase();\n\n        // The first and easiest test is for `contenteditable` elements.\n        if (el.isContentEditable) {\n          return true;\n        }\n\n        // Inputs matching these types will still trigger hotkey handling as\n        // they are not text inputs.\n        const allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];\n        if (tagName === 'input') {\n          return allowedInputTypes.indexOf(el.type) === -1;\n        }\n\n        // The final test is by tag name. These tags will be excluded entirely.\n        const excludedTags = ['textarea'];\n        return excludedTags.indexOf(tagName) !== -1;\n      };\n\n      // Bail out if the user is focused on an interactive form element.\n      if (excludeElement(this.el_.ownerDocument.activeElement)) {\n        return;\n      }\n      if (typeof userActions.hotkeys === 'function') {\n        userActions.hotkeys.call(this, event);\n      } else {\n        this.handleHotkeys(event);\n      }\n    }\n\n    /**\n     * Called when this Player receives a hotkey keydown event.\n     * Supported player-wide hotkeys are:\n     *\n     *   f          - toggle fullscreen\n     *   m          - toggle mute\n     *   k or Space - toggle play/pause\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown` event that caused this function to be called.\n     */\n    handleHotkeys(event) {\n      const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};\n\n      // set fullscreenKey, muteKey, playPauseKey from `hotkeys`, use defaults if not set\n      const {\n        fullscreenKey = keydownEvent => keycode.isEventKey(keydownEvent, 'f'),\n        muteKey = keydownEvent => keycode.isEventKey(keydownEvent, 'm'),\n        playPauseKey = keydownEvent => keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space')\n      } = hotkeys;\n      if (fullscreenKey.call(this, event)) {\n        event.preventDefault();\n        event.stopPropagation();\n        const FSToggle = Component$1.getComponent('FullscreenToggle');\n        if (document[this.fsApi_.fullscreenEnabled] !== false) {\n          FSToggle.prototype.handleClick.call(this, event);\n        }\n      } else if (muteKey.call(this, event)) {\n        event.preventDefault();\n        event.stopPropagation();\n        const MuteToggle = Component$1.getComponent('MuteToggle');\n        MuteToggle.prototype.handleClick.call(this, event);\n      } else if (playPauseKey.call(this, event)) {\n        event.preventDefault();\n        event.stopPropagation();\n        const PlayToggle = Component$1.getComponent('PlayToggle');\n        PlayToggle.prototype.handleClick.call(this, event);\n      }\n    }\n\n    /**\n     * Check whether the player can play a given mimetype\n     *\n     * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n     *\n     * @param {string} type\n     *        The mimetype to check\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string)\n     */\n    canPlayType(type) {\n      let can;\n\n      // Loop through each playback technology in the options order\n      for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {\n        const techName = j[i];\n        let tech = Tech.getTech(techName);\n\n        // Support old behavior of techs being registered as components.\n        // Remove once that deprecated behavior is removed.\n        if (!tech) {\n          tech = Component$1.getComponent(techName);\n        }\n\n        // Check if the current tech is defined before continuing\n        if (!tech) {\n          log$1.error(`The \"${techName}\" tech is undefined. Skipped browser support check for that tech.`);\n          continue;\n        }\n\n        // Check if the browser supports this technology\n        if (tech.isSupported()) {\n          can = tech.canPlayType(type);\n          if (can) {\n            return can;\n          }\n        }\n      }\n      return '';\n    }\n\n    /**\n     * Select source based on tech-order or source-order\n     * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n     * defaults to tech-order selection\n     *\n     * @param {Array} sources\n     *        The sources for a media asset\n     *\n     * @return {Object|boolean}\n     *         Object of source and tech order or false\n     */\n    selectSource(sources) {\n      // Get only the techs specified in `techOrder` that exist and are supported by the\n      // current platform\n      const techs = this.options_.techOrder.map(techName => {\n        return [techName, Tech.getTech(techName)];\n      }).filter(([techName, tech]) => {\n        // Check if the current tech is defined before continuing\n        if (tech) {\n          // Check if the browser supports this technology\n          return tech.isSupported();\n        }\n        log$1.error(`The \"${techName}\" tech is undefined. Skipped browser support check for that tech.`);\n        return false;\n      });\n\n      // Iterate over each `innerArray` element once per `outerArray` element and execute\n      // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n      // that value.\n      const findFirstPassingTechSourcePair = function (outerArray, innerArray, tester) {\n        let found;\n        outerArray.some(outerChoice => {\n          return innerArray.some(innerChoice => {\n            found = tester(outerChoice, innerChoice);\n            if (found) {\n              return true;\n            }\n          });\n        });\n        return found;\n      };\n      let foundSourceAndTech;\n      const flip = fn => (a, b) => fn(b, a);\n      const finder = ([techName, tech], source) => {\n        if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {\n          return {\n            source,\n            tech: techName\n          };\n        }\n      };\n\n      // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n      // to select from them based on their priority.\n      if (this.options_.sourceOrder) {\n        // Source-first ordering\n        foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n      } else {\n        // Tech-first ordering\n        foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n      }\n      return foundSourceAndTech || false;\n    }\n\n    /**\n     * Executes source setting and getting logic\n     *\n     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n     *        A SourceObject, an array of SourceObjects, or a string referencing\n     *        a URL to a media source. It is _highly recommended_ that an object\n     *        or array of objects is used here, so that source selection\n     *        algorithms can take the `type` into account.\n     *\n     *        If not provided, this method acts as a getter.\n     * @param {boolean} isRetry\n     *        Indicates whether this is being called internally as a result of a retry\n     *\n     * @return {string|undefined}\n     *         If the `source` argument is missing, returns the current source\n     *         URL. Otherwise, returns nothing/undefined.\n     */\n    handleSrc_(source, isRetry) {\n      // getter usage\n      if (typeof source === 'undefined') {\n        return this.cache_.src || '';\n      }\n\n      // Reset retry behavior for new source\n      if (this.resetRetryOnError_) {\n        this.resetRetryOnError_();\n      }\n\n      // filter out invalid sources and turn our source into\n      // an array of source objects\n      const sources = filterSource(source);\n\n      // if a source was passed in then it is invalid because\n      // it was filtered to a zero length Array. So we have to\n      // show an error\n      if (!sources.length) {\n        this.setTimeout(function () {\n          this.error({\n            code: 4,\n            message: this.options_.notSupportedMessage\n          });\n        }, 0);\n        return;\n      }\n\n      // initial sources\n      this.changingSrc_ = true;\n\n      // Only update the cached source list if we are not retrying a new source after error,\n      // since in that case we want to include the failed source(s) in the cache\n      if (!isRetry) {\n        this.cache_.sources = sources;\n      }\n      this.updateSourceCaches_(sources[0]);\n\n      // middlewareSource is the source after it has been changed by middleware\n      setSource(this, sources[0], (middlewareSource, mws) => {\n        this.middleware_ = mws;\n\n        // since sourceSet is async we have to update the cache again after we select a source since\n        // the source that is selected could be out of order from the cache update above this callback.\n        if (!isRetry) {\n          this.cache_.sources = sources;\n        }\n        this.updateSourceCaches_(middlewareSource);\n        const err = this.src_(middlewareSource);\n        if (err) {\n          if (sources.length > 1) {\n            return this.handleSrc_(sources.slice(1));\n          }\n          this.changingSrc_ = false;\n\n          // We need to wrap this in a timeout to give folks a chance to add error event handlers\n          this.setTimeout(function () {\n            this.error({\n              code: 4,\n              message: this.options_.notSupportedMessage\n            });\n          }, 0);\n\n          // we could not find an appropriate tech, but let's still notify the delegate that this is it\n          // this needs a better comment about why this is needed\n          this.triggerReady();\n          return;\n        }\n        setTech(mws, this.tech_);\n      });\n\n      // Try another available source if this one fails before playback.\n      if (sources.length > 1) {\n        const retry = () => {\n          // Remove the error modal\n          this.error(null);\n          this.handleSrc_(sources.slice(1), true);\n        };\n        const stopListeningForErrors = () => {\n          this.off('error', retry);\n        };\n        this.one('error', retry);\n        this.one('playing', stopListeningForErrors);\n        this.resetRetryOnError_ = () => {\n          this.off('error', retry);\n          this.off('playing', stopListeningForErrors);\n        };\n      }\n    }\n\n    /**\n     * Get or set the video source.\n     *\n     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n     *        A SourceObject, an array of SourceObjects, or a string referencing\n     *        a URL to a media source. It is _highly recommended_ that an object\n     *        or array of objects is used here, so that source selection\n     *        algorithms can take the `type` into account.\n     *\n     *        If not provided, this method acts as a getter.\n     *\n     * @return {string|undefined}\n     *         If the `source` argument is missing, returns the current source\n     *         URL. Otherwise, returns nothing/undefined.\n     */\n    src(source) {\n      return this.handleSrc_(source, false);\n    }\n\n    /**\n     * Set the source object on the tech, returns a boolean that indicates whether\n     * there is a tech that can play the source or not\n     *\n     * @param {Tech~SourceObject} source\n     *        The source object to set on the Tech\n     *\n     * @return {boolean}\n     *         - True if there is no Tech to playback this source\n     *         - False otherwise\n     *\n     * @private\n     */\n    src_(source) {\n      const sourceTech = this.selectSource([source]);\n      if (!sourceTech) {\n        return true;\n      }\n      if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n        this.changingSrc_ = true;\n        // load this technology with the chosen source\n        this.loadTech_(sourceTech.tech, sourceTech.source);\n        this.tech_.ready(() => {\n          this.changingSrc_ = false;\n        });\n        return false;\n      }\n\n      // wait until the tech is ready to set the source\n      // and set it synchronously if possible (#2326)\n      this.ready(function () {\n        // The setSource tech method was added with source handlers\n        // so older techs won't support it\n        // We need to check the direct prototype for the case where subclasses\n        // of the tech do not support source handlers\n        if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n          this.techCall_('setSource', source);\n        } else {\n          this.techCall_('src', source.src);\n        }\n        this.changingSrc_ = false;\n      }, true);\n      return false;\n    }\n\n    /**\n     * Begin loading the src data.\n     */\n    load() {\n      this.techCall_('load');\n    }\n\n    /**\n     * Reset the player. Loads the first tech in the techOrder,\n     * removes all the text tracks in the existing `tech`,\n     * and calls `reset` on the `tech`.\n     */\n    reset() {\n      if (this.paused()) {\n        this.doReset_();\n      } else {\n        const playPromise = this.play();\n        silencePromise(playPromise.then(() => this.doReset_()));\n      }\n    }\n    doReset_() {\n      if (this.tech_) {\n        this.tech_.clearTracks('text');\n      }\n      this.resetCache_();\n      this.poster('');\n      this.loadTech_(this.options_.techOrder[0], null);\n      this.techCall_('reset');\n      this.resetControlBarUI_();\n      if (isEvented(this)) {\n        this.trigger('playerreset');\n      }\n    }\n\n    /**\n     * Reset Control Bar's UI by calling sub-methods that reset\n     * all of Control Bar's components\n     */\n    resetControlBarUI_() {\n      this.resetProgressBar_();\n      this.resetPlaybackRate_();\n      this.resetVolumeBar_();\n    }\n\n    /**\n     * Reset tech's progress so progress bar is reset in the UI\n     */\n    resetProgressBar_() {\n      this.currentTime(0);\n      const {\n        durationDisplay,\n        remainingTimeDisplay\n      } = this.controlBar || {};\n      if (durationDisplay) {\n        durationDisplay.updateContent();\n      }\n      if (remainingTimeDisplay) {\n        remainingTimeDisplay.updateContent();\n      }\n    }\n\n    /**\n     * Reset Playback ratio\n     */\n    resetPlaybackRate_() {\n      this.playbackRate(this.defaultPlaybackRate());\n      this.handleTechRateChange_();\n    }\n\n    /**\n     * Reset Volume bar\n     */\n    resetVolumeBar_() {\n      this.volume(1.0);\n      this.trigger('volumechange');\n    }\n\n    /**\n     * Returns all of the current source objects.\n     *\n     * @return {Tech~SourceObject[]}\n     *         The current source objects\n     */\n    currentSources() {\n      const source = this.currentSource();\n      const sources = [];\n\n      // assume `{}` or `{ src }`\n      if (Object.keys(source).length !== 0) {\n        sources.push(source);\n      }\n      return this.cache_.sources || sources;\n    }\n\n    /**\n     * Returns the current source object.\n     *\n     * @return {Tech~SourceObject}\n     *         The current source object\n     */\n    currentSource() {\n      return this.cache_.source || {};\n    }\n\n    /**\n     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n     * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.\n     *\n     * @return {string}\n     *         The current source\n     */\n    currentSrc() {\n      return this.currentSource() && this.currentSource().src || '';\n    }\n\n    /**\n     * Get the current source type e.g. video/mp4\n     * This can allow you rebuild the current source object so that you could load the same\n     * source and tech later\n     *\n     * @return {string}\n     *         The source MIME type\n     */\n    currentType() {\n      return this.currentSource() && this.currentSource().type || '';\n    }\n\n    /**\n     * Get or set the preload attribute\n     *\n     * @param {boolean} [value]\n     *        - true means that we should preload\n     *        - false means that we should not preload\n     *\n     * @return {string}\n     *         The preload attribute value when getting\n     */\n    preload(value) {\n      if (value !== undefined) {\n        this.techCall_('setPreload', value);\n        this.options_.preload = value;\n        return;\n      }\n      return this.techGet_('preload');\n    }\n\n    /**\n     * Get or set the autoplay option. When this is a boolean it will\n     * modify the attribute on the tech. When this is a string the attribute on\n     * the tech will be removed and `Player` will handle autoplay on loadstarts.\n     *\n     * @param {boolean|string} [value]\n     *        - true: autoplay using the browser behavior\n     *        - false: do not autoplay\n     *        - 'play': call play() on every loadstart\n     *        - 'muted': call muted() then play() on every loadstart\n     *        - 'any': call play() on every loadstart. if that fails call muted() then play().\n     *        - *: values other than those listed here will be set `autoplay` to true\n     *\n     * @return {boolean|string}\n     *         The current value of autoplay when getting\n     */\n    autoplay(value) {\n      // getter usage\n      if (value === undefined) {\n        return this.options_.autoplay || false;\n      }\n      let techAutoplay;\n\n      // if the value is a valid string set it to that, or normalize `true` to 'play', if need be\n      if (typeof value === 'string' && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {\n        this.options_.autoplay = value;\n        this.manualAutoplay_(typeof value === 'string' ? value : 'play');\n        techAutoplay = false;\n\n        // any falsy value sets autoplay to false in the browser,\n        // lets do the same\n      } else if (!value) {\n        this.options_.autoplay = false;\n\n        // any other value (ie truthy) sets autoplay to true\n      } else {\n        this.options_.autoplay = true;\n      }\n      techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay;\n\n      // if we don't have a tech then we do not queue up\n      // a setAutoplay call on tech ready. We do this because the\n      // autoplay option will be passed in the constructor and we\n      // do not need to set it twice\n      if (this.tech_) {\n        this.techCall_('setAutoplay', techAutoplay);\n      }\n    }\n\n    /**\n     * Set or unset the playsinline attribute.\n     * Playsinline tells the browser that non-fullscreen playback is preferred.\n     *\n     * @param {boolean} [value]\n     *        - true means that we should try to play inline by default\n     *        - false means that we should use the browser's default playback mode,\n     *          which in most cases is inline. iOS Safari is a notable exception\n     *          and plays fullscreen by default.\n     *\n     * @return {string|Player}\n     *         - the current value of playsinline\n     *         - the player when setting\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n     */\n    playsinline(value) {\n      if (value !== undefined) {\n        this.techCall_('setPlaysinline', value);\n        this.options_.playsinline = value;\n        return this;\n      }\n      return this.techGet_('playsinline');\n    }\n\n    /**\n     * Get or set the loop attribute on the video element.\n     *\n     * @param {boolean} [value]\n     *        - true means that we should loop the video\n     *        - false means that we should not loop the video\n     *\n     * @return {boolean}\n     *         The current value of loop when getting\n     */\n    loop(value) {\n      if (value !== undefined) {\n        this.techCall_('setLoop', value);\n        this.options_.loop = value;\n        return;\n      }\n      return this.techGet_('loop');\n    }\n\n    /**\n     * Get or set the poster image source url\n     *\n     * @fires Player#posterchange\n     *\n     * @param {string} [src]\n     *        Poster image source URL\n     *\n     * @return {string}\n     *         The current value of poster when getting\n     */\n    poster(src) {\n      if (src === undefined) {\n        return this.poster_;\n      }\n\n      // The correct way to remove a poster is to set as an empty string\n      // other falsey values will throw errors\n      if (!src) {\n        src = '';\n      }\n      if (src === this.poster_) {\n        return;\n      }\n\n      // update the internal poster variable\n      this.poster_ = src;\n\n      // update the tech's poster\n      this.techCall_('setPoster', src);\n      this.isPosterFromTech_ = false;\n\n      // alert components that the poster has been set\n      /**\n       * This event fires when the poster image is changed on the player.\n       *\n       * @event Player#posterchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('posterchange');\n    }\n\n    /**\n     * Some techs (e.g. YouTube) can provide a poster source in an\n     * asynchronous way. We want the poster component to use this\n     * poster source so that it covers up the tech's controls.\n     * (YouTube's play button). However we only want to use this\n     * source if the player user hasn't set a poster through\n     * the normal APIs.\n     *\n     * @fires Player#posterchange\n     * @listens Tech#posterchange\n     * @private\n     */\n    handleTechPosterChange_() {\n      if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\n        const newPoster = this.tech_.poster() || '';\n        if (newPoster !== this.poster_) {\n          this.poster_ = newPoster;\n          this.isPosterFromTech_ = true;\n\n          // Let components know the poster has changed\n          this.trigger('posterchange');\n        }\n      }\n    }\n\n    /**\n     * Get or set whether or not the controls are showing.\n     *\n     * @fires Player#controlsenabled\n     *\n     * @param {boolean} [bool]\n     *        - true to turn controls on\n     *        - false to turn controls off\n     *\n     * @return {boolean}\n     *         The current value of controls when getting\n     */\n    controls(bool) {\n      if (bool === undefined) {\n        return !!this.controls_;\n      }\n      bool = !!bool;\n\n      // Don't trigger a change event unless it actually changed\n      if (this.controls_ === bool) {\n        return;\n      }\n      this.controls_ = bool;\n      if (this.usingNativeControls()) {\n        this.techCall_('setControls', bool);\n      }\n      if (this.controls_) {\n        this.removeClass('vjs-controls-disabled');\n        this.addClass('vjs-controls-enabled');\n        /**\n         * @event Player#controlsenabled\n         * @type {EventTarget~Event}\n         */\n        this.trigger('controlsenabled');\n        if (!this.usingNativeControls()) {\n          this.addTechControlsListeners_();\n        }\n      } else {\n        this.removeClass('vjs-controls-enabled');\n        this.addClass('vjs-controls-disabled');\n        /**\n         * @event Player#controlsdisabled\n         * @type {EventTarget~Event}\n         */\n        this.trigger('controlsdisabled');\n        if (!this.usingNativeControls()) {\n          this.removeTechControlsListeners_();\n        }\n      }\n    }\n\n    /**\n     * Toggle native controls on/off. Native controls are the controls built into\n     * devices (e.g. default iPhone controls) or other techs\n     * (e.g. Vimeo Controls)\n     * **This should only be set by the current tech, because only the tech knows\n     * if it can support native controls**\n     *\n     * @fires Player#usingnativecontrols\n     * @fires Player#usingcustomcontrols\n     *\n     * @param {boolean} [bool]\n     *        - true to turn native controls on\n     *        - false to turn native controls off\n     *\n     * @return {boolean}\n     *         The current value of native controls when getting\n     */\n    usingNativeControls(bool) {\n      if (bool === undefined) {\n        return !!this.usingNativeControls_;\n      }\n      bool = !!bool;\n\n      // Don't trigger a change event unless it actually changed\n      if (this.usingNativeControls_ === bool) {\n        return;\n      }\n      this.usingNativeControls_ = bool;\n      if (this.usingNativeControls_) {\n        this.addClass('vjs-using-native-controls');\n\n        /**\n         * player is using the native device controls\n         *\n         * @event Player#usingnativecontrols\n         * @type {EventTarget~Event}\n         */\n        this.trigger('usingnativecontrols');\n      } else {\n        this.removeClass('vjs-using-native-controls');\n\n        /**\n         * player is using the custom HTML controls\n         *\n         * @event Player#usingcustomcontrols\n         * @type {EventTarget~Event}\n         */\n        this.trigger('usingcustomcontrols');\n      }\n    }\n\n    /**\n     * Set or get the current MediaError\n     *\n     * @fires Player#error\n     *\n     * @param  {MediaError|string|number} [err]\n     *         A MediaError or a string/number to be turned\n     *         into a MediaError\n     *\n     * @return {MediaError|null}\n     *         The current MediaError when getting (or null)\n     */\n    error(err) {\n      if (err === undefined) {\n        return this.error_ || null;\n      }\n\n      // allow hooks to modify error object\n      hooks('beforeerror').forEach(hookFunction => {\n        const newErr = hookFunction(this, err);\n        if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === 'string' || typeof newErr === 'number' || newErr === null)) {\n          this.log.error('please return a value that MediaError expects in beforeerror hooks');\n          return;\n        }\n        err = newErr;\n      });\n\n      // Suppress the first error message for no compatible source until\n      // user interaction\n      if (this.options_.suppressNotSupportedError && err && err.code === 4) {\n        const triggerSuppressedError = function () {\n          this.error(err);\n        };\n        this.options_.suppressNotSupportedError = false;\n        this.any(['click', 'touchstart'], triggerSuppressedError);\n        this.one('loadstart', function () {\n          this.off(['click', 'touchstart'], triggerSuppressedError);\n        });\n        return;\n      }\n\n      // restoring to default\n      if (err === null) {\n        this.error_ = err;\n        this.removeClass('vjs-error');\n        if (this.errorDisplay) {\n          this.errorDisplay.close();\n        }\n        return;\n      }\n      this.error_ = new MediaError(err);\n\n      // add the vjs-error classname to the player\n      this.addClass('vjs-error');\n\n      // log the name of the error type and any message\n      // IE11 logs \"[object object]\" and required you to expand message to see error object\n      log$1.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);\n\n      /**\n       * @event Player#error\n       * @type {EventTarget~Event}\n       */\n      this.trigger('error');\n\n      // notify hooks of the per player error\n      hooks('error').forEach(hookFunction => hookFunction(this, this.error_));\n      return;\n    }\n\n    /**\n     * Report user activity\n     *\n     * @param {Object} event\n     *        Event object\n     */\n    reportUserActivity(event) {\n      this.userActivity_ = true;\n    }\n\n    /**\n     * Get/set if user is active\n     *\n     * @fires Player#useractive\n     * @fires Player#userinactive\n     *\n     * @param {boolean} [bool]\n     *        - true if the user is active\n     *        - false if the user is inactive\n     *\n     * @return {boolean}\n     *         The current value of userActive when getting\n     */\n    userActive(bool) {\n      if (bool === undefined) {\n        return this.userActive_;\n      }\n      bool = !!bool;\n      if (bool === this.userActive_) {\n        return;\n      }\n      this.userActive_ = bool;\n      if (this.userActive_) {\n        this.userActivity_ = true;\n        this.removeClass('vjs-user-inactive');\n        this.addClass('vjs-user-active');\n        /**\n         * @event Player#useractive\n         * @type {EventTarget~Event}\n         */\n        this.trigger('useractive');\n        return;\n      }\n\n      // Chrome/Safari/IE have bugs where when you change the cursor it can\n      // trigger a mousemove event. This causes an issue when you're hiding\n      // the cursor when the user is inactive, and a mousemove signals user\n      // activity. Making it impossible to go into inactive mode. Specifically\n      // this happens in fullscreen when we really need to hide the cursor.\n      //\n      // When this gets resolved in ALL browsers it can be removed\n      // https://code.google.com/p/chromium/issues/detail?id=103041\n      if (this.tech_) {\n        this.tech_.one('mousemove', function (e) {\n          e.stopPropagation();\n          e.preventDefault();\n        });\n      }\n      this.userActivity_ = false;\n      this.removeClass('vjs-user-active');\n      this.addClass('vjs-user-inactive');\n      /**\n       * @event Player#userinactive\n       * @type {EventTarget~Event}\n       */\n      this.trigger('userinactive');\n    }\n\n    /**\n     * Listen for user activity based on timeout value\n     *\n     * @private\n     */\n    listenForUserActivity_() {\n      let mouseInProgress;\n      let lastMoveX;\n      let lastMoveY;\n      const handleActivity = bind_(this, this.reportUserActivity);\n      const handleMouseMove = function (e) {\n        // #1068 - Prevent mousemove spamming\n        // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n          lastMoveX = e.screenX;\n          lastMoveY = e.screenY;\n          handleActivity();\n        }\n      };\n      const handleMouseDown = function () {\n        handleActivity();\n        // For as long as the they are touching the device or have their mouse down,\n        // we consider them active even if they're not moving their finger or mouse.\n        // So we want to continue to update that they are active\n        this.clearInterval(mouseInProgress);\n        // Setting userActivity=true now and setting the interval to the same time\n        // as the activityCheck interval (250) should ensure we never miss the\n        // next activityCheck\n        mouseInProgress = this.setInterval(handleActivity, 250);\n      };\n      const handleMouseUpAndMouseLeave = function (event) {\n        handleActivity();\n        // Stop the interval that maintains activity if the mouse/touch is down\n        this.clearInterval(mouseInProgress);\n      };\n\n      // Any mouse movement will be considered user activity\n      this.on('mousedown', handleMouseDown);\n      this.on('mousemove', handleMouseMove);\n      this.on('mouseup', handleMouseUpAndMouseLeave);\n      this.on('mouseleave', handleMouseUpAndMouseLeave);\n      const controlBar = this.getChild('controlBar');\n\n      // Fixes bug on Android & iOS where when tapping progressBar (when control bar is displayed)\n      // controlBar would no longer be hidden by default timeout.\n      if (controlBar && !IS_IOS && !IS_ANDROID) {\n        controlBar.on('mouseenter', function (event) {\n          if (this.player().options_.inactivityTimeout !== 0) {\n            this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;\n          }\n          this.player().options_.inactivityTimeout = 0;\n        });\n        controlBar.on('mouseleave', function (event) {\n          this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;\n        });\n      }\n\n      // Listen for keyboard navigation\n      // Shouldn't need to use inProgress interval because of key repeat\n      this.on('keydown', handleActivity);\n      this.on('keyup', handleActivity);\n\n      // Run an interval every 250 milliseconds instead of stuffing everything into\n      // the mousemove/touchmove function itself, to prevent performance degradation.\n      // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n      // then gets picked up by this loop\n      // http://ejohn.org/blog/learning-from-twitter/\n      let inactivityTimeout;\n      this.setInterval(function () {\n        // Check to see if mouse/touch activity has happened\n        if (!this.userActivity_) {\n          return;\n        }\n\n        // Reset the activity tracker\n        this.userActivity_ = false;\n\n        // If the user state was inactive, set the state to active\n        this.userActive(true);\n\n        // Clear any existing inactivity timeout to start the timer over\n        this.clearTimeout(inactivityTimeout);\n        const timeout = this.options_.inactivityTimeout;\n        if (timeout <= 0) {\n          return;\n        }\n\n        // In <timeout> milliseconds, if no more activity has occurred the\n        // user will be considered inactive\n        inactivityTimeout = this.setTimeout(function () {\n          // Protect against the case where the inactivityTimeout can trigger just\n          // before the next user activity is picked up by the activity check loop\n          // causing a flicker\n          if (!this.userActivity_) {\n            this.userActive(false);\n          }\n        }, timeout);\n      }, 250);\n    }\n\n    /**\n     * Gets or sets the current playback rate. A playback rate of\n     * 1.0 represents normal speed and 0.5 would indicate half-speed\n     * playback, for instance.\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n     *\n     * @param {number} [rate]\n     *       New playback rate to set.\n     *\n     * @return {number}\n     *         The current playback rate when getting or 1.0\n     */\n    playbackRate(rate) {\n      if (rate !== undefined) {\n        // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\n        // that is registered above\n        this.techCall_('setPlaybackRate', rate);\n        return;\n      }\n      if (this.tech_ && this.tech_.featuresPlaybackRate) {\n        return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\n      }\n      return 1.0;\n    }\n\n    /**\n     * Gets or sets the current default playback rate. A default playback rate of\n     * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n     * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not\n     * not the current playbackRate.\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n     *\n     * @param {number} [rate]\n     *       New default playback rate to set.\n     *\n     * @return {number|Player}\n     *         - The default playback rate when getting or 1.0\n     *         - the player when setting\n     */\n    defaultPlaybackRate(rate) {\n      if (rate !== undefined) {\n        return this.techCall_('setDefaultPlaybackRate', rate);\n      }\n      if (this.tech_ && this.tech_.featuresPlaybackRate) {\n        return this.techGet_('defaultPlaybackRate');\n      }\n      return 1.0;\n    }\n\n    /**\n     * Gets or sets the audio flag\n     *\n     * @param {boolean} bool\n     *        - true signals that this is an audio player\n     *        - false signals that this is not an audio player\n     *\n     * @return {boolean}\n     *         The current value of isAudio when getting\n     */\n    isAudio(bool) {\n      if (bool !== undefined) {\n        this.isAudio_ = !!bool;\n        return;\n      }\n      return !!this.isAudio_;\n    }\n    enableAudioOnlyUI_() {\n      // Update styling immediately to show the control bar so we can get its height\n      this.addClass('vjs-audio-only-mode');\n      const playerChildren = this.children();\n      const controlBar = this.getChild('ControlBar');\n      const controlBarHeight = controlBar && controlBar.currentHeight();\n\n      // Hide all player components except the control bar. Control bar components\n      // needed only for video are hidden with CSS\n      playerChildren.forEach(child => {\n        if (child === controlBar) {\n          return;\n        }\n        if (child.el_ && !child.hasClass('vjs-hidden')) {\n          child.hide();\n          this.audioOnlyCache_.hiddenChildren.push(child);\n        }\n      });\n      this.audioOnlyCache_.playerHeight = this.currentHeight();\n\n      // Set the player height the same as the control bar\n      this.height(controlBarHeight);\n      this.trigger('audioonlymodechange');\n    }\n    disableAudioOnlyUI_() {\n      this.removeClass('vjs-audio-only-mode');\n\n      // Show player components that were previously hidden\n      this.audioOnlyCache_.hiddenChildren.forEach(child => child.show());\n\n      // Reset player height\n      this.height(this.audioOnlyCache_.playerHeight);\n      this.trigger('audioonlymodechange');\n    }\n\n    /**\n     * Get the current audioOnlyMode state or set audioOnlyMode to true or false.\n     *\n     * Setting this to `true` will hide all player components except the control bar,\n     * as well as control bar components needed only for video.\n     *\n     * @param {boolean} [value]\n     *         The value to set audioOnlyMode to.\n     *\n     * @return {Promise|boolean}\n     *        A Promise is returned when setting the state, and a boolean when getting\n     *        the present state\n     */\n    audioOnlyMode(value) {\n      if (typeof value !== 'boolean' || value === this.audioOnlyMode_) {\n        return this.audioOnlyMode_;\n      }\n      this.audioOnlyMode_ = value;\n\n      // Enable Audio Only Mode\n      if (value) {\n        const exitPromises = [];\n\n        // Fullscreen and PiP are not supported in audioOnlyMode, so exit if we need to.\n        if (this.isInPictureInPicture()) {\n          exitPromises.push(this.exitPictureInPicture());\n        }\n        if (this.isFullscreen()) {\n          exitPromises.push(this.exitFullscreen());\n        }\n        if (this.audioPosterMode()) {\n          exitPromises.push(this.audioPosterMode(false));\n        }\n        return Promise.all(exitPromises).then(() => this.enableAudioOnlyUI_());\n      }\n\n      // Disable Audio Only Mode\n      return Promise.resolve().then(() => this.disableAudioOnlyUI_());\n    }\n    enablePosterModeUI_() {\n      // Hide the video element and show the poster image to enable posterModeUI\n      const tech = this.tech_ && this.tech_;\n      tech.hide();\n      this.addClass('vjs-audio-poster-mode');\n      this.trigger('audiopostermodechange');\n    }\n    disablePosterModeUI_() {\n      // Show the video element and hide the poster image to disable posterModeUI\n      const tech = this.tech_ && this.tech_;\n      tech.show();\n      this.removeClass('vjs-audio-poster-mode');\n      this.trigger('audiopostermodechange');\n    }\n\n    /**\n     * Get the current audioPosterMode state or set audioPosterMode to true or false\n     *\n     * @param {boolean} [value]\n     *         The value to set audioPosterMode to.\n     *\n     * @return {Promise|boolean}\n     *         A Promise is returned when setting the state, and a boolean when getting\n     *        the present state\n     */\n    audioPosterMode(value) {\n      if (typeof value !== 'boolean' || value === this.audioPosterMode_) {\n        return this.audioPosterMode_;\n      }\n      this.audioPosterMode_ = value;\n      if (value) {\n        if (this.audioOnlyMode()) {\n          const audioOnlyModePromise = this.audioOnlyMode(false);\n          return audioOnlyModePromise.then(() => {\n            // enable audio poster mode after audio only mode is disabled\n            this.enablePosterModeUI_();\n          });\n        }\n        return Promise.resolve().then(() => {\n          // enable audio poster mode\n          this.enablePosterModeUI_();\n        });\n      }\n      return Promise.resolve().then(() => {\n        // disable audio poster mode\n        this.disablePosterModeUI_();\n      });\n    }\n\n    /**\n     * A helper method for adding a {@link TextTrack} to our\n     * {@link TextTrackList}.\n     *\n     * In addition to the W3C settings we allow adding additional info through options.\n     *\n     * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n     *\n     * @param {string} [kind]\n     *        the kind of TextTrack you are adding\n     *\n     * @param {string} [label]\n     *        the label to give the TextTrack label\n     *\n     * @param {string} [language]\n     *        the language to set on the TextTrack\n     *\n     * @return {TextTrack|undefined}\n     *         the TextTrack that was added or undefined\n     *         if there is no tech\n     */\n    addTextTrack(kind, label, language) {\n      if (this.tech_) {\n        return this.tech_.addTextTrack(kind, label, language);\n      }\n    }\n\n    /**\n     * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.\n     *\n     * @param {Object} options\n     *        Options to pass to {@link HTMLTrackElement} during creation. See\n     *        {@link HTMLTrackElement} for object properties that you should use.\n     *\n     * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed\n     *                                        from the TextTrackList and HtmlTrackElementList\n     *                                        after a source change\n     *\n     * @return {HtmlTrackElement}\n     *         the HTMLTrackElement that was created and added\n     *         to the HtmlTrackElementList and the remote\n     *         TextTrackList\n     *\n     */\n    addRemoteTextTrack(options, manualCleanup) {\n      if (this.tech_) {\n        return this.tech_.addRemoteTextTrack(options, manualCleanup);\n      }\n    }\n\n    /**\n     * Remove a remote {@link TextTrack} from the respective\n     * {@link TextTrackList} and {@link HtmlTrackElementList}.\n     *\n     * @param {Object} track\n     *        Remote {@link TextTrack} to remove\n     *\n     * @return {undefined}\n     *         does not return anything\n     */\n    removeRemoteTextTrack(obj = {}) {\n      let {\n        track\n      } = obj;\n      if (!track) {\n        track = obj;\n      }\n\n      // destructure the input into an object with a track argument, defaulting to arguments[0]\n      // default the whole argument to an empty object if nothing was passed in\n\n      if (this.tech_) {\n        return this.tech_.removeRemoteTextTrack(track);\n      }\n    }\n\n    /**\n     * Gets available media playback quality metrics as specified by the W3C's Media\n     * Playback Quality API.\n     *\n     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n     *\n     * @return {Object|undefined}\n     *         An object with supported media playback quality metrics or undefined if there\n     *         is no tech or the tech does not support it.\n     */\n    getVideoPlaybackQuality() {\n      return this.techGet_('getVideoPlaybackQuality');\n    }\n\n    /**\n     * Get video width\n     *\n     * @return {number}\n     *         current video width\n     */\n    videoWidth() {\n      return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n    }\n\n    /**\n     * Get video height\n     *\n     * @return {number}\n     *         current video height\n     */\n    videoHeight() {\n      return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n    }\n\n    /**\n     * The player's language code.\n     *\n     * Changing the language will trigger\n     * [languagechange]{@link Player#event:languagechange}\n     * which Components can use to update control text.\n     * ClickableComponent will update its control text by default on\n     * [languagechange]{@link Player#event:languagechange}.\n     *\n     * @fires Player#languagechange\n     *\n     * @param {string} [code]\n     *        the language code to set the player to\n     *\n     * @return {string}\n     *         The current language code when getting\n     */\n    language(code) {\n      if (code === undefined) {\n        return this.language_;\n      }\n      if (this.language_ !== String(code).toLowerCase()) {\n        this.language_ = String(code).toLowerCase();\n\n        // during first init, it's possible some things won't be evented\n        if (isEvented(this)) {\n          /**\n          * fires when the player language change\n          *\n          * @event Player#languagechange\n          * @type {EventTarget~Event}\n          */\n          this.trigger('languagechange');\n        }\n      }\n    }\n\n    /**\n     * Get the player's language dictionary\n     * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n     * Languages specified directly in the player options have precedence\n     *\n     * @return {Array}\n     *         An array of of supported languages\n     */\n    languages() {\n      return merge$2(Player.prototype.options_.languages, this.languages_);\n    }\n\n    /**\n     * returns a JavaScript object reperesenting the current track\n     * information. **DOES not return it as JSON**\n     *\n     * @return {Object}\n     *         Object representing the current of track info\n     */\n    toJSON() {\n      const options = merge$2(this.options_);\n      const tracks = options.tracks;\n      options.tracks = [];\n      for (let i = 0; i < tracks.length; i++) {\n        let track = tracks[i];\n\n        // deep merge tracks and null out player so no circular references\n        track = merge$2(track);\n        track.player = undefined;\n        options.tracks[i] = track;\n      }\n      return options;\n    }\n\n    /**\n     * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n     * component) that immediately overlays the player with arbitrary\n     * content and removes itself when closed.\n     *\n     * @param {string|Function|Element|Array|null} content\n     *        Same as {@link ModalDialog#content}'s param of the same name.\n     *        The most straight-forward usage is to provide a string or DOM\n     *        element.\n     *\n     * @param {Object} [options]\n     *        Extra options which will be passed on to the {@link ModalDialog}.\n     *\n     * @return {ModalDialog}\n     *         the {@link ModalDialog} that was created\n     */\n    createModal(content, options) {\n      options = options || {};\n      options.content = content || '';\n      const modal = new ModalDialog(this, options);\n      this.addChild(modal);\n      modal.on('dispose', () => {\n        this.removeChild(modal);\n      });\n      modal.open();\n      return modal;\n    }\n\n    /**\n     * Change breakpoint classes when the player resizes.\n     *\n     * @private\n     */\n    updateCurrentBreakpoint_() {\n      if (!this.responsive()) {\n        return;\n      }\n      const currentBreakpoint = this.currentBreakpoint();\n      const currentWidth = this.currentWidth();\n      for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {\n        const candidateBreakpoint = BREAKPOINT_ORDER[i];\n        const maxWidth = this.breakpoints_[candidateBreakpoint];\n        if (currentWidth <= maxWidth) {\n          // The current breakpoint did not change, nothing to do.\n          if (currentBreakpoint === candidateBreakpoint) {\n            return;\n          }\n\n          // Only remove a class if there is a current breakpoint.\n          if (currentBreakpoint) {\n            this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);\n          }\n          this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);\n          this.breakpoint_ = candidateBreakpoint;\n          break;\n        }\n      }\n    }\n\n    /**\n     * Removes the current breakpoint.\n     *\n     * @private\n     */\n    removeCurrentBreakpoint_() {\n      const className = this.currentBreakpointClass();\n      this.breakpoint_ = '';\n      if (className) {\n        this.removeClass(className);\n      }\n    }\n\n    /**\n     * Get or set breakpoints on the player.\n     *\n     * Calling this method with an object or `true` will remove any previous\n     * custom breakpoints and start from the defaults again.\n     *\n     * @param  {Object|boolean} [breakpoints]\n     *         If an object is given, it can be used to provide custom\n     *         breakpoints. If `true` is given, will set default breakpoints.\n     *         If this argument is not given, will simply return the current\n     *         breakpoints.\n     *\n     * @param  {number} [breakpoints.tiny]\n     *         The maximum width for the \"vjs-layout-tiny\" class.\n     *\n     * @param  {number} [breakpoints.xsmall]\n     *         The maximum width for the \"vjs-layout-x-small\" class.\n     *\n     * @param  {number} [breakpoints.small]\n     *         The maximum width for the \"vjs-layout-small\" class.\n     *\n     * @param  {number} [breakpoints.medium]\n     *         The maximum width for the \"vjs-layout-medium\" class.\n     *\n     * @param  {number} [breakpoints.large]\n     *         The maximum width for the \"vjs-layout-large\" class.\n     *\n     * @param  {number} [breakpoints.xlarge]\n     *         The maximum width for the \"vjs-layout-x-large\" class.\n     *\n     * @param  {number} [breakpoints.huge]\n     *         The maximum width for the \"vjs-layout-huge\" class.\n     *\n     * @return {Object}\n     *         An object mapping breakpoint names to maximum width values.\n     */\n    breakpoints(breakpoints) {\n      // Used as a getter.\n      if (breakpoints === undefined) {\n        return Object.assign(this.breakpoints_);\n      }\n      this.breakpoint_ = '';\n      this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints);\n\n      // When breakpoint definitions change, we need to update the currently\n      // selected breakpoint.\n      this.updateCurrentBreakpoint_();\n\n      // Clone the breakpoints before returning.\n      return Object.assign(this.breakpoints_);\n    }\n\n    /**\n     * Get or set a flag indicating whether or not this player should adjust\n     * its UI based on its dimensions.\n     *\n     * @param  {boolean} value\n     *         Should be `true` if the player should adjust its UI based on its\n     *         dimensions; otherwise, should be `false`.\n     *\n     * @return {boolean}\n     *         Will be `true` if this player should adjust its UI based on its\n     *         dimensions; otherwise, will be `false`.\n     */\n    responsive(value) {\n      // Used as a getter.\n      if (value === undefined) {\n        return this.responsive_;\n      }\n      value = Boolean(value);\n      const current = this.responsive_;\n\n      // Nothing changed.\n      if (value === current) {\n        return;\n      }\n\n      // The value actually changed, set it.\n      this.responsive_ = value;\n\n      // Start listening for breakpoints and set the initial breakpoint if the\n      // player is now responsive.\n      if (value) {\n        this.on('playerresize', this.boundUpdateCurrentBreakpoint_);\n        this.updateCurrentBreakpoint_();\n\n        // Stop listening for breakpoints if the player is no longer responsive.\n      } else {\n        this.off('playerresize', this.boundUpdateCurrentBreakpoint_);\n        this.removeCurrentBreakpoint_();\n      }\n      return value;\n    }\n\n    /**\n     * Get current breakpoint name, if any.\n     *\n     * @return {string}\n     *         If there is currently a breakpoint set, returns a the key from the\n     *         breakpoints object matching it. Otherwise, returns an empty string.\n     */\n    currentBreakpoint() {\n      return this.breakpoint_;\n    }\n\n    /**\n     * Get the current breakpoint class name.\n     *\n     * @return {string}\n     *         The matching class name (e.g. `\"vjs-layout-tiny\"` or\n     *         `\"vjs-layout-large\"`) for the current breakpoint. Empty string if\n     *         there is no current breakpoint.\n     */\n    currentBreakpointClass() {\n      return BREAKPOINT_CLASSES[this.breakpoint_] || '';\n    }\n\n    /**\n     * An object that describes a single piece of media.\n     *\n     * Properties that are not part of this type description will be retained; so,\n     * this can be viewed as a generic metadata storage mechanism as well.\n     *\n     * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}\n     * @typedef  {Object} Player~MediaObject\n     *\n     * @property {string} [album]\n     *           Unused, except if this object is passed to the `MediaSession`\n     *           API.\n     *\n     * @property {string} [artist]\n     *           Unused, except if this object is passed to the `MediaSession`\n     *           API.\n     *\n     * @property {Object[]} [artwork]\n     *           Unused, except if this object is passed to the `MediaSession`\n     *           API. If not specified, will be populated via the `poster`, if\n     *           available.\n     *\n     * @property {string} [poster]\n     *           URL to an image that will display before playback.\n     *\n     * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]\n     *           A single source object, an array of source objects, or a string\n     *           referencing a URL to a media source. It is _highly recommended_\n     *           that an object or array of objects is used here, so that source\n     *           selection algorithms can take the `type` into account.\n     *\n     * @property {string} [title]\n     *           Unused, except if this object is passed to the `MediaSession`\n     *           API.\n     *\n     * @property {Object[]} [textTracks]\n     *           An array of objects to be used to create text tracks, following\n     *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.\n     *           For ease of removal, these will be created as \"remote\" text\n     *           tracks and set to automatically clean up on source changes.\n     *\n     *           These objects may have properties like `src`, `kind`, `label`,\n     *           and `language`, see {@link Tech#createRemoteTextTrack}.\n     */\n\n    /**\n     * Populate the player using a {@link Player~MediaObject|MediaObject}.\n     *\n     * @param  {Player~MediaObject} media\n     *         A media object.\n     *\n     * @param  {Function} ready\n     *         A callback to be called when the player is ready.\n     */\n    loadMedia(media, ready) {\n      if (!media || typeof media !== 'object') {\n        return;\n      }\n      this.reset();\n\n      // Clone the media object so it cannot be mutated from outside.\n      this.cache_.media = merge$2(media);\n      const {\n        artist,\n        artwork,\n        description,\n        poster,\n        src,\n        textTracks,\n        title\n      } = this.cache_.media;\n\n      // If `artwork` is not given, create it using `poster`.\n      if (!artwork && poster) {\n        this.cache_.media.artwork = [{\n          src: poster,\n          type: getMimetype(poster)\n        }];\n      }\n      if (src) {\n        this.src(src);\n      }\n      if (poster) {\n        this.poster(poster);\n      }\n      if (Array.isArray(textTracks)) {\n        textTracks.forEach(tt => this.addRemoteTextTrack(tt, false));\n      }\n      if (this.titleBar) {\n        this.titleBar.update({\n          title,\n          description: description || artist || ''\n        });\n      }\n      this.ready(ready);\n    }\n\n    /**\n     * Get a clone of the current {@link Player~MediaObject} for this player.\n     *\n     * If the `loadMedia` method has not been used, will attempt to return a\n     * {@link Player~MediaObject} based on the current state of the player.\n     *\n     * @return {Player~MediaObject}\n     */\n    getMedia() {\n      if (!this.cache_.media) {\n        const poster = this.poster();\n        const src = this.currentSources();\n        const textTracks = Array.prototype.map.call(this.remoteTextTracks(), tt => ({\n          kind: tt.kind,\n          label: tt.label,\n          language: tt.language,\n          src: tt.src\n        }));\n        const media = {\n          src,\n          textTracks\n        };\n        if (poster) {\n          media.poster = poster;\n          media.artwork = [{\n            src: media.poster,\n            type: getMimetype(media.poster)\n          }];\n        }\n        return media;\n      }\n      return merge$2(this.cache_.media);\n    }\n\n    /**\n     * Gets tag settings\n     *\n     * @param {Element} tag\n     *        The player tag\n     *\n     * @return {Object}\n     *         An object containing all of the settings\n     *         for a player tag\n     */\n    static getTagSettings(tag) {\n      const baseOptions = {\n        sources: [],\n        tracks: []\n      };\n      const tagOptions = getAttributes(tag);\n      const dataSetup = tagOptions['data-setup'];\n      if (hasClass(tag, 'vjs-fill')) {\n        tagOptions.fill = true;\n      }\n      if (hasClass(tag, 'vjs-fluid')) {\n        tagOptions.fluid = true;\n      }\n\n      // Check if data-setup attr exists.\n      if (dataSetup !== null) {\n        // Parse options JSON\n        // If empty string, make it a parsable json object.\n        const [err, data] = tuple(dataSetup || '{}');\n        if (err) {\n          log$1.error(err);\n        }\n        Object.assign(tagOptions, data);\n      }\n      Object.assign(baseOptions, tagOptions);\n\n      // Get tag children settings\n      if (tag.hasChildNodes()) {\n        const children = tag.childNodes;\n        for (let i = 0, j = children.length; i < j; i++) {\n          const child = children[i];\n          // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n          const childName = child.nodeName.toLowerCase();\n          if (childName === 'source') {\n            baseOptions.sources.push(getAttributes(child));\n          } else if (childName === 'track') {\n            baseOptions.tracks.push(getAttributes(child));\n          }\n        }\n      }\n      return baseOptions;\n    }\n\n    /**\n     * Set debug mode to enable/disable logs at info level.\n     *\n     * @param {boolean} enabled\n     * @fires Player#debugon\n     * @fires Player#debugoff\n     */\n    debug(enabled) {\n      if (enabled === undefined) {\n        return this.debugEnabled_;\n      }\n      if (enabled) {\n        this.trigger('debugon');\n        this.previousLogLevel_ = this.log.level;\n        this.log.level('debug');\n        this.debugEnabled_ = true;\n      } else {\n        this.trigger('debugoff');\n        this.log.level(this.previousLogLevel_);\n        this.previousLogLevel_ = undefined;\n        this.debugEnabled_ = false;\n      }\n    }\n\n    /**\n     * Set or get current playback rates.\n     * Takes an array and updates the playback rates menu with the new items.\n     * Pass in an empty array to hide the menu.\n     * Values other than arrays are ignored.\n     *\n     * @fires Player#playbackrateschange\n     * @param {number[]} newRates\n     *                   The new rates that the playback rates menu should update to.\n     *                   An empty array will hide the menu\n     * @return {number[]} When used as a getter will return the current playback rates\n     */\n    playbackRates(newRates) {\n      if (newRates === undefined) {\n        return this.cache_.playbackRates;\n      }\n\n      // ignore any value that isn't an array\n      if (!Array.isArray(newRates)) {\n        return;\n      }\n\n      // ignore any arrays that don't only contain numbers\n      if (!newRates.every(rate => typeof rate === 'number')) {\n        return;\n      }\n      this.cache_.playbackRates = newRates;\n\n      /**\n      * fires when the playback rates in a player are changed\n      *\n      * @event Player#playbackrateschange\n      * @type {EventTarget~Event}\n      */\n      this.trigger('playbackrateschange');\n    }\n  }\n\n  /**\n   * Get the {@link VideoTrackList}\n   *\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n   *\n   * @return {VideoTrackList}\n   *         the current video track list\n   *\n   * @method Player.prototype.videoTracks\n   */\n\n  /**\n   * Get the {@link AudioTrackList}\n   *\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n   *\n   * @return {AudioTrackList}\n   *         the current audio track list\n   *\n   * @method Player.prototype.audioTracks\n   */\n\n  /**\n   * Get the {@link TextTrackList}\n   *\n   * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n   *\n   * @return {TextTrackList}\n   *         the current text track list\n   *\n   * @method Player.prototype.textTracks\n   */\n\n  /**\n   * Get the remote {@link TextTrackList}\n   *\n   * @return {TextTrackList}\n   *         The current remote text track list\n   *\n   * @method Player.prototype.remoteTextTracks\n   */\n\n  /**\n   * Get the remote {@link HtmlTrackElementList} tracks.\n   *\n   * @return {HtmlTrackElementList}\n   *         The current remote text track element list\n   *\n   * @method Player.prototype.remoteTextTrackEls\n   */\n\n  ALL.names.forEach(function (name) {\n    const props = ALL[name];\n    Player.prototype[props.getterName] = function () {\n      if (this.tech_) {\n        return this.tech_[props.getterName]();\n      }\n\n      // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n      // these will be passed to the tech during loading\n      this[props.privateName] = this[props.privateName] || new props.ListClass();\n      return this[props.privateName];\n    };\n  });\n\n  /**\n   * Get or set the `Player`'s crossorigin option. For the HTML5 player, this\n   * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n   * behavior.\n   *\n   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n   *\n   * @param {string} [value]\n   *        The value to set the `Player`'s crossorigin to. If an argument is\n   *        given, must be one of `anonymous` or `use-credentials`.\n   *\n   * @return {string|undefined}\n   *         - The current crossorigin value of the `Player` when getting.\n   *         - undefined when setting\n   */\n  Player.prototype.crossorigin = Player.prototype.crossOrigin;\n\n  /**\n   * Global enumeration of players.\n   *\n   * The keys are the player IDs and the values are either the {@link Player}\n   * instance or `null` for disposed players.\n   *\n   * @type {Object}\n   */\n  Player.players = {};\n  const navigator = window.navigator;\n\n  /*\n   * Player instance options, surfaced using options\n   * options = Player.prototype.options_\n   * Make changes in options, not here.\n   *\n   * @type {Object}\n   * @private\n   */\n  Player.prototype.options_ = {\n    // Default order of fallback technology\n    techOrder: Tech.defaultTechOrder_,\n    html5: {},\n    // enable sourceset by default\n    enableSourceset: true,\n    // default inactivity timeout\n    inactivityTimeout: 2000,\n    // default playback rates\n    playbackRates: [],\n    // Add playback rate selection by adding rates\n    // 'playbackRates': [0.5, 1, 1.5, 2],\n    liveui: false,\n    // Included control sets\n    children: ['mediaLoader', 'posterImage', 'titleBar', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],\n    language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n    // locales and their language translations\n    languages: {},\n    // Default message to show when a video cannot be played.\n    notSupportedMessage: 'No compatible source was found for this media.',\n    normalizeAutoplay: false,\n    fullscreen: {\n      options: {\n        navigationUI: 'hide'\n      }\n    },\n    breakpoints: {},\n    responsive: false,\n    audioOnlyMode: false,\n    audioPosterMode: false\n  };\n  [\n  /**\n   * Returns whether or not the player is in the \"ended\" state.\n   *\n   * @return {Boolean} True if the player is in the ended state, false if not.\n   * @method Player#ended\n   */\n  'ended',\n  /**\n   * Returns whether or not the player is in the \"seeking\" state.\n   *\n   * @return {Boolean} True if the player is in the seeking state, false if not.\n   * @method Player#seeking\n   */\n  'seeking',\n  /**\n   * Returns the TimeRanges of the media that are currently available\n   * for seeking to.\n   *\n   * @return {TimeRanges} the seekable intervals of the media timeline\n   * @method Player#seekable\n   */\n  'seekable',\n  /**\n   * Returns the current state of network activity for the element, from\n   * the codes in the list below.\n   * - NETWORK_EMPTY (numeric value 0)\n   *   The element has not yet been initialised. All attributes are in\n   *   their initial states.\n   * - NETWORK_IDLE (numeric value 1)\n   *   The element's resource selection algorithm is active and has\n   *   selected a resource, but it is not actually using the network at\n   *   this time.\n   * - NETWORK_LOADING (numeric value 2)\n   *   The user agent is actively trying to download data.\n   * - NETWORK_NO_SOURCE (numeric value 3)\n   *   The element's resource selection algorithm is active, but it has\n   *   not yet found a resource to use.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n   * @return {number} the current network activity state\n   * @method Player#networkState\n   */\n  'networkState',\n  /**\n   * Returns a value that expresses the current state of the element\n   * with respect to rendering the current playback position, from the\n   * codes in the list below.\n   * - HAVE_NOTHING (numeric value 0)\n   *   No information regarding the media resource is available.\n   * - HAVE_METADATA (numeric value 1)\n   *   Enough of the resource has been obtained that the duration of the\n   *   resource is available.\n   * - HAVE_CURRENT_DATA (numeric value 2)\n   *   Data for the immediate current playback position is available.\n   * - HAVE_FUTURE_DATA (numeric value 3)\n   *   Data for the immediate current playback position is available, as\n   *   well as enough data for the user agent to advance the current\n   *   playback position in the direction of playback.\n   * - HAVE_ENOUGH_DATA (numeric value 4)\n   *   The user agent estimates that enough data is available for\n   *   playback to proceed uninterrupted.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n   * @return {number} the current playback rendering state\n   * @method Player#readyState\n   */\n  'readyState'].forEach(function (fn) {\n    Player.prototype[fn] = function () {\n      return this.techGet_(fn);\n    };\n  });\n  TECH_EVENTS_RETRIGGER.forEach(function (event) {\n    Player.prototype[`handleTech${toTitleCase$1(event)}_`] = function () {\n      return this.trigger(event);\n    };\n  });\n\n  /**\n   * Fired when the player has initial duration and dimension information\n   *\n   * @event Player#loadedmetadata\n   * @type {EventTarget~Event}\n   */\n\n  /**\n   * Fired when the player has downloaded data at the current playback position\n   *\n   * @event Player#loadeddata\n   * @type {EventTarget~Event}\n   */\n\n  /**\n   * Fired when the current playback position has changed *\n   * During playback this is fired every 15-250 milliseconds, depending on the\n   * playback technology in use.\n   *\n   * @event Player#timeupdate\n   * @type {EventTarget~Event}\n   */\n\n  /**\n   * Fired when the volume changes\n   *\n   * @event Player#volumechange\n   * @type {EventTarget~Event}\n   */\n\n  /**\n   * Reports whether or not a player has a plugin available.\n   *\n   * This does not report whether or not the plugin has ever been initialized\n   * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n   *\n   * @method Player#hasPlugin\n   * @param  {string}  name\n   *         The name of a plugin.\n   *\n   * @return {boolean}\n   *         Whether or not this player has the requested plugin available.\n   */\n\n  /**\n   * Reports whether or not a player is using a plugin by name.\n   *\n   * For basic plugins, this only reports whether the plugin has _ever_ been\n   * initialized on this player.\n   *\n   * @method Player#usingPlugin\n   * @param  {string} name\n   *         The name of a plugin.\n   *\n   * @return {boolean}\n   *         Whether or not this player is using the requested plugin.\n   */\n\n  Component$1.registerComponent('Player', Player);\n\n  /**\n   * @file plugin.js\n   */\n\n  /**\n   * The base plugin name.\n   *\n   * @private\n   * @constant\n   * @type {string}\n   */\n  const BASE_PLUGIN_NAME = 'plugin';\n\n  /**\n   * The key on which a player's active plugins cache is stored.\n   *\n   * @private\n   * @constant\n   * @type     {string}\n   */\n  const PLUGIN_CACHE_KEY = 'activePlugins_';\n\n  /**\n   * Stores registered plugins in a private space.\n   *\n   * @private\n   * @type    {Object}\n   */\n  const pluginStorage = {};\n\n  /**\n   * Reports whether or not a plugin has been registered.\n   *\n   * @private\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @return {boolean}\n   *          Whether or not the plugin has been registered.\n   */\n  const pluginExists = name => pluginStorage.hasOwnProperty(name);\n\n  /**\n   * Get a single registered plugin by name.\n   *\n   * @private\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @return {typeof Plugin|Function|undefined}\n   *          The plugin (or undefined).\n   */\n  const getPlugin = name => pluginExists(name) ? pluginStorage[name] : undefined;\n\n  /**\n   * Marks a plugin as \"active\" on a player.\n   *\n   * Also, ensures that the player has an object for tracking active plugins.\n   *\n   * @private\n   * @param   {Player} player\n   *          A Video.js player instance.\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   */\n  const markPluginAsActive = (player, name) => {\n    player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n    player[PLUGIN_CACHE_KEY][name] = true;\n  };\n\n  /**\n   * Triggers a pair of plugin setup events.\n   *\n   * @private\n   * @param  {Player} player\n   *         A Video.js player instance.\n   *\n   * @param  {Plugin~PluginEventHash} hash\n   *         A plugin event hash.\n   *\n   * @param  {boolean} [before]\n   *         If true, prefixes the event name with \"before\". In other words,\n   *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n   */\n  const triggerSetupEvent = (player, hash, before) => {\n    const eventName = (before ? 'before' : '') + 'pluginsetup';\n    player.trigger(eventName, hash);\n    player.trigger(eventName + ':' + hash.name, hash);\n  };\n\n  /**\n   * Takes a basic plugin function and returns a wrapper function which marks\n   * on the player that the plugin has been activated.\n   *\n   * @private\n   * @param   {string} name\n   *          The name of the plugin.\n   *\n   * @param   {Function} plugin\n   *          The basic plugin.\n   *\n   * @return {Function}\n   *          A wrapper function for the given plugin.\n   */\n  const createBasicPlugin = function (name, plugin) {\n    const basicPluginWrapper = function () {\n      // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n      // regardless, but we want the hash to be consistent with the hash provided\n      // for advanced plugins.\n      //\n      // The only potentially counter-intuitive thing here is the `instance` in\n      // the \"pluginsetup\" event is the value returned by the `plugin` function.\n      triggerSetupEvent(this, {\n        name,\n        plugin,\n        instance: null\n      }, true);\n      const instance = plugin.apply(this, arguments);\n      markPluginAsActive(this, name);\n      triggerSetupEvent(this, {\n        name,\n        plugin,\n        instance\n      });\n      return instance;\n    };\n    Object.keys(plugin).forEach(function (prop) {\n      basicPluginWrapper[prop] = plugin[prop];\n    });\n    return basicPluginWrapper;\n  };\n\n  /**\n   * Takes a plugin sub-class and returns a factory function for generating\n   * instances of it.\n   *\n   * This factory function will replace itself with an instance of the requested\n   * sub-class of Plugin.\n   *\n   * @private\n   * @param   {string} name\n   *          The name of the plugin.\n   *\n   * @param   {Plugin} PluginSubClass\n   *          The advanced plugin.\n   *\n   * @return {Function}\n   */\n  const createPluginFactory = (name, PluginSubClass) => {\n    // Add a `name` property to the plugin prototype so that each plugin can\n    // refer to itself by name.\n    PluginSubClass.prototype.name = name;\n    return function (...args) {\n      triggerSetupEvent(this, {\n        name,\n        plugin: PluginSubClass,\n        instance: null\n      }, true);\n      const instance = new PluginSubClass(...[this, ...args]);\n\n      // The plugin is replaced by a function that returns the current instance.\n      this[name] = () => instance;\n      triggerSetupEvent(this, instance.getEventHash());\n      return instance;\n    };\n  };\n\n  /**\n   * Parent class for all advanced plugins.\n   *\n   * @mixes   module:evented~EventedMixin\n   * @mixes   module:stateful~StatefulMixin\n   * @fires   Player#beforepluginsetup\n   * @fires   Player#beforepluginsetup:$name\n   * @fires   Player#pluginsetup\n   * @fires   Player#pluginsetup:$name\n   * @listens Player#dispose\n   * @throws  {Error}\n   *          If attempting to instantiate the base {@link Plugin} class\n   *          directly instead of via a sub-class.\n   */\n  class Plugin {\n    /**\n     * Creates an instance of this class.\n     *\n     * Sub-classes should call `super` to ensure plugins are properly initialized.\n     *\n     * @param {Player} player\n     *        A Video.js player instance.\n     */\n    constructor(player) {\n      if (this.constructor === Plugin) {\n        throw new Error('Plugin must be sub-classed; not directly instantiated.');\n      }\n      this.player = player;\n      if (!this.log) {\n        this.log = this.player.log.createLogger(this.name);\n      }\n\n      // Make this object evented, but remove the added `trigger` method so we\n      // use the prototype version instead.\n      evented(this);\n      delete this.trigger;\n      stateful(this, this.constructor.defaultState);\n      markPluginAsActive(player, this.name);\n\n      // Auto-bind the dispose method so we can use it as a listener and unbind\n      // it later easily.\n      this.dispose = this.dispose.bind(this);\n\n      // If the player is disposed, dispose the plugin.\n      player.on('dispose', this.dispose);\n    }\n\n    /**\n     * Get the version of the plugin that was set on <pluginName>.VERSION\n     */\n    version() {\n      return this.constructor.VERSION;\n    }\n\n    /**\n     * Each event triggered by plugins includes a hash of additional data with\n     * conventional properties.\n     *\n     * This returns that object or mutates an existing hash.\n     *\n     * @param   {Object} [hash={}]\n     *          An object to be used as event an event hash.\n     *\n     * @return {Plugin~PluginEventHash}\n     *          An event hash object with provided properties mixed-in.\n     */\n    getEventHash(hash = {}) {\n      hash.name = this.name;\n      hash.plugin = this.constructor;\n      hash.instance = this;\n      return hash;\n    }\n\n    /**\n     * Triggers an event on the plugin object and overrides\n     * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n     *\n     * @param   {string|Object} event\n     *          An event type or an object with a type property.\n     *\n     * @param   {Object} [hash={}]\n     *          Additional data hash to merge with a\n     *          {@link Plugin~PluginEventHash|PluginEventHash}.\n     *\n     * @return {boolean}\n     *          Whether or not default was prevented.\n     */\n    trigger(event, hash = {}) {\n      return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n    }\n\n    /**\n     * Handles \"statechanged\" events on the plugin. No-op by default, override by\n     * subclassing.\n     *\n     * @abstract\n     * @param    {Event} e\n     *           An event object provided by a \"statechanged\" event.\n     *\n     * @param    {Object} e.changes\n     *           An object describing changes that occurred with the \"statechanged\"\n     *           event.\n     */\n    handleStateChanged(e) {}\n\n    /**\n     * Disposes a plugin.\n     *\n     * Subclasses can override this if they want, but for the sake of safety,\n     * it's probably best to subscribe the \"dispose\" event.\n     *\n     * @fires Plugin#dispose\n     */\n    dispose() {\n      const {\n        name,\n        player\n      } = this;\n\n      /**\n       * Signals that a advanced plugin is about to be disposed.\n       *\n       * @event Plugin#dispose\n       * @type  {EventTarget~Event}\n       */\n      this.trigger('dispose');\n      this.off();\n      player.off('dispose', this.dispose);\n\n      // Eliminate any possible sources of leaking memory by clearing up\n      // references between the player and the plugin instance and nulling out\n      // the plugin's state and replacing methods with a function that throws.\n      player[PLUGIN_CACHE_KEY][name] = false;\n      this.player = this.state = null;\n\n      // Finally, replace the plugin name on the player with a new factory\n      // function, so that the plugin is ready to be set up again.\n      player[name] = createPluginFactory(name, pluginStorage[name]);\n    }\n\n    /**\n     * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n     *\n     * @param   {string|Function} plugin\n     *          If a string, matches the name of a plugin. If a function, will be\n     *          tested directly.\n     *\n     * @return {boolean}\n     *          Whether or not a plugin is a basic plugin.\n     */\n    static isBasic(plugin) {\n      const p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n      return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n    }\n\n    /**\n     * Register a Video.js plugin.\n     *\n     * @param   {string} name\n     *          The name of the plugin to be registered. Must be a string and\n     *          must not match an existing plugin or a method on the `Player`\n     *          prototype.\n     *\n     * @param   {typeof Plugin|Function} plugin\n     *          A sub-class of `Plugin` or a function for basic plugins.\n     *\n     * @return {typeof Plugin|Function}\n     *          For advanced plugins, a factory function for that plugin. For\n     *          basic plugins, a wrapper function that initializes the plugin.\n     */\n    static registerPlugin(name, plugin) {\n      if (typeof name !== 'string') {\n        throw new Error(`Illegal plugin name, \"${name}\", must be a string, was ${typeof name}.`);\n      }\n      if (pluginExists(name)) {\n        log$1.warn(`A plugin named \"${name}\" already exists. You may want to avoid re-registering plugins!`);\n      } else if (Player.prototype.hasOwnProperty(name)) {\n        throw new Error(`Illegal plugin name, \"${name}\", cannot share a name with an existing player method!`);\n      }\n      if (typeof plugin !== 'function') {\n        throw new Error(`Illegal plugin for \"${name}\", must be a function, was ${typeof plugin}.`);\n      }\n      pluginStorage[name] = plugin;\n\n      // Add a player prototype method for all sub-classed plugins (but not for\n      // the base Plugin class).\n      if (name !== BASE_PLUGIN_NAME) {\n        if (Plugin.isBasic(plugin)) {\n          Player.prototype[name] = createBasicPlugin(name, plugin);\n        } else {\n          Player.prototype[name] = createPluginFactory(name, plugin);\n        }\n      }\n      return plugin;\n    }\n\n    /**\n     * De-register a Video.js plugin.\n     *\n     * @param  {string} name\n     *         The name of the plugin to be de-registered. Must be a string that\n     *         matches an existing plugin.\n     *\n     * @throws {Error}\n     *         If an attempt is made to de-register the base plugin.\n     */\n    static deregisterPlugin(name) {\n      if (name === BASE_PLUGIN_NAME) {\n        throw new Error('Cannot de-register base plugin.');\n      }\n      if (pluginExists(name)) {\n        delete pluginStorage[name];\n        delete Player.prototype[name];\n      }\n    }\n\n    /**\n     * Gets an object containing multiple Video.js plugins.\n     *\n     * @param   {Array} [names]\n     *          If provided, should be an array of plugin names. Defaults to _all_\n     *          plugin names.\n     *\n     * @return {Object|undefined}\n     *          An object containing plugin(s) associated with their name(s) or\n     *          `undefined` if no matching plugins exist).\n     */\n    static getPlugins(names = Object.keys(pluginStorage)) {\n      let result;\n      names.forEach(name => {\n        const plugin = getPlugin(name);\n        if (plugin) {\n          result = result || {};\n          result[name] = plugin;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Gets a plugin's version, if available\n     *\n     * @param   {string} name\n     *          The name of a plugin.\n     *\n     * @return {string}\n     *          The plugin's version or an empty string.\n     */\n    static getPluginVersion(name) {\n      const plugin = getPlugin(name);\n      return plugin && plugin.VERSION || '';\n    }\n  }\n\n  /**\n   * Gets a plugin by name if it exists.\n   *\n   * @static\n   * @method   getPlugin\n   * @memberOf Plugin\n   * @param    {string} name\n   *           The name of a plugin.\n   *\n   * @returns  {typeof Plugin|Function|undefined}\n   *           The plugin (or `undefined`).\n   */\n  Plugin.getPlugin = getPlugin;\n\n  /**\n   * The name of the base plugin class as it is registered.\n   *\n   * @type {string}\n   */\n  Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n  Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n\n  /**\n   * Documented in player.js\n   *\n   * @ignore\n   */\n  Player.prototype.usingPlugin = function (name) {\n    return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n  };\n\n  /**\n   * Documented in player.js\n   *\n   * @ignore\n   */\n  Player.prototype.hasPlugin = function (name) {\n    return !!pluginExists(name);\n  };\n\n  /**\n   * Signals that a plugin is about to be set up on a player.\n   *\n   * @event    Player#beforepluginsetup\n   * @type     {Plugin~PluginEventHash}\n   */\n\n  /**\n   * Signals that a plugin is about to be set up on a player - by name. The name\n   * is the name of the plugin.\n   *\n   * @event    Player#beforepluginsetup:$name\n   * @type     {Plugin~PluginEventHash}\n   */\n\n  /**\n   * Signals that a plugin has just been set up on a player.\n   *\n   * @event    Player#pluginsetup\n   * @type     {Plugin~PluginEventHash}\n   */\n\n  /**\n   * Signals that a plugin has just been set up on a player - by name. The name\n   * is the name of the plugin.\n   *\n   * @event    Player#pluginsetup:$name\n   * @type     {Plugin~PluginEventHash}\n   */\n\n  /**\n   * @typedef  {Object} Plugin~PluginEventHash\n   *\n   * @property {string} instance\n   *           For basic plugins, the return value of the plugin function. For\n   *           advanced plugins, the plugin instance on which the event is fired.\n   *\n   * @property {string} name\n   *           The name of the plugin.\n   *\n   * @property {string} plugin\n   *           For basic plugins, the plugin function. For advanced plugins, the\n   *           plugin class/constructor.\n   */\n\n  /**\n   * @file deprecate.js\n   * @module deprecate\n   */\n\n  /**\n   * Decorate a function with a deprecation message the first time it is called.\n   *\n   * @param  {string}   message\n   *         A deprecation message to log the first time the returned function\n   *         is called.\n   *\n   * @param  {Function} fn\n   *         The function to be deprecated.\n   *\n   * @return {Function}\n   *         A wrapper function that will log a deprecation warning the first\n   *         time it is called. The return value will be the return value of\n   *         the wrapped function.\n   */\n  function deprecate(message, fn) {\n    let warned = false;\n    return function (...args) {\n      if (!warned) {\n        log$1.warn(message);\n      }\n      warned = true;\n      return fn.apply(this, args);\n    };\n  }\n\n  /**\n   * Internal function used to mark a function as deprecated in the next major\n   * version with consistent messaging.\n   *\n   * @param  {number}   major   The major version where it will be removed\n   * @param  {string}   oldName The old function name\n   * @param  {string}   newName The new function name\n   * @param  {Function} fn      The function to deprecate\n   * @return {Function}         The decorated function\n   */\n  function deprecateForMajor(major, oldName, newName, fn) {\n    return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);\n  }\n\n  /**\n   * @file video.js\n   * @module videojs\n   */\n\n  /**\n   * Normalize an `id` value by trimming off a leading `#`\n   *\n   * @private\n   * @param   {string} id\n   *          A string, maybe with a leading `#`.\n   *\n   * @return {string}\n   *          The string, without any leading `#`.\n   */\n  const normalizeId = id => id.indexOf('#') === 0 ? id.slice(1) : id;\n\n  /**\n   * A callback that is called when a component is ready. Does not have any\n   * parameters and any callback value will be ignored. See: {@link Component~ReadyCallback}\n   *\n   * @callback ReadyCallback\n   */\n\n  /**\n   * The `videojs()` function doubles as the main function for users to create a\n   * {@link Player} instance as well as the main library namespace.\n   *\n   * It can also be used as a getter for a pre-existing {@link Player} instance.\n   * However, we _strongly_ recommend using `videojs.getPlayer()` for this\n   * purpose because it avoids any potential for unintended initialization.\n   *\n   * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n   * of our JSDoc template, we cannot properly document this as both a function\n   * and a namespace, so its function signature is documented here.\n   *\n   * #### Arguments\n   * ##### id\n   * string|Element, **required**\n   *\n   * Video element or video element ID.\n   *\n   * ##### options\n   * Object, optional\n   *\n   * Options object for providing settings.\n   * See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n   *\n   * ##### ready\n   * {@link Component~ReadyCallback}, optional\n   *\n   * A function to be called when the {@link Player} and {@link Tech} are ready.\n   *\n   * #### Return Value\n   *\n   * The `videojs()` function returns a {@link Player} instance.\n   *\n   * @namespace\n   *\n   * @borrows AudioTrack as AudioTrack\n   * @borrows Component.getComponent as getComponent\n   * @borrows module:events.on as on\n   * @borrows module:events.one as one\n   * @borrows module:events.off as off\n   * @borrows module:events.trigger as trigger\n   * @borrows EventTarget as EventTarget\n   * @borrows module:middleware.use as use\n   * @borrows Player.players as players\n   * @borrows Plugin.registerPlugin as registerPlugin\n   * @borrows Plugin.deregisterPlugin as deregisterPlugin\n   * @borrows Plugin.getPlugins as getPlugins\n   * @borrows Plugin.getPlugin as getPlugin\n   * @borrows Plugin.getPluginVersion as getPluginVersion\n   * @borrows Tech.getTech as getTech\n   * @borrows Tech.registerTech as registerTech\n   * @borrows TextTrack as TextTrack\n   * @borrows VideoTrack as VideoTrack\n   *\n   * @param  {string|Element} id\n   *         Video element or video element ID.\n   *\n   * @param  {Object} [options]\n   *         Options object for providing settings.\n   *         See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n   *\n   * @param  {ReadyCallback} [ready]\n   *         A function to be called when the {@link Player} and {@link Tech} are\n   *         ready.\n   *\n   * @return {Player}\n   *         The `videojs()` function returns a {@link Player|Player} instance.\n   */\n  function videojs(id, options, ready) {\n    let player = videojs.getPlayer(id);\n    if (player) {\n      if (options) {\n        log$1.warn(`Player \"${id}\" is already initialised. Options will not be applied.`);\n      }\n      if (ready) {\n        player.ready(ready);\n      }\n      return player;\n    }\n    const el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\n    if (!isEl(el)) {\n      throw new TypeError('The element or ID supplied is not valid. (videojs)');\n    }\n\n    // document.body.contains(el) will only check if el is contained within that one document.\n    // This causes problems for elements in iframes.\n    // Instead, use the element's ownerDocument instead of the global document.\n    // This will make sure that the element is indeed in the dom of that document.\n    // Additionally, check that the document in question has a default view.\n    // If the document is no longer attached to the dom, the defaultView of the document will be null.\n    if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {\n      log$1.warn('The element supplied is not included in the DOM');\n    }\n    options = options || {};\n\n    // Store a copy of the el before modification, if it is to be restored in destroy()\n    // If div ingest, store the parent div\n    if (options.restoreEl === true) {\n      options.restoreEl = (el.parentNode && el.parentNode.hasAttribute('data-vjs-player') ? el.parentNode : el).cloneNode(true);\n    }\n    hooks('beforesetup').forEach(hookFunction => {\n      const opts = hookFunction(el, merge$2(options));\n      if (!isObject$1(opts) || Array.isArray(opts)) {\n        log$1.error('please return an object in beforesetup hooks');\n        return;\n      }\n      options = merge$2(options, opts);\n    });\n\n    // We get the current \"Player\" component here in case an integration has\n    // replaced it with a custom player.\n    const PlayerComponent = Component$1.getComponent('Player');\n    player = new PlayerComponent(el, options, ready);\n    hooks('setup').forEach(hookFunction => hookFunction(player));\n    return player;\n  }\n  videojs.hooks_ = hooks_;\n  videojs.hooks = hooks;\n  videojs.hook = hook;\n  videojs.hookOnce = hookOnce;\n  videojs.removeHook = removeHook;\n\n  // Add default styles\n  if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n    let style = $('.vjs-styles-defaults');\n    if (!style) {\n      style = createStyleElement('vjs-styles-defaults');\n      const head = $('head');\n      if (head) {\n        head.insertBefore(style, head.firstChild);\n      }\n      setTextContent(style, `\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    `);\n    }\n  }\n\n  // Run Auto-load players\n  // You have to wait at least once in case this script is loaded after your\n  // video in the DOM (weird behavior only with minified version)\n  autoSetupTimeout(1, videojs);\n\n  /**\n   * Current Video.js version. Follows [semantic versioning](https://semver.org/).\n   *\n   * @type {string}\n   */\n  videojs.VERSION = version$5;\n\n  /**\n   * The global options object. These are the settings that take effect\n   * if no overrides are specified when the player is created.\n   *\n   * @type {Object}\n   */\n  videojs.options = Player.prototype.options_;\n\n  /**\n   * Get an object with the currently created players, keyed by player ID\n   *\n   * @return {Object}\n   *         The created players\n   */\n  videojs.getPlayers = () => Player.players;\n\n  /**\n   * Get a single player based on an ID or DOM element.\n   *\n   * This is useful if you want to check if an element or ID has an associated\n   * Video.js player, but not create one if it doesn't.\n   *\n   * @param   {string|Element} id\n   *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\n   *          or a string matching the `id` of such an element.\n   *\n   * @return {Player|undefined}\n   *          A player instance or `undefined` if there is no player instance\n   *          matching the argument.\n   */\n  videojs.getPlayer = id => {\n    const players = Player.players;\n    let tag;\n    if (typeof id === 'string') {\n      const nId = normalizeId(id);\n      const player = players[nId];\n      if (player) {\n        return player;\n      }\n      tag = $('#' + nId);\n    } else {\n      tag = id;\n    }\n    if (isEl(tag)) {\n      const {\n        player,\n        playerId\n      } = tag;\n\n      // Element may have a `player` property referring to an already created\n      // player instance. If so, return that.\n      if (player || players[playerId]) {\n        return player || players[playerId];\n      }\n    }\n  };\n\n  /**\n   * Returns an array of all current players.\n   *\n   * @return {Array}\n   *         An array of all players. The array will be in the order that\n   *         `Object.keys` provides, which could potentially vary between\n   *         JavaScript engines.\n   *\n   */\n  videojs.getAllPlayers = () =>\n  // Disposed players leave a key with a `null` value, so we need to make sure\n  // we filter those out.\n  Object.keys(Player.players).map(k => Player.players[k]).filter(Boolean);\n  videojs.players = Player.players;\n  videojs.getComponent = Component$1.getComponent;\n\n  /**\n   * Register a component so it can referred to by name. Used when adding to other\n   * components, either through addChild `component.addChild('myComponent')` or through\n   * default children options  `{ children: ['myComponent'] }`.\n   *\n   * > NOTE: You could also just initialize the component before adding.\n   * `component.addChild(new MyComponent());`\n   *\n   * @param {string} name\n   *        The class name of the component\n   *\n   * @param {Component} comp\n   *        The component class\n   *\n   * @return {Component}\n   *         The newly registered component\n   */\n  videojs.registerComponent = (name, comp) => {\n    if (Tech.isTech(comp)) {\n      log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);\n    }\n    Component$1.registerComponent.call(Component$1, name, comp);\n  };\n  videojs.getTech = Tech.getTech;\n  videojs.registerTech = Tech.registerTech;\n  videojs.use = use;\n\n  /**\n   * An object that can be returned by a middleware to signify\n   * that the middleware is being terminated.\n   *\n   * @type {object}\n   * @property {object} middleware.TERMINATOR\n   */\n  Object.defineProperty(videojs, 'middleware', {\n    value: {},\n    writeable: false,\n    enumerable: true\n  });\n  Object.defineProperty(videojs.middleware, 'TERMINATOR', {\n    value: TERMINATOR,\n    writeable: false,\n    enumerable: true\n  });\n\n  /**\n   * A reference to the {@link module:browser|browser utility module} as an object.\n   *\n   * @type {Object}\n   * @see  {@link module:browser|browser}\n   */\n  videojs.browser = browser;\n\n  /**\n   * A reference to the {@link module:obj|obj utility module} as an object.\n   *\n   * @type {Object}\n   * @see  {@link module:obj|obj}\n   */\n  videojs.obj = Obj;\n\n  /**\n   * Deprecated reference to the {@link module:obj.merge|merge function}\n   *\n   * @type {Function}\n   * @see {@link module:obj.merge|merge}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.merge instead.\n   */\n  videojs.mergeOptions = deprecateForMajor(9, 'videojs.mergeOptions', 'videojs.obj.merge', merge$2);\n\n  /**\n   * Deprecated reference to the {@link module:obj.defineLazyProperty|defineLazyProperty function}\n   *\n   * @type {Function}\n   * @see {@link module:obj.defineLazyProperty|defineLazyProperty}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.defineLazyProperty instead.\n   */\n  videojs.defineLazyProperty = deprecateForMajor(9, 'videojs.defineLazyProperty', 'videojs.obj.defineLazyProperty', defineLazyProperty);\n\n  /**\n   * Deprecated reference to the {@link module:fn.bind_|fn.bind_ function}\n   *\n   * @type {Function}\n   * @see {@link module:fn.bind_|fn.bind_}\n   * @deprecated Deprecated and will be removed in 9.0. Please use native Function.prototype.bind instead.\n   */\n  videojs.bind = deprecateForMajor(9, 'videojs.bind', 'native Function.prototype.bind', bind_);\n  videojs.registerPlugin = Plugin.registerPlugin;\n  videojs.deregisterPlugin = Plugin.deregisterPlugin;\n\n  /**\n   * Deprecated method to register a plugin with Video.js\n   *\n   * @deprecated Deprecated and will be removed in 9.0. Use videojs.registerPlugin() instead.\n   *\n   * @param {string} name\n   *        The plugin name\n   *\n   * @param {Plugin|Function} plugin\n   *         The plugin sub-class or function\n   */\n  videojs.plugin = (name, plugin) => {\n    log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n    return Plugin.registerPlugin(name, plugin);\n  };\n  videojs.getPlugins = Plugin.getPlugins;\n  videojs.getPlugin = Plugin.getPlugin;\n  videojs.getPluginVersion = Plugin.getPluginVersion;\n\n  /**\n   * Adding languages so that they're available to all players.\n   * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n   *\n   * @param {string} code\n   *        The language code or dictionary property\n   *\n   * @param {Object} data\n   *        The data values to be translated\n   *\n   * @return {Object}\n   *         The resulting language dictionary object\n   */\n  videojs.addLanguage = function (code, data) {\n    code = ('' + code).toLowerCase();\n    videojs.options.languages = merge$2(videojs.options.languages, {\n      [code]: data\n    });\n    return videojs.options.languages[code];\n  };\n\n  /**\n   * A reference to the {@link module:log|log utility module} as an object.\n   *\n   * @type {Function}\n   * @see  {@link module:log|log}\n   */\n  videojs.log = log$1;\n  videojs.createLogger = createLogger;\n\n  /**\n   * A reference to the {@link module:time|time utility module} as an object.\n   *\n   * @type {Object}\n   * @see {@link module:time|time}\n   */\n  videojs.time = Time;\n\n  /**\n   * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}\n   *\n   * @type {Function}\n   * @see {@link module:time.createTimeRanges|createTimeRanges}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.\n   */\n  videojs.createTimeRange = deprecateForMajor(9, 'videojs.createTimeRange', 'videojs.time.createTimeRanges', createTimeRanges$1);\n\n  /**\n   * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}\n   *\n   * @type {Function}\n   * @see {@link module:time.createTimeRanges|createTimeRanges}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.\n   */\n  videojs.createTimeRanges = deprecateForMajor(9, 'videojs.createTimeRanges', 'videojs.time.createTimeRanges', createTimeRanges$1);\n\n  /**\n   * Deprecated reference to the {@link module:time.formatTime|formatTime function}\n   *\n   * @type {Function}\n   * @see {@link module:time.formatTime|formatTime}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.format instead.\n   */\n  videojs.formatTime = deprecateForMajor(9, 'videojs.formatTime', 'videojs.time.formatTime', formatTime);\n\n  /**\n   * Deprecated reference to the {@link module:time.setFormatTime|setFormatTime function}\n   *\n   * @type {Function}\n   * @see {@link module:time.setFormatTime|setFormatTime}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.setFormat instead.\n   */\n  videojs.setFormatTime = deprecateForMajor(9, 'videojs.setFormatTime', 'videojs.time.setFormatTime', setFormatTime);\n\n  /**\n   * Deprecated reference to the {@link module:time.resetFormatTime|resetFormatTime function}\n   *\n   * @type {Function}\n   * @see {@link module:time.resetFormatTime|resetFormatTime}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.resetFormat instead.\n   */\n  videojs.resetFormatTime = deprecateForMajor(9, 'videojs.resetFormatTime', 'videojs.time.resetFormatTime', resetFormatTime);\n\n  /**\n   * Deprecated reference to the {@link module:url.parseUrl|Url.parseUrl function}\n   *\n   * @type {Function}\n   * @see {@link module:url.parseUrl|parseUrl}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.parseUrl instead.\n   */\n  videojs.parseUrl = deprecateForMajor(9, 'videojs.parseUrl', 'videojs.url.parseUrl', parseUrl);\n\n  /**\n   * Deprecated reference to the {@link module:url.isCrossOrigin|Url.isCrossOrigin function}\n   *\n   * @type {Function}\n   * @see {@link module:url.isCrossOrigin|isCrossOrigin}\n   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.isCrossOrigin instead.\n   */\n  videojs.isCrossOrigin = deprecateForMajor(9, 'videojs.isCrossOrigin', 'videojs.url.isCrossOrigin', isCrossOrigin);\n  videojs.EventTarget = EventTarget$2;\n  videojs.any = any;\n  videojs.on = on;\n  videojs.one = one;\n  videojs.off = off;\n  videojs.trigger = trigger;\n\n  /**\n   * A cross-browser XMLHttpRequest wrapper.\n   *\n   * @function\n   * @param    {Object} options\n   *           Settings for the request.\n   *\n   * @return   {XMLHttpRequest|XDomainRequest}\n   *           The request object.\n   *\n   * @see      https://github.com/Raynos/xhr\n   */\n  videojs.xhr = lib;\n  videojs.TextTrack = TextTrack;\n  videojs.AudioTrack = AudioTrack;\n  videojs.VideoTrack = VideoTrack;\n  ['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(k => {\n    videojs[k] = function () {\n      log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);\n      return Dom[k].apply(null, arguments);\n    };\n  });\n  videojs.computedStyle = deprecateForMajor(9, 'videojs.computedStyle', 'videojs.dom.computedStyle', computedStyle);\n\n  /**\n   * A reference to the {@link module:dom|DOM utility module} as an object.\n   *\n   * @type {Object}\n   * @see {@link module:dom|dom}\n   */\n  videojs.dom = Dom;\n\n  /**\n   * A reference to the {@link module:fn|fn utility module} as an object.\n   *\n   * @type {Object}\n   * @see {@link module:fn|fn}\n   */\n  videojs.fn = Fn;\n\n  /**\n   * A reference to the {@link module:num|num utility module} as an object.\n   *\n   * @type {Object}\n   * @see {@link module:num|num}\n   */\n  videojs.num = Num;\n\n  /**\n   * A reference to the {@link module:str|str utility module} as an object.\n   *\n   * @type {Object}\n   * @see {@link module:str|str}\n   */\n  videojs.str = Str;\n\n  /**\n   * A reference to the {@link module:url|URL utility module} as an object.\n   *\n   * @type {Object}\n   * @see {@link module:url|url}\n   */\n  videojs.url = Url;\n\n  createCommonjsModule(function (module, exports) {\n    /*! @name videojs-contrib-quality-levels @version 3.0.0 @license Apache-2.0 */\n    (function (global, factory) {\n      module.exports = factory(videojs) ;\n    })(commonjsGlobal, function (videojs) {\n\n      function _interopDefaultLegacy(e) {\n        return e && typeof e === 'object' && 'default' in e ? e : {\n          'default': e\n        };\n      }\n      var videojs__default = /*#__PURE__*/_interopDefaultLegacy(videojs);\n\n      /**\n       * A single QualityLevel.\n       *\n       * interface QualityLevel {\n       *   readonly attribute DOMString id;\n       *            attribute DOMString label;\n       *   readonly attribute long width;\n       *   readonly attribute long height;\n       *   readonly attribute long bitrate;\n       *            attribute boolean enabled;\n       * };\n       *\n       * @class QualityLevel\n       */\n      class QualityLevel {\n        /**\n         * Creates a QualityLevel\n         *\n         * @param {Representation|Object} representation The representation of the quality level\n         * @param {string}   representation.id        Unique id of the QualityLevel\n         * @param {number=}  representation.width     Resolution width of the QualityLevel\n         * @param {number=}  representation.height    Resolution height of the QualityLevel\n         * @param {number}   representation.bandwidth Bitrate of the QualityLevel\n         * @param {number=}  representation.frameRate Frame-rate of the QualityLevel\n         * @param {Function} representation.enabled   Callback to enable/disable QualityLevel\n         */\n        constructor(representation) {\n          let level = this; // eslint-disable-line\n\n          level.id = representation.id;\n          level.label = level.id;\n          level.width = representation.width;\n          level.height = representation.height;\n          level.bitrate = representation.bandwidth;\n          level.frameRate = representation.frameRate;\n          level.enabled_ = representation.enabled;\n          Object.defineProperty(level, 'enabled', {\n            /**\n             * Get whether the QualityLevel is enabled.\n             *\n             * @return {boolean} True if the QualityLevel is enabled.\n             */\n            get() {\n              return level.enabled_();\n            },\n            /**\n             * Enable or disable the QualityLevel.\n             *\n             * @param {boolean} enable true to enable QualityLevel, false to disable.\n             */\n            set(enable) {\n              level.enabled_(enable);\n            }\n          });\n          return level;\n        }\n      }\n\n      /**\n       * A list of QualityLevels.\n       *\n       * interface QualityLevelList : EventTarget {\n       *   getter QualityLevel (unsigned long index);\n       *   readonly attribute unsigned long length;\n       *   readonly attribute long selectedIndex;\n       *\n       *   void addQualityLevel(QualityLevel qualityLevel)\n       *   void removeQualityLevel(QualityLevel remove)\n       *   QualityLevel? getQualityLevelById(DOMString id);\n       *\n       *   attribute EventHandler onchange;\n       *   attribute EventHandler onaddqualitylevel;\n       *   attribute EventHandler onremovequalitylevel;\n       * };\n       *\n       * @extends videojs.EventTarget\n       * @class QualityLevelList\n       */\n\n      class QualityLevelList extends videojs__default['default'].EventTarget {\n        constructor() {\n          super();\n          let list = this; // eslint-disable-line\n\n          list.levels_ = [];\n          list.selectedIndex_ = -1;\n          /**\n           * Get the index of the currently selected QualityLevel.\n           *\n           * @returns {number} The index of the selected QualityLevel. -1 if none selected.\n           * @readonly\n           */\n\n          Object.defineProperty(list, 'selectedIndex', {\n            get() {\n              return list.selectedIndex_;\n            }\n          });\n          /**\n           * Get the length of the list of QualityLevels.\n           *\n           * @returns {number} The length of the list.\n           * @readonly\n           */\n\n          Object.defineProperty(list, 'length', {\n            get() {\n              return list.levels_.length;\n            }\n          });\n          return list;\n        }\n        /**\n         * Adds a quality level to the list.\n         *\n         * @param {Representation|Object} representation The representation of the quality level\n         * @param {string}   representation.id        Unique id of the QualityLevel\n         * @param {number=}  representation.width     Resolution width of the QualityLevel\n         * @param {number=}  representation.height    Resolution height of the QualityLevel\n         * @param {number}   representation.bandwidth Bitrate of the QualityLevel\n         * @param {number=}  representation.frameRate Frame-rate of the QualityLevel\n         * @param {Function} representation.enabled   Callback to enable/disable QualityLevel\n         * @return {QualityLevel} the QualityLevel added to the list\n         * @method addQualityLevel\n         */\n\n        addQualityLevel(representation) {\n          let qualityLevel = this.getQualityLevelById(representation.id); // Do not add duplicate quality levels\n\n          if (qualityLevel) {\n            return qualityLevel;\n          }\n          const index = this.levels_.length;\n          qualityLevel = new QualityLevel(representation);\n          if (!('' + index in this)) {\n            Object.defineProperty(this, index, {\n              get() {\n                return this.levels_[index];\n              }\n            });\n          }\n          this.levels_.push(qualityLevel);\n          this.trigger({\n            qualityLevel,\n            type: 'addqualitylevel'\n          });\n          return qualityLevel;\n        }\n        /**\n         * Removes a quality level from the list.\n         *\n         * @param {QualityLevel} remove QualityLevel to remove to the list.\n         * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed\n         * @method removeQualityLevel\n         */\n\n        removeQualityLevel(qualityLevel) {\n          let removed = null;\n          for (let i = 0, l = this.length; i < l; i++) {\n            if (this[i] === qualityLevel) {\n              removed = this.levels_.splice(i, 1)[0];\n              if (this.selectedIndex_ === i) {\n                this.selectedIndex_ = -1;\n              } else if (this.selectedIndex_ > i) {\n                this.selectedIndex_--;\n              }\n              break;\n            }\n          }\n          if (removed) {\n            this.trigger({\n              qualityLevel,\n              type: 'removequalitylevel'\n            });\n          }\n          return removed;\n        }\n        /**\n         * Searches for a QualityLevel with the given id.\n         *\n         * @param {string} id The id of the QualityLevel to find.\n         * @return {QualityLevel|null} The QualityLevel with id, or null if not found.\n         * @method getQualityLevelById\n         */\n\n        getQualityLevelById(id) {\n          for (let i = 0, l = this.length; i < l; i++) {\n            const level = this[i];\n            if (level.id === id) {\n              return level;\n            }\n          }\n          return null;\n        }\n        /**\n         * Resets the list of QualityLevels to empty\n         *\n         * @method dispose\n         */\n\n        dispose() {\n          this.selectedIndex_ = -1;\n          this.levels_.length = 0;\n        }\n      }\n      /**\n       * change - The selected QualityLevel has changed.\n       * addqualitylevel - A QualityLevel has been added to the QualityLevelList.\n       * removequalitylevel - A QualityLevel has been removed from the QualityLevelList.\n       */\n\n      QualityLevelList.prototype.allowedEvents_ = {\n        change: 'change',\n        addqualitylevel: 'addqualitylevel',\n        removequalitylevel: 'removequalitylevel'\n      }; // emulate attribute EventHandler support to allow for feature detection\n\n      for (const event in QualityLevelList.prototype.allowedEvents_) {\n        QualityLevelList.prototype['on' + event] = null;\n      }\n      var version = \"3.0.0\";\n      const registerPlugin = videojs__default['default'].registerPlugin || videojs__default['default'].plugin;\n      /**\n       * Initialization function for the qualityLevels plugin. Sets up the QualityLevelList and\n       * event handlers.\n       *\n       * @param {Player} player Player object.\n       * @param {Object} options Plugin options object.\n       * @function initPlugin\n       */\n\n      const initPlugin = function (player, options) {\n        const originalPluginFn = player.qualityLevels;\n        const qualityLevelList = new QualityLevelList();\n        const disposeHandler = function () {\n          qualityLevelList.dispose();\n          player.qualityLevels = originalPluginFn;\n          player.off('dispose', disposeHandler);\n        };\n        player.on('dispose', disposeHandler);\n        player.qualityLevels = () => qualityLevelList;\n        player.qualityLevels.VERSION = version;\n        return qualityLevelList;\n      };\n      /**\n       * A video.js plugin.\n       *\n       * In the plugin function, the value of `this` is a video.js `Player`\n       * instance. You cannot rely on the player being in a \"ready\" state here,\n       * depending on how the plugin is invoked. This may or may not be important\n       * to you; if not, remove the wait for \"ready\"!\n       *\n       * @param {Object} options Plugin options object\n       * @function qualityLevels\n       */\n\n      const qualityLevels = function (options) {\n        return initPlugin(this, videojs__default['default'].mergeOptions({}, options));\n      }; // Register the plugin with video.js.\n\n      registerPlugin('qualityLevels', qualityLevels); // Include the version number.\n\n      qualityLevels.VERSION = version;\n      return qualityLevels;\n    });\n  });\n\n  var urlToolkit = createCommonjsModule(function (module, exports) {\n    // see https://tools.ietf.org/html/rfc1808\n\n    (function (root) {\n      var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n      var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n      var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n      var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n      var URLToolkit = {\n        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n        // E.g\n        // With opts.alwaysNormalize = false (default, spec compliant)\n        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n        // With opts.alwaysNormalize = true (not spec compliant)\n        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n        buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n          opts = opts || {};\n          // remove any remaining space and CRLF\n          baseURL = baseURL.trim();\n          relativeURL = relativeURL.trim();\n          if (!relativeURL) {\n            // 2a) If the embedded URL is entirely empty, it inherits the\n            // entire base URL (i.e., is set equal to the base URL)\n            // and we are done.\n            if (!opts.alwaysNormalize) {\n              return baseURL;\n            }\n            var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n            if (!basePartsForNormalise) {\n              throw new Error('Error trying to parse base URL.');\n            }\n            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n            return URLToolkit.buildURLFromParts(basePartsForNormalise);\n          }\n          var relativeParts = URLToolkit.parseURL(relativeURL);\n          if (!relativeParts) {\n            throw new Error('Error trying to parse relative URL.');\n          }\n          if (relativeParts.scheme) {\n            // 2b) If the embedded URL starts with a scheme name, it is\n            // interpreted as an absolute URL and we are done.\n            if (!opts.alwaysNormalize) {\n              return relativeURL;\n            }\n            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n            return URLToolkit.buildURLFromParts(relativeParts);\n          }\n          var baseParts = URLToolkit.parseURL(baseURL);\n          if (!baseParts) {\n            throw new Error('Error trying to parse base URL.');\n          }\n          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n            // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n            // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n            baseParts.netLoc = pathParts[1];\n            baseParts.path = pathParts[2];\n          }\n          if (baseParts.netLoc && !baseParts.path) {\n            baseParts.path = '/';\n          }\n          var builtParts = {\n            // 2c) Otherwise, the embedded URL inherits the scheme of\n            // the base URL.\n            scheme: baseParts.scheme,\n            netLoc: relativeParts.netLoc,\n            path: null,\n            params: relativeParts.params,\n            query: relativeParts.query,\n            fragment: relativeParts.fragment\n          };\n          if (!relativeParts.netLoc) {\n            // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n            // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n            // (if any) of the base URL.\n            builtParts.netLoc = baseParts.netLoc;\n            // 4) If the embedded URL path is preceded by a slash \"/\", the\n            // path is not relative and we skip to Step 7.\n            if (relativeParts.path[0] !== '/') {\n              if (!relativeParts.path) {\n                // 5) If the embedded URL path is empty (and not preceded by a\n                // slash), then the embedded URL inherits the base URL path\n                builtParts.path = baseParts.path;\n                // 5a) if the embedded URL's <params> is non-empty, we skip to\n                // step 7; otherwise, it inherits the <params> of the base\n                // URL (if any) and\n                if (!relativeParts.params) {\n                  builtParts.params = baseParts.params;\n                  // 5b) if the embedded URL's <query> is non-empty, we skip to\n                  // step 7; otherwise, it inherits the <query> of the base\n                  // URL (if any) and we skip to step 7.\n                  if (!relativeParts.query) {\n                    builtParts.query = baseParts.query;\n                  }\n                }\n              } else {\n                // 6) The last segment of the base URL's path (anything\n                // following the rightmost slash \"/\", or the entire path if no\n                // slash is present) is removed and the embedded URL's path is\n                // appended in its place.\n                var baseURLPath = baseParts.path;\n                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n                builtParts.path = URLToolkit.normalizePath(newPath);\n              }\n            }\n          }\n          if (builtParts.path === null) {\n            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n          }\n          return URLToolkit.buildURLFromParts(builtParts);\n        },\n        parseURL: function (url) {\n          var parts = URL_REGEX.exec(url);\n          if (!parts) {\n            return null;\n          }\n          return {\n            scheme: parts[1] || '',\n            netLoc: parts[2] || '',\n            path: parts[3] || '',\n            params: parts[4] || '',\n            query: parts[5] || '',\n            fragment: parts[6] || ''\n          };\n        },\n        normalizePath: function (path) {\n          // The following operations are\n          // then applied, in order, to the new path:\n          // 6a) All occurrences of \"./\", where \".\" is a complete path\n          // segment, are removed.\n          // 6b) If the path ends with \".\" as a complete path segment,\n          // that \".\" is removed.\n          path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n          // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n          // complete path segment not equal to \"..\", are removed.\n          // Removal of these path segments is performed iteratively,\n          // removing the leftmost matching pattern on each iteration,\n          // until no matching pattern remains.\n          // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n          // complete path segment not equal to \"..\", that\n          // \"<segment>/..\" is removed.\n          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\n          return path.split('').reverse().join('');\n        },\n        buildURLFromParts: function (parts) {\n          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n        }\n      };\n      module.exports = URLToolkit;\n    })();\n  });\n\n  var DEFAULT_LOCATION$1 = 'http://example.com';\n  var resolveUrl$2 = function resolveUrl(baseUrl, relativeUrl) {\n    // return early if we don't need to resolve\n    if (/^[a-z]+:/i.test(relativeUrl)) {\n      return relativeUrl;\n    } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n    if (/^data:/.test(baseUrl)) {\n      baseUrl = window.location && window.location.href || '';\n    } // IE11 supports URL but not the URL constructor\n    // feature detect the behavior we want\n\n    var nativeURL = typeof window.URL === 'function';\n    var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n    // and if baseUrl isn't an absolute url\n\n    var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n    if (nativeURL) {\n      baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION$1);\n    } else if (!/\\/\\//i.test(baseUrl)) {\n      baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\n    }\n    if (nativeURL) {\n      var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n      // and if we're location-less, remove the location\n      // otherwise, return the url unmodified\n\n      if (removeLocation) {\n        return newUrl.href.slice(DEFAULT_LOCATION$1.length);\n      } else if (protocolLess) {\n        return newUrl.href.slice(newUrl.protocol.length);\n      }\n      return newUrl.href;\n    }\n    return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n  };\n\n  /**\n   * @file stream.js\n   */\n\n  /**\n   * A lightweight readable stream implemention that handles event dispatching.\n   *\n   * @class Stream\n   */\n  var Stream = /*#__PURE__*/function () {\n    function Stream() {\n      this.listeners = {};\n    }\n    /**\n     * Add a listener for a specified event type.\n     *\n     * @param {string} type the event name\n     * @param {Function} listener the callback to be invoked when an event of\n     * the specified type occurs\n     */\n\n    var _proto = Stream.prototype;\n    _proto.on = function on(type, listener) {\n      if (!this.listeners[type]) {\n        this.listeners[type] = [];\n      }\n      this.listeners[type].push(listener);\n    }\n    /**\n     * Remove a listener for a specified event type.\n     *\n     * @param {string} type the event name\n     * @param {Function} listener  a function previously registered for this\n     * type of event through `on`\n     * @return {boolean} if we could turn it off or not\n     */;\n\n    _proto.off = function off(type, listener) {\n      if (!this.listeners[type]) {\n        return false;\n      }\n      var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n      // In Video.js we slice listener functions\n      // on trigger so that it does not mess up the order\n      // while we loop through.\n      //\n      // Here we slice on off so that the loop in trigger\n      // can continue using it's old reference to loop without\n      // messing up the order.\n\n      this.listeners[type] = this.listeners[type].slice(0);\n      this.listeners[type].splice(index, 1);\n      return index > -1;\n    }\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     *\n     * @param {string} type the event name\n     */;\n\n    _proto.trigger = function trigger(type) {\n      var callbacks = this.listeners[type];\n      if (!callbacks) {\n        return;\n      } // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n\n      if (arguments.length === 2) {\n        var length = callbacks.length;\n        for (var i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        var args = Array.prototype.slice.call(arguments, 1);\n        var _length = callbacks.length;\n        for (var _i = 0; _i < _length; ++_i) {\n          callbacks[_i].apply(this, args);\n        }\n      }\n    }\n    /**\n     * Destroys the stream and cleans up.\n     */;\n\n    _proto.dispose = function dispose() {\n      this.listeners = {};\n    }\n    /**\n     * Forwards all `data` events on this stream to the destination stream. The\n     * destination stream should provide a method `push` to receive the data\n     * events as they arrive.\n     *\n     * @param {Stream} destination the stream that will receive all `data` events\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n     */;\n\n    _proto.pipe = function pipe(destination) {\n      this.on('data', function (data) {\n        destination.push(data);\n      });\n    };\n    return Stream;\n  }();\n\n  var atob$1 = function atob(s) {\n    return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n  };\n  function decodeB64ToUint8Array$1(b64Text) {\n    var decodedString = atob$1(b64Text);\n    var array = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n      array[i] = decodedString.charCodeAt(i);\n    }\n    return array;\n  }\n\n  /*! @name m3u8-parser @version 6.0.0 @license Apache-2.0 */\n\n  /**\n   * @file m3u8/line-stream.js\n   */\n  /**\n   * A stream that buffers string input and generates a `data` event for each\n   * line.\n   *\n   * @class LineStream\n   * @extends Stream\n   */\n\n  class LineStream extends Stream {\n    constructor() {\n      super();\n      this.buffer = '';\n    }\n    /**\n     * Add new data to be parsed.\n     *\n     * @param {string} data the text to process\n     */\n\n    push(data) {\n      let nextNewline;\n      this.buffer += data;\n      nextNewline = this.buffer.indexOf('\\n');\n      for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n        this.trigger('data', this.buffer.substring(0, nextNewline));\n        this.buffer = this.buffer.substring(nextNewline + 1);\n      }\n    }\n  }\n  const TAB = String.fromCharCode(0x09);\n  const parseByterange = function (byterangeString) {\n    // optionally match and capture 0+ digits before `@`\n    // optionally match and capture 0+ digits after `@`\n    const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n    const result = {};\n    if (match[1]) {\n      result.length = parseInt(match[1], 10);\n    }\n    if (match[2]) {\n      result.offset = parseInt(match[2], 10);\n    }\n    return result;\n  };\n  /**\n   * \"forgiving\" attribute list psuedo-grammar:\n   * attributes -> keyvalue (',' keyvalue)*\n   * keyvalue   -> key '=' value\n   * key        -> [^=]*\n   * value      -> '\"' [^\"]* '\"' | [^,]*\n   */\n\n  const attributeSeparator = function () {\n    const key = '[^=]*';\n    const value = '\"[^\"]*\"|[^,]*';\n    const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n    return new RegExp('(?:^|,)(' + keyvalue + ')');\n  };\n  /**\n   * Parse attributes from a line given the separator\n   *\n   * @param {string} attributes the attribute line to parse\n   */\n\n  const parseAttributes$1 = function (attributes) {\n    const result = {};\n    if (!attributes) {\n      return result;\n    } // split the string using attributes as the separator\n\n    const attrs = attributes.split(attributeSeparator());\n    let i = attrs.length;\n    let attr;\n    while (i--) {\n      // filter out unmatched portions of the string\n      if (attrs[i] === '') {\n        continue;\n      } // split the key and value\n\n      attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n      attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n      attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n      attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n      result[attr[0]] = attr[1];\n    }\n    return result;\n  };\n  /**\n   * A line-level M3U8 parser event stream. It expects to receive input one\n   * line at a time and performs a context-free parse of its contents. A stream\n   * interpretation of a manifest can be useful if the manifest is expected to\n   * be too large to fit comfortably into memory or the entirety of the input\n   * is not immediately available. Otherwise, it's probably much easier to work\n   * with a regular `Parser` object.\n   *\n   * Produces `data` events with an object that captures the parser's\n   * interpretation of the input. That object has a property `tag` that is one\n   * of `uri`, `comment`, or `tag`. URIs only have a single additional\n   * property, `line`, which captures the entirety of the input without\n   * interpretation. Comments similarly have a single additional property\n   * `text` which is the input without the leading `#`.\n   *\n   * Tags always have a property `tagType` which is the lower-cased version of\n   * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n   * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n   * tags are given the tag type `unknown` and a single additional property\n   * `data` with the remainder of the input.\n   *\n   * @class ParseStream\n   * @extends Stream\n   */\n\n  class ParseStream extends Stream {\n    constructor() {\n      super();\n      this.customParsers = [];\n      this.tagMappers = [];\n    }\n    /**\n     * Parses an additional line of input.\n     *\n     * @param {string} line a single line of an M3U8 file to parse\n     */\n\n    push(line) {\n      let match;\n      let event; // strip whitespace\n\n      line = line.trim();\n      if (line.length === 0) {\n        // ignore empty lines\n        return;\n      } // URIs\n\n      if (line[0] !== '#') {\n        this.trigger('data', {\n          type: 'uri',\n          uri: line\n        });\n        return;\n      } // map tags\n\n      const newLines = this.tagMappers.reduce((acc, mapper) => {\n        const mappedLine = mapper(line); // skip if unchanged\n\n        if (mappedLine === line) {\n          return acc;\n        }\n        return acc.concat([mappedLine]);\n      }, [line]);\n      newLines.forEach(newLine => {\n        for (let i = 0; i < this.customParsers.length; i++) {\n          if (this.customParsers[i].call(this, newLine)) {\n            return;\n          }\n        } // Comments\n\n        if (newLine.indexOf('#EXT') !== 0) {\n          this.trigger('data', {\n            type: 'comment',\n            text: newLine.slice(1)\n          });\n          return;\n        } // strip off any carriage returns here so the regex matching\n        // doesn't have to account for them.\n\n        newLine = newLine.replace('\\r', ''); // Tags\n\n        match = /^#EXTM3U/.exec(newLine);\n        if (match) {\n          this.trigger('data', {\n            type: 'tag',\n            tagType: 'm3u'\n          });\n          return;\n        }\n        match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'inf'\n          };\n          if (match[1]) {\n            event.duration = parseFloat(match[1]);\n          }\n          if (match[2]) {\n            event.title = match[2];\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'targetduration'\n          };\n          if (match[1]) {\n            event.duration = parseInt(match[1], 10);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'version'\n          };\n          if (match[1]) {\n            event.version = parseInt(match[1], 10);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'media-sequence'\n          };\n          if (match[1]) {\n            event.number = parseInt(match[1], 10);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'discontinuity-sequence'\n          };\n          if (match[1]) {\n            event.number = parseInt(match[1], 10);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'playlist-type'\n          };\n          if (match[1]) {\n            event.playlistType = match[1];\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n        if (match) {\n          event = _extends$1(parseByterange(match[1]), {\n            type: 'tag',\n            tagType: 'byterange'\n          });\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'allow-cache'\n          };\n          if (match[1]) {\n            event.allowed = !/NO/.test(match[1]);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'map'\n          };\n          if (match[1]) {\n            const attributes = parseAttributes$1(match[1]);\n            if (attributes.URI) {\n              event.uri = attributes.URI;\n            }\n            if (attributes.BYTERANGE) {\n              event.byterange = parseByterange(attributes.BYTERANGE);\n            }\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'stream-inf'\n          };\n          if (match[1]) {\n            event.attributes = parseAttributes$1(match[1]);\n            if (event.attributes.RESOLUTION) {\n              const split = event.attributes.RESOLUTION.split('x');\n              const resolution = {};\n              if (split[0]) {\n                resolution.width = parseInt(split[0], 10);\n              }\n              if (split[1]) {\n                resolution.height = parseInt(split[1], 10);\n              }\n              event.attributes.RESOLUTION = resolution;\n            }\n            if (event.attributes.BANDWIDTH) {\n              event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n            }\n            if (event.attributes['FRAME-RATE']) {\n              event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n            }\n            if (event.attributes['PROGRAM-ID']) {\n              event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n            }\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'media'\n          };\n          if (match[1]) {\n            event.attributes = parseAttributes$1(match[1]);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-ENDLIST/.exec(newLine);\n        if (match) {\n          this.trigger('data', {\n            type: 'tag',\n            tagType: 'endlist'\n          });\n          return;\n        }\n        match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n        if (match) {\n          this.trigger('data', {\n            type: 'tag',\n            tagType: 'discontinuity'\n          });\n          return;\n        }\n        match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'program-date-time'\n          };\n          if (match[1]) {\n            event.dateTimeString = match[1];\n            event.dateTimeObject = new Date(match[1]);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'key'\n          };\n          if (match[1]) {\n            event.attributes = parseAttributes$1(match[1]); // parse the IV string into a Uint32Array\n\n            if (event.attributes.IV) {\n              if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n                event.attributes.IV = event.attributes.IV.substring(2);\n              }\n              event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n              event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n              event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n              event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n              event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n              event.attributes.IV = new Uint32Array(event.attributes.IV);\n            }\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-START:(.*)$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'start'\n          };\n          if (match[1]) {\n            event.attributes = parseAttributes$1(match[1]);\n            event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n            event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'cue-out-cont'\n          };\n          if (match[1]) {\n            event.data = match[1];\n          } else {\n            event.data = '';\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'cue-out'\n          };\n          if (match[1]) {\n            event.data = match[1];\n          } else {\n            event.data = '';\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n        if (match) {\n          event = {\n            type: 'tag',\n            tagType: 'cue-in'\n          };\n          if (match[1]) {\n            event.data = match[1];\n          } else {\n            event.data = '';\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n        if (match && match[1]) {\n          event = {\n            type: 'tag',\n            tagType: 'skip'\n          };\n          event.attributes = parseAttributes$1(match[1]);\n          if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n            event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n          }\n          if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n            event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n        if (match && match[1]) {\n          event = {\n            type: 'tag',\n            tagType: 'part'\n          };\n          event.attributes = parseAttributes$1(match[1]);\n          ['DURATION'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = parseFloat(event.attributes[key]);\n            }\n          });\n          ['INDEPENDENT', 'GAP'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = /YES/.test(event.attributes[key]);\n            }\n          });\n          if (event.attributes.hasOwnProperty('BYTERANGE')) {\n            event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n          }\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n        if (match && match[1]) {\n          event = {\n            type: 'tag',\n            tagType: 'server-control'\n          };\n          event.attributes = parseAttributes$1(match[1]);\n          ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = parseFloat(event.attributes[key]);\n            }\n          });\n          ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = /YES/.test(event.attributes[key]);\n            }\n          });\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n        if (match && match[1]) {\n          event = {\n            type: 'tag',\n            tagType: 'part-inf'\n          };\n          event.attributes = parseAttributes$1(match[1]);\n          ['PART-TARGET'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = parseFloat(event.attributes[key]);\n            }\n          });\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n        if (match && match[1]) {\n          event = {\n            type: 'tag',\n            tagType: 'preload-hint'\n          };\n          event.attributes = parseAttributes$1(match[1]);\n          ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = parseInt(event.attributes[key], 10);\n              const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n              event.attributes.byterange = event.attributes.byterange || {};\n              event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n              delete event.attributes[key];\n            }\n          });\n          this.trigger('data', event);\n          return;\n        }\n        match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n        if (match && match[1]) {\n          event = {\n            type: 'tag',\n            tagType: 'rendition-report'\n          };\n          event.attributes = parseAttributes$1(match[1]);\n          ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n            if (event.attributes.hasOwnProperty(key)) {\n              event.attributes[key] = parseInt(event.attributes[key], 10);\n            }\n          });\n          this.trigger('data', event);\n          return;\n        } // unknown tag type\n\n        this.trigger('data', {\n          type: 'tag',\n          data: newLine.slice(4)\n        });\n      });\n    }\n    /**\n     * Add a parser for custom headers\n     *\n     * @param {Object}   options              a map of options for the added parser\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\n     * @param {string}   options.customType   the custom type to register to the output\n     * @param {Function} [options.dataParser] function to parse the line into an object\n     * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n     */\n\n    addParser({\n      expression,\n      customType,\n      dataParser,\n      segment\n    }) {\n      if (typeof dataParser !== 'function') {\n        dataParser = line => line;\n      }\n      this.customParsers.push(line => {\n        const match = expression.exec(line);\n        if (match) {\n          this.trigger('data', {\n            type: 'custom',\n            data: dataParser(line),\n            customType,\n            segment\n          });\n          return true;\n        }\n      });\n    }\n    /**\n     * Add a custom header mapper\n     *\n     * @param {Object}   options\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\n     * @param {Function} options.map          function to translate tag into a different tag\n     */\n\n    addTagMapper({\n      expression,\n      map\n    }) {\n      const mapFn = line => {\n        if (expression.test(line)) {\n          return map(line);\n        }\n        return line;\n      };\n      this.tagMappers.push(mapFn);\n    }\n  }\n  const camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n  const camelCaseKeys = function (attributes) {\n    const result = {};\n    Object.keys(attributes).forEach(function (key) {\n      result[camelCase(key)] = attributes[key];\n    });\n    return result;\n  }; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n  // we need this helper because defaults are based upon targetDuration and\n  // partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n  // target durations are set.\n\n  const setHoldBack = function (manifest) {\n    const {\n      serverControl,\n      targetDuration,\n      partTargetDuration\n    } = manifest;\n    if (!serverControl) {\n      return;\n    }\n    const tag = '#EXT-X-SERVER-CONTROL';\n    const hb = 'holdBack';\n    const phb = 'partHoldBack';\n    const minTargetDuration = targetDuration && targetDuration * 3;\n    const minPartDuration = partTargetDuration && partTargetDuration * 2;\n    if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n      serverControl[hb] = minTargetDuration;\n      this.trigger('info', {\n        message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n      });\n    }\n    if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n      this.trigger('warn', {\n        message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n      });\n      serverControl[hb] = minTargetDuration;\n    } // default no part hold back to part target duration * 3\n\n    if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n      serverControl[phb] = partTargetDuration * 3;\n      this.trigger('info', {\n        message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n      });\n    } // if part hold back is too small default it to part target duration * 2\n\n    if (partTargetDuration && serverControl[phb] < minPartDuration) {\n      this.trigger('warn', {\n        message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n      });\n      serverControl[phb] = minPartDuration;\n    }\n  };\n  /**\n   * A parser for M3U8 files. The current interpretation of the input is\n   * exposed as a property `manifest` on parser objects. It's just two lines to\n   * create and parse a manifest once you have the contents available as a string:\n   *\n   * ```js\n   * var parser = new m3u8.Parser();\n   * parser.push(xhr.responseText);\n   * ```\n   *\n   * New input can later be applied to update the manifest object by calling\n   * `push` again.\n   *\n   * The parser attempts to create a usable manifest object even if the\n   * underlying input is somewhat nonsensical. It emits `info` and `warning`\n   * events during the parse if it encounters input that seems invalid or\n   * requires some property of the manifest object to be defaulted.\n   *\n   * @class Parser\n   * @extends Stream\n   */\n\n  class Parser extends Stream {\n    constructor() {\n      super();\n      this.lineStream = new LineStream();\n      this.parseStream = new ParseStream();\n      this.lineStream.pipe(this.parseStream);\n      /* eslint-disable consistent-this */\n\n      const self = this;\n      /* eslint-enable consistent-this */\n\n      const uris = [];\n      let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n      let currentMap; // if specified, the active decryption key\n\n      let key;\n      let hasParts = false;\n      const noop = function () {};\n      const defaultMediaGroups = {\n        'AUDIO': {},\n        'VIDEO': {},\n        'CLOSED-CAPTIONS': {},\n        'SUBTITLES': {}\n      }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n      // used in MPDs with Widevine encrypted streams.\n\n      const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n      let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n      this.manifest = {\n        allowCache: true,\n        discontinuityStarts: [],\n        segments: []\n      }; // keep track of the last seen segment's byte range end, as segments are not required\n      // to provide the offset, in which case it defaults to the next byte after the\n      // previous segment\n\n      let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n      let lastPartByterangeEnd = 0;\n      this.on('end', () => {\n        // only add preloadSegment if we don't yet have a uri for it.\n        // and we actually have parts/preloadHints\n        if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n          return;\n        }\n        if (!currentUri.map && currentMap) {\n          currentUri.map = currentMap;\n        }\n        if (!currentUri.key && key) {\n          currentUri.key = key;\n        }\n        if (!currentUri.timeline && typeof currentTimeline === 'number') {\n          currentUri.timeline = currentTimeline;\n        }\n        this.manifest.preloadSegment = currentUri;\n      }); // update the manifest with the m3u8 entry from the parse stream\n\n      this.parseStream.on('data', function (entry) {\n        let mediaGroup;\n        let rendition;\n        ({\n          tag() {\n            // switch based on the tag type\n            (({\n              version() {\n                if (entry.version) {\n                  this.manifest.version = entry.version;\n                }\n              },\n              'allow-cache'() {\n                this.manifest.allowCache = entry.allowed;\n                if (!('allowed' in entry)) {\n                  this.trigger('info', {\n                    message: 'defaulting allowCache to YES'\n                  });\n                  this.manifest.allowCache = true;\n                }\n              },\n              byterange() {\n                const byterange = {};\n                if ('length' in entry) {\n                  currentUri.byterange = byterange;\n                  byterange.length = entry.length;\n                  if (!('offset' in entry)) {\n                    /*\n                     * From the latest spec (as of this writing):\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                     *\n                     * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                     *\n                     * \"If o [offset] is not present, the sub-range begins at the next byte\n                     * following the sub-range of the previous media segment.\"\n                     */\n                    entry.offset = lastByterangeEnd;\n                  }\n                }\n                if ('offset' in entry) {\n                  currentUri.byterange = byterange;\n                  byterange.offset = entry.offset;\n                }\n                lastByterangeEnd = byterange.offset + byterange.length;\n              },\n              endlist() {\n                this.manifest.endList = true;\n              },\n              inf() {\n                if (!('mediaSequence' in this.manifest)) {\n                  this.manifest.mediaSequence = 0;\n                  this.trigger('info', {\n                    message: 'defaulting media sequence to zero'\n                  });\n                }\n                if (!('discontinuitySequence' in this.manifest)) {\n                  this.manifest.discontinuitySequence = 0;\n                  this.trigger('info', {\n                    message: 'defaulting discontinuity sequence to zero'\n                  });\n                }\n                if (entry.duration > 0) {\n                  currentUri.duration = entry.duration;\n                }\n                if (entry.duration === 0) {\n                  currentUri.duration = 0.01;\n                  this.trigger('info', {\n                    message: 'updating zero segment duration to a small value'\n                  });\n                }\n                this.manifest.segments = uris;\n              },\n              key() {\n                if (!entry.attributes) {\n                  this.trigger('warn', {\n                    message: 'ignoring key declaration without attribute list'\n                  });\n                  return;\n                } // clear the active encryption key\n\n                if (entry.attributes.METHOD === 'NONE') {\n                  key = null;\n                  return;\n                }\n                if (!entry.attributes.URI) {\n                  this.trigger('warn', {\n                    message: 'ignoring key declaration without URI'\n                  });\n                  return;\n                }\n                if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                  this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                  this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                    attributes: entry.attributes\n                  };\n                  return;\n                }\n                if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                  this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                  this.manifest.contentProtection['com.microsoft.playready'] = {\n                    uri: entry.attributes.URI\n                  };\n                  return;\n                } // check if the content is encrypted for Widevine\n                // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n                if (entry.attributes.KEYFORMAT === widevineUuid) {\n                  const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n                  if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                    this.trigger('warn', {\n                      message: 'invalid key method provided for Widevine'\n                    });\n                    return;\n                  }\n                  if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                    this.trigger('warn', {\n                      message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                    });\n                  }\n                  if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                    this.trigger('warn', {\n                      message: 'invalid key URI provided for Widevine'\n                    });\n                    return;\n                  }\n                  if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                    this.trigger('warn', {\n                      message: 'invalid key ID provided for Widevine'\n                    });\n                    return;\n                  } // if Widevine key attributes are valid, store them as `contentProtection`\n                  // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n                  this.manifest.contentProtection = this.manifest.contentProtection || {};\n                  this.manifest.contentProtection['com.widevine.alpha'] = {\n                    attributes: {\n                      schemeIdUri: entry.attributes.KEYFORMAT,\n                      // remove '0x' from the key id string\n                      keyId: entry.attributes.KEYID.substring(2)\n                    },\n                    // decode the base64-encoded PSSH box\n                    pssh: decodeB64ToUint8Array$1(entry.attributes.URI.split(',')[1])\n                  };\n                  return;\n                }\n                if (!entry.attributes.METHOD) {\n                  this.trigger('warn', {\n                    message: 'defaulting key method to AES-128'\n                  });\n                } // setup an encryption key for upcoming segments\n\n                key = {\n                  method: entry.attributes.METHOD || 'AES-128',\n                  uri: entry.attributes.URI\n                };\n                if (typeof entry.attributes.IV !== 'undefined') {\n                  key.iv = entry.attributes.IV;\n                }\n              },\n              'media-sequence'() {\n                if (!isFinite(entry.number)) {\n                  this.trigger('warn', {\n                    message: 'ignoring invalid media sequence: ' + entry.number\n                  });\n                  return;\n                }\n                this.manifest.mediaSequence = entry.number;\n              },\n              'discontinuity-sequence'() {\n                if (!isFinite(entry.number)) {\n                  this.trigger('warn', {\n                    message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                  });\n                  return;\n                }\n                this.manifest.discontinuitySequence = entry.number;\n                currentTimeline = entry.number;\n              },\n              'playlist-type'() {\n                if (!/VOD|EVENT/.test(entry.playlistType)) {\n                  this.trigger('warn', {\n                    message: 'ignoring unknown playlist type: ' + entry.playlist\n                  });\n                  return;\n                }\n                this.manifest.playlistType = entry.playlistType;\n              },\n              map() {\n                currentMap = {};\n                if (entry.uri) {\n                  currentMap.uri = entry.uri;\n                }\n                if (entry.byterange) {\n                  currentMap.byterange = entry.byterange;\n                }\n                if (key) {\n                  currentMap.key = key;\n                }\n              },\n              'stream-inf'() {\n                this.manifest.playlists = uris;\n                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                if (!entry.attributes) {\n                  this.trigger('warn', {\n                    message: 'ignoring empty stream-inf attributes'\n                  });\n                  return;\n                }\n                if (!currentUri.attributes) {\n                  currentUri.attributes = {};\n                }\n                _extends$1(currentUri.attributes, entry.attributes);\n              },\n              media() {\n                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                  this.trigger('warn', {\n                    message: 'ignoring incomplete or missing media group'\n                  });\n                  return;\n                } // find the media group, creating defaults as necessary\n\n                const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n                mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n                mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n                rendition = {\n                  default: /yes/i.test(entry.attributes.DEFAULT)\n                };\n                if (rendition.default) {\n                  rendition.autoselect = true;\n                } else {\n                  rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n                }\n                if (entry.attributes.LANGUAGE) {\n                  rendition.language = entry.attributes.LANGUAGE;\n                }\n                if (entry.attributes.URI) {\n                  rendition.uri = entry.attributes.URI;\n                }\n                if (entry.attributes['INSTREAM-ID']) {\n                  rendition.instreamId = entry.attributes['INSTREAM-ID'];\n                }\n                if (entry.attributes.CHARACTERISTICS) {\n                  rendition.characteristics = entry.attributes.CHARACTERISTICS;\n                }\n                if (entry.attributes.FORCED) {\n                  rendition.forced = /yes/i.test(entry.attributes.FORCED);\n                } // insert the new rendition\n\n                mediaGroup[entry.attributes.NAME] = rendition;\n              },\n              discontinuity() {\n                currentTimeline += 1;\n                currentUri.discontinuity = true;\n                this.manifest.discontinuityStarts.push(uris.length);\n              },\n              'program-date-time'() {\n                if (typeof this.manifest.dateTimeString === 'undefined') {\n                  // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                  // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                  // to the manifest object\n                  // TODO: Consider removing this in future major version\n                  this.manifest.dateTimeString = entry.dateTimeString;\n                  this.manifest.dateTimeObject = entry.dateTimeObject;\n                }\n                currentUri.dateTimeString = entry.dateTimeString;\n                currentUri.dateTimeObject = entry.dateTimeObject;\n              },\n              targetduration() {\n                if (!isFinite(entry.duration) || entry.duration < 0) {\n                  this.trigger('warn', {\n                    message: 'ignoring invalid target duration: ' + entry.duration\n                  });\n                  return;\n                }\n                this.manifest.targetDuration = entry.duration;\n                setHoldBack.call(this, this.manifest);\n              },\n              start() {\n                if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                  this.trigger('warn', {\n                    message: 'ignoring start declaration without appropriate attribute list'\n                  });\n                  return;\n                }\n                this.manifest.start = {\n                  timeOffset: entry.attributes['TIME-OFFSET'],\n                  precise: entry.attributes.PRECISE\n                };\n              },\n              'cue-out'() {\n                currentUri.cueOut = entry.data;\n              },\n              'cue-out-cont'() {\n                currentUri.cueOutCont = entry.data;\n              },\n              'cue-in'() {\n                currentUri.cueIn = entry.data;\n              },\n              'skip'() {\n                this.manifest.skip = camelCaseKeys(entry.attributes);\n                this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n              },\n              'part'() {\n                hasParts = true; // parts are always specifed before a segment\n\n                const segmentIndex = this.manifest.segments.length;\n                const part = camelCaseKeys(entry.attributes);\n                currentUri.parts = currentUri.parts || [];\n                currentUri.parts.push(part);\n                if (part.byterange) {\n                  if (!part.byterange.hasOwnProperty('offset')) {\n                    part.byterange.offset = lastPartByterangeEnd;\n                  }\n                  lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n                }\n                const partIndex = currentUri.parts.length - 1;\n                this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n                if (this.manifest.renditionReports) {\n                  this.manifest.renditionReports.forEach((r, i) => {\n                    if (!r.hasOwnProperty('lastPart')) {\n                      this.trigger('warn', {\n                        message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                      });\n                    }\n                  });\n                }\n              },\n              'server-control'() {\n                const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n                if (!attrs.hasOwnProperty('canBlockReload')) {\n                  attrs.canBlockReload = false;\n                  this.trigger('info', {\n                    message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                  });\n                }\n                setHoldBack.call(this, this.manifest);\n                if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                  this.trigger('warn', {\n                    message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                  });\n                }\n              },\n              'preload-hint'() {\n                // parts are always specifed before a segment\n                const segmentIndex = this.manifest.segments.length;\n                const hint = camelCaseKeys(entry.attributes);\n                const isPart = hint.type && hint.type === 'PART';\n                currentUri.preloadHints = currentUri.preloadHints || [];\n                currentUri.preloadHints.push(hint);\n                if (hint.byterange) {\n                  if (!hint.byterange.hasOwnProperty('offset')) {\n                    // use last part byterange end or zero if not a part.\n                    hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n                    if (isPart) {\n                      lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                    }\n                  }\n                }\n                const index = currentUri.preloadHints.length - 1;\n                this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n                if (!hint.type) {\n                  return;\n                } // search through all preload hints except for the current one for\n                // a duplicate type.\n\n                for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                  const otherHint = currentUri.preloadHints[i];\n                  if (!otherHint.type) {\n                    continue;\n                  }\n                  if (otherHint.type === hint.type) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                    });\n                  }\n                }\n              },\n              'rendition-report'() {\n                const report = camelCaseKeys(entry.attributes);\n                this.manifest.renditionReports = this.manifest.renditionReports || [];\n                this.manifest.renditionReports.push(report);\n                const index = this.manifest.renditionReports.length - 1;\n                const required = ['LAST-MSN', 'URI'];\n                if (hasParts) {\n                  required.push('LAST-PART');\n                }\n                this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n              },\n              'part-inf'() {\n                this.manifest.partInf = camelCaseKeys(entry.attributes);\n                this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n                if (this.manifest.partInf.partTarget) {\n                  this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n                }\n                setHoldBack.call(this, this.manifest);\n              }\n            })[entry.tagType] || noop).call(self);\n          },\n          uri() {\n            currentUri.uri = entry.uri;\n            uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n            if (this.manifest.targetDuration && !('duration' in currentUri)) {\n              this.trigger('warn', {\n                message: 'defaulting segment duration to the target duration'\n              });\n              currentUri.duration = this.manifest.targetDuration;\n            } // annotate with encryption information, if necessary\n\n            if (key) {\n              currentUri.key = key;\n            }\n            currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n            if (currentMap) {\n              currentUri.map = currentMap;\n            } // reset the last byterange end as it needs to be 0 between parts\n\n            lastPartByterangeEnd = 0; // prepare for the next URI\n\n            currentUri = {};\n          },\n          comment() {// comments are not important for playback\n          },\n          custom() {\n            // if this is segment-level data attach the output to the segment\n            if (entry.segment) {\n              currentUri.custom = currentUri.custom || {};\n              currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n            } else {\n              this.manifest.custom = this.manifest.custom || {};\n              this.manifest.custom[entry.customType] = entry.data;\n            }\n          }\n        })[entry.type].call(self);\n      });\n    }\n    warnOnMissingAttributes_(identifier, attributes, required) {\n      const missing = [];\n      required.forEach(function (key) {\n        if (!attributes.hasOwnProperty(key)) {\n          missing.push(key);\n        }\n      });\n      if (missing.length) {\n        this.trigger('warn', {\n          message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n        });\n      }\n    }\n    /**\n     * Parse the input string and update the manifest object.\n     *\n     * @param {string} chunk a potentially incomplete portion of the manifest\n     */\n\n    push(chunk) {\n      this.lineStream.push(chunk);\n    }\n    /**\n     * Flush any remaining input. This can be handy if the last line of an M3U8\n     * manifest did not contain a trailing newline but the file has been\n     * completely received.\n     */\n\n    end() {\n      // flush any buffered input\n      this.lineStream.push('\\n');\n      this.trigger('end');\n    }\n    /**\n     * Add an additional parser for non-standard tags\n     *\n     * @param {Object}   options              a map of options for the added parser\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\n     * @param {string}   options.type         the type to register to the output\n     * @param {Function} [options.dataParser] function to parse the line into an object\n     * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n     */\n\n    addParser(options) {\n      this.parseStream.addParser(options);\n    }\n    /**\n     * Add a custom header mapper\n     *\n     * @param {Object}   options\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\n     * @param {Function} options.map          function to translate tag into a different tag\n     */\n\n    addTagMapper(options) {\n      this.parseStream.addTagMapper(options);\n    }\n  }\n\n  var regexs = {\n    // to determine mime types\n    mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n    webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n    ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n    // to determine if a codec is audio or video\n    video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n    audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n    text: /^(stpp.ttml.im1t)/,\n    // mux.js support regex\n    muxerVideo: /^(avc0?1)/,\n    muxerAudio: /^(mp4a)/,\n    // match nothing as muxer does not support text right now.\n    // there cannot never be a character before the start of a string\n    // so this matches nothing.\n    muxerText: /a^/\n  };\n  var mediaTypes = ['video', 'audio', 'text'];\n  var upperMediaTypes = ['Video', 'Audio', 'Text'];\n  /**\n   * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n   * `avc1.<hhhhhh>`\n   *\n   * @param {string} codec\n   *        Codec string to translate\n   * @return {string}\n   *         The translated codec string\n   */\n\n  var translateLegacyCodec = function translateLegacyCodec(codec) {\n    if (!codec) {\n      return codec;\n    }\n    return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\n    });\n  };\n  /**\n   * @typedef {Object} ParsedCodecInfo\n   * @property {number} codecCount\n   *           Number of codecs parsed\n   * @property {string} [videoCodec]\n   *           Parsed video codec (if found)\n   * @property {string} [videoObjectTypeIndicator]\n   *           Video object type indicator (if found)\n   * @property {string|null} audioProfile\n   *           Audio profile\n   */\n\n  /**\n   * Parses a codec string to retrieve the number of codecs specified, the video codec and\n   * object type indicator, and the audio profile.\n   *\n   * @param {string} [codecString]\n   *        The codec string to parse\n   * @return {ParsedCodecInfo}\n   *         Parsed codec info\n   */\n\n  var parseCodecs = function parseCodecs(codecString) {\n    if (codecString === void 0) {\n      codecString = '';\n    }\n    var codecs = codecString.split(',');\n    var result = [];\n    codecs.forEach(function (codec) {\n      codec = codec.trim();\n      var codecType;\n      mediaTypes.forEach(function (name) {\n        var match = regexs[name].exec(codec.toLowerCase());\n        if (!match || match.length <= 1) {\n          return;\n        }\n        codecType = name; // maintain codec case\n\n        var type = codec.substring(0, match[1].length);\n        var details = codec.replace(type, '');\n        result.push({\n          type: type,\n          details: details,\n          mediaType: name\n        });\n      });\n      if (!codecType) {\n        result.push({\n          type: codec,\n          details: '',\n          mediaType: 'unknown'\n        });\n      }\n    });\n    return result;\n  };\n  /**\n   * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n   * a default alternate audio playlist for the provided audio group.\n   *\n   * @param {Object} master\n   *        The master playlist\n   * @param {string} audioGroupId\n   *        ID of the audio group for which to find the default codec info\n   * @return {ParsedCodecInfo}\n   *         Parsed codec info\n   */\n\n  var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n    if (!master.mediaGroups.AUDIO || !audioGroupId) {\n      return null;\n    }\n    var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n    if (!audioGroup) {\n      return null;\n    }\n    for (var name in audioGroup) {\n      var audioType = audioGroup[name];\n      if (audioType.default && audioType.playlists) {\n        // codec should be the same for all playlists within the audio type\n        return parseCodecs(audioType.playlists[0].attributes.CODECS);\n      }\n    }\n    return null;\n  };\n  var isAudioCodec = function isAudioCodec(codec) {\n    if (codec === void 0) {\n      codec = '';\n    }\n    return regexs.audio.test(codec.trim().toLowerCase());\n  };\n  var isTextCodec = function isTextCodec(codec) {\n    if (codec === void 0) {\n      codec = '';\n    }\n    return regexs.text.test(codec.trim().toLowerCase());\n  };\n  var getMimeForCodec = function getMimeForCodec(codecString) {\n    if (!codecString || typeof codecString !== 'string') {\n      return;\n    }\n    var codecs = codecString.toLowerCase().split(',').map(function (c) {\n      return translateLegacyCodec(c.trim());\n    }); // default to video type\n\n    var type = 'video'; // only change to audio type if the only codec we have is\n    // audio\n\n    if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n      type = 'audio';\n    } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n      // text uses application/<container> for now\n      type = 'application';\n    } // default the container to mp4\n\n    var container = 'mp4'; // every codec must be able to go into the container\n    // for that container to be the correct one\n\n    if (codecs.every(function (c) {\n      return regexs.mp4.test(c);\n    })) {\n      container = 'mp4';\n    } else if (codecs.every(function (c) {\n      return regexs.webm.test(c);\n    })) {\n      container = 'webm';\n    } else if (codecs.every(function (c) {\n      return regexs.ogg.test(c);\n    })) {\n      container = 'ogg';\n    }\n    return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n  };\n  var browserSupportsCodec = function browserSupportsCodec(codecString) {\n    if (codecString === void 0) {\n      codecString = '';\n    }\n    return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n  };\n  var muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n    if (codecString === void 0) {\n      codecString = '';\n    }\n    return codecString.toLowerCase().split(',').every(function (codec) {\n      codec = codec.trim(); // any match is supported.\n\n      for (var i = 0; i < upperMediaTypes.length; i++) {\n        var type = upperMediaTypes[i];\n        if (regexs[\"muxer\" + type].test(codec)) {\n          return true;\n        }\n      }\n      return false;\n    });\n  };\n  var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\n  var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\n\n  var MPEGURL_REGEX = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\n  var DASH_REGEX = /^application\\/dash\\+xml/i;\n  /**\n   * Returns a string that describes the type of source based on a video source object's\n   * media type.\n   *\n   * @see {@link https://dev.w3.org/html5/pf-summary/video.html#dom-source-type|Source Type}\n   *\n   * @param {string} type\n   *        Video source object media type\n   * @return {('hls'|'dash'|'vhs-json'|null)}\n   *         VHS source type string\n   */\n\n  var simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\n    if (MPEGURL_REGEX.test(type)) {\n      return 'hls';\n    }\n    if (DASH_REGEX.test(type)) {\n      return 'dash';\n    } // Denotes the special case of a manifest object passed to http-streaming instead of a\n    // source URL.\n    //\n    // See https://en.wikipedia.org/wiki/Media_type for details on specifying media types.\n    //\n    // In this case, vnd stands for vendor, video.js for the organization, VHS for this\n    // project, and the +json suffix identifies the structure of the media type.\n\n    if (type === 'application/vnd.videojs.vhs+json') {\n      return 'vhs-json';\n    }\n    return null;\n  };\n\n  // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\n  // we used to do this with log2 but BigInt does not support builtin math\n  // Math.ceil(log2(x));\n\n  var countBits = function countBits(x) {\n    return x.toString(2).length;\n  }; // count the number of whole bytes it would take to represent a number\n\n  var countBytes = function countBytes(x) {\n    return Math.ceil(countBits(x) / 8);\n  };\n  var isArrayBufferView = function isArrayBufferView(obj) {\n    if (ArrayBuffer.isView === 'function') {\n      return ArrayBuffer.isView(obj);\n    }\n    return obj && obj.buffer instanceof ArrayBuffer;\n  };\n  var isTypedArray = function isTypedArray(obj) {\n    return isArrayBufferView(obj);\n  };\n  var toUint8 = function toUint8(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return bytes;\n    }\n    if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n      // any non-number or NaN leads to empty uint8array\n      // eslint-disable-next-line\n      if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n        bytes = 0;\n      } else {\n        bytes = [bytes];\n      }\n    }\n    return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n  };\n  var BigInt = window.BigInt || Number;\n  var BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n  (function () {\n    var a = new Uint16Array([0xFFCC]);\n    var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    if (b[0] === 0xFF) {\n      return 'big';\n    }\n    if (b[0] === 0xCC) {\n      return 'little';\n    }\n    return 'unknown';\n  })();\n  var bytesToNumber = function bytesToNumber(bytes, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$signed = _ref.signed,\n      signed = _ref$signed === void 0 ? false : _ref$signed,\n      _ref$le = _ref.le,\n      le = _ref$le === void 0 ? false : _ref$le;\n    bytes = toUint8(bytes);\n    var fn = le ? 'reduce' : 'reduceRight';\n    var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n    var number = obj.call(bytes, function (total, byte, i) {\n      var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n      return total + BigInt(byte) * BYTE_TABLE[exponent];\n    }, BigInt(0));\n    if (signed) {\n      var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n      number = BigInt(number);\n      if (number > max) {\n        number -= max;\n        number -= max;\n        number -= BigInt(2);\n      }\n    }\n    return Number(number);\n  };\n  var numberToBytes = function numberToBytes(number, _temp2) {\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\n      _ref2$le = _ref2.le,\n      le = _ref2$le === void 0 ? false : _ref2$le;\n\n    // eslint-disable-next-line\n    if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n      number = 0;\n    }\n    number = BigInt(number);\n    var byteCount = countBytes(number);\n    var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n    for (var i = 0; i < byteCount; i++) {\n      var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n      bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n      if (number < 0) {\n        bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n        bytes[byteIndex] -= i === 0 ? 1 : 2;\n      }\n    }\n    return bytes;\n  };\n  var stringToBytes = function stringToBytes(string, stringIsBytes) {\n    if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n      string = string.toString();\n    }\n    if (typeof string !== 'string') {\n      return new Uint8Array();\n    } // If the string already is bytes, we don't have to do this\n    // otherwise we do this so that we split multi length characters\n    // into individual bytes\n\n    if (!stringIsBytes) {\n      string = unescape(encodeURIComponent(string));\n    }\n    var view = new Uint8Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      view[i] = string.charCodeAt(i);\n    }\n    return view;\n  };\n  var concatTypedArrays = function concatTypedArrays() {\n    for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n      buffers[_key] = arguments[_key];\n    }\n    buffers = buffers.filter(function (b) {\n      return b && (b.byteLength || b.length) && typeof b !== 'string';\n    });\n    if (buffers.length <= 1) {\n      // for 0 length we will return empty uint8\n      // for 1 length we return the first uint8\n      return toUint8(buffers[0]);\n    }\n    var totalLen = buffers.reduce(function (total, buf, i) {\n      return total + (buf.byteLength || buf.length);\n    }, 0);\n    var tempBuffer = new Uint8Array(totalLen);\n    var offset = 0;\n    buffers.forEach(function (buf) {\n      buf = toUint8(buf);\n      tempBuffer.set(buf, offset);\n      offset += buf.byteLength;\n    });\n    return tempBuffer;\n  };\n  /**\n   * Check if the bytes \"b\" are contained within bytes \"a\".\n   *\n   * @param {Uint8Array|Array} a\n   *        Bytes to check in\n   *\n   * @param {Uint8Array|Array} b\n   *        Bytes to check for\n   *\n   * @param {Object} options\n   *        options\n   *\n   * @param {Array|Uint8Array} [offset=0]\n   *        offset to use when looking at bytes in a\n   *\n   * @param {Array|Uint8Array} [mask=[]]\n   *        mask to use on bytes before comparison.\n   *\n   * @return {boolean}\n   *         If all bytes in b are inside of a, taking into account\n   *         bit masks.\n   */\n\n  var bytesMatch = function bytesMatch(a, b, _temp3) {\n    var _ref3 = _temp3 === void 0 ? {} : _temp3,\n      _ref3$offset = _ref3.offset,\n      offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n      _ref3$mask = _ref3.mask,\n      mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n    a = toUint8(a);\n    b = toUint8(b); // ie 11 does not support uint8 every\n\n    var fn = b.every ? b.every : Array.prototype.every;\n    return b.length && a.length - offset >= b.length &&\n    // ie 11 doesn't support every on uin8\n    fn.call(b, function (bByte, i) {\n      var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n      return bByte === aByte;\n    });\n  };\n\n  var DEFAULT_LOCATION = 'http://example.com';\n  var resolveUrl$1 = function resolveUrl(baseUrl, relativeUrl) {\n    // return early if we don't need to resolve\n    if (/^[a-z]+:/i.test(relativeUrl)) {\n      return relativeUrl;\n    } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n    if (/^data:/.test(baseUrl)) {\n      baseUrl = window.location && window.location.href || '';\n    } // IE11 supports URL but not the URL constructor\n    // feature detect the behavior we want\n\n    var nativeURL = typeof window.URL === 'function';\n    var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n    // and if baseUrl isn't an absolute url\n\n    var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n    if (nativeURL) {\n      baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION);\n    } else if (!/\\/\\//i.test(baseUrl)) {\n      baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\n    }\n    if (nativeURL) {\n      var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n      // and if we're location-less, remove the location\n      // otherwise, return the url unmodified\n\n      if (removeLocation) {\n        return newUrl.href.slice(DEFAULT_LOCATION.length);\n      } else if (protocolLess) {\n        return newUrl.href.slice(newUrl.protocol.length);\n      }\n      return newUrl.href;\n    }\n    return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n  };\n\n  /**\n   * Loops through all supported media groups in master and calls the provided\n   * callback for each group\n   *\n   * @param {Object} master\n   *        The parsed master manifest object\n   * @param {string[]} groups\n   *        The media groups to call the callback for\n   * @param {Function} callback\n   *        Callback to call for each media group\n   */\n  var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback) {\n    groups.forEach(function (mediaType) {\n      for (var groupKey in master.mediaGroups[mediaType]) {\n        for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n          var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n          callback(mediaProperties, mediaType, groupKey, labelKey);\n        }\n      }\n    });\n  };\n\n  var atob = function atob(s) {\n    return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n  };\n  function decodeB64ToUint8Array(b64Text) {\n    var decodedString = atob(b64Text);\n    var array = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n      array[i] = decodedString.charCodeAt(i);\n    }\n    return array;\n  }\n\n  /**\n   * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.\n   *\n   * Works with anything that has a `length` property and index access properties, including NodeList.\n   *\n   * @template {unknown} T\n   * @param {Array<T> | ({length:number, [number]: T})} list\n   * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate\n   * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,\n   * \t\t\t\tallows injecting a custom implementation in tests\n   * @returns {T | undefined}\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n   * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find\n   */\n  function find$1(list, predicate, ac) {\n    if (ac === undefined) {\n      ac = Array.prototype;\n    }\n    if (list && typeof ac.find === 'function') {\n      return ac.find.call(list, predicate);\n    }\n    for (var i = 0; i < list.length; i++) {\n      if (Object.prototype.hasOwnProperty.call(list, i)) {\n        var item = list[i];\n        if (predicate.call(undefined, item, i, list)) {\n          return item;\n        }\n      }\n    }\n  }\n\n  /**\n   * \"Shallow freezes\" an object to render it immutable.\n   * Uses `Object.freeze` if available,\n   * otherwise the immutability is only in the type.\n   *\n   * Is used to create \"enum like\" objects.\n   *\n   * @template T\n   * @param {T} object the object to freeze\n   * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,\n   * \t\t\t\tallows to inject custom object constructor for tests\n   * @returns {Readonly<T>}\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n   */\n  function freeze(object, oc) {\n    if (oc === undefined) {\n      oc = Object;\n    }\n    return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;\n  }\n\n  /**\n   * Since we can not rely on `Object.assign` we provide a simplified version\n   * that is sufficient for our needs.\n   *\n   * @param {Object} target\n   * @param {Object | null | undefined} source\n   *\n   * @returns {Object} target\n   * @throws TypeError if target is not an object\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n   * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign\n   */\n  function assign(target, source) {\n    if (target === null || typeof target !== 'object') {\n      throw new TypeError('target is not an object');\n    }\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n    return target;\n  }\n\n  /**\n   * All mime types that are allowed as input to `DOMParser.parseFromString`\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN\n   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec\n   * @see DOMParser.prototype.parseFromString\n   */\n  var MIME_TYPE = freeze({\n    /**\n     * `text/html`, the only mime type that triggers treating an XML document as HTML.\n     *\n     * @see DOMParser.SupportedType.isHTML\n     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n     * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec\n     */\n    HTML: 'text/html',\n    /**\n     * Helper method to check a mime type if it indicates an HTML document\n     *\n     * @param {string} [value]\n     * @returns {boolean}\n     *\n     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n     * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring \t */\n    isHTML: function (value) {\n      return value === MIME_TYPE.HTML;\n    },\n    /**\n     * `application/xml`, the standard mime type for XML documents.\n     *\n     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration\n     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303\n     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n     */\n    XML_APPLICATION: 'application/xml',\n    /**\n     * `text/html`, an alias for `application/xml`.\n     *\n     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303\n     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration\n     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n     */\n    XML_TEXT: 'text/xml',\n    /**\n     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,\n     * but is parsed as an XML document.\n     *\n     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec\n     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia\n     */\n    XML_XHTML_APPLICATION: 'application/xhtml+xml',\n    /**\n     * `image/svg+xml`,\n     *\n     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration\n     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1\n     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia\n     */\n    XML_SVG_IMAGE: 'image/svg+xml'\n  });\n\n  /**\n   * Namespaces that are used in this code base.\n   *\n   * @see http://www.w3.org/TR/REC-xml-names\n   */\n  var NAMESPACE$3 = freeze({\n    /**\n     * The XHTML namespace.\n     *\n     * @see http://www.w3.org/1999/xhtml\n     */\n    HTML: 'http://www.w3.org/1999/xhtml',\n    /**\n     * Checks if `uri` equals `NAMESPACE.HTML`.\n     *\n     * @param {string} [uri]\n     *\n     * @see NAMESPACE.HTML\n     */\n    isHTML: function (uri) {\n      return uri === NAMESPACE$3.HTML;\n    },\n    /**\n     * The SVG namespace.\n     *\n     * @see http://www.w3.org/2000/svg\n     */\n    SVG: 'http://www.w3.org/2000/svg',\n    /**\n     * The `xml:` namespace.\n     *\n     * @see http://www.w3.org/XML/1998/namespace\n     */\n    XML: 'http://www.w3.org/XML/1998/namespace',\n    /**\n     * The `xmlns:` namespace\n     *\n     * @see https://www.w3.org/2000/xmlns/\n     */\n    XMLNS: 'http://www.w3.org/2000/xmlns/'\n  });\n  var assign_1 = assign;\n  var find_1 = find$1;\n  var freeze_1 = freeze;\n  var MIME_TYPE_1 = MIME_TYPE;\n  var NAMESPACE_1 = NAMESPACE$3;\n  var conventions = {\n    assign: assign_1,\n    find: find_1,\n    freeze: freeze_1,\n    MIME_TYPE: MIME_TYPE_1,\n    NAMESPACE: NAMESPACE_1\n  };\n\n  var find = conventions.find;\n  var NAMESPACE$2 = conventions.NAMESPACE;\n\n  /**\n   * A prerequisite for `[].filter`, to drop elements that are empty\n   * @param {string} input\n   * @returns {boolean}\n   */\n  function notEmptyString(input) {\n    return input !== '';\n  }\n  /**\n   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace\n   * @see https://infra.spec.whatwg.org/#ascii-whitespace\n   *\n   * @param {string} input\n   * @returns {string[]} (can be empty)\n   */\n  function splitOnASCIIWhitespace(input) {\n    // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\n    return input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : [];\n  }\n\n  /**\n   * Adds element as a key to current if it is not already present.\n   *\n   * @param {Record<string, boolean | undefined>} current\n   * @param {string} element\n   * @returns {Record<string, boolean | undefined>}\n   */\n  function orderedSetReducer(current, element) {\n    if (!current.hasOwnProperty(element)) {\n      current[element] = true;\n    }\n    return current;\n  }\n\n  /**\n   * @see https://infra.spec.whatwg.org/#ordered-set\n   * @param {string} input\n   * @returns {string[]}\n   */\n  function toOrderedSet(input) {\n    if (!input) return [];\n    var list = splitOnASCIIWhitespace(input);\n    return Object.keys(list.reduce(orderedSetReducer, {}));\n  }\n\n  /**\n   * Uses `list.indexOf` to implement something like `Array.prototype.includes`,\n   * which we can not rely on being available.\n   *\n   * @param {any[]} list\n   * @returns {function(any): boolean}\n   */\n  function arrayIncludes(list) {\n    return function (element) {\n      return list && list.indexOf(element) !== -1;\n    };\n  }\n  function copy(src, dest) {\n    for (var p in src) {\n      if (Object.prototype.hasOwnProperty.call(src, p)) {\n        dest[p] = src[p];\n      }\n    }\n  }\n\n  /**\n  ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n  ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n   */\n  function _extends(Class, Super) {\n    var pt = Class.prototype;\n    if (!(pt instanceof Super)) {\n      function t() {}\n      t.prototype = Super.prototype;\n      t = new t();\n      copy(pt, t);\n      Class.prototype = pt = t;\n    }\n    if (pt.constructor != Class) {\n      if (typeof Class != 'function') {\n        console.error(\"unknown Class:\" + Class);\n      }\n      pt.constructor = Class;\n    }\n  }\n\n  // Node Types\n  var NodeType = {};\n  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\n  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\n  var TEXT_NODE = NodeType.TEXT_NODE = 3;\n  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\n  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\n  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;\n  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\n  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;\n  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\n  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\n  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\n  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;\n\n  // ExceptionCode\n  var ExceptionCode = {};\n  var ExceptionMessage = {};\n  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = \"Index size error\", 1);\n  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = \"DOMString size error\", 2);\n  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = \"Hierarchy request error\", 3);\n  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = \"Wrong document\", 4);\n  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = \"Invalid character\", 5);\n  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = \"No data allowed\", 6);\n  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = \"No modification allowed\", 7);\n  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = \"Not found\", 8);\n  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = \"Not supported\", 9);\n  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = \"Attribute in use\", 10);\n  //level2\n  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = \"Invalid state\", 11);\n  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = \"Syntax error\", 12);\n  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = \"Invalid modification\", 13);\n  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = \"Invalid namespace\", 14);\n  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = \"Invalid access\", 15);\n\n  /**\n   * DOM Level 2\n   * Object DOMException\n   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n   * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n   */\n  function DOMException(code, message) {\n    if (message instanceof Error) {\n      var error = message;\n    } else {\n      error = this;\n      Error.call(this, ExceptionMessage[code]);\n      this.message = ExceptionMessage[code];\n      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n    }\n    error.code = code;\n    if (message) this.message = this.message + \": \" + message;\n    return error;\n  }\n  DOMException.prototype = Error.prototype;\n  copy(ExceptionCode, DOMException);\n\n  /**\n   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n   * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n   * The items in the NodeList are accessible via an integral index, starting from 0.\n   */\n  function NodeList() {}\n  NodeList.prototype = {\n    /**\n     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n     * @standard level1\n     */\n    length: 0,\n    /**\n     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n     * @standard level1\n     * @param index  unsigned long\n     *   Index into the collection.\n     * @return Node\n     * \tThe node at the indexth position in the NodeList, or null if that is not a valid index.\n     */\n    item: function (index) {\n      return this[index] || null;\n    },\n    toString: function (isHTML, nodeFilter) {\n      for (var buf = [], i = 0; i < this.length; i++) {\n        serializeToString(this[i], buf, isHTML, nodeFilter);\n      }\n      return buf.join('');\n    },\n    /**\n     * @private\n     * @param {function (Node):boolean} predicate\n     * @returns {Node[]}\n     */\n    filter: function (predicate) {\n      return Array.prototype.filter.call(this, predicate);\n    },\n    /**\n     * @private\n     * @param {Node} item\n     * @returns {number}\n     */\n    indexOf: function (item) {\n      return Array.prototype.indexOf.call(this, item);\n    }\n  };\n  function LiveNodeList(node, refresh) {\n    this._node = node;\n    this._refresh = refresh;\n    _updateLiveList(this);\n  }\n  function _updateLiveList(list) {\n    var inc = list._node._inc || list._node.ownerDocument._inc;\n    if (list._inc != inc) {\n      var ls = list._refresh(list._node);\n      //console.log(ls.length)\n      __set__(list, 'length', ls.length);\n      copy(ls, list);\n      list._inc = inc;\n    }\n  }\n  LiveNodeList.prototype.item = function (i) {\n    _updateLiveList(this);\n    return this[i];\n  };\n  _extends(LiveNodeList, NodeList);\n\n  /**\n   * Objects implementing the NamedNodeMap interface are used\n   * to represent collections of nodes that can be accessed by name.\n   * Note that NamedNodeMap does not inherit from NodeList;\n   * NamedNodeMaps are not maintained in any particular order.\n   * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,\n   * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\n   * and does not imply that the DOM specifies an order to these Nodes.\n   * NamedNodeMap objects in the DOM are live.\n   * used for attributes or DocumentType entities\n   */\n  function NamedNodeMap() {}\n  function _findNodeIndex(list, node) {\n    var i = list.length;\n    while (i--) {\n      if (list[i] === node) {\n        return i;\n      }\n    }\n  }\n  function _addNamedNode(el, list, newAttr, oldAttr) {\n    if (oldAttr) {\n      list[_findNodeIndex(list, oldAttr)] = newAttr;\n    } else {\n      list[list.length++] = newAttr;\n    }\n    if (el) {\n      newAttr.ownerElement = el;\n      var doc = el.ownerDocument;\n      if (doc) {\n        oldAttr && _onRemoveAttribute(doc, el, oldAttr);\n        _onAddAttribute(doc, el, newAttr);\n      }\n    }\n  }\n  function _removeNamedNode(el, list, attr) {\n    //console.log('remove attr:'+attr)\n    var i = _findNodeIndex(list, attr);\n    if (i >= 0) {\n      var lastIndex = list.length - 1;\n      while (i < lastIndex) {\n        list[i] = list[++i];\n      }\n      list.length = lastIndex;\n      if (el) {\n        var doc = el.ownerDocument;\n        if (doc) {\n          _onRemoveAttribute(doc, el, attr);\n          attr.ownerElement = null;\n        }\n      }\n    } else {\n      throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));\n    }\n  }\n  NamedNodeMap.prototype = {\n    length: 0,\n    item: NodeList.prototype.item,\n    getNamedItem: function (key) {\n      //\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n      //\t\t\treturn null;\n      //\t\t}\n      //console.log()\n      var i = this.length;\n      while (i--) {\n        var attr = this[i];\n        //console.log(attr.nodeName,key)\n        if (attr.nodeName == key) {\n          return attr;\n        }\n      }\n    },\n    setNamedItem: function (attr) {\n      var el = attr.ownerElement;\n      if (el && el != this._ownerElement) {\n        throw new DOMException(INUSE_ATTRIBUTE_ERR);\n      }\n      var oldAttr = this.getNamedItem(attr.nodeName);\n      _addNamedNode(this._ownerElement, this, attr, oldAttr);\n      return oldAttr;\n    },\n    /* returns Node */\n    setNamedItemNS: function (attr) {\n      // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n      var el = attr.ownerElement,\n        oldAttr;\n      if (el && el != this._ownerElement) {\n        throw new DOMException(INUSE_ATTRIBUTE_ERR);\n      }\n      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n      _addNamedNode(this._ownerElement, this, attr, oldAttr);\n      return oldAttr;\n    },\n    /* returns Node */\n    removeNamedItem: function (key) {\n      var attr = this.getNamedItem(key);\n      _removeNamedNode(this._ownerElement, this, attr);\n      return attr;\n    },\n    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\n    //for level2\n    removeNamedItemNS: function (namespaceURI, localName) {\n      var attr = this.getNamedItemNS(namespaceURI, localName);\n      _removeNamedNode(this._ownerElement, this, attr);\n      return attr;\n    },\n    getNamedItemNS: function (namespaceURI, localName) {\n      var i = this.length;\n      while (i--) {\n        var node = this[i];\n        if (node.localName == localName && node.namespaceURI == namespaceURI) {\n          return node;\n        }\n      }\n      return null;\n    }\n  };\n\n  /**\n   * The DOMImplementation interface represents an object providing methods\n   * which are not dependent on any particular document.\n   * Such an object is returned by the `Document.implementation` property.\n   *\n   * __The individual methods describe the differences compared to the specs.__\n   *\n   * @constructor\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\n   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)\n   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\n   * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\n   */\n  function DOMImplementation$1() {}\n  DOMImplementation$1.prototype = {\n    /**\n     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.\n     * The different implementations fairly diverged in what kind of features were reported.\n     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.\n     *\n     * @deprecated It is deprecated and modern browsers return true in all cases.\n     *\n     * @param {string} feature\n     * @param {string} [version]\n     * @returns {boolean} always true\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\n     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\n     */\n    hasFeature: function (feature, version) {\n      return true;\n    },\n    /**\n     * Creates an XML Document object of the specified type with its document element.\n     *\n     * __It behaves slightly different from the description in the living standard__:\n     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.\n     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n     * - this implementation is not validating names or qualified names\n     *   (when parsing XML strings, the SAX parser takes care of that)\n     *\n     * @param {string|null} namespaceURI\n     * @param {string} qualifiedName\n     * @param {DocumentType=null} doctype\n     * @returns {Document}\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\n     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core\n     *\n     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n     */\n    createDocument: function (namespaceURI, qualifiedName, doctype) {\n      var doc = new Document();\n      doc.implementation = this;\n      doc.childNodes = new NodeList();\n      doc.doctype = doctype || null;\n      if (doctype) {\n        doc.appendChild(doctype);\n      }\n      if (qualifiedName) {\n        var root = doc.createElementNS(namespaceURI, qualifiedName);\n        doc.appendChild(root);\n      }\n      return doc;\n    },\n    /**\n     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.\n     *\n     * __This behavior is slightly different from the in the specs__:\n     * - this implementation is not validating names or qualified names\n     *   (when parsing XML strings, the SAX parser takes care of that)\n     *\n     * @param {string} qualifiedName\n     * @param {string} [publicId]\n     * @param {string} [systemId]\n     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation\n     * \t\t\t\t  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN\n     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard\n     *\n     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n     */\n    createDocumentType: function (qualifiedName, publicId, systemId) {\n      var node = new DocumentType();\n      node.name = qualifiedName;\n      node.nodeName = qualifiedName;\n      node.publicId = publicId || '';\n      node.systemId = systemId || '';\n      return node;\n    }\n  };\n\n  /**\n   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n   */\n\n  function Node() {}\n  Node.prototype = {\n    firstChild: null,\n    lastChild: null,\n    previousSibling: null,\n    nextSibling: null,\n    attributes: null,\n    parentNode: null,\n    childNodes: null,\n    ownerDocument: null,\n    nodeValue: null,\n    namespaceURI: null,\n    prefix: null,\n    localName: null,\n    // Modified in DOM Level 2:\n    insertBefore: function (newChild, refChild) {\n      //raises\n      return _insertBefore(this, newChild, refChild);\n    },\n    replaceChild: function (newChild, oldChild) {\n      //raises\n      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n      if (oldChild) {\n        this.removeChild(oldChild);\n      }\n    },\n    removeChild: function (oldChild) {\n      return _removeChild(this, oldChild);\n    },\n    appendChild: function (newChild) {\n      return this.insertBefore(newChild, null);\n    },\n    hasChildNodes: function () {\n      return this.firstChild != null;\n    },\n    cloneNode: function (deep) {\n      return cloneNode(this.ownerDocument || this, this, deep);\n    },\n    // Modified in DOM Level 2:\n    normalize: function () {\n      var child = this.firstChild;\n      while (child) {\n        var next = child.nextSibling;\n        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n          this.removeChild(next);\n          child.appendData(next.data);\n        } else {\n          child.normalize();\n          child = next;\n        }\n      }\n    },\n    // Introduced in DOM Level 2:\n    isSupported: function (feature, version) {\n      return this.ownerDocument.implementation.hasFeature(feature, version);\n    },\n    // Introduced in DOM Level 2:\n    hasAttributes: function () {\n      return this.attributes.length > 0;\n    },\n    /**\n     * Look up the prefix associated to the given namespace URI, starting from this node.\n     * **The default namespace declarations are ignored by this method.**\n     * See Namespace Prefix Lookup for details on the algorithm used by this method.\n     *\n     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._\n     *\n     * @param {string | null} namespaceURI\n     * @returns {string | null}\n     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\n     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\n     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\n     * @see https://github.com/xmldom/xmldom/issues/322\n     */\n    lookupPrefix: function (namespaceURI) {\n      var el = this;\n      while (el) {\n        var map = el._nsMap;\n        //console.dir(map)\n        if (map) {\n          for (var n in map) {\n            if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {\n              return n;\n            }\n          }\n        }\n        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n      }\n      return null;\n    },\n    // Introduced in DOM Level 3:\n    lookupNamespaceURI: function (prefix) {\n      var el = this;\n      while (el) {\n        var map = el._nsMap;\n        //console.dir(map)\n        if (map) {\n          if (Object.prototype.hasOwnProperty.call(map, prefix)) {\n            return map[prefix];\n          }\n        }\n        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n      }\n      return null;\n    },\n    // Introduced in DOM Level 3:\n    isDefaultNamespace: function (namespaceURI) {\n      var prefix = this.lookupPrefix(namespaceURI);\n      return prefix == null;\n    }\n  };\n  function _xmlEncoder(c) {\n    return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\n  }\n  copy(NodeType, Node);\n  copy(NodeType, Node.prototype);\n\n  /**\n   * @param callback return true for continue,false for break\n   * @return boolean true: break visit;\n   */\n  function _visitNode(node, callback) {\n    if (callback(node)) {\n      return true;\n    }\n    if (node = node.firstChild) {\n      do {\n        if (_visitNode(node, callback)) {\n          return true;\n        }\n      } while (node = node.nextSibling);\n    }\n  }\n  function Document() {\n    this.ownerDocument = this;\n  }\n  function _onAddAttribute(doc, el, newAttr) {\n    doc && doc._inc++;\n    var ns = newAttr.namespaceURI;\n    if (ns === NAMESPACE$2.XMLNS) {\n      //update namespace\n      el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n    }\n  }\n  function _onRemoveAttribute(doc, el, newAttr, remove) {\n    doc && doc._inc++;\n    var ns = newAttr.namespaceURI;\n    if (ns === NAMESPACE$2.XMLNS) {\n      //update namespace\n      delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n    }\n  }\n\n  /**\n   * Updates `el.childNodes`, updating the indexed items and it's `length`.\n   * Passing `newChild` means it will be appended.\n   * Otherwise it's assumed that an item has been removed,\n   * and `el.firstNode` and it's `.nextSibling` are used\n   * to walk the current list of child nodes.\n   *\n   * @param {Document} doc\n   * @param {Node} el\n   * @param {Node} [newChild]\n   * @private\n   */\n  function _onUpdateChild(doc, el, newChild) {\n    if (doc && doc._inc) {\n      doc._inc++;\n      //update childNodes\n      var cs = el.childNodes;\n      if (newChild) {\n        cs[cs.length++] = newChild;\n      } else {\n        var child = el.firstChild;\n        var i = 0;\n        while (child) {\n          cs[i++] = child;\n          child = child.nextSibling;\n        }\n        cs.length = i;\n        delete cs[cs.length];\n      }\n    }\n  }\n\n  /**\n   * Removes the connections between `parentNode` and `child`\n   * and any existing `child.previousSibling` or `child.nextSibling`.\n   *\n   * @see https://github.com/xmldom/xmldom/issues/135\n   * @see https://github.com/xmldom/xmldom/issues/145\n   *\n   * @param {Node} parentNode\n   * @param {Node} child\n   * @returns {Node} the child that was removed.\n   * @private\n   */\n  function _removeChild(parentNode, child) {\n    var previous = child.previousSibling;\n    var next = child.nextSibling;\n    if (previous) {\n      previous.nextSibling = next;\n    } else {\n      parentNode.firstChild = next;\n    }\n    if (next) {\n      next.previousSibling = previous;\n    } else {\n      parentNode.lastChild = previous;\n    }\n    child.parentNode = null;\n    child.previousSibling = null;\n    child.nextSibling = null;\n    _onUpdateChild(parentNode.ownerDocument, parentNode);\n    return child;\n  }\n\n  /**\n   * Returns `true` if `node` can be a parent for insertion.\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasValidParentNodeType(node) {\n    return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);\n  }\n\n  /**\n   * Returns `true` if `node` can be inserted according to it's `nodeType`.\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasInsertableNodeType(node) {\n    return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);\n  }\n\n  /**\n   * Returns true if `node` is a DOCTYPE node\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function isDocTypeNode(node) {\n    return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;\n  }\n\n  /**\n   * Returns true if the node is an element\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function isElementNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * Returns true if `node` is a text node\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function isTextNode(node) {\n    return node && node.nodeType === Node.TEXT_NODE;\n  }\n\n  /**\n   * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n   * according to the presence and position of a doctype node on the same level.\n   *\n   * @param {Document} doc The document node\n   * @param {Node} child the node that would become the nextSibling if the element would be inserted\n   * @returns {boolean} `true` if an element can be inserted before child\n   * @private\n   * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n   */\n  function isElementInsertionPossible(doc, child) {\n    var parentChildNodes = doc.childNodes || [];\n    if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {\n      return false;\n    }\n    var docTypeNode = find(parentChildNodes, isDocTypeNode);\n    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n  }\n\n  /**\n   * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n   * according to the presence and position of a doctype node on the same level.\n   *\n   * @param {Node} doc The document node\n   * @param {Node} child the node that would become the nextSibling if the element would be inserted\n   * @returns {boolean} `true` if an element can be inserted before child\n   * @private\n   * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n   */\n  function isElementReplacementPossible(doc, child) {\n    var parentChildNodes = doc.childNodes || [];\n    function hasElementChildThatIsNotChild(node) {\n      return isElementNode(node) && node !== child;\n    }\n    if (find(parentChildNodes, hasElementChildThatIsNotChild)) {\n      return false;\n    }\n    var docTypeNode = find(parentChildNodes, isDocTypeNode);\n    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n  }\n\n  /**\n   * @private\n   * Steps 1-5 of the checks before inserting and before replacing a child are the same.\n   *\n   * @param {Node} parent the parent node to insert `node` into\n   * @param {Node} node the node to insert\n   * @param {Node=} child the node that should become the `nextSibling` of `node`\n   * @returns {Node}\n   * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n   * @throws DOMException if `child` is provided but is not a child of `parent`.\n   * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n   * @see https://dom.spec.whatwg.org/#concept-node-replace\n   */\n  function assertPreInsertionValidity1to5(parent, node, child) {\n    // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a \"HierarchyRequestError\" DOMException.\n    if (!hasValidParentNodeType(parent)) {\n      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);\n    }\n    // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a \"HierarchyRequestError\" DOMException.\n    // not implemented!\n    // 3. If `child` is non-null and its parent is not `parent`, then throw a \"NotFoundError\" DOMException.\n    if (child && child.parentNode !== parent) {\n      throw new DOMException(NOT_FOUND_ERR, 'child not in parent');\n    }\n    if (\n    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a \"HierarchyRequestError\" DOMException.\n    !hasInsertableNodeType(node) ||\n    // 5. If either `node` is a Text node and `parent` is a document,\n    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0\n    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)\n    // or `node` is a doctype and `parent` is not a document, then throw a \"HierarchyRequestError\" DOMException.\n    isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {\n      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType);\n    }\n  }\n\n  /**\n   * @private\n   * Step 6 of the checks before inserting and before replacing a child are different.\n   *\n   * @param {Document} parent the parent node to insert `node` into\n   * @param {Node} node the node to insert\n   * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n   * @returns {Node}\n   * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n   * @throws DOMException if `child` is provided but is not a child of `parent`.\n   * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n   * @see https://dom.spec.whatwg.org/#concept-node-replace\n   */\n  function assertPreInsertionValidityInDocument(parent, node, child) {\n    var parentChildNodes = parent.childNodes || [];\n    var nodeChildNodes = node.childNodes || [];\n\n    // DocumentFragment\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      var nodeChildElements = nodeChildNodes.filter(isElementNode);\n      // If node has more than one element child or has a Text node child.\n      if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n      }\n      // Otherwise, if `node` has one element child and either `parent` has an element child,\n      // `child` is a doctype, or `child` is non-null and a doctype is following `child`.\n      if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n      }\n    }\n    // Element\n    if (isElementNode(node)) {\n      // `parent` has an element child, `child` is a doctype,\n      // or `child` is non-null and a doctype is following `child`.\n      if (!isElementInsertionPossible(parent, child)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n      }\n    }\n    // DocumentType\n    if (isDocTypeNode(node)) {\n      // `parent` has a doctype child,\n      if (find(parentChildNodes, isDocTypeNode)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n      }\n      var parentElementChild = find(parentChildNodes, isElementNode);\n      // `child` is non-null and an element is preceding `child`,\n      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n      }\n      // or `child` is null and `parent` has an element child.\n      if (!child && parentElementChild) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');\n      }\n    }\n  }\n\n  /**\n   * @private\n   * Step 6 of the checks before inserting and before replacing a child are different.\n   *\n   * @param {Document} parent the parent node to insert `node` into\n   * @param {Node} node the node to insert\n   * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n   * @returns {Node}\n   * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n   * @throws DOMException if `child` is provided but is not a child of `parent`.\n   * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n   * @see https://dom.spec.whatwg.org/#concept-node-replace\n   */\n  function assertPreReplacementValidityInDocument(parent, node, child) {\n    var parentChildNodes = parent.childNodes || [];\n    var nodeChildNodes = node.childNodes || [];\n\n    // DocumentFragment\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      var nodeChildElements = nodeChildNodes.filter(isElementNode);\n      // If `node` has more than one element child or has a Text node child.\n      if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n      }\n      // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.\n      if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n      }\n    }\n    // Element\n    if (isElementNode(node)) {\n      // `parent` has an element child that is not `child` or a doctype is following `child`.\n      if (!isElementReplacementPossible(parent, child)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n      }\n    }\n    // DocumentType\n    if (isDocTypeNode(node)) {\n      function hasDoctypeChildThatIsNotChild(node) {\n        return isDocTypeNode(node) && node !== child;\n      }\n\n      // `parent` has a doctype child that is not `child`,\n      if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n      }\n      var parentElementChild = find(parentChildNodes, isElementNode);\n      // or an element is preceding `child`.\n      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n        throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Node} parent the parent node to insert `node` into\n   * @param {Node} node the node to insert\n   * @param {Node=} child the node that should become the `nextSibling` of `node`\n   * @returns {Node}\n   * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n   * @throws DOMException if `child` is provided but is not a child of `parent`.\n   * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n   */\n  function _insertBefore(parent, node, child, _inDocumentAssertion) {\n    // To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n    assertPreInsertionValidity1to5(parent, node, child);\n\n    // If parent is a document, and any of the statements below, switched on the interface node implements,\n    // are true, then throw a \"HierarchyRequestError\" DOMException.\n    if (parent.nodeType === Node.DOCUMENT_NODE) {\n      (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);\n    }\n    var cp = node.parentNode;\n    if (cp) {\n      cp.removeChild(node); //remove and update\n    }\n\n    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      var newFirst = node.firstChild;\n      if (newFirst == null) {\n        return node;\n      }\n      var newLast = node.lastChild;\n    } else {\n      newFirst = newLast = node;\n    }\n    var pre = child ? child.previousSibling : parent.lastChild;\n    newFirst.previousSibling = pre;\n    newLast.nextSibling = child;\n    if (pre) {\n      pre.nextSibling = newFirst;\n    } else {\n      parent.firstChild = newFirst;\n    }\n    if (child == null) {\n      parent.lastChild = newLast;\n    } else {\n      child.previousSibling = newLast;\n    }\n    do {\n      newFirst.parentNode = parent;\n    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n    _onUpdateChild(parent.ownerDocument || parent, parent);\n    //console.log(parent.lastChild.nextSibling == null)\n    if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {\n      node.firstChild = node.lastChild = null;\n    }\n    return node;\n  }\n\n  /**\n   * Appends `newChild` to `parentNode`.\n   * If `newChild` is already connected to a `parentNode` it is first removed from it.\n   *\n   * @see https://github.com/xmldom/xmldom/issues/135\n   * @see https://github.com/xmldom/xmldom/issues/145\n   * @param {Node} parentNode\n   * @param {Node} newChild\n   * @returns {Node}\n   * @private\n   */\n  function _appendSingleChild(parentNode, newChild) {\n    if (newChild.parentNode) {\n      newChild.parentNode.removeChild(newChild);\n    }\n    newChild.parentNode = parentNode;\n    newChild.previousSibling = parentNode.lastChild;\n    newChild.nextSibling = null;\n    if (newChild.previousSibling) {\n      newChild.previousSibling.nextSibling = newChild;\n    } else {\n      parentNode.firstChild = newChild;\n    }\n    parentNode.lastChild = newChild;\n    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\n    return newChild;\n  }\n  Document.prototype = {\n    //implementation : null,\n    nodeName: '#document',\n    nodeType: DOCUMENT_NODE,\n    /**\n     * The DocumentType node of the document.\n     *\n     * @readonly\n     * @type DocumentType\n     */\n    doctype: null,\n    documentElement: null,\n    _inc: 1,\n    insertBefore: function (newChild, refChild) {\n      //raises\n      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n        var child = newChild.firstChild;\n        while (child) {\n          var next = child.nextSibling;\n          this.insertBefore(child, refChild);\n          child = next;\n        }\n        return newChild;\n      }\n      _insertBefore(this, newChild, refChild);\n      newChild.ownerDocument = this;\n      if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {\n        this.documentElement = newChild;\n      }\n      return newChild;\n    },\n    removeChild: function (oldChild) {\n      if (this.documentElement == oldChild) {\n        this.documentElement = null;\n      }\n      return _removeChild(this, oldChild);\n    },\n    replaceChild: function (newChild, oldChild) {\n      //raises\n      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n      newChild.ownerDocument = this;\n      if (oldChild) {\n        this.removeChild(oldChild);\n      }\n      if (isElementNode(newChild)) {\n        this.documentElement = newChild;\n      }\n    },\n    // Introduced in DOM Level 2:\n    importNode: function (importedNode, deep) {\n      return importNode(this, importedNode, deep);\n    },\n    // Introduced in DOM Level 2:\n    getElementById: function (id) {\n      var rtv = null;\n      _visitNode(this.documentElement, function (node) {\n        if (node.nodeType == ELEMENT_NODE) {\n          if (node.getAttribute('id') == id) {\n            rtv = node;\n            return true;\n          }\n        }\n      });\n      return rtv;\n    },\n    /**\n     * The `getElementsByClassName` method of `Document` interface returns an array-like object\n     * of all child elements which have **all** of the given class name(s).\n     *\n     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.\n     *\n     *\n     * Warning: This is a live LiveNodeList.\n     * Changes in the DOM will reflect in the array as the changes occur.\n     * If an element selected by this array no longer qualifies for the selector,\n     * it will automatically be removed. Be aware of this for iteration purposes.\n     *\n     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n     */\n    getElementsByClassName: function (classNames) {\n      var classNamesSet = toOrderedSet(classNames);\n      return new LiveNodeList(this, function (base) {\n        var ls = [];\n        if (classNamesSet.length > 0) {\n          _visitNode(base.documentElement, function (node) {\n            if (node !== base && node.nodeType === ELEMENT_NODE) {\n              var nodeClassNames = node.getAttribute('class');\n              // can be null if the attribute does not exist\n              if (nodeClassNames) {\n                // before splitting and iterating just compare them for the most common case\n                var matches = classNames === nodeClassNames;\n                if (!matches) {\n                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);\n                  matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));\n                }\n                if (matches) {\n                  ls.push(node);\n                }\n              }\n            }\n          });\n        }\n        return ls;\n      });\n    },\n    //document factory method:\n    createElement: function (tagName) {\n      var node = new Element();\n      node.ownerDocument = this;\n      node.nodeName = tagName;\n      node.tagName = tagName;\n      node.localName = tagName;\n      node.childNodes = new NodeList();\n      var attrs = node.attributes = new NamedNodeMap();\n      attrs._ownerElement = node;\n      return node;\n    },\n    createDocumentFragment: function () {\n      var node = new DocumentFragment();\n      node.ownerDocument = this;\n      node.childNodes = new NodeList();\n      return node;\n    },\n    createTextNode: function (data) {\n      var node = new Text();\n      node.ownerDocument = this;\n      node.appendData(data);\n      return node;\n    },\n    createComment: function (data) {\n      var node = new Comment();\n      node.ownerDocument = this;\n      node.appendData(data);\n      return node;\n    },\n    createCDATASection: function (data) {\n      var node = new CDATASection();\n      node.ownerDocument = this;\n      node.appendData(data);\n      return node;\n    },\n    createProcessingInstruction: function (target, data) {\n      var node = new ProcessingInstruction();\n      node.ownerDocument = this;\n      node.tagName = node.target = target;\n      node.nodeValue = node.data = data;\n      return node;\n    },\n    createAttribute: function (name) {\n      var node = new Attr();\n      node.ownerDocument = this;\n      node.name = name;\n      node.nodeName = name;\n      node.localName = name;\n      node.specified = true;\n      return node;\n    },\n    createEntityReference: function (name) {\n      var node = new EntityReference();\n      node.ownerDocument = this;\n      node.nodeName = name;\n      return node;\n    },\n    // Introduced in DOM Level 2:\n    createElementNS: function (namespaceURI, qualifiedName) {\n      var node = new Element();\n      var pl = qualifiedName.split(':');\n      var attrs = node.attributes = new NamedNodeMap();\n      node.childNodes = new NodeList();\n      node.ownerDocument = this;\n      node.nodeName = qualifiedName;\n      node.tagName = qualifiedName;\n      node.namespaceURI = namespaceURI;\n      if (pl.length == 2) {\n        node.prefix = pl[0];\n        node.localName = pl[1];\n      } else {\n        //el.prefix = null;\n        node.localName = qualifiedName;\n      }\n      attrs._ownerElement = node;\n      return node;\n    },\n    // Introduced in DOM Level 2:\n    createAttributeNS: function (namespaceURI, qualifiedName) {\n      var node = new Attr();\n      var pl = qualifiedName.split(':');\n      node.ownerDocument = this;\n      node.nodeName = qualifiedName;\n      node.name = qualifiedName;\n      node.namespaceURI = namespaceURI;\n      node.specified = true;\n      if (pl.length == 2) {\n        node.prefix = pl[0];\n        node.localName = pl[1];\n      } else {\n        //el.prefix = null;\n        node.localName = qualifiedName;\n      }\n      return node;\n    }\n  };\n  _extends(Document, Node);\n  function Element() {\n    this._nsMap = {};\n  }\n  Element.prototype = {\n    nodeType: ELEMENT_NODE,\n    hasAttribute: function (name) {\n      return this.getAttributeNode(name) != null;\n    },\n    getAttribute: function (name) {\n      var attr = this.getAttributeNode(name);\n      return attr && attr.value || '';\n    },\n    getAttributeNode: function (name) {\n      return this.attributes.getNamedItem(name);\n    },\n    setAttribute: function (name, value) {\n      var attr = this.ownerDocument.createAttribute(name);\n      attr.value = attr.nodeValue = \"\" + value;\n      this.setAttributeNode(attr);\n    },\n    removeAttribute: function (name) {\n      var attr = this.getAttributeNode(name);\n      attr && this.removeAttributeNode(attr);\n    },\n    //four real opeartion method\n    appendChild: function (newChild) {\n      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        return this.insertBefore(newChild, null);\n      } else {\n        return _appendSingleChild(this, newChild);\n      }\n    },\n    setAttributeNode: function (newAttr) {\n      return this.attributes.setNamedItem(newAttr);\n    },\n    setAttributeNodeNS: function (newAttr) {\n      return this.attributes.setNamedItemNS(newAttr);\n    },\n    removeAttributeNode: function (oldAttr) {\n      //console.log(this == oldAttr.ownerElement)\n      return this.attributes.removeNamedItem(oldAttr.nodeName);\n    },\n    //get real attribute name,and remove it by removeAttributeNode\n    removeAttributeNS: function (namespaceURI, localName) {\n      var old = this.getAttributeNodeNS(namespaceURI, localName);\n      old && this.removeAttributeNode(old);\n    },\n    hasAttributeNS: function (namespaceURI, localName) {\n      return this.getAttributeNodeNS(namespaceURI, localName) != null;\n    },\n    getAttributeNS: function (namespaceURI, localName) {\n      var attr = this.getAttributeNodeNS(namespaceURI, localName);\n      return attr && attr.value || '';\n    },\n    setAttributeNS: function (namespaceURI, qualifiedName, value) {\n      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n      attr.value = attr.nodeValue = \"\" + value;\n      this.setAttributeNode(attr);\n    },\n    getAttributeNodeNS: function (namespaceURI, localName) {\n      return this.attributes.getNamedItemNS(namespaceURI, localName);\n    },\n    getElementsByTagName: function (tagName) {\n      return new LiveNodeList(this, function (base) {\n        var ls = [];\n        _visitNode(base, function (node) {\n          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {\n            ls.push(node);\n          }\n        });\n        return ls;\n      });\n    },\n    getElementsByTagNameNS: function (namespaceURI, localName) {\n      return new LiveNodeList(this, function (base) {\n        var ls = [];\n        _visitNode(base, function (node) {\n          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\n            ls.push(node);\n          }\n        });\n        return ls;\n      });\n    }\n  };\n  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\n  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n  _extends(Element, Node);\n  function Attr() {}\n  Attr.prototype.nodeType = ATTRIBUTE_NODE;\n  _extends(Attr, Node);\n  function CharacterData() {}\n  CharacterData.prototype = {\n    data: '',\n    substringData: function (offset, count) {\n      return this.data.substring(offset, offset + count);\n    },\n    appendData: function (text) {\n      text = this.data + text;\n      this.nodeValue = this.data = text;\n      this.length = text.length;\n    },\n    insertData: function (offset, text) {\n      this.replaceData(offset, 0, text);\n    },\n    appendChild: function (newChild) {\n      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);\n    },\n    deleteData: function (offset, count) {\n      this.replaceData(offset, count, \"\");\n    },\n    replaceData: function (offset, count, text) {\n      var start = this.data.substring(0, offset);\n      var end = this.data.substring(offset + count);\n      text = start + text + end;\n      this.nodeValue = this.data = text;\n      this.length = text.length;\n    }\n  };\n  _extends(CharacterData, Node);\n  function Text() {}\n  Text.prototype = {\n    nodeName: \"#text\",\n    nodeType: TEXT_NODE,\n    splitText: function (offset) {\n      var text = this.data;\n      var newText = text.substring(offset);\n      text = text.substring(0, offset);\n      this.data = this.nodeValue = text;\n      this.length = text.length;\n      var newNode = this.ownerDocument.createTextNode(newText);\n      if (this.parentNode) {\n        this.parentNode.insertBefore(newNode, this.nextSibling);\n      }\n      return newNode;\n    }\n  };\n  _extends(Text, CharacterData);\n  function Comment() {}\n  Comment.prototype = {\n    nodeName: \"#comment\",\n    nodeType: COMMENT_NODE\n  };\n  _extends(Comment, CharacterData);\n  function CDATASection() {}\n  CDATASection.prototype = {\n    nodeName: \"#cdata-section\",\n    nodeType: CDATA_SECTION_NODE\n  };\n  _extends(CDATASection, CharacterData);\n  function DocumentType() {}\n  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n  _extends(DocumentType, Node);\n  function Notation() {}\n  Notation.prototype.nodeType = NOTATION_NODE;\n  _extends(Notation, Node);\n  function Entity() {}\n  Entity.prototype.nodeType = ENTITY_NODE;\n  _extends(Entity, Node);\n  function EntityReference() {}\n  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n  _extends(EntityReference, Node);\n  function DocumentFragment() {}\n  DocumentFragment.prototype.nodeName = \"#document-fragment\";\n  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n  _extends(DocumentFragment, Node);\n  function ProcessingInstruction() {}\n  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n  _extends(ProcessingInstruction, Node);\n  function XMLSerializer() {}\n  XMLSerializer.prototype.serializeToString = function (node, isHtml, nodeFilter) {\n    return nodeSerializeToString.call(node, isHtml, nodeFilter);\n  };\n  Node.prototype.toString = nodeSerializeToString;\n  function nodeSerializeToString(isHtml, nodeFilter) {\n    var buf = [];\n    var refNode = this.nodeType == 9 && this.documentElement || this;\n    var prefix = refNode.prefix;\n    var uri = refNode.namespaceURI;\n    if (uri && prefix == null) {\n      //console.log(prefix)\n      var prefix = refNode.lookupPrefix(uri);\n      if (prefix == null) {\n        //isHTML = true;\n        var visibleNamespaces = [{\n          namespace: uri,\n          prefix: null\n        }\n        //{namespace:uri,prefix:''}\n        ];\n      }\n    }\n\n    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);\n    //console.log('###',this.nodeType,uri,prefix,buf.join(''))\n    return buf.join('');\n  }\n  function needNamespaceDefine(node, isHTML, visibleNamespaces) {\n    var prefix = node.prefix || '';\n    var uri = node.namespaceURI;\n    // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n    // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n    // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n    // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n    // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n    // > [...] Furthermore, the attribute value [...] must not be an empty string.\n    // so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n    if (!uri) {\n      return false;\n    }\n    if (prefix === \"xml\" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {\n      return false;\n    }\n    var i = visibleNamespaces.length;\n    while (i--) {\n      var ns = visibleNamespaces[i];\n      // get namespace prefix\n      if (ns.prefix === prefix) {\n        return ns.namespace !== uri;\n      }\n    }\n    return true;\n  }\n  /**\n   * Well-formed constraint: No < in Attribute Values\n   * > The replacement text of any entity referred to directly or indirectly\n   * > in an attribute value must not contain a <.\n   * @see https://www.w3.org/TR/xml11/#CleanAttrVals\n   * @see https://www.w3.org/TR/xml11/#NT-AttValue\n   *\n   * Literal whitespace other than space that appear in attribute values\n   * are serialized as their entity references, so they will be preserved.\n   * (In contrast to whitespace literals in the input which are normalized to spaces)\n   * @see https://www.w3.org/TR/xml11/#AVNormalize\n   * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes\n   */\n  function addSerializedAttribute(buf, qualifiedName, value) {\n    buf.push(' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/g, _xmlEncoder), '\"');\n  }\n  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {\n    if (!visibleNamespaces) {\n      visibleNamespaces = [];\n    }\n    if (nodeFilter) {\n      node = nodeFilter(node);\n      if (node) {\n        if (typeof node == 'string') {\n          buf.push(node);\n          return;\n        }\n      } else {\n        return;\n      }\n      //buf.sort.apply(attrs, attributeSorter);\n    }\n\n    switch (node.nodeType) {\n      case ELEMENT_NODE:\n        var attrs = node.attributes;\n        var len = attrs.length;\n        var child = node.firstChild;\n        var nodeName = node.tagName;\n        isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;\n        var prefixedNodeName = nodeName;\n        if (!isHTML && !node.prefix && node.namespaceURI) {\n          var defaultNS;\n          // lookup current default ns from `xmlns` attribute\n          for (var ai = 0; ai < attrs.length; ai++) {\n            if (attrs.item(ai).name === 'xmlns') {\n              defaultNS = attrs.item(ai).value;\n              break;\n            }\n          }\n          if (!defaultNS) {\n            // lookup current default ns in visibleNamespaces\n            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n              var namespace = visibleNamespaces[nsi];\n              if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n                defaultNS = namespace.namespace;\n                break;\n              }\n            }\n          }\n          if (defaultNS !== node.namespaceURI) {\n            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n              var namespace = visibleNamespaces[nsi];\n              if (namespace.namespace === node.namespaceURI) {\n                if (namespace.prefix) {\n                  prefixedNodeName = namespace.prefix + ':' + nodeName;\n                }\n                break;\n              }\n            }\n          }\n        }\n        buf.push('<', prefixedNodeName);\n        for (var i = 0; i < len; i++) {\n          // add namespaces for attributes\n          var attr = attrs.item(i);\n          if (attr.prefix == 'xmlns') {\n            visibleNamespaces.push({\n              prefix: attr.localName,\n              namespace: attr.value\n            });\n          } else if (attr.nodeName == 'xmlns') {\n            visibleNamespaces.push({\n              prefix: '',\n              namespace: attr.value\n            });\n          }\n        }\n        for (var i = 0; i < len; i++) {\n          var attr = attrs.item(i);\n          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\n            var prefix = attr.prefix || '';\n            var uri = attr.namespaceURI;\n            addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n            visibleNamespaces.push({\n              prefix: prefix,\n              namespace: uri\n            });\n          }\n          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);\n        }\n\n        // add namespace for current node\n        if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n          var prefix = node.prefix || '';\n          var uri = node.namespaceURI;\n          addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n          visibleNamespaces.push({\n            prefix: prefix,\n            namespace: uri\n          });\n        }\n        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {\n          buf.push('>');\n          //if is cdata child node\n          if (isHTML && /^script$/i.test(nodeName)) {\n            while (child) {\n              if (child.data) {\n                buf.push(child.data);\n              } else {\n                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n              }\n              child = child.nextSibling;\n            }\n          } else {\n            while (child) {\n              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n              child = child.nextSibling;\n            }\n          }\n          buf.push('</', prefixedNodeName, '>');\n        } else {\n          buf.push('/>');\n        }\n        // remove added visible namespaces\n        //visibleNamespaces.length = startVisibleNamespaces;\n        return;\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        var child = node.firstChild;\n        while (child) {\n          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n          child = child.nextSibling;\n        }\n        return;\n      case ATTRIBUTE_NODE:\n        return addSerializedAttribute(buf, node.name, node.value);\n      case TEXT_NODE:\n        /**\n         * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n         * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.\n         * If they are needed elsewhere, they must be escaped using either numeric character references or the strings\n         * `&amp;` and `&lt;` respectively.\n         * The right angle bracket (>) may be represented using the string \" &gt; \", and must, for compatibility,\n         * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,\n         * when that string is not marking the end of a CDATA section.\n         *\n         * In the content of elements, character data is any string of characters\n         * which does not contain the start-delimiter of any markup\n         * and does not include the CDATA-section-close delimiter, `]]>`.\n         *\n         * @see https://www.w3.org/TR/xml/#NT-CharData\n         * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n         */\n        return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));\n      case CDATA_SECTION_NODE:\n        return buf.push('<![CDATA[', node.data, ']]>');\n      case COMMENT_NODE:\n        return buf.push(\"<!--\", node.data, \"-->\");\n      case DOCUMENT_TYPE_NODE:\n        var pubid = node.publicId;\n        var sysid = node.systemId;\n        buf.push('<!DOCTYPE ', node.name);\n        if (pubid) {\n          buf.push(' PUBLIC ', pubid);\n          if (sysid && sysid != '.') {\n            buf.push(' ', sysid);\n          }\n          buf.push('>');\n        } else if (sysid && sysid != '.') {\n          buf.push(' SYSTEM ', sysid, '>');\n        } else {\n          var sub = node.internalSubset;\n          if (sub) {\n            buf.push(\" [\", sub, \"]\");\n          }\n          buf.push(\">\");\n        }\n        return;\n      case PROCESSING_INSTRUCTION_NODE:\n        return buf.push(\"<?\", node.target, \" \", node.data, \"?>\");\n      case ENTITY_REFERENCE_NODE:\n        return buf.push('&', node.nodeName, ';');\n      //case ENTITY_NODE:\n      //case NOTATION_NODE:\n      default:\n        buf.push('??', node.nodeName);\n    }\n  }\n  function importNode(doc, node, deep) {\n    var node2;\n    switch (node.nodeType) {\n      case ELEMENT_NODE:\n        node2 = node.cloneNode(false);\n        node2.ownerDocument = doc;\n      //var attrs = node2.attributes;\n      //var len = attrs.length;\n      //for(var i=0;i<len;i++){\n      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n      //}\n      case DOCUMENT_FRAGMENT_NODE:\n        break;\n      case ATTRIBUTE_NODE:\n        deep = true;\n        break;\n      //case ENTITY_REFERENCE_NODE:\n      //case PROCESSING_INSTRUCTION_NODE:\n      ////case TEXT_NODE:\n      //case CDATA_SECTION_NODE:\n      //case COMMENT_NODE:\n      //\tdeep = false;\n      //\tbreak;\n      //case DOCUMENT_NODE:\n      //case DOCUMENT_TYPE_NODE:\n      //cannot be imported.\n      //case ENTITY_NODE:\n      //case NOTATION_NODE\n      //can not hit in level3\n      //default:throw e;\n    }\n\n    if (!node2) {\n      node2 = node.cloneNode(false); //false\n    }\n\n    node2.ownerDocument = doc;\n    node2.parentNode = null;\n    if (deep) {\n      var child = node.firstChild;\n      while (child) {\n        node2.appendChild(importNode(doc, child, deep));\n        child = child.nextSibling;\n      }\n    }\n    return node2;\n  }\n  //\n  //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n  //\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\n  function cloneNode(doc, node, deep) {\n    var node2 = new node.constructor();\n    for (var n in node) {\n      if (Object.prototype.hasOwnProperty.call(node, n)) {\n        var v = node[n];\n        if (typeof v != \"object\") {\n          if (v != node2[n]) {\n            node2[n] = v;\n          }\n        }\n      }\n    }\n    if (node.childNodes) {\n      node2.childNodes = new NodeList();\n    }\n    node2.ownerDocument = doc;\n    switch (node2.nodeType) {\n      case ELEMENT_NODE:\n        var attrs = node.attributes;\n        var attrs2 = node2.attributes = new NamedNodeMap();\n        var len = attrs.length;\n        attrs2._ownerElement = node2;\n        for (var i = 0; i < len; i++) {\n          node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));\n        }\n        break;\n      case ATTRIBUTE_NODE:\n        deep = true;\n    }\n    if (deep) {\n      var child = node.firstChild;\n      while (child) {\n        node2.appendChild(cloneNode(doc, child, deep));\n        child = child.nextSibling;\n      }\n    }\n    return node2;\n  }\n  function __set__(object, key, value) {\n    object[key] = value;\n  }\n  //do dynamic\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty(LiveNodeList.prototype, 'length', {\n        get: function () {\n          _updateLiveList(this);\n          return this.$$length;\n        }\n      });\n      Object.defineProperty(Node.prototype, 'textContent', {\n        get: function () {\n          return getTextContent(this);\n        },\n        set: function (data) {\n          switch (this.nodeType) {\n            case ELEMENT_NODE:\n            case DOCUMENT_FRAGMENT_NODE:\n              while (this.firstChild) {\n                this.removeChild(this.firstChild);\n              }\n              if (data || String(data)) {\n                this.appendChild(this.ownerDocument.createTextNode(data));\n              }\n              break;\n            default:\n              this.data = data;\n              this.value = data;\n              this.nodeValue = data;\n          }\n        }\n      });\n      function getTextContent(node) {\n        switch (node.nodeType) {\n          case ELEMENT_NODE:\n          case DOCUMENT_FRAGMENT_NODE:\n            var buf = [];\n            node = node.firstChild;\n            while (node) {\n              if (node.nodeType !== 7 && node.nodeType !== 8) {\n                buf.push(getTextContent(node));\n              }\n              node = node.nextSibling;\n            }\n            return buf.join('');\n          default:\n            return node.nodeValue;\n        }\n      }\n      __set__ = function (object, key, value) {\n        //console.log(value)\n        object['$$' + key] = value;\n      };\n    }\n  } catch (e) {//ie8\n  }\n\n  //if(typeof require == 'function'){\n  var DocumentType_1 = DocumentType;\n  var DOMException_1 = DOMException;\n  var DOMImplementation_1 = DOMImplementation$1;\n  var Element_1 = Element;\n  var Node_1 = Node;\n  var NodeList_1 = NodeList;\n  var XMLSerializer_1 = XMLSerializer;\n  //}\n\n  var dom = {\n    DocumentType: DocumentType_1,\n    DOMException: DOMException_1,\n    DOMImplementation: DOMImplementation_1,\n    Element: Element_1,\n    Node: Node_1,\n    NodeList: NodeList_1,\n    XMLSerializer: XMLSerializer_1\n  };\n\n  var entities = createCommonjsModule(function (module, exports) {\n    var freeze = conventions.freeze;\n\n    /**\n     * The entities that are predefined in every XML document.\n     *\n     * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1\n     * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0\n     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia\n     */\n    exports.XML_ENTITIES = freeze({\n      amp: '&',\n      apos: \"'\",\n      gt: '>',\n      lt: '<',\n      quot: '\"'\n    });\n\n    /**\n     * A map of currently 241 entities that are detected in an HTML document.\n     * They contain all entries from `XML_ENTITIES`.\n     *\n     * @see XML_ENTITIES\n     * @see DOMParser.parseFromString\n     * @see DOMImplementation.prototype.createHTMLDocument\n     * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec\n     * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names\n     * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML\n     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)\n     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)\n     */\n    exports.HTML_ENTITIES = freeze({\n      lt: '<',\n      gt: '>',\n      amp: '&',\n      quot: '\"',\n      apos: \"'\",\n      Agrave: \"\",\n      Aacute: \"\",\n      Acirc: \"\",\n      Atilde: \"\",\n      Auml: \"\",\n      Aring: \"\",\n      AElig: \"\",\n      Ccedil: \"\",\n      Egrave: \"\",\n      Eacute: \"\",\n      Ecirc: \"\",\n      Euml: \"\",\n      Igrave: \"\",\n      Iacute: \"\",\n      Icirc: \"\",\n      Iuml: \"\",\n      ETH: \"\",\n      Ntilde: \"\",\n      Ograve: \"\",\n      Oacute: \"\",\n      Ocirc: \"\",\n      Otilde: \"\",\n      Ouml: \"\",\n      Oslash: \"\",\n      Ugrave: \"\",\n      Uacute: \"\",\n      Ucirc: \"\",\n      Uuml: \"\",\n      Yacute: \"\",\n      THORN: \"\",\n      szlig: \"\",\n      agrave: \"\",\n      aacute: \"\",\n      acirc: \"\",\n      atilde: \"\",\n      auml: \"\",\n      aring: \"\",\n      aelig: \"\",\n      ccedil: \"\",\n      egrave: \"\",\n      eacute: \"\",\n      ecirc: \"\",\n      euml: \"\",\n      igrave: \"\",\n      iacute: \"\",\n      icirc: \"\",\n      iuml: \"\",\n      eth: \"\",\n      ntilde: \"\",\n      ograve: \"\",\n      oacute: \"\",\n      ocirc: \"\",\n      otilde: \"\",\n      ouml: \"\",\n      oslash: \"\",\n      ugrave: \"\",\n      uacute: \"\",\n      ucirc: \"\",\n      uuml: \"\",\n      yacute: \"\",\n      thorn: \"\",\n      yuml: \"\",\n      nbsp: \"\\u00a0\",\n      iexcl: \"\",\n      cent: \"\",\n      pound: \"\",\n      curren: \"\",\n      yen: \"\",\n      brvbar: \"\",\n      sect: \"\",\n      uml: \"\",\n      copy: \"\",\n      ordf: \"\",\n      laquo: \"\",\n      not: \"\",\n      shy: \"\",\n      reg: \"\",\n      macr: \"\",\n      deg: \"\",\n      plusmn: \"\",\n      sup2: \"\",\n      sup3: \"\",\n      acute: \"\",\n      micro: \"\",\n      para: \"\",\n      middot: \"\",\n      cedil: \"\",\n      sup1: \"\",\n      ordm: \"\",\n      raquo: \"\",\n      frac14: \"\",\n      frac12: \"\",\n      frac34: \"\",\n      iquest: \"\",\n      times: \"\",\n      divide: \"\",\n      forall: \"\",\n      part: \"\",\n      exist: \"\",\n      empty: \"\",\n      nabla: \"\",\n      isin: \"\",\n      notin: \"\",\n      ni: \"\",\n      prod: \"\",\n      sum: \"\",\n      minus: \"\",\n      lowast: \"\",\n      radic: \"\",\n      prop: \"\",\n      infin: \"\",\n      ang: \"\",\n      and: \"\",\n      or: \"\",\n      cap: \"\",\n      cup: \"\",\n      'int': \"\",\n      there4: \"\",\n      sim: \"\",\n      cong: \"\",\n      asymp: \"\",\n      ne: \"\",\n      equiv: \"\",\n      le: \"\",\n      ge: \"\",\n      sub: \"\",\n      sup: \"\",\n      nsub: \"\",\n      sube: \"\",\n      supe: \"\",\n      oplus: \"\",\n      otimes: \"\",\n      perp: \"\",\n      sdot: \"\",\n      Alpha: \"\",\n      Beta: \"\",\n      Gamma: \"\",\n      Delta: \"\",\n      Epsilon: \"\",\n      Zeta: \"\",\n      Eta: \"\",\n      Theta: \"\",\n      Iota: \"\",\n      Kappa: \"\",\n      Lambda: \"\",\n      Mu: \"\",\n      Nu: \"\",\n      Xi: \"\",\n      Omicron: \"\",\n      Pi: \"\",\n      Rho: \"\",\n      Sigma: \"\",\n      Tau: \"\",\n      Upsilon: \"\",\n      Phi: \"\",\n      Chi: \"\",\n      Psi: \"\",\n      Omega: \"\",\n      alpha: \"\",\n      beta: \"\",\n      gamma: \"\",\n      delta: \"\",\n      epsilon: \"\",\n      zeta: \"\",\n      eta: \"\",\n      theta: \"\",\n      iota: \"\",\n      kappa: \"\",\n      lambda: \"\",\n      mu: \"\",\n      nu: \"\",\n      xi: \"\",\n      omicron: \"\",\n      pi: \"\",\n      rho: \"\",\n      sigmaf: \"\",\n      sigma: \"\",\n      tau: \"\",\n      upsilon: \"\",\n      phi: \"\",\n      chi: \"\",\n      psi: \"\",\n      omega: \"\",\n      thetasym: \"\",\n      upsih: \"\",\n      piv: \"\",\n      OElig: \"\",\n      oelig: \"\",\n      Scaron: \"\",\n      scaron: \"\",\n      Yuml: \"\",\n      fnof: \"\",\n      circ: \"\",\n      tilde: \"\",\n      ensp: \"\",\n      emsp: \"\",\n      thinsp: \"\",\n      zwnj: \"\",\n      zwj: \"\",\n      lrm: \"\",\n      rlm: \"\",\n      ndash: \"\",\n      mdash: \"\",\n      lsquo: \"\",\n      rsquo: \"\",\n      sbquo: \"\",\n      ldquo: \"\",\n      rdquo: \"\",\n      bdquo: \"\",\n      dagger: \"\",\n      Dagger: \"\",\n      bull: \"\",\n      hellip: \"\",\n      permil: \"\",\n      prime: \"\",\n      Prime: \"\",\n      lsaquo: \"\",\n      rsaquo: \"\",\n      oline: \"\",\n      euro: \"\",\n      trade: \"\",\n      larr: \"\",\n      uarr: \"\",\n      rarr: \"\",\n      darr: \"\",\n      harr: \"\",\n      crarr: \"\",\n      lceil: \"\",\n      rceil: \"\",\n      lfloor: \"\",\n      rfloor: \"\",\n      loz: \"\",\n      spades: \"\",\n      clubs: \"\",\n      hearts: \"\",\n      diams: \"\"\n    });\n\n    /**\n     * @deprecated use `HTML_ENTITIES` instead\n     * @see HTML_ENTITIES\n     */\n    exports.entityMap = exports.HTML_ENTITIES;\n  });\n  entities.XML_ENTITIES;\n  entities.HTML_ENTITIES;\n  entities.entityMap;\n\n  var NAMESPACE$1 = conventions.NAMESPACE;\n\n  //[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n  //[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n  //[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\n  var nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\n  var nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\n  var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$');\n  //var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n  //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n  //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n  //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n  var S_TAG = 0; //tag name offerring\n  var S_ATTR = 1; //attr name offerring\n  var S_ATTR_SPACE = 2; //attr name end and space offer\n  var S_EQ = 3; //=space?\n  var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\n  var S_ATTR_END = 5; //attr value end and no space(quot end)\n  var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\n  var S_TAG_CLOSE = 7; //closed el<el />\n\n  /**\n   * Creates an error that will not be caught by XMLReader aka the SAX parser.\n   *\n   * @param {string} message\n   * @param {any?} locator Optional, can provide details about the location in the source\n   * @constructor\n   */\n  function ParseError$1(message, locator) {\n    this.message = message;\n    this.locator = locator;\n    if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError$1);\n  }\n  ParseError$1.prototype = new Error();\n  ParseError$1.prototype.name = ParseError$1.name;\n  function XMLReader$1() {}\n  XMLReader$1.prototype = {\n    parse: function (source, defaultNSMap, entityMap) {\n      var domBuilder = this.domBuilder;\n      domBuilder.startDocument();\n      _copy(defaultNSMap, defaultNSMap = {});\n      parse$1(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n      domBuilder.endDocument();\n    }\n  };\n  function parse$1(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n    function fixedFromCharCode(code) {\n      // String.prototype.fromCharCode does not supports\n      // > 2 bytes unicode chars directly\n      if (code > 0xffff) {\n        code -= 0x10000;\n        var surrogate1 = 0xd800 + (code >> 10),\n          surrogate2 = 0xdc00 + (code & 0x3ff);\n        return String.fromCharCode(surrogate1, surrogate2);\n      } else {\n        return String.fromCharCode(code);\n      }\n    }\n    function entityReplacer(a) {\n      var k = a.slice(1, -1);\n      if (Object.hasOwnProperty.call(entityMap, k)) {\n        return entityMap[k];\n      } else if (k.charAt(0) === '#') {\n        return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\n      } else {\n        errorHandler.error('entity not found:' + a);\n        return a;\n      }\n    }\n    function appendText(end) {\n      //has some bugs\n      if (end > start) {\n        var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\n        locator && position(start);\n        domBuilder.characters(xt, 0, end - start);\n        start = end;\n      }\n    }\n    function position(p, m) {\n      while (p >= lineEnd && (m = linePattern.exec(source))) {\n        lineStart = m.index;\n        lineEnd = lineStart + m[0].length;\n        locator.lineNumber++;\n        //console.log('line++:',locator,startPos,endPos)\n      }\n\n      locator.columnNumber = p - lineStart + 1;\n    }\n    var lineStart = 0;\n    var lineEnd = 0;\n    var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g;\n    var locator = domBuilder.locator;\n    var parseStack = [{\n      currentNSMap: defaultNSMapCopy\n    }];\n    var closeMap = {};\n    var start = 0;\n    while (true) {\n      try {\n        var tagStart = source.indexOf('<', start);\n        if (tagStart < 0) {\n          if (!source.substr(start).match(/^\\s*$/)) {\n            var doc = domBuilder.doc;\n            var text = doc.createTextNode(source.substr(start));\n            doc.appendChild(text);\n            domBuilder.currentElement = text;\n          }\n          return;\n        }\n        if (tagStart > start) {\n          appendText(tagStart);\n        }\n        switch (source.charAt(tagStart + 1)) {\n          case '/':\n            var end = source.indexOf('>', tagStart + 3);\n            var tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\n            var config = parseStack.pop();\n            if (end < 0) {\n              tagName = source.substring(tagStart + 2).replace(/[\\s<].*/, '');\n              errorHandler.error(\"end tag name: \" + tagName + ' is not complete:' + config.tagName);\n              end = tagStart + 1 + tagName.length;\n            } else if (tagName.match(/\\s</)) {\n              tagName = tagName.replace(/[\\s<].*/, '');\n              errorHandler.error(\"end tag name: \" + tagName + ' maybe not complete');\n              end = tagStart + 1 + tagName.length;\n            }\n            var localNSMap = config.localNSMap;\n            var endMatch = config.tagName == tagName;\n            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();\n            if (endIgnoreCaseMach) {\n              domBuilder.endElement(config.uri, config.localName, tagName);\n              if (localNSMap) {\n                for (var prefix in localNSMap) {\n                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n                    domBuilder.endPrefixMapping(prefix);\n                  }\n                }\n              }\n              if (!endMatch) {\n                errorHandler.fatalError(\"end tag name: \" + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case\n              }\n            } else {\n              parseStack.push(config);\n            }\n            end++;\n            break;\n          // end elment\n          case '?':\n            // <?...?>\n            locator && position(tagStart);\n            end = parseInstruction(source, tagStart, domBuilder);\n            break;\n          case '!':\n            // <!doctype,<![CDATA,<!--\n            locator && position(tagStart);\n            end = parseDCC(source, tagStart, domBuilder, errorHandler);\n            break;\n          default:\n            locator && position(tagStart);\n            var el = new ElementAttributes();\n            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n            //elStartEnd\n            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);\n            var len = el.length;\n            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\n              el.closed = true;\n              if (!entityMap.nbsp) {\n                errorHandler.warning('unclosed xml attribute');\n              }\n            }\n            if (locator && len) {\n              var locator2 = copyLocator(locator, {});\n              //try{//attribute position fixed\n              for (var i = 0; i < len; i++) {\n                var a = el[i];\n                position(a.offset);\n                a.locator = copyLocator(locator, {});\n              }\n              domBuilder.locator = locator2;\n              if (appendElement$1(el, domBuilder, currentNSMap)) {\n                parseStack.push(el);\n              }\n              domBuilder.locator = locator;\n            } else {\n              if (appendElement$1(el, domBuilder, currentNSMap)) {\n                parseStack.push(el);\n              }\n            }\n            if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {\n              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n            } else {\n              end++;\n            }\n        }\n      } catch (e) {\n        if (e instanceof ParseError$1) {\n          throw e;\n        }\n        errorHandler.error('element parse error: ' + e);\n        end = -1;\n      }\n      if (end > start) {\n        start = end;\n      } else {\n        //TODO: sax\n        appendText(Math.max(tagStart, start) + 1);\n      }\n    }\n  }\n  function copyLocator(f, t) {\n    t.lineNumber = f.lineNumber;\n    t.columnNumber = f.columnNumber;\n    return t;\n  }\n\n  /**\n   * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\n   * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\n   */\n  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {\n    /**\n     * @param {string} qname\n     * @param {string} value\n     * @param {number} startIndex\n     */\n    function addAttribute(qname, value, startIndex) {\n      if (el.attributeNames.hasOwnProperty(qname)) {\n        errorHandler.fatalError('Attribute ' + qname + ' redefined');\n      }\n      el.addValue(qname,\n      // @see https://www.w3.org/TR/xml/#AVNormalize\n      // since the xmldom sax parser does not \"interpret\" DTD the following is not implemented:\n      // - recursive replacement of (DTD) entity references\n      // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA\n      value.replace(/[\\t\\n\\r]/g, ' ').replace(/&#?\\w+;/g, entityReplacer), startIndex);\n    }\n    var attrName;\n    var value;\n    var p = ++start;\n    var s = S_TAG; //status\n    while (true) {\n      var c = source.charAt(p);\n      switch (c) {\n        case '=':\n          if (s === S_ATTR) {\n            //attrName\n            attrName = source.slice(start, p);\n            s = S_EQ;\n          } else if (s === S_ATTR_SPACE) {\n            s = S_EQ;\n          } else {\n            //fatalError: equal must after attrName or space after attrName\n            throw new Error('attribute equal must after attrName'); // No known test case\n          }\n\n          break;\n        case '\\'':\n        case '\"':\n          if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n          ) {\n            //equal\n            if (s === S_ATTR) {\n              errorHandler.warning('attribute value must after \"=\"');\n              attrName = source.slice(start, p);\n            }\n            start = p + 1;\n            p = source.indexOf(c, start);\n            if (p > 0) {\n              value = source.slice(start, p);\n              addAttribute(attrName, value, start - 1);\n              s = S_ATTR_END;\n            } else {\n              //fatalError: no end quot match\n              throw new Error('attribute value no end \\'' + c + '\\' match');\n            }\n          } else if (s == S_ATTR_NOQUOT_VALUE) {\n            value = source.slice(start, p);\n            addAttribute(attrName, value, start);\n            errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n            start = p + 1;\n            s = S_ATTR_END;\n          } else {\n            //fatalError: no equal before\n            throw new Error('attribute value must after \"=\"'); // No known test case\n          }\n\n          break;\n        case '/':\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p));\n            case S_ATTR_END:\n            case S_TAG_SPACE:\n            case S_TAG_CLOSE:\n              s = S_TAG_CLOSE;\n              el.closed = true;\n            case S_ATTR_NOQUOT_VALUE:\n            case S_ATTR:\n            case S_ATTR_SPACE:\n              break;\n            //case S_EQ:\n            default:\n              throw new Error(\"attribute invalid close char('/')\");\n            // No known test case\n          }\n\n          break;\n        case '':\n          //end document\n          errorHandler.error('unexpected end of input');\n          if (s == S_TAG) {\n            el.setTagName(source.slice(start, p));\n          }\n          return p;\n        case '>':\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p));\n            case S_ATTR_END:\n            case S_TAG_SPACE:\n            case S_TAG_CLOSE:\n              break;\n            //normal\n            case S_ATTR_NOQUOT_VALUE: //Compatible state\n            case S_ATTR:\n              value = source.slice(start, p);\n              if (value.slice(-1) === '/') {\n                el.closed = true;\n                value = value.slice(0, -1);\n              }\n            case S_ATTR_SPACE:\n              if (s === S_ATTR_SPACE) {\n                value = attrName;\n              }\n              if (s == S_ATTR_NOQUOT_VALUE) {\n                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\n                addAttribute(attrName, value, start);\n              } else {\n                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {\n                  errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n                }\n                addAttribute(value, value, start);\n              }\n              break;\n            case S_EQ:\n              throw new Error('attribute value missed!!');\n          }\n          //\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n          return p;\n        /*xml space '\\x20' | #x9 | #xD | #xA; */\n        case '\\u0080':\n          c = ' ';\n        default:\n          if (c <= ' ') {\n            //space\n            switch (s) {\n              case S_TAG:\n                el.setTagName(source.slice(start, p)); //tagName\n                s = S_TAG_SPACE;\n                break;\n              case S_ATTR:\n                attrName = source.slice(start, p);\n                s = S_ATTR_SPACE;\n                break;\n              case S_ATTR_NOQUOT_VALUE:\n                var value = source.slice(start, p);\n                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n                addAttribute(attrName, value, start);\n              case S_ATTR_END:\n                s = S_TAG_SPACE;\n                break;\n              //case S_TAG_SPACE:\n              //case S_EQ:\n              //case S_ATTR_SPACE:\n              //\tvoid();break;\n              //case S_TAG_CLOSE:\n              //ignore warning\n            }\n          } else {\n            //not space\n            //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n            //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n            switch (s) {\n              //case S_TAG:void();break;\n              //case S_ATTR:void();break;\n              //case S_ATTR_NOQUOT_VALUE:void();break;\n              case S_ATTR_SPACE:\n                el.tagName;\n                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n                  errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n                }\n                addAttribute(attrName, attrName, start);\n                start = p;\n                s = S_ATTR;\n                break;\n              case S_ATTR_END:\n                errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n              case S_TAG_SPACE:\n                s = S_ATTR;\n                start = p;\n                break;\n              case S_EQ:\n                s = S_ATTR_NOQUOT_VALUE;\n                start = p;\n                break;\n              case S_TAG_CLOSE:\n                throw new Error(\"elements closed character '/' and '>' must be connected to\");\n            }\n          }\n      } //end outer switch\n      //console.log('p++',p)\n      p++;\n    }\n  }\n  /**\n   * @return true if has new namespace define\n   */\n  function appendElement$1(el, domBuilder, currentNSMap) {\n    var tagName = el.tagName;\n    var localNSMap = null;\n    //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n    var i = el.length;\n    while (i--) {\n      var a = el[i];\n      var qName = a.qName;\n      var value = a.value;\n      var nsp = qName.indexOf(':');\n      if (nsp > 0) {\n        var prefix = a.prefix = qName.slice(0, nsp);\n        var localName = qName.slice(nsp + 1);\n        var nsPrefix = prefix === 'xmlns' && localName;\n      } else {\n        localName = qName;\n        prefix = null;\n        nsPrefix = qName === 'xmlns' && '';\n      }\n      //can not set prefix,because prefix !== ''\n      a.localName = localName;\n      //prefix == null for no ns prefix attribute\n      if (nsPrefix !== false) {\n        //hack!!\n        if (localNSMap == null) {\n          localNSMap = {};\n          //console.log(currentNSMap,0)\n          _copy(currentNSMap, currentNSMap = {});\n          //console.log(currentNSMap,1)\n        }\n\n        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n        a.uri = NAMESPACE$1.XMLNS;\n        domBuilder.startPrefixMapping(nsPrefix, value);\n      }\n    }\n    var i = el.length;\n    while (i--) {\n      a = el[i];\n      var prefix = a.prefix;\n      if (prefix) {\n        //no prefix attribute has no namespace\n        if (prefix === 'xml') {\n          a.uri = NAMESPACE$1.XML;\n        }\n        if (prefix !== 'xmlns') {\n          a.uri = currentNSMap[prefix || ''];\n\n          //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n        }\n      }\n    }\n\n    var nsp = tagName.indexOf(':');\n    if (nsp > 0) {\n      prefix = el.prefix = tagName.slice(0, nsp);\n      localName = el.localName = tagName.slice(nsp + 1);\n    } else {\n      prefix = null; //important!!\n      localName = el.localName = tagName;\n    }\n    //no prefix element has default namespace\n    var ns = el.uri = currentNSMap[prefix || ''];\n    domBuilder.startElement(ns, localName, tagName, el);\n    //endPrefixMapping and startPrefixMapping have not any help for dom builder\n    //localNSMap = null\n    if (el.closed) {\n      domBuilder.endElement(ns, localName, tagName);\n      if (localNSMap) {\n        for (prefix in localNSMap) {\n          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n            domBuilder.endPrefixMapping(prefix);\n          }\n        }\n      }\n    } else {\n      el.currentNSMap = currentNSMap;\n      el.localNSMap = localNSMap;\n      //parseStack.push(el);\n      return true;\n    }\n  }\n  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n    if (/^(?:script|textarea)$/i.test(tagName)) {\n      var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n      var text = source.substring(elStartEnd + 1, elEndStart);\n      if (/[&<]/.test(text)) {\n        if (/^script$/i.test(tagName)) {\n          //if(!/\\]\\]>/.test(text)){\n          //lexHandler.startCDATA();\n          domBuilder.characters(text, 0, text.length);\n          //lexHandler.endCDATA();\n          return elEndStart;\n          //}\n        } //}else{//text area\n        text = text.replace(/&#?\\w+;/g, entityReplacer);\n        domBuilder.characters(text, 0, text.length);\n        return elEndStart;\n        //}\n      }\n    }\n\n    return elStartEnd + 1;\n  }\n  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {\n    //if(tagName in closeMap){\n    var pos = closeMap[tagName];\n    if (pos == null) {\n      //console.log(tagName)\n      pos = source.lastIndexOf('</' + tagName + '>');\n      if (pos < elStartEnd) {\n        //\n        pos = source.lastIndexOf('</' + tagName);\n      }\n      closeMap[tagName] = pos;\n    }\n    return pos < elStartEnd;\n    //}\n  }\n\n  function _copy(source, target) {\n    for (var n in source) {\n      if (Object.prototype.hasOwnProperty.call(source, n)) {\n        target[n] = source[n];\n      }\n    }\n  }\n  function parseDCC(source, start, domBuilder, errorHandler) {\n    //sure start with '<!'\n    var next = source.charAt(start + 2);\n    switch (next) {\n      case '-':\n        if (source.charAt(start + 3) === '-') {\n          var end = source.indexOf('-->', start + 4);\n          //append comment source.substring(4,end)//<!--\n          if (end > start) {\n            domBuilder.comment(source, start + 4, end - start - 4);\n            return end + 3;\n          } else {\n            errorHandler.error(\"Unclosed comment\");\n            return -1;\n          }\n        } else {\n          //error\n          return -1;\n        }\n      default:\n        if (source.substr(start + 3, 6) == 'CDATA[') {\n          var end = source.indexOf(']]>', start + 9);\n          domBuilder.startCDATA();\n          domBuilder.characters(source, start + 9, end - start - 9);\n          domBuilder.endCDATA();\n          return end + 3;\n        }\n        //<!DOCTYPE\n        //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)\n        var matchs = split(source, start);\n        var len = matchs.length;\n        if (len > 1 && /!doctype/i.test(matchs[0][0])) {\n          var name = matchs[1][0];\n          var pubid = false;\n          var sysid = false;\n          if (len > 3) {\n            if (/^public$/i.test(matchs[2][0])) {\n              pubid = matchs[3][0];\n              sysid = len > 4 && matchs[4][0];\n            } else if (/^system$/i.test(matchs[2][0])) {\n              sysid = matchs[3][0];\n            }\n          }\n          var lastMatch = matchs[len - 1];\n          domBuilder.startDTD(name, pubid, sysid);\n          domBuilder.endDTD();\n          return lastMatch.index + lastMatch[0].length;\n        }\n    }\n    return -1;\n  }\n  function parseInstruction(source, start, domBuilder) {\n    var end = source.indexOf('?>', start);\n    if (end) {\n      var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n      if (match) {\n        match[0].length;\n        domBuilder.processingInstruction(match[1], match[2]);\n        return end + 2;\n      } else {\n        //error\n        return -1;\n      }\n    }\n    return -1;\n  }\n  function ElementAttributes() {\n    this.attributeNames = {};\n  }\n  ElementAttributes.prototype = {\n    setTagName: function (tagName) {\n      if (!tagNamePattern.test(tagName)) {\n        throw new Error('invalid tagName:' + tagName);\n      }\n      this.tagName = tagName;\n    },\n    addValue: function (qName, value, offset) {\n      if (!tagNamePattern.test(qName)) {\n        throw new Error('invalid attribute:' + qName);\n      }\n      this.attributeNames[qName] = this.length;\n      this[this.length++] = {\n        qName: qName,\n        value: value,\n        offset: offset\n      };\n    },\n    length: 0,\n    getLocalName: function (i) {\n      return this[i].localName;\n    },\n    getLocator: function (i) {\n      return this[i].locator;\n    },\n    getQName: function (i) {\n      return this[i].qName;\n    },\n    getURI: function (i) {\n      return this[i].uri;\n    },\n    getValue: function (i) {\n      return this[i].value;\n    }\n    //\t,getIndex:function(uri, localName)){\n    //\t\tif(localName){\n    //\n    //\t\t}else{\n    //\t\t\tvar qName = uri\n    //\t\t}\n    //\t},\n    //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n    //\tgetType:function(uri,localName){}\n    //\tgetType:function(i){},\n  };\n\n  function split(source, start) {\n    var match;\n    var buf = [];\n    var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n    reg.lastIndex = start;\n    reg.exec(source); //skip <\n    while (match = reg.exec(source)) {\n      buf.push(match);\n      if (match[1]) return buf;\n    }\n  }\n  var XMLReader_1 = XMLReader$1;\n  var ParseError_1 = ParseError$1;\n  var sax = {\n    XMLReader: XMLReader_1,\n    ParseError: ParseError_1\n  };\n\n  var DOMImplementation = dom.DOMImplementation;\n  var NAMESPACE = conventions.NAMESPACE;\n  var ParseError = sax.ParseError;\n  var XMLReader = sax.XMLReader;\n\n  /**\n   * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:\n   *\n   * > XML parsed entities are often stored in computer files which,\n   * > for editing convenience, are organized into lines.\n   * > These lines are typically separated by some combination\n   * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n   * >\n   * > To simplify the tasks of applications, the XML processor must behave\n   * > as if it normalized all line breaks in external parsed entities (including the document entity)\n   * > on input, before parsing, by translating all of the following to a single #xA character:\n   * >\n   * > 1. the two-character sequence #xD #xA\n   * > 2. the two-character sequence #xD #x85\n   * > 3. the single character #x85\n   * > 4. the single character #x2028\n   * > 5. any #xD character that is not immediately followed by #xA or #x85.\n   *\n   * @param {string} input\n   * @returns {string}\n   */\n  function normalizeLineEndings(input) {\n    return input.replace(/\\r[\\n\\u0085]/g, '\\n').replace(/[\\r\\u0085\\u2028]/g, '\\n');\n  }\n\n  /**\n   * @typedef Locator\n   * @property {number} [columnNumber]\n   * @property {number} [lineNumber]\n   */\n\n  /**\n   * @typedef DOMParserOptions\n   * @property {DOMHandler} [domBuilder]\n   * @property {Function} [errorHandler]\n   * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing\n   * \t\t\t\t\t\tdefaults to `normalizeLineEndings`\n   * @property {Locator} [locator]\n   * @property {Record<string, string>} [xmlns]\n   *\n   * @see normalizeLineEndings\n   */\n\n  /**\n   * The DOMParser interface provides the ability to parse XML or HTML source code\n   * from a string into a DOM `Document`.\n   *\n   * _xmldom is different from the spec in that it allows an `options` parameter,\n   * to override the default behavior._\n   *\n   * @param {DOMParserOptions} [options]\n   * @constructor\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n   */\n  function DOMParser$1(options) {\n    this.options = options || {\n      locator: {}\n    };\n  }\n  DOMParser$1.prototype.parseFromString = function (source, mimeType) {\n    var options = this.options;\n    var sax = new XMLReader();\n    var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\n    var errorHandler = options.errorHandler;\n    var locator = options.locator;\n    var defaultNSMap = options.xmlns || {};\n    var isHTML = /\\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;\n    var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;\n    if (locator) {\n      domBuilder.setDocumentLocator(locator);\n    }\n    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\n    sax.domBuilder = options.domBuilder || domBuilder;\n    if (isHTML) {\n      defaultNSMap[''] = NAMESPACE.HTML;\n    }\n    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n    var normalize = options.normalizeLineEndings || normalizeLineEndings;\n    if (source && typeof source === 'string') {\n      sax.parse(normalize(source), defaultNSMap, entityMap);\n    } else {\n      sax.errorHandler.error('invalid doc source');\n    }\n    return domBuilder.doc;\n  };\n  function buildErrorHandler(errorImpl, domBuilder, locator) {\n    if (!errorImpl) {\n      if (domBuilder instanceof DOMHandler) {\n        return domBuilder;\n      }\n      errorImpl = domBuilder;\n    }\n    var errorHandler = {};\n    var isCallback = errorImpl instanceof Function;\n    locator = locator || {};\n    function build(key) {\n      var fn = errorImpl[key];\n      if (!fn && isCallback) {\n        fn = errorImpl.length == 2 ? function (msg) {\n          errorImpl(key, msg);\n        } : errorImpl;\n      }\n      errorHandler[key] = fn && function (msg) {\n        fn('[xmldom ' + key + ']\\t' + msg + _locator(locator));\n      } || function () {};\n    }\n    build('warning');\n    build('error');\n    build('fatalError');\n    return errorHandler;\n  }\n\n  //console.log('#\\n\\n\\n\\n\\n\\n\\n####')\n  /**\n   * +ContentHandler+ErrorHandler\n   * +LexicalHandler+EntityResolver2\n   * -DeclHandler-DTDHandler\n   *\n   * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\n   * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\n   */\n  function DOMHandler() {\n    this.cdata = false;\n  }\n  function position(locator, node) {\n    node.lineNumber = locator.lineNumber;\n    node.columnNumber = locator.columnNumber;\n  }\n  /**\n   * @see org.xml.sax.ContentHandler#startDocument\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n   */\n  DOMHandler.prototype = {\n    startDocument: function () {\n      this.doc = new DOMImplementation().createDocument(null, null, null);\n      if (this.locator) {\n        this.doc.documentURI = this.locator.systemId;\n      }\n    },\n    startElement: function (namespaceURI, localName, qName, attrs) {\n      var doc = this.doc;\n      var el = doc.createElementNS(namespaceURI, qName || localName);\n      var len = attrs.length;\n      appendElement(this, el);\n      this.currentElement = el;\n      this.locator && position(this.locator, el);\n      for (var i = 0; i < len; i++) {\n        var namespaceURI = attrs.getURI(i);\n        var value = attrs.getValue(i);\n        var qName = attrs.getQName(i);\n        var attr = doc.createAttributeNS(namespaceURI, qName);\n        this.locator && position(attrs.getLocator(i), attr);\n        attr.value = attr.nodeValue = value;\n        el.setAttributeNode(attr);\n      }\n    },\n    endElement: function (namespaceURI, localName, qName) {\n      var current = this.currentElement;\n      current.tagName;\n      this.currentElement = current.parentNode;\n    },\n    startPrefixMapping: function (prefix, uri) {},\n    endPrefixMapping: function (prefix) {},\n    processingInstruction: function (target, data) {\n      var ins = this.doc.createProcessingInstruction(target, data);\n      this.locator && position(this.locator, ins);\n      appendElement(this, ins);\n    },\n    ignorableWhitespace: function (ch, start, length) {},\n    characters: function (chars, start, length) {\n      chars = _toString.apply(this, arguments);\n      //console.log(chars)\n      if (chars) {\n        if (this.cdata) {\n          var charNode = this.doc.createCDATASection(chars);\n        } else {\n          var charNode = this.doc.createTextNode(chars);\n        }\n        if (this.currentElement) {\n          this.currentElement.appendChild(charNode);\n        } else if (/^\\s*$/.test(chars)) {\n          this.doc.appendChild(charNode);\n          //process xml\n        }\n\n        this.locator && position(this.locator, charNode);\n      }\n    },\n    skippedEntity: function (name) {},\n    endDocument: function () {\n      this.doc.normalize();\n    },\n    setDocumentLocator: function (locator) {\n      if (this.locator = locator) {\n        // && !('lineNumber' in locator)){\n        locator.lineNumber = 0;\n      }\n    },\n    //LexicalHandler\n    comment: function (chars, start, length) {\n      chars = _toString.apply(this, arguments);\n      var comm = this.doc.createComment(chars);\n      this.locator && position(this.locator, comm);\n      appendElement(this, comm);\n    },\n    startCDATA: function () {\n      //used in characters() methods\n      this.cdata = true;\n    },\n    endCDATA: function () {\n      this.cdata = false;\n    },\n    startDTD: function (name, publicId, systemId) {\n      var impl = this.doc.implementation;\n      if (impl && impl.createDocumentType) {\n        var dt = impl.createDocumentType(name, publicId, systemId);\n        this.locator && position(this.locator, dt);\n        appendElement(this, dt);\n        this.doc.doctype = dt;\n      }\n    },\n    /**\n     * @see org.xml.sax.ErrorHandler\n     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n     */\n    warning: function (error) {\n      console.warn('[xmldom warning]\\t' + error, _locator(this.locator));\n    },\n    error: function (error) {\n      console.error('[xmldom error]\\t' + error, _locator(this.locator));\n    },\n    fatalError: function (error) {\n      throw new ParseError(error, this.locator);\n    }\n  };\n  function _locator(l) {\n    if (l) {\n      return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n    }\n  }\n  function _toString(chars, start, length) {\n    if (typeof chars == 'string') {\n      return chars.substr(start, length);\n    } else {\n      //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n      if (chars.length >= start + length || start) {\n        return new java.lang.String(chars, start, length) + '';\n      }\n      return chars;\n    }\n  }\n\n  /*\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n   * used method of org.xml.sax.ext.LexicalHandler:\n   *  #comment(chars, start, length)\n   *  #startCDATA()\n   *  #endCDATA()\n   *  #startDTD(name, publicId, systemId)\n   *\n   *\n   * IGNORED method of org.xml.sax.ext.LexicalHandler:\n   *  #endDTD()\n   *  #startEntity(name)\n   *  #endEntity(name)\n   *\n   *\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n   * IGNORED method of org.xml.sax.ext.DeclHandler\n   * \t#attributeDecl(eName, aName, type, mode, value)\n   *  #elementDecl(name, model)\n   *  #externalEntityDecl(name, publicId, systemId)\n   *  #internalEntityDecl(name, value)\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n   * IGNORED method of org.xml.sax.EntityResolver2\n   *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n   *  #resolveEntity(publicId, systemId)\n   *  #getExternalSubset(name, baseURI)\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n   * IGNORED method of org.xml.sax.DTDHandler\n   *  #notationDecl(name, publicId, systemId) {};\n   *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n   */\n  \"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\n    DOMHandler.prototype[key] = function () {\n      return null;\n    };\n  });\n\n  /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\n  function appendElement(hander, node) {\n    if (!hander.currentElement) {\n      hander.doc.appendChild(node);\n    } else {\n      hander.currentElement.appendChild(node);\n    }\n  } //appendChild and setAttributeNS are preformance key\n\n  var __DOMHandler = DOMHandler;\n  var normalizeLineEndings_1 = normalizeLineEndings;\n  var DOMParser_1 = DOMParser$1;\n  var domParser = {\n    __DOMHandler: __DOMHandler,\n    normalizeLineEndings: normalizeLineEndings_1,\n    DOMParser: DOMParser_1\n  };\n\n  var DOMParser = domParser.DOMParser;\n\n  /*! @name mpd-parser @version 1.0.1 @license Apache-2.0 */\n  const isObject = obj => {\n    return !!obj && typeof obj === 'object';\n  };\n  const merge$1 = (...objects) => {\n    return objects.reduce((result, source) => {\n      if (typeof source !== 'object') {\n        return result;\n      }\n      Object.keys(source).forEach(key => {\n        if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n          result[key] = result[key].concat(source[key]);\n        } else if (isObject(result[key]) && isObject(source[key])) {\n          result[key] = merge$1(result[key], source[key]);\n        } else {\n          result[key] = source[key];\n        }\n      });\n      return result;\n    }, {});\n  };\n  const values = o => Object.keys(o).map(k => o[k]);\n  const range = (start, end) => {\n    const result = [];\n    for (let i = start; i < end; i++) {\n      result.push(i);\n    }\n    return result;\n  };\n  const flatten = lists => lists.reduce((x, y) => x.concat(y), []);\n  const from = list => {\n    if (!list.length) {\n      return [];\n    }\n    const result = [];\n    for (let i = 0; i < list.length; i++) {\n      result.push(list[i]);\n    }\n    return result;\n  };\n  const findIndexes = (l, key) => l.reduce((a, e, i) => {\n    if (e[key]) {\n      a.push(i);\n    }\n    return a;\n  }, []);\n  /**\n   * Returns a union of the included lists provided each element can be identified by a key.\n   *\n   * @param {Array} list - list of lists to get the union of\n   * @param {Function} keyFunction - the function to use as a key for each element\n   *\n   * @return {Array} the union of the arrays\n   */\n\n  const union = (lists, keyFunction) => {\n    return values(lists.reduce((acc, list) => {\n      list.forEach(el => {\n        acc[keyFunction(el)] = el;\n      });\n      return acc;\n    }, {}));\n  };\n  var errors = {\n    INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n    DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n    DASH_INVALID_XML: 'DASH_INVALID_XML',\n    NO_BASE_URL: 'NO_BASE_URL',\n    MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n    SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n    UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n  };\n\n  /**\n   * @typedef {Object} SingleUri\n   * @property {string} uri - relative location of segment\n   * @property {string} resolvedUri - resolved location of segment\n   * @property {Object} byterange - Object containing information on how to make byte range\n   *   requests following byte-range-spec per RFC2616.\n   * @property {String} byterange.length - length of range request\n   * @property {String} byterange.offset - byte offset of range request\n   *\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n   */\n\n  /**\n   * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n   * that conforms to how m3u8-parser is structured\n   *\n   * @see https://github.com/videojs/m3u8-parser\n   *\n   * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n   * @param {string} source - source url for segment\n   * @param {string} range - optional range used for range calls,\n   *   follows  RFC 2616, Clause 14.35.1\n   * @return {SingleUri} full segment information transformed into a format similar\n   *   to m3u8-parser\n   */\n\n  const urlTypeToSegment = ({\n    baseUrl = '',\n    source = '',\n    range = '',\n    indexRange = ''\n  }) => {\n    const segment = {\n      uri: source,\n      resolvedUri: resolveUrl$1(baseUrl || '', source)\n    };\n    if (range || indexRange) {\n      const rangeStr = range ? range : indexRange;\n      const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n      let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n      let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n      if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n        startRange = Number(startRange);\n      }\n      if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n        endRange = Number(endRange);\n      }\n      let length;\n      if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n        length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n      } else {\n        length = endRange - startRange + 1;\n      }\n      if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n        length = Number(length);\n      } // byterange should be inclusive according to\n      // RFC 2616, Clause 14.35.1\n\n      segment.byterange = {\n        length,\n        offset: startRange\n      };\n    }\n    return segment;\n  };\n  const byteRangeToString = byterange => {\n    // `endRange` is one less than `offset + length` because the HTTP range\n    // header uses inclusive ranges\n    let endRange;\n    if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n      endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n    } else {\n      endRange = byterange.offset + byterange.length - 1;\n    }\n    return `${byterange.offset}-${endRange}`;\n  };\n\n  /**\n   * parse the end number attribue that can be a string\n   * number, or undefined.\n   *\n   * @param {string|number|undefined} endNumber\n   *        The end number attribute.\n   *\n   * @return {number|null}\n   *          The result of parsing the end number.\n   */\n\n  const parseEndNumber = endNumber => {\n    if (endNumber && typeof endNumber !== 'number') {\n      endNumber = parseInt(endNumber, 10);\n    }\n    if (isNaN(endNumber)) {\n      return null;\n    }\n    return endNumber;\n  };\n  /**\n   * Functions for calculating the range of available segments in static and dynamic\n   * manifests.\n   */\n\n  const segmentRange = {\n    /**\n     * Returns the entire range of available segments for a static MPD\n     *\n     * @param {Object} attributes\n     *        Inheritied MPD attributes\n     * @return {{ start: number, end: number }}\n     *         The start and end numbers for available segments\n     */\n    static(attributes) {\n      const {\n        duration,\n        timescale = 1,\n        sourceDuration,\n        periodDuration\n      } = attributes;\n      const endNumber = parseEndNumber(attributes.endNumber);\n      const segmentDuration = duration / timescale;\n      if (typeof endNumber === 'number') {\n        return {\n          start: 0,\n          end: endNumber\n        };\n      }\n      if (typeof periodDuration === 'number') {\n        return {\n          start: 0,\n          end: periodDuration / segmentDuration\n        };\n      }\n      return {\n        start: 0,\n        end: sourceDuration / segmentDuration\n      };\n    },\n    /**\n     * Returns the current live window range of available segments for a dynamic MPD\n     *\n     * @param {Object} attributes\n     *        Inheritied MPD attributes\n     * @return {{ start: number, end: number }}\n     *         The start and end numbers for available segments\n     */\n    dynamic(attributes) {\n      const {\n        NOW,\n        clientOffset,\n        availabilityStartTime,\n        timescale = 1,\n        duration,\n        periodStart = 0,\n        minimumUpdatePeriod = 0,\n        timeShiftBufferDepth = Infinity\n      } = attributes;\n      const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n      // after retrieving UTC server time.\n\n      const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n      // Convert the period start time to EPOCH.\n\n      const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n      const periodEndWC = now + minimumUpdatePeriod;\n      const periodDuration = periodEndWC - periodStartWC;\n      const segmentCount = Math.ceil(periodDuration * timescale / duration);\n      const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n      const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n      return {\n        start: Math.max(0, availableStart),\n        end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n      };\n    }\n  };\n  /**\n   * Maps a range of numbers to objects with information needed to build the corresponding\n   * segment list\n   *\n   * @name toSegmentsCallback\n   * @function\n   * @param {number} number\n   *        Number of the segment\n   * @param {number} index\n   *        Index of the number in the range list\n   * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n   *         Object with segment timing and duration info\n   */\n\n  /**\n   * Returns a callback for Array.prototype.map for mapping a range of numbers to\n   * information needed to build the segment list.\n   *\n   * @param {Object} attributes\n   *        Inherited MPD attributes\n   * @return {toSegmentsCallback}\n   *         Callback map function\n   */\n\n  const toSegments = attributes => number => {\n    const {\n      duration,\n      timescale = 1,\n      periodStart,\n      startNumber = 1\n    } = attributes;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodStart,\n      time: number * duration\n    };\n  };\n  /**\n   * Returns a list of objects containing segment timing and duration info used for\n   * building the list of segments. This uses the @duration attribute specified\n   * in the MPD manifest to derive the range of segments.\n   *\n   * @param {Object} attributes\n   *        Inherited MPD attributes\n   * @return {{number: number, duration: number, time: number, timeline: number}[]}\n   *         List of Objects with segment timing and duration info\n   */\n\n  const parseByDuration = attributes => {\n    const {\n      type,\n      duration,\n      timescale = 1,\n      periodDuration,\n      sourceDuration\n    } = attributes;\n    const {\n      start,\n      end\n    } = segmentRange[type](attributes);\n    const segments = range(start, end).map(toSegments(attributes));\n    if (type === 'static') {\n      const index = segments.length - 1; // section is either a period or the full source\n\n      const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n      segments[index].duration = sectionDuration - duration / timescale * index;\n    }\n    return segments;\n  };\n\n  /**\n   * Translates SegmentBase into a set of segments.\n   * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n   * node should be translated into segment.\n   *\n   * @param {Object} attributes\n   *   Object containing all inherited attributes from parent elements with attribute\n   *   names as keys\n   * @return {Object.<Array>} list of segments\n   */\n\n  const segmentsFromBase = attributes => {\n    const {\n      baseUrl,\n      initialization = {},\n      sourceDuration,\n      indexRange = '',\n      periodStart,\n      presentationTime,\n      number = 0,\n      duration\n    } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n    if (!baseUrl) {\n      throw new Error(errors.NO_BASE_URL);\n    }\n    const initSegment = urlTypeToSegment({\n      baseUrl,\n      source: initialization.sourceURL,\n      range: initialization.range\n    });\n    const segment = urlTypeToSegment({\n      baseUrl,\n      source: baseUrl,\n      indexRange\n    });\n    segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n    // (since SegmentBase is only for one total segment)\n\n    if (duration) {\n      const segmentTimeInfo = parseByDuration(attributes);\n      if (segmentTimeInfo.length) {\n        segment.duration = segmentTimeInfo[0].duration;\n        segment.timeline = segmentTimeInfo[0].timeline;\n      }\n    } else if (sourceDuration) {\n      segment.duration = sourceDuration;\n      segment.timeline = periodStart;\n    } // If presentation time is provided, these segments are being generated by SIDX\n    // references, and should use the time provided. For the general case of SegmentBase,\n    // there should only be one segment in the period, so its presentation time is the same\n    // as its period start.\n\n    segment.presentationTime = presentationTime || periodStart;\n    segment.number = number;\n    return [segment];\n  };\n  /**\n   * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n   * according to the sidx information given.\n   *\n   * playlist.sidx has metadadata about the sidx where-as the sidx param\n   * is the parsed sidx box itself.\n   *\n   * @param {Object} playlist the playlist to update the sidx information for\n   * @param {Object} sidx the parsed sidx box\n   * @return {Object} the playlist object with the updated sidx information\n   */\n\n  const addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n    // Retain init segment information\n    const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n    const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n    const timeline = playlist.timeline || 0;\n    const sidxByteRange = playlist.sidx.byterange;\n    const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n    const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n    const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n    const segments = [];\n    const type = playlist.endList ? 'static' : 'dynamic';\n    const periodStart = playlist.sidx.timeline;\n    let presentationTime = periodStart;\n    let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n    let startIndex; // eslint-disable-next-line\n\n    if (typeof sidx.firstOffset === 'bigint') {\n      startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n    } else {\n      startIndex = sidxEnd + sidx.firstOffset;\n    }\n    for (let i = 0; i < mediaReferences.length; i++) {\n      const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n      const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n      // this will be converted to seconds when generating segments\n\n      const duration = reference.subsegmentDuration; // should be an inclusive range\n\n      let endIndex; // eslint-disable-next-line\n\n      if (typeof startIndex === 'bigint') {\n        endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n      } else {\n        endIndex = startIndex + size - 1;\n      }\n      const indexRange = `${startIndex}-${endIndex}`;\n      const attributes = {\n        baseUrl,\n        timescale,\n        timeline,\n        periodStart,\n        presentationTime,\n        number,\n        duration,\n        sourceDuration,\n        indexRange,\n        type\n      };\n      const segment = segmentsFromBase(attributes)[0];\n      if (initSegment) {\n        segment.map = initSegment;\n      }\n      segments.push(segment);\n      if (typeof startIndex === 'bigint') {\n        startIndex += window.BigInt(size);\n      } else {\n        startIndex += size;\n      }\n      presentationTime += duration / timescale;\n      number++;\n    }\n    playlist.segments = segments;\n    return playlist;\n  };\n  const SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\n  const TIME_FUDGE = 1 / 60;\n  /**\n   * Given a list of timelineStarts, combines, dedupes, and sorts them.\n   *\n   * @param {TimelineStart[]} timelineStarts - list of timeline starts\n   *\n   * @return {TimelineStart[]} the combined and deduped timeline starts\n   */\n\n  const getUniqueTimelineStarts = timelineStarts => {\n    return union(timelineStarts, ({\n      timeline\n    }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n  };\n  /**\n   * Finds the playlist with the matching NAME attribute.\n   *\n   * @param {Array} playlists - playlists to search through\n   * @param {string} name - the NAME attribute to search for\n   *\n   * @return {Object|null} the matching playlist object, or null\n   */\n\n  const findPlaylistWithName = (playlists, name) => {\n    for (let i = 0; i < playlists.length; i++) {\n      if (playlists[i].attributes.NAME === name) {\n        return playlists[i];\n      }\n    }\n    return null;\n  };\n  /**\n   * Gets a flattened array of media group playlists.\n   *\n   * @param {Object} manifest - the main manifest object\n   *\n   * @return {Array} the media group playlists\n   */\n\n  const getMediaGroupPlaylists = manifest => {\n    let mediaGroupPlaylists = [];\n    forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n      mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n    });\n    return mediaGroupPlaylists;\n  };\n  /**\n   * Updates the playlist's media sequence numbers.\n   *\n   * @param {Object} config - options object\n   * @param {Object} config.playlist - the playlist to update\n   * @param {number} config.mediaSequence - the mediaSequence number to start with\n   */\n\n  const updateMediaSequenceForPlaylist = ({\n    playlist,\n    mediaSequence\n  }) => {\n    playlist.mediaSequence = mediaSequence;\n    playlist.segments.forEach((segment, index) => {\n      segment.number = playlist.mediaSequence + index;\n    });\n  };\n  /**\n   * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n   * and a complete list of timeline starts.\n   *\n   * If no matching playlist is found, only the discontinuity sequence number of the playlist\n   * will be updated.\n   *\n   * Since early available timelines are not supported, at least one segment must be present.\n   *\n   * @param {Object} config - options object\n   * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n   * @param {Object[]} newPlaylists - the new playlists to update\n   * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n   */\n\n  const updateSequenceNumbers = ({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts\n  }) => {\n    newPlaylists.forEach(playlist => {\n      playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n        timeline\n      }) {\n        return timeline === playlist.timeline;\n      }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n      // (see ISO_23009-1-2012 5.3.5.2).\n      //\n      // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n      const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n      if (!oldPlaylist) {\n        // Since this is a new playlist, the media sequence values can start from 0 without\n        // consequence.\n        return;\n      } // TODO better support for live SIDX\n      //\n      // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n      // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n      // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n      // not supported when the SIDX properties change on refreshes.\n      //\n      // In the future, if support needs to be added, the merging logic here can be called\n      // after SIDX references are resolved. For now, exit early to prevent exceptions being\n      // thrown due to undefined references.\n\n      if (playlist.sidx) {\n        return;\n      } // Since we don't yet support early available timelines, we don't need to support\n      // playlists with no segments.\n\n      const firstNewSegment = playlist.segments[0];\n      const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n        return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n      }); // No matching segment from the old playlist means the entire playlist was refreshed.\n      // In this case the media sequence should account for this update, and the new segments\n      // should be marked as discontinuous from the prior content, since the last prior\n      // timeline was removed.\n\n      if (oldMatchingSegmentIndex === -1) {\n        updateMediaSequenceForPlaylist({\n          playlist,\n          mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n        });\n        playlist.segments[0].discontinuity = true;\n        playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n        //\n        // If the new playlist's timeline is the same as the last seen segment's timeline,\n        // then a discontinuity can be added to identify that there's potentially missing\n        // content. If there's no missing content, the discontinuity should still be rather\n        // harmless. It's possible that if segment durations are accurate enough, that the\n        // existence of a gap can be determined using the presentation times and durations,\n        // but if the segment timing info is off, it may introduce more problems than simply\n        // adding the discontinuity.\n        //\n        // If the new playlist's timeline is different from the last seen segment's timeline,\n        // then a discontinuity can be added to identify that this is the first seen segment\n        // of a new timeline. However, the logic at the start of this function that\n        // determined the disconinuity sequence by timeline index is now off by one (the\n        // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n        // we added it), so the disconinuity sequence must be decremented.\n        //\n        // A period may also have a duration of zero, so the case of no segments is handled\n        // here even though we don't yet support early available periods.\n\n        if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n          playlist.discontinuitySequence--;\n        }\n        return;\n      } // If the first segment matched with a prior segment on a discontinuity (it's matching\n      // on the first segment of a period), then the discontinuitySequence shouldn't be the\n      // timeline's matching one, but instead should be the one prior, and the first segment\n      // of the new manifest should be marked with a discontinuity.\n      //\n      // The reason for this special case is that discontinuity sequence shows how many\n      // discontinuities have fallen off of the playlist, and discontinuities are marked on\n      // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n      // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n      // sequence, and that first segment is an indicator, but can be removed before that\n      // timeline is gone.\n\n      const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n      if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n        firstNewSegment.discontinuity = true;\n        playlist.discontinuityStarts.unshift(0);\n        playlist.discontinuitySequence--;\n      }\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n      });\n    });\n  };\n  /**\n   * Given an old parsed manifest object and a new parsed manifest object, updates the\n   * sequence and timing values within the new manifest to ensure that it lines up with the\n   * old.\n   *\n   * @param {Array} oldManifest - the old main manifest object\n   * @param {Array} newManifest - the new main manifest object\n   *\n   * @return {Object} the updated new manifest object\n   */\n\n  const positionManifestOnTimeline = ({\n    oldManifest,\n    newManifest\n  }) => {\n    // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n    //\n    // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n    //\n    // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n    //\n    // Because of this change, and the difficulty of supporting periods with changing start\n    // times, periods with changing start times are not supported. This makes the logic much\n    // simpler, since periods with the same start time can be considerred the same period\n    // across refreshes.\n    //\n    // To give an example as to the difficulty of handling periods where the start time may\n    // change, if a single period manifest is refreshed with another manifest with a single\n    // period, and both the start and end times are increased, then the only way to determine\n    // if it's a new period or an old one that has changed is to look through the segments of\n    // each playlist and determine the presentation time bounds to find a match. In addition,\n    // if the period start changed to exceed the old period end, then there would be no\n    // match, and it would not be possible to determine whether the refreshed period is a new\n    // one or the old one.\n    const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n    const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n    // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n    // of properties are saved for each seen Period. Even long running live streams won't\n    // generate too many Periods, unless the stream is watched for decades. In the future,\n    // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n    // but it may not become an issue, and the additional info can be useful for debugging.\n\n    newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n    updateSequenceNumbers({\n      oldPlaylists,\n      newPlaylists,\n      timelineStarts: newManifest.timelineStarts\n    });\n    return newManifest;\n  };\n  const generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n  const mergeDiscontiguousPlaylists = playlists => {\n    const mergedPlaylists = values(playlists.reduce((acc, playlist) => {\n      // assuming playlist IDs are the same across periods\n      // TODO: handle multiperiod where representation sets are not the same\n      // across periods\n      const name = playlist.attributes.id + (playlist.attributes.lang || '');\n      if (!acc[name]) {\n        // First Period\n        acc[name] = playlist;\n        acc[name].attributes.timelineStarts = [];\n      } else {\n        // Subsequent Periods\n        if (playlist.segments) {\n          // first segment of subsequent periods signal a discontinuity\n          if (playlist.segments[0]) {\n            playlist.segments[0].discontinuity = true;\n          }\n          acc[name].segments.push(...playlist.segments);\n        } // bubble up contentProtection, this assumes all DRM content\n        // has the same contentProtection\n\n        if (playlist.attributes.contentProtection) {\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n        }\n      }\n      acc[name].attributes.timelineStarts.push({\n        // Although they represent the same number, it's important to have both to make it\n        // compatible with HLS potentially having a similar attribute.\n        start: playlist.attributes.periodStart,\n        timeline: playlist.attributes.periodStart\n      });\n      return acc;\n    }, {}));\n    return mergedPlaylists.map(playlist => {\n      playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n      return playlist;\n    });\n  };\n  const addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n    const sidxKey = generateSidxKey(playlist.sidx);\n    const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n    if (sidxMatch) {\n      addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n    }\n    return playlist;\n  };\n  const addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n    if (!Object.keys(sidxMapping).length) {\n      return playlists;\n    }\n    for (const i in playlists) {\n      playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n    }\n    return playlists;\n  };\n  const formatAudioPlaylist = ({\n    attributes,\n    segments,\n    sidx,\n    mediaSequence,\n    discontinuitySequence,\n    discontinuityStarts\n  }, isAudioOnly) => {\n    const playlist = {\n      attributes: {\n        NAME: attributes.id,\n        BANDWIDTH: attributes.bandwidth,\n        CODECS: attributes.codecs,\n        ['PROGRAM-ID']: 1\n      },\n      uri: '',\n      endList: attributes.type === 'static',\n      timeline: attributes.periodStart,\n      resolvedUri: '',\n      targetDuration: attributes.duration,\n      discontinuitySequence,\n      discontinuityStarts,\n      timelineStarts: attributes.timelineStarts,\n      mediaSequence,\n      segments\n    };\n    if (attributes.contentProtection) {\n      playlist.contentProtection = attributes.contentProtection;\n    }\n    if (sidx) {\n      playlist.sidx = sidx;\n    }\n    if (isAudioOnly) {\n      playlist.attributes.AUDIO = 'audio';\n      playlist.attributes.SUBTITLES = 'subs';\n    }\n    return playlist;\n  };\n  const formatVttPlaylist = ({\n    attributes,\n    segments,\n    mediaSequence,\n    discontinuityStarts,\n    discontinuitySequence\n  }) => {\n    if (typeof segments === 'undefined') {\n      // vtt tracks may use single file in BaseURL\n      segments = [{\n        uri: attributes.baseUrl,\n        timeline: attributes.periodStart,\n        resolvedUri: attributes.baseUrl || '',\n        duration: attributes.sourceDuration,\n        number: 0\n      }]; // targetDuration should be the same duration as the only segment\n\n      attributes.duration = attributes.sourceDuration;\n    }\n    const m3u8Attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    };\n    if (attributes.codecs) {\n      m3u8Attributes.CODECS = attributes.codecs;\n    }\n    return {\n      attributes: m3u8Attributes,\n      uri: '',\n      endList: attributes.type === 'static',\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      targetDuration: attributes.duration,\n      timelineStarts: attributes.timelineStarts,\n      discontinuityStarts,\n      discontinuitySequence,\n      mediaSequence,\n      segments\n    };\n  };\n  const organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n    let mainPlaylist;\n    const formattedPlaylists = playlists.reduce((a, playlist) => {\n      const role = playlist.attributes.role && playlist.attributes.role.value || '';\n      const language = playlist.attributes.lang || '';\n      let label = playlist.attributes.label || 'main';\n      if (language && !playlist.attributes.label) {\n        const roleLabel = role ? ` (${role})` : '';\n        label = `${playlist.attributes.lang}${roleLabel}`;\n      }\n      if (!a[label]) {\n        a[label] = {\n          language,\n          autoselect: true,\n          default: role === 'main',\n          playlists: [],\n          uri: ''\n        };\n      }\n      const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n      a[label].playlists.push(formatted);\n      if (typeof mainPlaylist === 'undefined' && role === 'main') {\n        mainPlaylist = playlist;\n        mainPlaylist.default = true;\n      }\n      return a;\n    }, {}); // if no playlists have role \"main\", mark the first as main\n\n    if (!mainPlaylist) {\n      const firstLabel = Object.keys(formattedPlaylists)[0];\n      formattedPlaylists[firstLabel].default = true;\n    }\n    return formattedPlaylists;\n  };\n  const organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n    return playlists.reduce((a, playlist) => {\n      const label = playlist.attributes.lang || 'text';\n      if (!a[label]) {\n        a[label] = {\n          language: label,\n          default: false,\n          autoselect: false,\n          playlists: [],\n          uri: ''\n        };\n      }\n      a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n      return a;\n    }, {});\n  };\n  const organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n    if (!svc) {\n      return svcObj;\n    }\n    svc.forEach(service => {\n      const {\n        channel,\n        language\n      } = service;\n      svcObj[language] = {\n        autoselect: false,\n        default: false,\n        instreamId: channel,\n        language\n      };\n      if (service.hasOwnProperty('aspectRatio')) {\n        svcObj[language].aspectRatio = service.aspectRatio;\n      }\n      if (service.hasOwnProperty('easyReader')) {\n        svcObj[language].easyReader = service.easyReader;\n      }\n      if (service.hasOwnProperty('3D')) {\n        svcObj[language]['3D'] = service['3D'];\n      }\n    });\n    return svcObj;\n  }, {});\n  const formatVideoPlaylist = ({\n    attributes,\n    segments,\n    sidx,\n    discontinuityStarts\n  }) => {\n    const playlist = {\n      attributes: {\n        NAME: attributes.id,\n        AUDIO: 'audio',\n        SUBTITLES: 'subs',\n        RESOLUTION: {\n          width: attributes.width,\n          height: attributes.height\n        },\n        CODECS: attributes.codecs,\n        BANDWIDTH: attributes.bandwidth,\n        ['PROGRAM-ID']: 1\n      },\n      uri: '',\n      endList: attributes.type === 'static',\n      timeline: attributes.periodStart,\n      resolvedUri: '',\n      targetDuration: attributes.duration,\n      discontinuityStarts,\n      timelineStarts: attributes.timelineStarts,\n      segments\n    };\n    if (attributes.frameRate) {\n      playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n    }\n    if (attributes.contentProtection) {\n      playlist.contentProtection = attributes.contentProtection;\n    }\n    if (sidx) {\n      playlist.sidx = sidx;\n    }\n    return playlist;\n  };\n  const videoOnly = ({\n    attributes\n  }) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n  const audioOnly = ({\n    attributes\n  }) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n  const vttOnly = ({\n    attributes\n  }) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n  /**\n   * Contains start and timeline properties denoting a timeline start. For DASH, these will\n   * be the same number.\n   *\n   * @typedef {Object} TimelineStart\n   * @property {number} start - the start time of the timeline\n   * @property {number} timeline - the timeline number\n   */\n\n  /**\n   * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n   *\n   * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n   * DASH specific attribute used in constructing segment URI's from templates. However, from\n   * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n   * value, which should start at the original media sequence value (or 0) and increment by 1\n   * for each segment thereafter. Since DASH's `startNumber` values are independent per\n   * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n   * from a 0 mediaSequence value and increment from there.\n   *\n   * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n   * debugging and making sense of the manifest.\n   *\n   * For live playlists, to account for values increasing in manifests when periods are\n   * removed on refreshes, merging logic should be used to update the numbers to their\n   * appropriate values (to ensure they're sequential and increasing).\n   *\n   * @param {Object[]} playlists - the playlists to update\n   * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n   */\n\n  const addMediaSequenceValues = (playlists, timelineStarts) => {\n    // increment all segments sequentially\n    playlists.forEach(playlist => {\n      playlist.mediaSequence = 0;\n      playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n        timeline\n      }) {\n        return timeline === playlist.timeline;\n      });\n      if (!playlist.segments) {\n        return;\n      }\n      playlist.segments.forEach((segment, index) => {\n        segment.number = index;\n      });\n    });\n  };\n  /**\n   * Given a media group object, flattens all playlists within the media group into a single\n   * array.\n   *\n   * @param {Object} mediaGroupObject - the media group object\n   *\n   * @return {Object[]}\n   *         The media group playlists\n   */\n\n  const flattenMediaGroupPlaylists = mediaGroupObject => {\n    if (!mediaGroupObject) {\n      return [];\n    }\n    return Object.keys(mediaGroupObject).reduce((acc, label) => {\n      const labelContents = mediaGroupObject[label];\n      return acc.concat(labelContents.playlists);\n    }, []);\n  };\n  const toM3u8 = ({\n    dashPlaylists,\n    locations,\n    sidxMapping = {},\n    previousManifest\n  }) => {\n    if (!dashPlaylists.length) {\n      return {};\n    } // grab all main manifest attributes\n\n    const {\n      sourceDuration: duration,\n      type,\n      suggestedPresentationDelay,\n      minimumUpdatePeriod\n    } = dashPlaylists[0].attributes;\n    const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n    const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n    const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n    const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n    const manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: [],\n      endList: true,\n      mediaGroups: {\n        AUDIO: {},\n        VIDEO: {},\n        ['CLOSED-CAPTIONS']: {},\n        SUBTITLES: {}\n      },\n      uri: '',\n      duration,\n      playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n    };\n    if (minimumUpdatePeriod >= 0) {\n      manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n    }\n    if (locations) {\n      manifest.locations = locations;\n    }\n    if (type === 'dynamic') {\n      manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n    }\n    const isAudioOnly = manifest.playlists.length === 0;\n    const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n    const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n    const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n    const playlistTimelineStarts = formattedPlaylists.map(({\n      timelineStarts\n    }) => timelineStarts);\n    manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n    addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n    if (organizedAudioGroup) {\n      manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n    }\n    if (organizedVttGroup) {\n      manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n    }\n    if (captions.length) {\n      manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n    }\n    if (previousManifest) {\n      return positionManifestOnTimeline({\n        oldManifest: previousManifest,\n        newManifest: manifest\n      });\n    }\n    return manifest;\n  };\n\n  /**\n   * Calculates the R (repetition) value for a live stream (for the final segment\n   * in a manifest where the r value is negative 1)\n   *\n   * @param {Object} attributes\n   *        Object containing all inherited attributes from parent elements with attribute\n   *        names as keys\n   * @param {number} time\n   *        current time (typically the total time up until the final segment)\n   * @param {number} duration\n   *        duration property for the given <S />\n   *\n   * @return {number}\n   *        R value to reach the end of the given period\n   */\n  const getLiveRValue = (attributes, time, duration) => {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      periodStart = 0,\n      minimumUpdatePeriod = 0\n    } = attributes;\n    const now = (NOW + clientOffset) / 1000;\n    const periodStartWC = availabilityStartTime + periodStart;\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    return Math.ceil((periodDuration * timescale - time) / duration);\n  };\n  /**\n   * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n   * timing and duration\n   *\n   * @param {Object} attributes\n   *        Object containing all inherited attributes from parent elements with attribute\n   *        names as keys\n   * @param {Object[]} segmentTimeline\n   *        List of objects representing the attributes of each S element contained within\n   *\n   * @return {{number: number, duration: number, time: number, timeline: number}[]}\n   *         List of Objects with segment timing and duration info\n   */\n\n  const parseByTimeline = (attributes, segmentTimeline) => {\n    const {\n      type,\n      minimumUpdatePeriod = 0,\n      media = '',\n      sourceDuration,\n      timescale = 1,\n      startNumber = 1,\n      periodStart: timeline\n    } = attributes;\n    const segments = [];\n    let time = -1;\n    for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n      const S = segmentTimeline[sIndex];\n      const duration = S.d;\n      const repeat = S.r || 0;\n      const segmentTime = S.t || 0;\n      if (time < 0) {\n        // first segment\n        time = segmentTime;\n      }\n      if (segmentTime && segmentTime > time) {\n        // discontinuity\n        // TODO: How to handle this type of discontinuity\n        // timeline++ here would treat it like HLS discontuity and content would\n        // get appended without gap\n        // E.G.\n        //  <S t=\"0\" d=\"1\" />\n        //  <S d=\"1\" />\n        //  <S d=\"1\" />\n        //  <S t=\"5\" d=\"1\" />\n        // would have $Time$ values of [0, 1, 2, 5]\n        // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n        // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n        // does the value of sourceDuration consider this when calculating arbitrary\n        // negative @r repeat value?\n        // E.G. Same elements as above with this added at the end\n        //  <S d=\"1\" r=\"-1\" />\n        //  with a sourceDuration of 10\n        // Would the 2 gaps be included in the time duration calculations resulting in\n        // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n        // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n        time = segmentTime;\n      }\n      let count;\n      if (repeat < 0) {\n        const nextS = sIndex + 1;\n        if (nextS === segmentTimeline.length) {\n          // last segment\n          if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n            count = getLiveRValue(attributes, time, duration);\n          } else {\n            // TODO: This may be incorrect depending on conclusion of TODO above\n            count = (sourceDuration * timescale - time) / duration;\n          }\n        } else {\n          count = (segmentTimeline[nextS].t - time) / duration;\n        }\n      } else {\n        count = repeat + 1;\n      }\n      const end = startNumber + segments.length + count;\n      let number = startNumber + segments.length;\n      while (number < end) {\n        segments.push({\n          number,\n          duration: duration / timescale,\n          time,\n          timeline\n        });\n        time += duration;\n        number++;\n      }\n    }\n    return segments;\n  };\n  const identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n  /**\n   * Replaces template identifiers with corresponding values. To be used as the callback\n   * for String.prototype.replace\n   *\n   * @name replaceCallback\n   * @function\n   * @param {string} match\n   *        Entire match of identifier\n   * @param {string} identifier\n   *        Name of matched identifier\n   * @param {string} format\n   *        Format tag string. Its presence indicates that padding is expected\n   * @param {string} width\n   *        Desired length of the replaced value. Values less than this width shall be left\n   *        zero padded\n   * @return {string}\n   *         Replacement for the matched identifier\n   */\n\n  /**\n   * Returns a function to be used as a callback for String.prototype.replace to replace\n   * template identifiers\n   *\n   * @param {Obect} values\n   *        Object containing values that shall be used to replace known identifiers\n   * @param {number} values.RepresentationID\n   *        Value of the Representation@id attribute\n   * @param {number} values.Number\n   *        Number of the corresponding segment\n   * @param {number} values.Bandwidth\n   *        Value of the Representation@bandwidth attribute.\n   * @param {number} values.Time\n   *        Timestamp value of the corresponding segment\n   * @return {replaceCallback}\n   *         Callback to be used with String.prototype.replace to replace identifiers\n   */\n\n  const identifierReplacement = values => (match, identifier, format, width) => {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n    const value = '' + values[identifier];\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n    if (value.length >= width) {\n      return value;\n    }\n    return `${new Array(width - value.length + 1).join('0')}${value}`;\n  };\n  /**\n   * Constructs a segment url from a template string\n   *\n   * @param {string} url\n   *        Template string to construct url from\n   * @param {Obect} values\n   *        Object containing values that shall be used to replace known identifiers\n   * @param {number} values.RepresentationID\n   *        Value of the Representation@id attribute\n   * @param {number} values.Number\n   *        Number of the corresponding segment\n   * @param {number} values.Bandwidth\n   *        Value of the Representation@bandwidth attribute.\n   * @param {number} values.Time\n   *        Timestamp value of the corresponding segment\n   * @return {string}\n   *         Segment url with identifiers replaced\n   */\n\n  const constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n  /**\n   * Generates a list of objects containing timing and duration information about each\n   * segment needed to generate segment uris and the complete segment object\n   *\n   * @param {Object} attributes\n   *        Object containing all inherited attributes from parent elements with attribute\n   *        names as keys\n   * @param {Object[]|undefined} segmentTimeline\n   *        List of objects representing the attributes of each S element contained within\n   *        the SegmentTimeline element\n   * @return {{number: number, duration: number, time: number, timeline: number}[]}\n   *         List of Objects with segment timing and duration info\n   */\n\n  const parseTemplateInfo = (attributes, segmentTimeline) => {\n    if (!attributes.duration && !segmentTimeline) {\n      // if neither @duration or SegmentTimeline are present, then there shall be exactly\n      // one media segment\n      return [{\n        number: attributes.startNumber || 1,\n        duration: attributes.sourceDuration,\n        time: 0,\n        timeline: attributes.periodStart\n      }];\n    }\n    if (attributes.duration) {\n      return parseByDuration(attributes);\n    }\n    return parseByTimeline(attributes, segmentTimeline);\n  };\n  /**\n   * Generates a list of segments using information provided by the SegmentTemplate element\n   *\n   * @param {Object} attributes\n   *        Object containing all inherited attributes from parent elements with attribute\n   *        names as keys\n   * @param {Object[]|undefined} segmentTimeline\n   *        List of objects representing the attributes of each S element contained within\n   *        the SegmentTimeline element\n   * @return {Object[]}\n   *         List of segment objects\n   */\n\n  const segmentsFromTemplate = (attributes, segmentTimeline) => {\n    const templateValues = {\n      RepresentationID: attributes.id,\n      Bandwidth: attributes.bandwidth || 0\n    };\n    const {\n      initialization = {\n        sourceURL: '',\n        range: ''\n      }\n    } = attributes;\n    const mapSegment = urlTypeToSegment({\n      baseUrl: attributes.baseUrl,\n      source: constructTemplateUrl(initialization.sourceURL, templateValues),\n      range: initialization.range\n    });\n    const segments = parseTemplateInfo(attributes, segmentTimeline);\n    return segments.map(segment => {\n      templateValues.Number = segment.number;\n      templateValues.Time = segment.time;\n      const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      const presentationTime =\n      // Even if the @t attribute is not specified for the segment, segment.time is\n      // calculated in mpd-parser prior to this, so it's assumed to be available.\n      attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n      const map = {\n        uri,\n        timeline: segment.timeline,\n        duration: segment.duration,\n        resolvedUri: resolveUrl$1(attributes.baseUrl || '', uri),\n        map: mapSegment,\n        number: segment.number,\n        presentationTime\n      };\n      return map;\n    });\n  };\n\n  /**\n   * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n   * to an object that matches the output of a segment in videojs/mpd-parser\n   *\n   * @param {Object} attributes\n   *   Object containing all inherited attributes from parent elements with attribute\n   *   names as keys\n   * @param {Object} segmentUrl\n   *   <SegmentURL> node to translate into a segment object\n   * @return {Object} translated segment object\n   */\n\n  const SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n    const {\n      baseUrl,\n      initialization = {}\n    } = attributes;\n    const initSegment = urlTypeToSegment({\n      baseUrl,\n      source: initialization.sourceURL,\n      range: initialization.range\n    });\n    const segment = urlTypeToSegment({\n      baseUrl,\n      source: segmentUrl.media,\n      range: segmentUrl.mediaRange\n    });\n    segment.map = initSegment;\n    return segment;\n  };\n  /**\n   * Generates a list of segments using information provided by the SegmentList element\n   * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n   * node should be translated into segment.\n   *\n   * @param {Object} attributes\n   *   Object containing all inherited attributes from parent elements with attribute\n   *   names as keys\n   * @param {Object[]|undefined} segmentTimeline\n   *        List of objects representing the attributes of each S element contained within\n   *        the SegmentTimeline element\n   * @return {Object.<Array>} list of segments\n   */\n\n  const segmentsFromList = (attributes, segmentTimeline) => {\n    const {\n      duration,\n      segmentUrls = [],\n      periodStart\n    } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n    // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n    if (!duration && !segmentTimeline || duration && segmentTimeline) {\n      throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n    }\n    const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n    let segmentTimeInfo;\n    if (duration) {\n      segmentTimeInfo = parseByDuration(attributes);\n    }\n    if (segmentTimeline) {\n      segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n    }\n    const segments = segmentTimeInfo.map((segmentTime, index) => {\n      if (segmentUrlMap[index]) {\n        const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n        // - if timescale isn't present on any level, default to 1.\n\n        const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n        const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n        segment.timeline = segmentTime.timeline;\n        segment.duration = segmentTime.duration;\n        segment.number = segmentTime.number;\n        segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n        return segment;\n      } // Since we're mapping we should get rid of any blank segments (in case\n      // the given SegmentTimeline is handling for more elements than we have\n      // SegmentURLs for).\n    }).filter(segment => segment);\n    return segments;\n  };\n  const generateSegments = ({\n    attributes,\n    segmentInfo\n  }) => {\n    let segmentAttributes;\n    let segmentsFn;\n    if (segmentInfo.template) {\n      segmentsFn = segmentsFromTemplate;\n      segmentAttributes = merge$1(attributes, segmentInfo.template);\n    } else if (segmentInfo.base) {\n      segmentsFn = segmentsFromBase;\n      segmentAttributes = merge$1(attributes, segmentInfo.base);\n    } else if (segmentInfo.list) {\n      segmentsFn = segmentsFromList;\n      segmentAttributes = merge$1(attributes, segmentInfo.list);\n    }\n    const segmentsInfo = {\n      attributes\n    };\n    if (!segmentsFn) {\n      return segmentsInfo;\n    }\n    const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n    // must be in seconds. Since we've generated the segment list, we no longer need\n    // @duration to be in @timescale units, so we can convert it here.\n\n    if (segmentAttributes.duration) {\n      const {\n        duration,\n        timescale = 1\n      } = segmentAttributes;\n      segmentAttributes.duration = duration / timescale;\n    } else if (segments.length) {\n      // if there is no @duration attribute, use the largest segment duration as\n      // as target duration\n      segmentAttributes.duration = segments.reduce((max, segment) => {\n        return Math.max(max, Math.ceil(segment.duration));\n      }, 0);\n    } else {\n      segmentAttributes.duration = 0;\n    }\n    segmentsInfo.attributes = segmentAttributes;\n    segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n    if (segmentInfo.base && segmentAttributes.indexRange) {\n      segmentsInfo.sidx = segments[0];\n      segmentsInfo.segments = [];\n    }\n    return segmentsInfo;\n  };\n  const toPlaylists = representations => representations.map(generateSegments);\n  const findChildren = (element, name) => from(element.childNodes).filter(({\n    tagName\n  }) => tagName === name);\n  const getContent = element => element.textContent.trim();\n\n  /**\n   * Converts the provided string that may contain a division operation to a number.\n   *\n   * @param {string} value - the provided string value\n   *\n   * @return {number} the parsed string value\n   */\n  const parseDivisionValue = value => {\n    return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n  };\n  const parseDuration = str => {\n    const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n    const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n    const SECONDS_IN_DAY = 24 * 60 * 60;\n    const SECONDS_IN_HOUR = 60 * 60;\n    const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n    const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n    const match = durationRegex.exec(str);\n    if (!match) {\n      return 0;\n    }\n    const [year, month, day, hour, minute, second] = match.slice(1);\n    return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n  };\n  const parseDate = str => {\n    // Date format without timezone according to ISO 8601\n    // YYY-MM-DDThh:mm:ss.ssssss\n    const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n    // expressed by ending with 'Z'\n\n    if (dateRegex.test(str)) {\n      str += 'Z';\n    }\n    return Date.parse(str);\n  };\n  const parsers = {\n    /**\n     * Specifies the duration of the entire Media Presentation. Format is a duration string\n     * as specified in ISO 8601\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The duration in seconds\n     */\n    mediaPresentationDuration(value) {\n      return parseDuration(value);\n    },\n    /**\n     * Specifies the Segment availability start time for all Segments referred to in this\n     * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n     * time. Format is a date string as specified in ISO 8601\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The date as seconds from unix epoch\n     */\n    availabilityStartTime(value) {\n      return parseDate(value) / 1000;\n    },\n    /**\n     * Specifies the smallest period between potential changes to the MPD. Format is a\n     * duration string as specified in ISO 8601\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The duration in seconds\n     */\n    minimumUpdatePeriod(value) {\n      return parseDuration(value);\n    },\n    /**\n     * Specifies the suggested presentation delay. Format is a\n     * duration string as specified in ISO 8601\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The duration in seconds\n     */\n    suggestedPresentationDelay(value) {\n      return parseDuration(value);\n    },\n    /**\n     * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     *\n     * @return {string}\n     *         The type as a string\n     */\n    type(value) {\n      return value;\n    },\n    /**\n     * Specifies the duration of the smallest time shifting buffer for any Representation\n     * in the MPD. Format is a duration string as specified in ISO 8601\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The duration in seconds\n     */\n    timeShiftBufferDepth(value) {\n      return parseDuration(value);\n    },\n    /**\n     * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n     * Format is a duration string as specified in ISO 8601\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The duration in seconds\n     */\n    start(value) {\n      return parseDuration(value);\n    },\n    /**\n     * Specifies the width of the visual presentation\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed width\n     */\n    width(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the height of the visual presentation\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed height\n     */\n    height(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the bitrate of the representation\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed bandwidth\n     */\n    bandwidth(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the frame rate of the representation\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed frame rate\n     */\n    frameRate(value) {\n      return parseDivisionValue(value);\n    },\n    /**\n     * Specifies the number of the first Media Segment in this Representation in the Period\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed number\n     */\n    startNumber(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the timescale in units per seconds\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed timescale\n     */\n    timescale(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the presentationTimeOffset.\n     *\n     * @param {string} value\n     *        value of the attribute as a string\n     *\n     * @return {number}\n     *         The parsed presentationTimeOffset\n     */\n    presentationTimeOffset(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the constant approximate Segment duration\n     * NOTE: The <Period> element also contains an @duration attribute. This duration\n     *       specifies the duration of the Period. This attribute is currently not\n     *       supported by the rest of the parser, however we still check for it to prevent\n     *       errors.\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed duration\n     */\n    duration(value) {\n      const parsedValue = parseInt(value, 10);\n      if (isNaN(parsedValue)) {\n        return parseDuration(value);\n      }\n      return parsedValue;\n    },\n    /**\n     * Specifies the Segment duration, in units of the value of the @timescale.\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed duration\n     */\n    d(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the MPD start time, in @timescale units, the first Segment in the series\n     * starts relative to the beginning of the Period\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed time\n     */\n    t(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Specifies the repeat count of the number of following contiguous Segments with the\n     * same duration expressed by the value of @d\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {number}\n     *         The parsed number\n     */\n    r(value) {\n      return parseInt(value, 10);\n    },\n    /**\n     * Default parser for all other attributes. Acts as a no-op and just returns the value\n     * as a string\n     *\n     * @param {string} value\n     *        value of attribute as a string\n     * @return {string}\n     *         Unparsed value\n     */\n    DEFAULT(value) {\n      return value;\n    }\n  };\n  /**\n   * Gets all the attributes and values of the provided node, parses attributes with known\n   * types, and returns an object with attribute names mapped to values.\n   *\n   * @param {Node} el\n   *        The node to parse attributes from\n   * @return {Object}\n   *         Object with all attributes of el parsed\n   */\n\n  const parseAttributes = el => {\n    if (!(el && el.attributes)) {\n      return {};\n    }\n    return from(el.attributes).reduce((a, e) => {\n      const parseFn = parsers[e.name] || parsers.DEFAULT;\n      a[e.name] = parseFn(e.value);\n      return a;\n    }, {});\n  };\n  const keySystemsMap = {\n    'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n    'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n    'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n    'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n  };\n  /**\n   * Builds a list of urls that is the product of the reference urls and BaseURL values\n   *\n   * @param {string[]} referenceUrls\n   *        List of reference urls to resolve to\n   * @param {Node[]} baseUrlElements\n   *        List of BaseURL nodes from the mpd\n   * @return {string[]}\n   *         List of resolved urls\n   */\n\n  const buildBaseUrls = (referenceUrls, baseUrlElements) => {\n    if (!baseUrlElements.length) {\n      return referenceUrls;\n    }\n    return flatten(referenceUrls.map(function (reference) {\n      return baseUrlElements.map(function (baseUrlElement) {\n        return resolveUrl$1(reference, getContent(baseUrlElement));\n      });\n    }));\n  };\n  /**\n   * Contains all Segment information for its containing AdaptationSet\n   *\n   * @typedef {Object} SegmentInformation\n   * @property {Object|undefined} template\n   *           Contains the attributes for the SegmentTemplate node\n   * @property {Object[]|undefined} segmentTimeline\n   *           Contains a list of atrributes for each S node within the SegmentTimeline node\n   * @property {Object|undefined} list\n   *           Contains the attributes for the SegmentList node\n   * @property {Object|undefined} base\n   *           Contains the attributes for the SegmentBase node\n   */\n\n  /**\n   * Returns all available Segment information contained within the AdaptationSet node\n   *\n   * @param {Node} adaptationSet\n   *        The AdaptationSet node to get Segment information from\n   * @return {SegmentInformation}\n   *         The Segment information contained within the provided AdaptationSet\n   */\n\n  const getSegmentInformation = adaptationSet => {\n    const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n    const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n    const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge$1({\n      tag: 'SegmentURL'\n    }, parseAttributes(s)));\n    const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n    const segmentTimelineParentNode = segmentList || segmentTemplate;\n    const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n    const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n    const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n    // @initialization and an <Initialization> node.  @initialization can be templated,\n    // while the node can have a url and range specified.  If the <SegmentTemplate> has\n    // both @initialization and an <Initialization> subelement we opt to override with\n    // the node, as this interaction is not defined in the spec.\n\n    const template = segmentTemplate && parseAttributes(segmentTemplate);\n    if (template && segmentInitialization) {\n      template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n    } else if (template && template.initialization) {\n      // If it is @initialization we convert it to an object since this is the format that\n      // later functions will rely on for the initialization segment.  This is only valid\n      // for <SegmentTemplate>\n      template.initialization = {\n        sourceURL: template.initialization\n      };\n    }\n    const segmentInfo = {\n      template,\n      segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n      list: segmentList && merge$1(parseAttributes(segmentList), {\n        segmentUrls,\n        initialization: parseAttributes(segmentInitialization)\n      }),\n      base: segmentBase && merge$1(parseAttributes(segmentBase), {\n        initialization: parseAttributes(segmentInitialization)\n      })\n    };\n    Object.keys(segmentInfo).forEach(key => {\n      if (!segmentInfo[key]) {\n        delete segmentInfo[key];\n      }\n    });\n    return segmentInfo;\n  };\n  /**\n   * Contains Segment information and attributes needed to construct a Playlist object\n   * from a Representation\n   *\n   * @typedef {Object} RepresentationInformation\n   * @property {SegmentInformation} segmentInfo\n   *           Segment information for this Representation\n   * @property {Object} attributes\n   *           Inherited attributes for this Representation\n   */\n\n  /**\n   * Maps a Representation node to an object containing Segment information and attributes\n   *\n   * @name inheritBaseUrlsCallback\n   * @function\n   * @param {Node} representation\n   *        Representation node from the mpd\n   * @return {RepresentationInformation}\n   *         Representation information needed to construct a Playlist object\n   */\n\n  /**\n   * Returns a callback for Array.prototype.map for mapping Representation nodes to\n   * Segment information and attributes using inherited BaseURL nodes.\n   *\n   * @param {Object} adaptationSetAttributes\n   *        Contains attributes inherited by the AdaptationSet\n   * @param {string[]} adaptationSetBaseUrls\n   *        Contains list of resolved base urls inherited by the AdaptationSet\n   * @param {SegmentInformation} adaptationSetSegmentInfo\n   *        Contains Segment information for the AdaptationSet\n   * @return {inheritBaseUrlsCallback}\n   *         Callback map function\n   */\n\n  const inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n    const repBaseUrlElements = findChildren(representation, 'BaseURL');\n    const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    const attributes = merge$1(adaptationSetAttributes, parseAttributes(representation));\n    const representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(baseUrl => {\n      return {\n        segmentInfo: merge$1(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge$1(attributes, {\n          baseUrl\n        })\n      };\n    });\n  };\n  /**\n   * Tranforms a series of content protection nodes to\n   * an object containing pssh data by key system\n   *\n   * @param {Node[]} contentProtectionNodes\n   *        Content protection nodes\n   * @return {Object}\n   *        Object containing pssh data by key system\n   */\n\n  const generateKeySystemInformation = contentProtectionNodes => {\n    return contentProtectionNodes.reduce((acc, node) => {\n      const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n      // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n      // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n      // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n      if (attributes.schemeIdUri) {\n        attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n      }\n      const keySystem = keySystemsMap[attributes.schemeIdUri];\n      if (keySystem) {\n        acc[keySystem] = {\n          attributes\n        };\n        const psshNode = findChildren(node, 'cenc:pssh')[0];\n        if (psshNode) {\n          const pssh = getContent(psshNode);\n          acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n        }\n      }\n      return acc;\n    }, {});\n  }; // defined in ANSI_SCTE 214-1 2016\n\n  const parseCaptionServiceMetadata = service => {\n    // 608 captions\n    if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n      const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n      return values.map(value => {\n        let channel;\n        let language; // default language to value\n\n        language = value;\n        if (/^CC\\d=/.test(value)) {\n          [channel, language] = value.split('=');\n        } else if (/^CC\\d$/.test(value)) {\n          channel = value;\n        }\n        return {\n          channel,\n          language\n        };\n      });\n    } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n      const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n      return values.map(value => {\n        const flags = {\n          // service or channel number 1-63\n          'channel': undefined,\n          // language is a 3ALPHA per ISO 639.2/B\n          // field is required\n          'language': undefined,\n          // BIT 1/0 or ?\n          // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n          'aspectRatio': 1,\n          // BIT 1/0\n          // easy reader flag indicated the text is tailed to the needs of beginning readers\n          // default 0, or off\n          'easyReader': 0,\n          // BIT 1/0\n          // If 3d metadata is present (CEA-708.1) then 1\n          // default 0\n          '3D': 0\n        };\n        if (/=/.test(value)) {\n          const [channel, opts = ''] = value.split('=');\n          flags.channel = channel;\n          flags.language = value;\n          opts.split(',').forEach(opt => {\n            const [name, val] = opt.split(':');\n            if (name === 'lang') {\n              flags.language = val; // er for easyReadery\n            } else if (name === 'er') {\n              flags.easyReader = Number(val); // war for wide aspect ratio\n            } else if (name === 'war') {\n              flags.aspectRatio = Number(val);\n            } else if (name === '3D') {\n              flags['3D'] = Number(val);\n            }\n          });\n        } else {\n          flags.language = value;\n        }\n        if (flags.channel) {\n          flags.channel = 'SERVICE' + flags.channel;\n        }\n        return flags;\n      });\n    }\n  };\n  /**\n   * Maps an AdaptationSet node to a list of Representation information objects\n   *\n   * @name toRepresentationsCallback\n   * @function\n   * @param {Node} adaptationSet\n   *        AdaptationSet node from the mpd\n   * @return {RepresentationInformation[]}\n   *         List of objects containing Representaion information\n   */\n\n  /**\n   * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n   * Representation information objects\n   *\n   * @param {Object} periodAttributes\n   *        Contains attributes inherited by the Period\n   * @param {string[]} periodBaseUrls\n   *        Contains list of resolved base urls inherited by the Period\n   * @param {string[]} periodSegmentInfo\n   *        Contains Segment Information at the period level\n   * @return {toRepresentationsCallback}\n   *         Callback map function\n   */\n\n  const toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n    const adaptationSetAttributes = parseAttributes(adaptationSet);\n    const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    const role = findChildren(adaptationSet, 'Role')[0];\n    const roleAttributes = {\n      role: parseAttributes(role)\n    };\n    let attrs = merge$1(periodAttributes, adaptationSetAttributes, roleAttributes);\n    const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n    const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n    if (captionServices) {\n      attrs = merge$1(attrs, {\n        captionServices\n      });\n    }\n    const label = findChildren(adaptationSet, 'Label')[0];\n    if (label && label.childNodes.length) {\n      const labelVal = label.childNodes[0].nodeValue.trim();\n      attrs = merge$1(attrs, {\n        label: labelVal\n      });\n    }\n    const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n    if (Object.keys(contentProtection).length) {\n      attrs = merge$1(attrs, {\n        contentProtection\n      });\n    }\n    const segmentInfo = getSegmentInformation(adaptationSet);\n    const representations = findChildren(adaptationSet, 'Representation');\n    const adaptationSetSegmentInfo = merge$1(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n  /**\n   * Contains all period information for mapping nodes onto adaptation sets.\n   *\n   * @typedef {Object} PeriodInformation\n   * @property {Node} period.node\n   *           Period node from the mpd\n   * @property {Object} period.attributes\n   *           Parsed period attributes from node plus any added\n   */\n\n  /**\n   * Maps a PeriodInformation object to a list of Representation information objects for all\n   * AdaptationSet nodes contained within the Period.\n   *\n   * @name toAdaptationSetsCallback\n   * @function\n   * @param {PeriodInformation} period\n   *        Period object containing necessary period information\n   * @param {number} periodStart\n   *        Start time of the Period within the mpd\n   * @return {RepresentationInformation[]}\n   *         List of objects containing Representaion information\n   */\n\n  /**\n   * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n   * Representation information objects\n   *\n   * @param {Object} mpdAttributes\n   *        Contains attributes inherited by the mpd\n   * @param {string[]} mpdBaseUrls\n   *        Contains list of resolved base urls inherited by the mpd\n   * @return {toAdaptationSetsCallback}\n   *         Callback map function\n   */\n\n  const toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n    const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n    const periodAttributes = merge$1(mpdAttributes, {\n      periodStart: period.attributes.start\n    });\n    if (typeof period.attributes.duration === 'number') {\n      periodAttributes.periodDuration = period.attributes.duration;\n    }\n    const adaptationSets = findChildren(period.node, 'AdaptationSet');\n    const periodSegmentInfo = getSegmentInformation(period.node);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n  /**\n   * Gets Period@start property for a given period.\n   *\n   * @param {Object} options\n   *        Options object\n   * @param {Object} options.attributes\n   *        Period attributes\n   * @param {Object} [options.priorPeriodAttributes]\n   *        Prior period attributes (if prior period is available)\n   * @param {string} options.mpdType\n   *        The MPD@type these periods came from\n   * @return {number|null}\n   *         The period start, or null if it's an early available period or error\n   */\n\n  const getPeriodStart = ({\n    attributes,\n    priorPeriodAttributes,\n    mpdType\n  }) => {\n    // Summary of period start time calculation from DASH spec section 5.3.2.1\n    //\n    // A period's start is the first period's start + time elapsed after playing all\n    // prior periods to this one. Periods continue one after the other in time (without\n    // gaps) until the end of the presentation.\n    //\n    // The value of Period@start should be:\n    // 1. if Period@start is present: value of Period@start\n    // 2. if previous period exists and it has @duration: previous Period@start +\n    //    previous Period@duration\n    // 3. if this is first period and MPD@type is 'static': 0\n    // 4. in all other cases, consider the period an \"early available period\" (note: not\n    //    currently supported)\n    // (1)\n    if (typeof attributes.start === 'number') {\n      return attributes.start;\n    } // (2)\n\n    if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n      return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n    } // (3)\n\n    if (!priorPeriodAttributes && mpdType === 'static') {\n      return 0;\n    } // (4)\n    // There is currently no logic for calculating the Period@start value if there is\n    // no Period@start or prior Period@start and Period@duration available. This is not made\n    // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n    // nothing about any other resolution strategies, it's implied. Thus, this case should\n    // be considered an early available period, or error, and null should suffice for both\n    // of those cases.\n\n    return null;\n  };\n  /**\n   * Traverses the mpd xml tree to generate a list of Representation information objects\n   * that have inherited attributes from parent nodes\n   *\n   * @param {Node} mpd\n   *        The root node of the mpd\n   * @param {Object} options\n   *        Available options for inheritAttributes\n   * @param {string} options.manifestUri\n   *        The uri source of the mpd\n   * @param {number} options.NOW\n   *        Current time per DASH IOP.  Default is current time in ms since epoch\n   * @param {number} options.clientOffset\n   *        Client time difference from NOW (in milliseconds)\n   * @return {RepresentationInformation[]}\n   *         List of objects containing Representation information\n   */\n\n  const inheritAttributes = (mpd, options = {}) => {\n    const {\n      manifestUri = '',\n      NOW = Date.now(),\n      clientOffset = 0\n    } = options;\n    const periodNodes = findChildren(mpd, 'Period');\n    if (!periodNodes.length) {\n      throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n    }\n    const locations = findChildren(mpd, 'Location');\n    const mpdAttributes = parseAttributes(mpd);\n    const mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n    mpdAttributes.type = mpdAttributes.type || 'static';\n    mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n    mpdAttributes.NOW = NOW;\n    mpdAttributes.clientOffset = clientOffset;\n    if (locations.length) {\n      mpdAttributes.locations = locations.map(getContent);\n    }\n    const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n    // adding properties that require looking at prior periods is to parse attributes and add\n    // missing ones before toAdaptationSets is called. If more such properties are added, it\n    // may be better to refactor toAdaptationSets.\n\n    periodNodes.forEach((node, index) => {\n      const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n      // for this period.\n\n      const priorPeriod = periods[index - 1];\n      attributes.start = getPeriodStart({\n        attributes,\n        priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n        mpdType: mpdAttributes.type\n      });\n      periods.push({\n        node,\n        attributes\n      });\n    });\n    return {\n      locations: mpdAttributes.locations,\n      representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n    };\n  };\n  const stringToMpdXml = manifestString => {\n    if (manifestString === '') {\n      throw new Error(errors.DASH_EMPTY_MANIFEST);\n    }\n    const parser = new DOMParser();\n    let xml;\n    let mpd;\n    try {\n      xml = parser.parseFromString(manifestString, 'application/xml');\n      mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n    } catch (e) {// ie 11 throwsw on invalid xml\n    }\n    if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n      throw new Error(errors.DASH_INVALID_XML);\n    }\n    return mpd;\n  };\n\n  /**\n   * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n   *\n   * @param {string} mpd\n   *        XML string of the MPD manifest\n   * @return {Object|null}\n   *         Attributes of UTCTiming node specified in the manifest. Null if none found\n   */\n\n  const parseUTCTimingScheme = mpd => {\n    const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n    if (!UTCTimingNode) {\n      return null;\n    }\n    const attributes = parseAttributes(UTCTimingNode);\n    switch (attributes.schemeIdUri) {\n      case 'urn:mpeg:dash:utc:http-head:2014':\n      case 'urn:mpeg:dash:utc:http-head:2012':\n        attributes.method = 'HEAD';\n        break;\n      case 'urn:mpeg:dash:utc:http-xsdate:2014':\n      case 'urn:mpeg:dash:utc:http-iso:2014':\n      case 'urn:mpeg:dash:utc:http-xsdate:2012':\n      case 'urn:mpeg:dash:utc:http-iso:2012':\n        attributes.method = 'GET';\n        break;\n      case 'urn:mpeg:dash:utc:direct:2014':\n      case 'urn:mpeg:dash:utc:direct:2012':\n        attributes.method = 'DIRECT';\n        attributes.value = Date.parse(attributes.value);\n        break;\n      case 'urn:mpeg:dash:utc:http-ntp:2014':\n      case 'urn:mpeg:dash:utc:ntp:2014':\n      case 'urn:mpeg:dash:utc:sntp:2014':\n      default:\n        throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n    }\n    return attributes;\n  };\n  /*\n   * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n   * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n   *\n   * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n   * parsed DASH manifest will have its media sequence and discontinuity sequence values\n   * updated to reflect its position relative to the prior manifest.\n   *\n   * @param {string} manifestString - the DASH manifest as a string\n   * @param {options} [options] - any options\n   *\n   * @return {Object} the manifest object\n   */\n\n  const parse = (manifestString, options = {}) => {\n    const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n    const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n    return toM3u8({\n      dashPlaylists: playlists,\n      locations: parsedManifestInfo.locations,\n      sidxMapping: options.sidxMapping,\n      previousManifest: options.previousManifest\n    });\n  };\n  /**\n   * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n   *\n   * @param {string} manifestString\n   *        XML string of the MPD manifest\n   * @return {Object|null}\n   *         Attributes of UTCTiming node specified in the manifest. Null if none found\n   */\n\n  const parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\n  var MAX_UINT32 = Math.pow(2, 32);\n  var getUint64$1 = function (uint8) {\n    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n    var value;\n    if (dv.getBigUint64) {\n      value = dv.getBigUint64(0);\n      if (value < Number.MAX_SAFE_INTEGER) {\n        return Number(value);\n      }\n      return value;\n    }\n    return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);\n  };\n  var numbers = {\n    getUint64: getUint64$1,\n    MAX_UINT32: MAX_UINT32\n  };\n\n  var getUint64 = numbers.getUint64;\n  var parseSidx = function (data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n      result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        references: [],\n        referenceId: view.getUint32(4),\n        timescale: view.getUint32(8)\n      },\n      i = 12;\n    if (result.version === 0) {\n      result.earliestPresentationTime = view.getUint32(i);\n      result.firstOffset = view.getUint32(i + 4);\n      i += 8;\n    } else {\n      // read 64 bits\n      result.earliestPresentationTime = getUint64(data.subarray(i));\n      result.firstOffset = getUint64(data.subarray(i + 8));\n      i += 16;\n    }\n    i += 2; // reserved\n\n    var referenceCount = view.getUint16(i);\n    i += 2; // start of references\n\n    for (; referenceCount > 0; i += 12, referenceCount--) {\n      result.references.push({\n        referenceType: (data[i] & 0x80) >>> 7,\n        referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n        subsegmentDuration: view.getUint32(i + 4),\n        startsWithSap: !!(data[i + 8] & 0x80),\n        sapType: (data[i + 8] & 0x70) >>> 4,\n        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n      });\n    }\n    return result;\n  };\n  var parseSidx_1 = parseSidx;\n\n  var ID3 = toUint8([0x49, 0x44, 0x33]);\n  var getId3Size = function getId3Size(bytes, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    bytes = toUint8(bytes);\n    var flags = bytes[offset + 5];\n    var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];\n    var footerPresent = (flags & 16) >> 4;\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n    return returnSize + 10;\n  };\n  var getId3Offset = function getId3Offset(bytes, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    bytes = toUint8(bytes);\n    if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {\n      offset: offset\n    })) {\n      return offset;\n    }\n    offset += getId3Size(bytes, offset); // recursive check for id3 tags as some files\n    // have multiple ID3 tag sections even though\n    // they should not.\n\n    return getId3Offset(bytes, offset);\n  };\n\n  var normalizePath$1 = function normalizePath(path) {\n    if (typeof path === 'string') {\n      return stringToBytes(path);\n    }\n    if (typeof path === 'number') {\n      return path;\n    }\n    return path;\n  };\n  var normalizePaths$1 = function normalizePaths(paths) {\n    if (!Array.isArray(paths)) {\n      return [normalizePath$1(paths)];\n    }\n    return paths.map(function (p) {\n      return normalizePath$1(p);\n    });\n  };\n  /**\n   * find any number of boxes by name given a path to it in an iso bmff\n   * such as mp4.\n   *\n   * @param {TypedArray} bytes\n   *        bytes for the iso bmff to search for boxes in\n   *\n   * @param {Uint8Array[]|string[]|string|Uint8Array} name\n   *        An array of paths or a single path representing the name\n   *        of boxes to search through in bytes. Paths may be\n   *        uint8 (character codes) or strings.\n   *\n   * @param {boolean} [complete=false]\n   *        Should we search only for complete boxes on the final path.\n   *        This is very useful when you do not want to get back partial boxes\n   *        in the case of streaming files.\n   *\n   * @return {Uint8Array[]}\n   *         An array of the end paths that we found.\n   */\n\n  var findBox = function findBox(bytes, paths, complete) {\n    if (complete === void 0) {\n      complete = false;\n    }\n    paths = normalizePaths$1(paths);\n    bytes = toUint8(bytes);\n    var results = [];\n    if (!paths.length) {\n      // short-circuit the search for empty paths\n      return results;\n    }\n    var i = 0;\n    while (i < bytes.length) {\n      var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n      var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n      if (size === 0) {\n        break;\n      }\n      var end = i + size;\n      if (end > bytes.length) {\n        // this box is bigger than the number of bytes we have\n        // and complete is set, we cannot find any more boxes.\n        if (complete) {\n          break;\n        }\n        end = bytes.length;\n      }\n      var data = bytes.subarray(i + 8, end);\n      if (bytesMatch(type, paths[0])) {\n        if (paths.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push(data);\n        } else {\n          // recursively search for the next box along the path\n          results.push.apply(results, findBox(data, paths.slice(1), complete));\n        }\n      }\n      i = end;\n    } // we've finished searching all of bytes\n\n    return results;\n  };\n\n  // https://matroska-org.github.io/libebml/specs.html\n  // https://www.matroska.org/technical/elements.html\n  // https://www.webmproject.org/docs/container/\n\n  var EBML_TAGS = {\n    EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n    DocType: toUint8([0x42, 0x82]),\n    Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n    SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n    Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n    Track: toUint8([0xAE]),\n    TrackNumber: toUint8([0xd7]),\n    DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n    TrackEntry: toUint8([0xAE]),\n    TrackType: toUint8([0x83]),\n    FlagDefault: toUint8([0x88]),\n    CodecID: toUint8([0x86]),\n    CodecPrivate: toUint8([0x63, 0xA2]),\n    VideoTrack: toUint8([0xe0]),\n    AudioTrack: toUint8([0xe1]),\n    // Not used yet, but will be used for live webm/mkv\n    // see https://www.matroska.org/technical/basics.html#block-structure\n    // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n    Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n    Timestamp: toUint8([0xE7]),\n    TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n    BlockGroup: toUint8([0xA0]),\n    BlockDuration: toUint8([0x9B]),\n    Block: toUint8([0xA1]),\n    SimpleBlock: toUint8([0xA3])\n  };\n  /**\n   * This is a simple table to determine the length\n   * of things in ebml. The length is one based (starts at 1,\n   * rather than zero) and for every zero bit before a one bit\n   * we add one to length. We also need this table because in some\n   * case we have to xor all the length bits from another value.\n   */\n\n  var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n  var getLength = function getLength(byte) {\n    var len = 1;\n    for (var i = 0; i < LENGTH_TABLE.length; i++) {\n      if (byte & LENGTH_TABLE[i]) {\n        break;\n      }\n      len++;\n    }\n    return len;\n  }; // length in ebml is stored in the first 4 to 8 bits\n  // of the first byte. 4 for the id length and 8 for the\n  // data size length. Length is measured by converting the number to binary\n  // then 1 + the number of zeros before a 1 is encountered starting\n  // from the left.\n\n  var getvint = function getvint(bytes, offset, removeLength, signed) {\n    if (removeLength === void 0) {\n      removeLength = true;\n    }\n    if (signed === void 0) {\n      signed = false;\n    }\n    var length = getLength(bytes[offset]);\n    var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n    // as they will be modified below to remove the dataSizeLen bits and we do not\n    // want to modify the original data. normally we could just call slice on\n    // uint8array but ie 11 does not support that...\n\n    if (removeLength) {\n      valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n      valueBytes[0] ^= LENGTH_TABLE[length - 1];\n    }\n    return {\n      length: length,\n      value: bytesToNumber(valueBytes, {\n        signed: signed\n      }),\n      bytes: valueBytes\n    };\n  };\n  var normalizePath = function normalizePath(path) {\n    if (typeof path === 'string') {\n      return path.match(/.{1,2}/g).map(function (p) {\n        return normalizePath(p);\n      });\n    }\n    if (typeof path === 'number') {\n      return numberToBytes(path);\n    }\n    return path;\n  };\n  var normalizePaths = function normalizePaths(paths) {\n    if (!Array.isArray(paths)) {\n      return [normalizePath(paths)];\n    }\n    return paths.map(function (p) {\n      return normalizePath(p);\n    });\n  };\n  var getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n    if (offset >= bytes.length) {\n      return bytes.length;\n    }\n    var innerid = getvint(bytes, offset, false);\n    if (bytesMatch(id.bytes, innerid.bytes)) {\n      return offset;\n    }\n    var dataHeader = getvint(bytes, offset + innerid.length);\n    return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n  };\n  /**\n   * Notes on the EBLM format.\n   *\n   * EBLM uses \"vints\" tags. Every vint tag contains\n   * two parts\n   *\n   * 1. The length from the first byte. You get this by\n   *    converting the byte to binary and counting the zeros\n   *    before a 1. Then you add 1 to that. Examples\n   *    00011111 = length 4 because there are 3 zeros before a 1.\n   *    00100000 = length 3 because there are 2 zeros before a 1.\n   *    00000011 = length 7 because there are 6 zeros before a 1.\n   *\n   * 2. The bits used for length are removed from the first byte\n   *    Then all the bytes are merged into a value. NOTE: this\n   *    is not the case for id ebml tags as there id includes\n   *    length bits.\n   *\n   */\n\n  var findEbml = function findEbml(bytes, paths) {\n    paths = normalizePaths(paths);\n    bytes = toUint8(bytes);\n    var results = [];\n    if (!paths.length) {\n      return results;\n    }\n    var i = 0;\n    while (i < bytes.length) {\n      var id = getvint(bytes, i, false);\n      var dataHeader = getvint(bytes, i + id.length);\n      var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n      if (dataHeader.value === 0x7f) {\n        dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n        if (dataHeader.value !== bytes.length) {\n          dataHeader.value -= dataStart;\n        }\n      }\n      var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n      var data = bytes.subarray(dataStart, dataEnd);\n      if (bytesMatch(paths[0], id.bytes)) {\n        if (paths.length === 1) {\n          // this is the end of the paths and we've found the tag we were\n          // looking for\n          results.push(data);\n        } else {\n          // recursively search for the next tag inside of the data\n          // of this one\n          results = results.concat(findEbml(data, paths.slice(1)));\n        }\n      }\n      var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n      i += totalLength;\n    }\n    return results;\n  }; // see https://www.matroska.org/technical/basics.html#block-structure\n\n  var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\n  var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\n  var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   *\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n\n  var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n    var positions = [];\n    var i = 1; // Find all `Emulation Prevention Bytes`\n\n    while (i < bytes.length - 2) {\n      if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n        positions.push(i + 2);\n        i++;\n      }\n      i++;\n    } // If no Emulation Prevention Bytes were found just return the original\n    // array\n\n    if (positions.length === 0) {\n      return bytes;\n    } // Create a new array to hold the NAL unit data\n\n    var newLength = bytes.length - positions.length;\n    var newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === positions[0]) {\n        // Skip this byte\n        sourceIndex++; // Remove this position index\n\n        positions.shift();\n      }\n      newData[i] = bytes[sourceIndex];\n    }\n    return newData;\n  };\n  var findNal = function findNal(bytes, dataType, types, nalLimit) {\n    if (nalLimit === void 0) {\n      nalLimit = Infinity;\n    }\n    bytes = toUint8(bytes);\n    types = [].concat(types);\n    var i = 0;\n    var nalStart;\n    var nalsFound = 0; // keep searching until:\n    // we reach the end of bytes\n    // we reach the maximum number of nals they want to seach\n    // NOTE: that we disregard nalLimit when we have found the start\n    // of the nal we want so that we can find the end of the nal we want.\n\n    while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n      var nalOffset = void 0;\n      if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n        nalOffset = 4;\n      } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n        nalOffset = 3;\n      } // we are unsynced,\n      // find the next nal unit\n\n      if (!nalOffset) {\n        i++;\n        continue;\n      }\n      nalsFound++;\n      if (nalStart) {\n        return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n      }\n      var nalType = void 0;\n      if (dataType === 'h264') {\n        nalType = bytes[i + nalOffset] & 0x1f;\n      } else if (dataType === 'h265') {\n        nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n      }\n      if (types.indexOf(nalType) !== -1) {\n        nalStart = i + nalOffset;\n      } // nal header is 1 length for h264, and 2 for h265\n\n      i += nalOffset + (dataType === 'h264' ? 1 : 2);\n    }\n    return bytes.subarray(0, 0);\n  };\n  var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n    return findNal(bytes, 'h264', type, nalLimit);\n  };\n  var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n    return findNal(bytes, 'h265', type, nalLimit);\n  };\n\n  var CONSTANTS = {\n    // \"webm\" string literal in hex\n    'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n    // \"matroska\" string literal in hex\n    'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n    // \"fLaC\" string literal in hex\n    'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n    // \"OggS\" string literal in hex\n    'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n    // ac-3 sync byte, also works for ec-3 as that is simply a codec\n    // of ac-3\n    'ac3': toUint8([0x0b, 0x77]),\n    // \"RIFF\" string literal in hex used for wav and avi\n    'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n    // \"AVI\" string literal in hex\n    'avi': toUint8([0x41, 0x56, 0x49]),\n    // \"WAVE\" string literal in hex\n    'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n    // \"ftyp3g\" string literal in hex\n    '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n    // \"ftyp\" string literal in hex\n    'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n    // \"styp\" string literal in hex\n    'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n    // \"ftypqt\" string literal in hex\n    'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n    // moov string literal in hex\n    'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n    // moof string literal in hex\n    'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n  };\n  var _isLikely = {\n    aac: function aac(bytes) {\n      var offset = getId3Offset(bytes);\n      return bytesMatch(bytes, [0xFF, 0x10], {\n        offset: offset,\n        mask: [0xFF, 0x16]\n      });\n    },\n    mp3: function mp3(bytes) {\n      var offset = getId3Offset(bytes);\n      return bytesMatch(bytes, [0xFF, 0x02], {\n        offset: offset,\n        mask: [0xFF, 0x06]\n      });\n    },\n    webm: function webm(bytes) {\n      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n      return bytesMatch(docType, CONSTANTS.webm);\n    },\n    mkv: function mkv(bytes) {\n      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n      return bytesMatch(docType, CONSTANTS.matroska);\n    },\n    mp4: function mp4(bytes) {\n      // if this file is another base media file format, it is not mp4\n      if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n        return false;\n      } // if this file starts with a ftyp or styp box its mp4\n\n      if (bytesMatch(bytes, CONSTANTS.mp4, {\n        offset: 4\n      }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n        offset: 4\n      })) {\n        return true;\n      } // if this file starts with a moof/moov box its mp4\n\n      if (bytesMatch(bytes, CONSTANTS.moof, {\n        offset: 4\n      }) || bytesMatch(bytes, CONSTANTS.moov, {\n        offset: 4\n      })) {\n        return true;\n      }\n    },\n    mov: function mov(bytes) {\n      return bytesMatch(bytes, CONSTANTS.mov, {\n        offset: 4\n      });\n    },\n    '3gp': function gp(bytes) {\n      return bytesMatch(bytes, CONSTANTS['3gp'], {\n        offset: 4\n      });\n    },\n    ac3: function ac3(bytes) {\n      var offset = getId3Offset(bytes);\n      return bytesMatch(bytes, CONSTANTS.ac3, {\n        offset: offset\n      });\n    },\n    ts: function ts(bytes) {\n      if (bytes.length < 189 && bytes.length >= 1) {\n        return bytes[0] === 0x47;\n      }\n      var i = 0; // check the first 376 bytes for two matching sync bytes\n\n      while (i + 188 < bytes.length && i < 188) {\n        if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n          return true;\n        }\n        i += 1;\n      }\n      return false;\n    },\n    flac: function flac(bytes) {\n      var offset = getId3Offset(bytes);\n      return bytesMatch(bytes, CONSTANTS.flac, {\n        offset: offset\n      });\n    },\n    ogg: function ogg(bytes) {\n      return bytesMatch(bytes, CONSTANTS.ogg);\n    },\n    avi: function avi(bytes) {\n      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n        offset: 8\n      });\n    },\n    wav: function wav(bytes) {\n      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n        offset: 8\n      });\n    },\n    'h264': function h264(bytes) {\n      // find seq_parameter_set_rbsp\n      return findH264Nal(bytes, 7, 3).length;\n    },\n    'h265': function h265(bytes) {\n      // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n      return findH265Nal(bytes, [32, 33], 3).length;\n    }\n  }; // get all the isLikely functions\n  // but make sure 'ts' is above h264 and h265\n  // but below everything else as it is the least specific\n\n  var isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n  .filter(function (t) {\n    return t !== 'ts' && t !== 'h264' && t !== 'h265';\n  }) // add it back to the bottom\n  .concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\n  isLikelyTypes.forEach(function (type) {\n    var isLikelyFn = _isLikely[type];\n    _isLikely[type] = function (bytes) {\n      return isLikelyFn(toUint8(bytes));\n    };\n  }); // export after wrapping\n\n  var isLikely = _isLikely; // A useful list of file signatures can be found here\n  // https://en.wikipedia.org/wiki/List_of_file_signatures\n\n  var detectContainerForBytes = function detectContainerForBytes(bytes) {\n    bytes = toUint8(bytes);\n    for (var i = 0; i < isLikelyTypes.length; i++) {\n      var type = isLikelyTypes[i];\n      if (isLikely[type](bytes)) {\n        return type;\n      }\n    }\n    return '';\n  }; // fmp4 is not a container\n\n  var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n    return findBox(bytes, ['moof']).length > 0;\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var ONE_SECOND_IN_TS = 90000,\n    // 90kHz clock\n    secondsToVideoTs,\n    secondsToAudioTs,\n    videoTsToSeconds,\n    audioTsToSeconds,\n    audioTsToVideoTs,\n    videoTsToAudioTs,\n    metadataTsToSeconds;\n  secondsToVideoTs = function (seconds) {\n    return seconds * ONE_SECOND_IN_TS;\n  };\n  secondsToAudioTs = function (seconds, sampleRate) {\n    return seconds * sampleRate;\n  };\n  videoTsToSeconds = function (timestamp) {\n    return timestamp / ONE_SECOND_IN_TS;\n  };\n  audioTsToSeconds = function (timestamp, sampleRate) {\n    return timestamp / sampleRate;\n  };\n  audioTsToVideoTs = function (timestamp, sampleRate) {\n    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n  };\n  videoTsToAudioTs = function (timestamp, sampleRate) {\n    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n  };\n\n  /**\n   * Adjust ID3 tag or caption timing information by the timeline pts values\n   * (if keepOriginalTimestamps is false) and convert to seconds\n   */\n  metadataTsToSeconds = function (timestamp, timelineStartPts, keepOriginalTimestamps) {\n    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n  };\n  var clock = {\n    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,\n    secondsToVideoTs: secondsToVideoTs,\n    secondsToAudioTs: secondsToAudioTs,\n    videoTsToSeconds: videoTsToSeconds,\n    audioTsToSeconds: audioTsToSeconds,\n    audioTsToVideoTs: audioTsToVideoTs,\n    videoTsToAudioTs: videoTsToAudioTs,\n    metadataTsToSeconds: metadataTsToSeconds\n  };\n  var clock_1 = clock.ONE_SECOND_IN_TS;\n\n  /*! @name @videojs/http-streaming @version 3.0.0 @license Apache-2.0 */\n\n  /**\n   * @file resolve-url.js - Handling how URLs are resolved and manipulated\n   */\n  const resolveUrl = resolveUrl$2;\n  /**\n   * If the xhr request was redirected, return the responseURL, otherwise,\n   * return the original url.\n   *\n   * @api private\n   *\n   * @param  {string} url - an url being requested\n   * @param  {XMLHttpRequest} req - xhr request result\n   *\n   * @return {string}\n   */\n\n  const resolveManifestRedirect = (url, req) => {\n    // To understand how the responseURL below is set and generated:\n    // - https://fetch.spec.whatwg.org/#concept-response-url\n    // - https://fetch.spec.whatwg.org/#atomic-http-redirect-handling\n    if (req && req.responseURL && url !== req.responseURL) {\n      return req.responseURL;\n    }\n    return url;\n  };\n  const logger = source => {\n    if (videojs.log.debug) {\n      return videojs.log.debug.bind(videojs, 'VHS:', `${source} >`);\n    }\n    return function () {};\n  };\n\n  /**\n   * Provides a compatibility layer between Video.js 7 and 8 API changes for VHS.\n   */\n  /**\n   * Delegates to videojs.obj.merge (Video.js 8) or\n   * videojs.mergeOptions (Video.js 7).\n   */\n\n  function merge(...args) {\n    const context = videojs.obj || videojs;\n    const fn = context.merge || context.mergeOptions;\n    return fn.apply(context, args);\n  }\n  /**\n   * Delegates to videojs.time.createTimeRanges (Video.js 8) or\n   * videojs.createTimeRanges (Video.js 7).\n   */\n\n  function createTimeRanges(...args) {\n    const context = videojs.time || videojs;\n    const fn = context.createTimeRanges || context.createTimeRanges;\n    return fn.apply(context, args);\n  }\n\n  /**\n   * ranges\n   *\n   * Utilities for working with TimeRanges.\n   *\n   */\n\n  const TIME_FUDGE_FACTOR = 1 / 30; // Comparisons between time values such as current time and the end of the buffered range\n  // can be misleading because of precision differences or when the current media has poorly\n  // aligned audio and video, which can cause values to be slightly off from what you would\n  // expect. This value is what we consider to be safe to use in such comparisons to account\n  // for these scenarios.\n\n  const SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n  const filterRanges = function (timeRanges, predicate) {\n    const results = [];\n    let i;\n    if (timeRanges && timeRanges.length) {\n      // Search for ranges that match the predicate\n      for (i = 0; i < timeRanges.length; i++) {\n        if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n          results.push([timeRanges.start(i), timeRanges.end(i)]);\n        }\n      }\n    }\n    return createTimeRanges(results);\n  };\n  /**\n   * Attempts to find the buffered TimeRange that contains the specified\n   * time.\n   *\n   * @param {TimeRanges} buffered - the TimeRanges object to query\n   * @param {number} time  - the time to filter on.\n   * @return {TimeRanges} a new TimeRanges object\n   */\n\n  const findRange = function (buffered, time) {\n    return filterRanges(buffered, function (start, end) {\n      return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;\n    });\n  };\n  /**\n   * Returns the TimeRanges that begin later than the specified time.\n   *\n   * @param {TimeRanges} timeRanges - the TimeRanges object to query\n   * @param {number} time - the time to filter on.\n   * @return {TimeRanges} a new TimeRanges object.\n   */\n\n  const findNextRange = function (timeRanges, time) {\n    return filterRanges(timeRanges, function (start) {\n      return start - TIME_FUDGE_FACTOR >= time;\n    });\n  };\n  /**\n   * Returns gaps within a list of TimeRanges\n   *\n   * @param {TimeRanges} buffered - the TimeRanges object\n   * @return {TimeRanges} a TimeRanges object of gaps\n   */\n\n  const findGaps = function (buffered) {\n    if (buffered.length < 2) {\n      return createTimeRanges();\n    }\n    const ranges = [];\n    for (let i = 1; i < buffered.length; i++) {\n      const start = buffered.end(i - 1);\n      const end = buffered.start(i);\n      ranges.push([start, end]);\n    }\n    return createTimeRanges(ranges);\n  };\n  /**\n   * Calculate the intersection of two TimeRanges\n   *\n   * @param {TimeRanges} bufferA\n   * @param {TimeRanges} bufferB\n   * @return {TimeRanges} The interesection of `bufferA` with `bufferB`\n   */\n\n  const bufferIntersection = function (bufferA, bufferB) {\n    let start = null;\n    let end = null;\n    let arity = 0;\n    const extents = [];\n    const ranges = [];\n    if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n      return createTimeRanges();\n    } // Handle the case where we have both buffers and create an\n    // intersection of the two\n\n    let count = bufferA.length; // A) Gather up all start and end times\n\n    while (count--) {\n      extents.push({\n        time: bufferA.start(count),\n        type: 'start'\n      });\n      extents.push({\n        time: bufferA.end(count),\n        type: 'end'\n      });\n    }\n    count = bufferB.length;\n    while (count--) {\n      extents.push({\n        time: bufferB.start(count),\n        type: 'start'\n      });\n      extents.push({\n        time: bufferB.end(count),\n        type: 'end'\n      });\n    } // B) Sort them by time\n\n    extents.sort(function (a, b) {\n      return a.time - b.time;\n    }); // C) Go along one by one incrementing arity for start and decrementing\n    //    arity for ends\n\n    for (count = 0; count < extents.length; count++) {\n      if (extents[count].type === 'start') {\n        arity++; // D) If arity is ever incremented to 2 we are entering an\n        //    overlapping range\n\n        if (arity === 2) {\n          start = extents[count].time;\n        }\n      } else if (extents[count].type === 'end') {\n        arity--; // E) If arity is ever decremented to 1 we leaving an\n        //    overlapping range\n\n        if (arity === 1) {\n          end = extents[count].time;\n        }\n      } // F) Record overlapping ranges\n\n      if (start !== null && end !== null) {\n        ranges.push([start, end]);\n        start = null;\n        end = null;\n      }\n    }\n    return createTimeRanges(ranges);\n  };\n  /**\n   * Gets a human readable string for a TimeRange\n   *\n   * @param {TimeRange} range\n   * @return {string} a human readable string\n   */\n\n  const printableRange = range => {\n    const strArr = [];\n    if (!range || !range.length) {\n      return '';\n    }\n    for (let i = 0; i < range.length; i++) {\n      strArr.push(range.start(i) + ' => ' + range.end(i));\n    }\n    return strArr.join(', ');\n  };\n  /**\n   * Calculates the amount of time left in seconds until the player hits the end of the\n   * buffer and causes a rebuffer\n   *\n   * @param {TimeRange} buffered\n   *        The state of the buffer\n   * @param {Numnber} currentTime\n   *        The current time of the player\n   * @param {number} playbackRate\n   *        The current playback rate of the player. Defaults to 1.\n   * @return {number}\n   *         Time until the player has to start rebuffering in seconds.\n   * @function timeUntilRebuffer\n   */\n\n  const timeUntilRebuffer = function (buffered, currentTime, playbackRate = 1) {\n    const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n    return (bufferedEnd - currentTime) / playbackRate;\n  };\n  /**\n   * Converts a TimeRanges object into an array representation\n   *\n   * @param {TimeRanges} timeRanges\n   * @return {Array}\n   */\n\n  const timeRangesToArray = timeRanges => {\n    const timeRangesList = [];\n    for (let i = 0; i < timeRanges.length; i++) {\n      timeRangesList.push({\n        start: timeRanges.start(i),\n        end: timeRanges.end(i)\n      });\n    }\n    return timeRangesList;\n  };\n  /**\n   * Determines if two time range objects are different.\n   *\n   * @param {TimeRange} a\n   *        the first time range object to check\n   *\n   * @param {TimeRange} b\n   *        the second time range object to check\n   *\n   * @return {Boolean}\n   *         Whether the time range objects differ\n   */\n\n  const isRangeDifferent = function (a, b) {\n    // same object\n    if (a === b) {\n      return false;\n    } // one or the other is undefined\n\n    if (!a && b || !b && a) {\n      return true;\n    } // length is different\n\n    if (a.length !== b.length) {\n      return true;\n    } // see if any start/end pair is different\n\n    for (let i = 0; i < a.length; i++) {\n      if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {\n        return true;\n      }\n    } // if the length and every pair is the same\n    // this is the same time range\n\n    return false;\n  };\n  const lastBufferedEnd = function (a) {\n    if (!a || !a.length || !a.end) {\n      return;\n    }\n    return a.end(a.length - 1);\n  };\n  /**\n   * A utility function to add up the amount of time in a timeRange\n   * after a specified startTime.\n   * ie:[[0, 10], [20, 40], [50, 60]] with a startTime 0\n   *     would return 40 as there are 40s seconds after 0 in the timeRange\n   *\n   * @param {TimeRange} range\n   *        The range to check against\n   * @param {number} startTime\n   *        The time in the time range that you should start counting from\n   *\n   * @return {number}\n   *          The number of seconds in the buffer passed the specified time.\n   */\n\n  const timeAheadOf = function (range, startTime) {\n    let time = 0;\n    if (!range || !range.length) {\n      return time;\n    }\n    for (let i = 0; i < range.length; i++) {\n      const start = range.start(i);\n      const end = range.end(i); // startTime is after this range entirely\n\n      if (startTime > end) {\n        continue;\n      } // startTime is within this range\n\n      if (startTime > start && startTime <= end) {\n        time += end - startTime;\n        continue;\n      } // startTime is before this range.\n\n      time += end - start;\n    }\n    return time;\n  };\n\n  /**\n   * @file playlist.js\n   *\n   * Playlist related utilities.\n   */\n  /**\n   * Get the duration of a segment, with special cases for\n   * llhls segments that do not have a duration yet.\n   *\n   * @param {Object} playlist\n   *        the playlist that the segment belongs to.\n   * @param {Object} segment\n   *        the segment to get a duration for.\n   *\n   * @return {number}\n   *          the segment duration\n   */\n\n  const segmentDurationWithParts = (playlist, segment) => {\n    // if this isn't a preload segment\n    // then we will have a segment duration that is accurate.\n    if (!segment.preload) {\n      return segment.duration;\n    } // otherwise we have to add up parts and preload hints\n    // to get an up to date duration.\n\n    let result = 0;\n    (segment.parts || []).forEach(function (p) {\n      result += p.duration;\n    }); // for preload hints we have to use partTargetDuration\n    // as they won't even have a duration yet.\n\n    (segment.preloadHints || []).forEach(function (p) {\n      if (p.type === 'PART') {\n        result += playlist.partTargetDuration;\n      }\n    });\n    return result;\n  };\n  /**\n   * A function to get a combined list of parts and segments with durations\n   * and indexes.\n   *\n   * @param {Playlist} playlist the playlist to get the list for.\n   *\n   * @return {Array} The part/segment list.\n   */\n\n  const getPartsAndSegments = playlist => (playlist.segments || []).reduce((acc, segment, si) => {\n    if (segment.parts) {\n      segment.parts.forEach(function (part, pi) {\n        acc.push({\n          duration: part.duration,\n          segmentIndex: si,\n          partIndex: pi,\n          part,\n          segment\n        });\n      });\n    } else {\n      acc.push({\n        duration: segment.duration,\n        segmentIndex: si,\n        partIndex: null,\n        segment,\n        part: null\n      });\n    }\n    return acc;\n  }, []);\n  const getLastParts = media => {\n    const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];\n    return lastSegment && lastSegment.parts || [];\n  };\n  const getKnownPartCount = ({\n    preloadSegment\n  }) => {\n    if (!preloadSegment) {\n      return;\n    }\n    const {\n      parts,\n      preloadHints\n    } = preloadSegment;\n    let partCount = (preloadHints || []).reduce((count, hint) => count + (hint.type === 'PART' ? 1 : 0), 0);\n    partCount += parts && parts.length ? parts.length : 0;\n    return partCount;\n  };\n  /**\n   * Get the number of seconds to delay from the end of a\n   * live playlist.\n   *\n   * @param {Playlist} main the main playlist\n   * @param {Playlist} media the media playlist\n   * @return {number} the hold back in seconds.\n   */\n\n  const liveEdgeDelay = (main, media) => {\n    if (media.endList) {\n      return 0;\n    } // dash suggestedPresentationDelay trumps everything\n\n    if (main && main.suggestedPresentationDelay) {\n      return main.suggestedPresentationDelay;\n    }\n    const hasParts = getLastParts(media).length > 0; // look for \"part\" delays from ll-hls first\n\n    if (hasParts && media.serverControl && media.serverControl.partHoldBack) {\n      return media.serverControl.partHoldBack;\n    } else if (hasParts && media.partTargetDuration) {\n      return media.partTargetDuration * 3; // finally look for full segment delays\n    } else if (media.serverControl && media.serverControl.holdBack) {\n      return media.serverControl.holdBack;\n    } else if (media.targetDuration) {\n      return media.targetDuration * 3;\n    }\n    return 0;\n  };\n  /**\n   * walk backward until we find a duration we can use\n   * or return a failure\n   *\n   * @param {Playlist} playlist the playlist to walk through\n   * @param {Number} endSequence the mediaSequence to stop walking on\n   */\n\n  const backwardDuration = function (playlist, endSequence) {\n    let result = 0;\n    let i = endSequence - playlist.mediaSequence; // if a start time is available for segment immediately following\n    // the interval, use it\n\n    let segment = playlist.segments[i]; // Walk backward until we find the latest segment with timeline\n    // information that is earlier than endSequence\n\n    if (segment) {\n      if (typeof segment.start !== 'undefined') {\n        return {\n          result: segment.start,\n          precise: true\n        };\n      }\n      if (typeof segment.end !== 'undefined') {\n        return {\n          result: segment.end - segment.duration,\n          precise: true\n        };\n      }\n    }\n    while (i--) {\n      segment = playlist.segments[i];\n      if (typeof segment.end !== 'undefined') {\n        return {\n          result: result + segment.end,\n          precise: true\n        };\n      }\n      result += segmentDurationWithParts(playlist, segment);\n      if (typeof segment.start !== 'undefined') {\n        return {\n          result: result + segment.start,\n          precise: true\n        };\n      }\n    }\n    return {\n      result,\n      precise: false\n    };\n  };\n  /**\n   * walk forward until we find a duration we can use\n   * or return a failure\n   *\n   * @param {Playlist} playlist the playlist to walk through\n   * @param {number} endSequence the mediaSequence to stop walking on\n   */\n\n  const forwardDuration = function (playlist, endSequence) {\n    let result = 0;\n    let segment;\n    let i = endSequence - playlist.mediaSequence; // Walk forward until we find the earliest segment with timeline\n    // information\n\n    for (; i < playlist.segments.length; i++) {\n      segment = playlist.segments[i];\n      if (typeof segment.start !== 'undefined') {\n        return {\n          result: segment.start - result,\n          precise: true\n        };\n      }\n      result += segmentDurationWithParts(playlist, segment);\n      if (typeof segment.end !== 'undefined') {\n        return {\n          result: segment.end - result,\n          precise: true\n        };\n      }\n    } // indicate we didn't find a useful duration estimate\n\n    return {\n      result: -1,\n      precise: false\n    };\n  };\n  /**\n    * Calculate the media duration from the segments associated with a\n    * playlist. The duration of a subinterval of the available segments\n    * may be calculated by specifying an end index.\n    *\n    * @param {Object} playlist a media playlist object\n    * @param {number=} endSequence an exclusive upper boundary\n    * for the playlist.  Defaults to playlist length.\n    * @param {number} expired the amount of time that has dropped\n    * off the front of the playlist in a live scenario\n    * @return {number} the duration between the first available segment\n    * and end index.\n    */\n\n  const intervalDuration = function (playlist, endSequence, expired) {\n    if (typeof endSequence === 'undefined') {\n      endSequence = playlist.mediaSequence + playlist.segments.length;\n    }\n    if (endSequence < playlist.mediaSequence) {\n      return 0;\n    } // do a backward walk to estimate the duration\n\n    const backward = backwardDuration(playlist, endSequence);\n    if (backward.precise) {\n      // if we were able to base our duration estimate on timing\n      // information provided directly from the Media Source, return\n      // it\n      return backward.result;\n    } // walk forward to see if a precise duration estimate can be made\n    // that way\n\n    const forward = forwardDuration(playlist, endSequence);\n    if (forward.precise) {\n      // we found a segment that has been buffered and so it's\n      // position is known precisely\n      return forward.result;\n    } // return the less-precise, playlist-based duration estimate\n\n    return backward.result + expired;\n  };\n  /**\n    * Calculates the duration of a playlist. If a start and end index\n    * are specified, the duration will be for the subset of the media\n    * timeline between those two indices. The total duration for live\n    * playlists is always Infinity.\n    *\n    * @param {Object} playlist a media playlist object\n    * @param {number=} endSequence an exclusive upper\n    * boundary for the playlist. Defaults to the playlist media\n    * sequence number plus its length.\n    * @param {number=} expired the amount of time that has\n    * dropped off the front of the playlist in a live scenario\n    * @return {number} the duration between the start index and end\n    * index.\n    */\n\n  const duration = function (playlist, endSequence, expired) {\n    if (!playlist) {\n      return 0;\n    }\n    if (typeof expired !== 'number') {\n      expired = 0;\n    } // if a slice of the total duration is not requested, use\n    // playlist-level duration indicators when they're present\n\n    if (typeof endSequence === 'undefined') {\n      // if present, use the duration specified in the playlist\n      if (playlist.totalDuration) {\n        return playlist.totalDuration;\n      } // duration should be Infinity for live playlists\n\n      if (!playlist.endList) {\n        return window.Infinity;\n      }\n    } // calculate the total duration based on the segment durations\n\n    return intervalDuration(playlist, endSequence, expired);\n  };\n  /**\n    * Calculate the time between two indexes in the current playlist\n    * neight the start- nor the end-index need to be within the current\n    * playlist in which case, the targetDuration of the playlist is used\n    * to approximate the durations of the segments\n    *\n    * @param {Array} options.durationList list to iterate over for durations.\n    * @param {number} options.defaultDuration duration to use for elements before or after the durationList\n    * @param {number} options.startIndex partsAndSegments index to start\n    * @param {number} options.endIndex partsAndSegments index to end.\n    * @return {number} the number of seconds between startIndex and endIndex\n    */\n\n  const sumDurations = function ({\n    defaultDuration,\n    durationList,\n    startIndex,\n    endIndex\n  }) {\n    let durations = 0;\n    if (startIndex > endIndex) {\n      [startIndex, endIndex] = [endIndex, startIndex];\n    }\n    if (startIndex < 0) {\n      for (let i = startIndex; i < Math.min(0, endIndex); i++) {\n        durations += defaultDuration;\n      }\n      startIndex = 0;\n    }\n    for (let i = startIndex; i < endIndex; i++) {\n      durations += durationList[i].duration;\n    }\n    return durations;\n  };\n  /**\n   * Calculates the playlist end time\n   *\n   * @param {Object} playlist a media playlist object\n   * @param {number=} expired the amount of time that has\n   *                  dropped off the front of the playlist in a live scenario\n   * @param {boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n   *                        playlist end calculation should consider the safe live end\n   *                        (truncate the playlist end by three segments). This is normally\n   *                        used for calculating the end of the playlist's seekable range.\n   *                        This takes into account the value of liveEdgePadding.\n   *                        Setting liveEdgePadding to 0 is equivalent to setting this to false.\n   * @param {number} liveEdgePadding a number indicating how far from the end of the playlist we should be in seconds.\n   *                 If this is provided, it is used in the safe live end calculation.\n   *                 Setting useSafeLiveEnd=false or liveEdgePadding=0 are equivalent.\n   *                 Corresponds to suggestedPresentationDelay in DASH manifests.\n   * @return {number} the end time of playlist\n   * @function playlistEnd\n   */\n\n  const playlistEnd = function (playlist, expired, useSafeLiveEnd, liveEdgePadding) {\n    if (!playlist || !playlist.segments) {\n      return null;\n    }\n    if (playlist.endList) {\n      return duration(playlist);\n    }\n    if (expired === null) {\n      return null;\n    }\n    expired = expired || 0;\n    let lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);\n    if (useSafeLiveEnd) {\n      liveEdgePadding = typeof liveEdgePadding === 'number' ? liveEdgePadding : liveEdgeDelay(null, playlist);\n      lastSegmentEndTime -= liveEdgePadding;\n    } // don't return a time less than zero\n\n    return Math.max(0, lastSegmentEndTime);\n  };\n  /**\n    * Calculates the interval of time that is currently seekable in a\n    * playlist. The returned time ranges are relative to the earliest\n    * moment in the specified playlist that is still available. A full\n    * seekable implementation for live streams would need to offset\n    * these values by the duration of content that has expired from the\n    * stream.\n    *\n    * @param {Object} playlist a media playlist object\n    * dropped off the front of the playlist in a live scenario\n    * @param {number=} expired the amount of time that has\n    * dropped off the front of the playlist in a live scenario\n    * @param {number} liveEdgePadding how far from the end of the playlist we should be in seconds.\n    *        Corresponds to suggestedPresentationDelay in DASH manifests.\n    * @return {TimeRanges} the periods of time that are valid targets\n    * for seeking\n    */\n\n  const seekable = function (playlist, expired, liveEdgePadding) {\n    const useSafeLiveEnd = true;\n    const seekableStart = expired || 0;\n    const seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);\n    if (seekableEnd === null) {\n      return createTimeRanges();\n    }\n    return createTimeRanges(seekableStart, seekableEnd);\n  };\n  /**\n   * Determine the index and estimated starting time of the segment that\n   * contains a specified playback position in a media playlist.\n   *\n   * @param {Object} options.playlist the media playlist to query\n   * @param {number} options.currentTime The number of seconds since the earliest\n   * possible position to determine the containing segment for\n   * @param {number} options.startTime the time when the segment/part starts\n   * @param {number} options.startingSegmentIndex the segment index to start looking at.\n   * @param {number?} [options.startingPartIndex] the part index to look at within the segment.\n   *\n   * @return {Object} an object with partIndex, segmentIndex, and startTime.\n   */\n\n  const getMediaInfoForTime = function ({\n    playlist,\n    currentTime,\n    startingSegmentIndex,\n    startingPartIndex,\n    startTime,\n    exactManifestTimings\n  }) {\n    let time = currentTime - startTime;\n    const partsAndSegments = getPartsAndSegments(playlist);\n    let startIndex = 0;\n    for (let i = 0; i < partsAndSegments.length; i++) {\n      const partAndSegment = partsAndSegments[i];\n      if (startingSegmentIndex !== partAndSegment.segmentIndex) {\n        continue;\n      } // skip this if part index does not match.\n\n      if (typeof startingPartIndex === 'number' && typeof partAndSegment.partIndex === 'number' && startingPartIndex !== partAndSegment.partIndex) {\n        continue;\n      }\n      startIndex = i;\n      break;\n    }\n    if (time < 0) {\n      // Walk backward from startIndex in the playlist, adding durations\n      // until we find a segment that contains `time` and return it\n      if (startIndex > 0) {\n        for (let i = startIndex - 1; i >= 0; i--) {\n          const partAndSegment = partsAndSegments[i];\n          time += partAndSegment.duration;\n          if (exactManifestTimings) {\n            if (time < 0) {\n              continue;\n            }\n          } else if (time + TIME_FUDGE_FACTOR <= 0) {\n            continue;\n          }\n          return {\n            partIndex: partAndSegment.partIndex,\n            segmentIndex: partAndSegment.segmentIndex,\n            startTime: startTime - sumDurations({\n              defaultDuration: playlist.targetDuration,\n              durationList: partsAndSegments,\n              startIndex,\n              endIndex: i\n            })\n          };\n        }\n      } // We were unable to find a good segment within the playlist\n      // so select the first segment\n\n      return {\n        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\n        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\n        startTime: currentTime\n      };\n    } // When startIndex is negative, we first walk forward to first segment\n    // adding target durations. If we \"run out of time\" before getting to\n    // the first segment, return the first segment\n\n    if (startIndex < 0) {\n      for (let i = startIndex; i < 0; i++) {\n        time -= playlist.targetDuration;\n        if (time < 0) {\n          return {\n            partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\n            segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\n            startTime: currentTime\n          };\n        }\n      }\n      startIndex = 0;\n    } // Walk forward from startIndex in the playlist, subtracting durations\n    // until we find a segment that contains `time` and return it\n\n    for (let i = startIndex; i < partsAndSegments.length; i++) {\n      const partAndSegment = partsAndSegments[i];\n      time -= partAndSegment.duration;\n      if (exactManifestTimings) {\n        if (time > 0) {\n          continue;\n        }\n      } else if (time - TIME_FUDGE_FACTOR >= 0) {\n        continue;\n      }\n      return {\n        partIndex: partAndSegment.partIndex,\n        segmentIndex: partAndSegment.segmentIndex,\n        startTime: startTime + sumDurations({\n          defaultDuration: playlist.targetDuration,\n          durationList: partsAndSegments,\n          startIndex,\n          endIndex: i\n        })\n      };\n    } // We are out of possible candidates so load the last one...\n\n    return {\n      segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,\n      partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,\n      startTime: currentTime\n    };\n  };\n  /**\n   * Check whether the playlist is excluded or not.\n   *\n   * @param {Object} playlist the media playlist object\n   * @return {boolean} whether the playlist is excluded or not\n   * @function isExcluded\n   */\n\n  const isExcluded = function (playlist) {\n    return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n  };\n  /**\n   * Check whether the playlist is compatible with current playback configuration or has\n   * been excluded permanently for being incompatible.\n   *\n   * @param {Object} playlist the media playlist object\n   * @return {boolean} whether the playlist is incompatible or not\n   * @function isIncompatible\n   */\n\n  const isIncompatible = function (playlist) {\n    return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n  };\n  /**\n   * Check whether the playlist is enabled or not.\n   *\n   * @param {Object} playlist the media playlist object\n   * @return {boolean} whether the playlist is enabled or not\n   * @function isEnabled\n   */\n\n  const isEnabled = function (playlist) {\n    const excluded = isExcluded(playlist);\n    return !playlist.disabled && !excluded;\n  };\n  /**\n   * Check whether the playlist has been manually disabled through the representations api.\n   *\n   * @param {Object} playlist the media playlist object\n   * @return {boolean} whether the playlist is disabled manually or not\n   * @function isDisabled\n   */\n\n  const isDisabled = function (playlist) {\n    return playlist.disabled;\n  };\n  /**\n   * Returns whether the current playlist is an AES encrypted HLS stream\n   *\n   * @return {boolean} true if it's an AES encrypted HLS stream\n   */\n\n  const isAes = function (media) {\n    for (let i = 0; i < media.segments.length; i++) {\n      if (media.segments[i].key) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Checks if the playlist has a value for the specified attribute\n   *\n   * @param {string} attr\n   *        Attribute to check for\n   * @param {Object} playlist\n   *        The media playlist object\n   * @return {boolean}\n   *         Whether the playlist contains a value for the attribute or not\n   * @function hasAttribute\n   */\n\n  const hasAttribute = function (attr, playlist) {\n    return playlist.attributes && playlist.attributes[attr];\n  };\n  /**\n   * Estimates the time required to complete a segment download from the specified playlist\n   *\n   * @param {number} segmentDuration\n   *        Duration of requested segment\n   * @param {number} bandwidth\n   *        Current measured bandwidth of the player\n   * @param {Object} playlist\n   *        The media playlist object\n   * @param {number=} bytesReceived\n   *        Number of bytes already received for the request. Defaults to 0\n   * @return {number|NaN}\n   *         The estimated time to request the segment. NaN if bandwidth information for\n   *         the given playlist is unavailable\n   * @function estimateSegmentRequestTime\n   */\n\n  const estimateSegmentRequestTime = function (segmentDuration, bandwidth, playlist, bytesReceived = 0) {\n    if (!hasAttribute('BANDWIDTH', playlist)) {\n      return NaN;\n    }\n    const size = segmentDuration * playlist.attributes.BANDWIDTH;\n    return (size - bytesReceived * 8) / bandwidth;\n  };\n  /*\n   * Returns whether the current playlist is the lowest rendition\n   *\n   * @return {Boolean} true if on lowest rendition\n   */\n\n  const isLowestEnabledRendition = (main, media) => {\n    if (main.playlists.length === 1) {\n      return true;\n    }\n    const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n    return main.playlists.filter(playlist => {\n      if (!isEnabled(playlist)) {\n        return false;\n      }\n      return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n    }).length === 0;\n  };\n  const playlistMatch = (a, b) => {\n    // both playlits are null\n    // or only one playlist is non-null\n    // no match\n    if (!a && !b || !a && b || a && !b) {\n      return false;\n    } // playlist objects are the same, match\n\n    if (a === b) {\n      return true;\n    } // first try to use id as it should be the most\n    // accurate\n\n    if (a.id && b.id && a.id === b.id) {\n      return true;\n    } // next try to use reslovedUri as it should be the\n    // second most accurate.\n\n    if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {\n      return true;\n    } // finally try to use uri as it should be accurate\n    // but might miss a few cases for relative uris\n\n    if (a.uri && b.uri && a.uri === b.uri) {\n      return true;\n    }\n    return false;\n  };\n  const someAudioVariant = function (main, callback) {\n    const AUDIO = main && main.mediaGroups && main.mediaGroups.AUDIO || {};\n    let found = false;\n    for (const groupName in AUDIO) {\n      for (const label in AUDIO[groupName]) {\n        found = callback(AUDIO[groupName][label]);\n        if (found) {\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    return !!found;\n  };\n  const isAudioOnly = main => {\n    // we are audio only if we have no main playlists but do\n    // have media group playlists.\n    if (!main || !main.playlists || !main.playlists.length) {\n      // without audio variants or playlists this\n      // is not an audio only main.\n      const found = someAudioVariant(main, variant => variant.playlists && variant.playlists.length || variant.uri);\n      return found;\n    } // if every playlist has only an audio codec it is audio only\n\n    for (let i = 0; i < main.playlists.length; i++) {\n      const playlist = main.playlists[i];\n      const CODECS = playlist.attributes && playlist.attributes.CODECS; // all codecs are audio, this is an audio playlist.\n\n      if (CODECS && CODECS.split(',').every(c => isAudioCodec(c))) {\n        continue;\n      } // playlist is in an audio group it is audio only\n\n      const found = someAudioVariant(main, variant => playlistMatch(playlist, variant));\n      if (found) {\n        continue;\n      } // if we make it here this playlist isn't audio and we\n      // are not audio only\n\n      return false;\n    } // if we make it past every playlist without returning, then\n    // this is an audio only playlist.\n\n    return true;\n  }; // exports\n\n  var Playlist = {\n    liveEdgeDelay,\n    duration,\n    seekable,\n    getMediaInfoForTime,\n    isEnabled,\n    isDisabled,\n    isExcluded,\n    isIncompatible,\n    playlistEnd,\n    isAes,\n    hasAttribute,\n    estimateSegmentRequestTime,\n    isLowestEnabledRendition,\n    isAudioOnly,\n    playlistMatch,\n    segmentDurationWithParts\n  };\n  const {\n    log\n  } = videojs;\n  const createPlaylistID = (index, uri) => {\n    return `${index}-${uri}`;\n  };\n  /**\n   * Parses a given m3u8 playlist\n   *\n   * @param {Function} [onwarn]\n   *        a function to call when the parser triggers a warning event.\n   * @param {Function} [oninfo]\n   *        a function to call when the parser triggers an info event.\n   * @param {string} manifestString\n   *        The downloaded manifest string\n   * @param {Object[]} [customTagParsers]\n   *        An array of custom tag parsers for the m3u8-parser instance\n   * @param {Object[]} [customTagMappers]\n   *        An array of custom tag mappers for the m3u8-parser instance\n   * @param {boolean} [llhls]\n   *        Whether to keep ll-hls features in the manifest after parsing.\n   * @return {Object}\n   *         The manifest object\n   */\n\n  const parseManifest = ({\n    onwarn,\n    oninfo,\n    manifestString,\n    customTagParsers = [],\n    customTagMappers = [],\n    llhls\n  }) => {\n    const parser = new Parser();\n    if (onwarn) {\n      parser.on('warn', onwarn);\n    }\n    if (oninfo) {\n      parser.on('info', oninfo);\n    }\n    customTagParsers.forEach(customParser => parser.addParser(customParser));\n    customTagMappers.forEach(mapper => parser.addTagMapper(mapper));\n    parser.push(manifestString);\n    parser.end();\n    const manifest = parser.manifest; // remove llhls features from the parsed manifest\n    // if we don't want llhls support.\n\n    if (!llhls) {\n      ['preloadSegment', 'skip', 'serverControl', 'renditionReports', 'partInf', 'partTargetDuration'].forEach(function (k) {\n        if (manifest.hasOwnProperty(k)) {\n          delete manifest[k];\n        }\n      });\n      if (manifest.segments) {\n        manifest.segments.forEach(function (segment) {\n          ['parts', 'preloadHints'].forEach(function (k) {\n            if (segment.hasOwnProperty(k)) {\n              delete segment[k];\n            }\n          });\n        });\n      }\n    }\n    if (!manifest.targetDuration) {\n      let targetDuration = 10;\n      if (manifest.segments && manifest.segments.length) {\n        targetDuration = manifest.segments.reduce((acc, s) => Math.max(acc, s.duration), 0);\n      }\n      if (onwarn) {\n        onwarn(`manifest has no targetDuration defaulting to ${targetDuration}`);\n      }\n      manifest.targetDuration = targetDuration;\n    }\n    const parts = getLastParts(manifest);\n    if (parts.length && !manifest.partTargetDuration) {\n      const partTargetDuration = parts.reduce((acc, p) => Math.max(acc, p.duration), 0);\n      if (onwarn) {\n        onwarn(`manifest has no partTargetDuration defaulting to ${partTargetDuration}`);\n        log.error('LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.');\n      }\n      manifest.partTargetDuration = partTargetDuration;\n    }\n    return manifest;\n  };\n  /**\n   * Loops through all supported media groups in main and calls the provided\n   * callback for each group\n   *\n   * @param {Object} main\n   *        The parsed main manifest object\n   * @param {Function} callback\n   *        Callback to call for each media group\n   */\n\n  const forEachMediaGroup = (main, callback) => {\n    if (!main.mediaGroups) {\n      return;\n    }\n    ['AUDIO', 'SUBTITLES'].forEach(mediaType => {\n      if (!main.mediaGroups[mediaType]) {\n        return;\n      }\n      for (const groupKey in main.mediaGroups[mediaType]) {\n        for (const labelKey in main.mediaGroups[mediaType][groupKey]) {\n          const mediaProperties = main.mediaGroups[mediaType][groupKey][labelKey];\n          callback(mediaProperties, mediaType, groupKey, labelKey);\n        }\n      }\n    });\n  };\n  /**\n   * Adds properties and attributes to the playlist to keep consistent functionality for\n   * playlists throughout VHS.\n   *\n   * @param {Object} config\n   *        Arguments object\n   * @param {Object} config.playlist\n   *        The media playlist\n   * @param {string} [config.uri]\n   *        The uri to the media playlist (if media playlist is not from within a main\n   *        playlist)\n   * @param {string} id\n   *        ID to use for the playlist\n   */\n\n  const setupMediaPlaylist = ({\n    playlist,\n    uri,\n    id\n  }) => {\n    playlist.id = id;\n    playlist.playlistErrors_ = 0;\n    if (uri) {\n      // For media playlists, m3u8-parser does not have access to a URI, as HLS media\n      // playlists do not contain their own source URI, but one is needed for consistency in\n      // VHS.\n      playlist.uri = uri;\n    } // For HLS main playlists, even though certain attributes MUST be defined, the\n    // stream may still be played without them.\n    // For HLS media playlists, m3u8-parser does not attach an attributes object to the\n    // manifest.\n    //\n    // To avoid undefined reference errors through the project, and make the code easier\n    // to write/read, add an empty attributes object for these cases.\n\n    playlist.attributes = playlist.attributes || {};\n  };\n  /**\n   * Adds ID, resolvedUri, and attributes properties to each playlist of the main, where\n   * necessary. In addition, creates playlist IDs for each playlist and adds playlist ID to\n   * playlist references to the playlists array.\n   *\n   * @param {Object} main\n   *        The main playlist\n   */\n\n  const setupMediaPlaylists = main => {\n    let i = main.playlists.length;\n    while (i--) {\n      const playlist = main.playlists[i];\n      setupMediaPlaylist({\n        playlist,\n        id: createPlaylistID(i, playlist.uri)\n      });\n      playlist.resolvedUri = resolveUrl(main.uri, playlist.uri);\n      main.playlists[playlist.id] = playlist; // URI reference added for backwards compatibility\n\n      main.playlists[playlist.uri] = playlist; // Although the spec states an #EXT-X-STREAM-INF tag MUST have a BANDWIDTH attribute,\n      // the stream can be played without it. Although an attributes property may have been\n      // added to the playlist to prevent undefined references, issue a warning to fix the\n      // manifest.\n\n      if (!playlist.attributes.BANDWIDTH) {\n        log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n      }\n    }\n  };\n  /**\n   * Adds resolvedUri properties to each media group.\n   *\n   * @param {Object} main\n   *        The main playlist\n   */\n\n  const resolveMediaGroupUris = main => {\n    forEachMediaGroup(main, properties => {\n      if (properties.uri) {\n        properties.resolvedUri = resolveUrl(main.uri, properties.uri);\n      }\n    });\n  };\n  /**\n   * Creates a main playlist wrapper to insert a sole media playlist into.\n   *\n   * @param {Object} media\n   *        Media playlist\n   * @param {string} uri\n   *        The media URI\n   *\n   * @return {Object}\n   *         main playlist\n   */\n\n  const mainForMedia = (media, uri) => {\n    const id = createPlaylistID(0, uri);\n    const main = {\n      mediaGroups: {\n        'AUDIO': {},\n        'VIDEO': {},\n        'CLOSED-CAPTIONS': {},\n        'SUBTITLES': {}\n      },\n      uri: window.location.href,\n      resolvedUri: window.location.href,\n      playlists: [{\n        uri,\n        id,\n        resolvedUri: uri,\n        // m3u8-parser does not attach an attributes property to media playlists so make\n        // sure that the property is attached to avoid undefined reference errors\n        attributes: {}\n      }]\n    }; // set up ID reference\n\n    main.playlists[id] = main.playlists[0]; // URI reference added for backwards compatibility\n\n    main.playlists[uri] = main.playlists[0];\n    return main;\n  };\n  /**\n   * Does an in-place update of the main manifest to add updated playlist URI references\n   * as well as other properties needed by VHS that aren't included by the parser.\n   *\n   * @param {Object} main\n   *        main manifest object\n   * @param {string} uri\n   *        The source URI\n   */\n\n  const addPropertiesToMain = (main, uri) => {\n    main.uri = uri;\n    for (let i = 0; i < main.playlists.length; i++) {\n      if (!main.playlists[i].uri) {\n        // Set up phony URIs for the playlists since playlists are referenced by their URIs\n        // throughout VHS, but some formats (e.g., DASH) don't have external URIs\n        // TODO: consider adding dummy URIs in mpd-parser\n        const phonyUri = `placeholder-uri-${i}`;\n        main.playlists[i].uri = phonyUri;\n      }\n    }\n    const audioOnlyMain = isAudioOnly(main);\n    forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n      const groupId = `placeholder-uri-${mediaType}-${groupKey}-${labelKey}`; // add a playlist array under properties\n\n      if (!properties.playlists || !properties.playlists.length) {\n        // If the manifest is audio only and this media group does not have a uri, check\n        // if the media group is located in the main list of playlists. If it is, don't add\n        // placeholder properties as it shouldn't be considered an alternate audio track.\n        if (audioOnlyMain && mediaType === 'AUDIO' && !properties.uri) {\n          for (let i = 0; i < main.playlists.length; i++) {\n            const p = main.playlists[i];\n            if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {\n              return;\n            }\n          }\n        }\n        properties.playlists = [_extends$1({}, properties)];\n      }\n      properties.playlists.forEach(function (p, i) {\n        const id = createPlaylistID(i, groupId);\n        if (p.uri) {\n          p.resolvedUri = p.resolvedUri || resolveUrl(main.uri, p.uri);\n        } else {\n          // DEPRECATED, this has been added to prevent a breaking change.\n          // previously we only ever had a single media group playlist, so\n          // we mark the first playlist uri without prepending the index as we used to\n          // ideally we would do all of the playlists the same way.\n          p.uri = i === 0 ? groupId : id; // don't resolve a placeholder uri to an absolute url, just use\n          // the placeholder again\n\n          p.resolvedUri = p.uri;\n        }\n        p.id = p.id || id; // add an empty attributes object, all playlists are\n        // expected to have this.\n\n        p.attributes = p.attributes || {}; // setup ID and URI references (URI for backwards compatibility)\n\n        main.playlists[p.id] = p;\n        main.playlists[p.uri] = p;\n      });\n    });\n    setupMediaPlaylists(main);\n    resolveMediaGroupUris(main);\n  };\n\n  /**\n   * @file playlist-loader.js\n   *\n   * A state machine that manages the loading, caching, and updating of\n   * M3U8 playlists.\n   *\n   */\n  const {\n    EventTarget: EventTarget$1\n  } = videojs;\n  const addLLHLSQueryDirectives = (uri, media) => {\n    if (media.endList || !media.serverControl) {\n      return uri;\n    }\n    const parameters = {};\n    if (media.serverControl.canBlockReload) {\n      const {\n        preloadSegment\n      } = media; // next msn is a zero based value, length is not.\n\n      let nextMSN = media.mediaSequence + media.segments.length; // If preload segment has parts then it is likely\n      // that we are going to request a part of that preload segment.\n      // the logic below is used to determine that.\n\n      if (preloadSegment) {\n        const parts = preloadSegment.parts || []; // _HLS_part is a zero based index\n\n        const nextPart = getKnownPartCount(media) - 1; // if nextPart is > -1 and not equal to just the\n        // length of parts, then we know we had part preload hints\n        // and we need to add the _HLS_part= query\n\n        if (nextPart > -1 && nextPart !== parts.length - 1) {\n          // add existing parts to our preload hints\n          // eslint-disable-next-line\n          parameters._HLS_part = nextPart;\n        } // this if statement makes sure that we request the msn\n        // of the preload segment if:\n        // 1. the preload segment had parts (and was not yet a full segment)\n        //    but was added to our segments array\n        // 2. the preload segment had preload hints for parts that are not in\n        //    the manifest yet.\n        // in all other cases we want the segment after the preload segment\n        // which will be given by using media.segments.length because it is 1 based\n        // rather than 0 based.\n\n        if (nextPart > -1 || parts.length) {\n          nextMSN--;\n        }\n      } // add _HLS_msn= in front of any _HLS_part query\n      // eslint-disable-next-line\n\n      parameters._HLS_msn = nextMSN;\n    }\n    if (media.serverControl && media.serverControl.canSkipUntil) {\n      // add _HLS_skip= infront of all other queries.\n      // eslint-disable-next-line\n      parameters._HLS_skip = media.serverControl.canSkipDateranges ? 'v2' : 'YES';\n    }\n    if (Object.keys(parameters).length) {\n      const parsedUri = new window.URL(uri);\n      ['_HLS_skip', '_HLS_msn', '_HLS_part'].forEach(function (name) {\n        if (!parameters.hasOwnProperty(name)) {\n          return;\n        }\n        parsedUri.searchParams.set(name, parameters[name]);\n      });\n      uri = parsedUri.toString();\n    }\n    return uri;\n  };\n  /**\n   * Returns a new segment object with properties and\n   * the parts array merged.\n   *\n   * @param {Object} a the old segment\n   * @param {Object} b the new segment\n   *\n   * @return {Object} the merged segment\n   */\n\n  const updateSegment = (a, b) => {\n    if (!a) {\n      return b;\n    }\n    const result = merge(a, b); // if only the old segment has preload hints\n    // and the new one does not, remove preload hints.\n\n    if (a.preloadHints && !b.preloadHints) {\n      delete result.preloadHints;\n    } // if only the old segment has parts\n    // then the parts are no longer valid\n\n    if (a.parts && !b.parts) {\n      delete result.parts; // if both segments have parts\n      // copy part propeties from the old segment\n      // to the new one.\n    } else if (a.parts && b.parts) {\n      for (let i = 0; i < b.parts.length; i++) {\n        if (a.parts && a.parts[i]) {\n          result.parts[i] = merge(a.parts[i], b.parts[i]);\n        }\n      }\n    } // set skipped to false for segments that have\n    // have had information merged from the old segment.\n\n    if (!a.skipped && b.skipped) {\n      result.skipped = false;\n    } // set preload to false for segments that have\n    // had information added in the new segment.\n\n    if (a.preload && !b.preload) {\n      result.preload = false;\n    }\n    return result;\n  };\n  /**\n   * Returns a new array of segments that is the result of merging\n   * properties from an older list of segments onto an updated\n   * list. No properties on the updated playlist will be ovewritten.\n   *\n   * @param {Array} original the outdated list of segments\n   * @param {Array} update the updated list of segments\n   * @param {number=} offset the index of the first update\n   * segment in the original segment list. For non-live playlists,\n   * this should always be zero and does not need to be\n   * specified. For live playlists, it should be the difference\n   * between the media sequence numbers in the original and updated\n   * playlists.\n   * @return {Array} a list of merged segment objects\n   */\n\n  const updateSegments = (original, update, offset) => {\n    const oldSegments = original.slice();\n    const newSegments = update.slice();\n    offset = offset || 0;\n    const result = [];\n    let currentMap;\n    for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {\n      const oldSegment = oldSegments[newIndex + offset];\n      const newSegment = newSegments[newIndex];\n      if (oldSegment) {\n        currentMap = oldSegment.map || currentMap;\n        result.push(updateSegment(oldSegment, newSegment));\n      } else {\n        // carry over map to new segment if it is missing\n        if (currentMap && !newSegment.map) {\n          newSegment.map = currentMap;\n        }\n        result.push(newSegment);\n      }\n    }\n    return result;\n  };\n  const resolveSegmentUris = (segment, baseUri) => {\n    // preloadSegment will not have a uri at all\n    // as the segment isn't actually in the manifest yet, only parts\n    if (!segment.resolvedUri && segment.uri) {\n      segment.resolvedUri = resolveUrl(baseUri, segment.uri);\n    }\n    if (segment.key && !segment.key.resolvedUri) {\n      segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);\n    }\n    if (segment.map && !segment.map.resolvedUri) {\n      segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);\n    }\n    if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {\n      segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);\n    }\n    if (segment.parts && segment.parts.length) {\n      segment.parts.forEach(p => {\n        if (p.resolvedUri) {\n          return;\n        }\n        p.resolvedUri = resolveUrl(baseUri, p.uri);\n      });\n    }\n    if (segment.preloadHints && segment.preloadHints.length) {\n      segment.preloadHints.forEach(p => {\n        if (p.resolvedUri) {\n          return;\n        }\n        p.resolvedUri = resolveUrl(baseUri, p.uri);\n      });\n    }\n  };\n  const getAllSegments = function (media) {\n    const segments = media.segments || [];\n    const preloadSegment = media.preloadSegment; // a preloadSegment with only preloadHints is not currently\n    // a usable segment, only include a preloadSegment that has\n    // parts.\n\n    if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {\n      // if preloadHints has a MAP that means that the\n      // init segment is going to change. We cannot use any of the parts\n      // from this preload segment.\n      if (preloadSegment.preloadHints) {\n        for (let i = 0; i < preloadSegment.preloadHints.length; i++) {\n          if (preloadSegment.preloadHints[i].type === 'MAP') {\n            return segments;\n          }\n        }\n      } // set the duration for our preload segment to target duration.\n\n      preloadSegment.duration = media.targetDuration;\n      preloadSegment.preload = true;\n      segments.push(preloadSegment);\n    }\n    return segments;\n  }; // consider the playlist unchanged if the playlist object is the same or\n  // the number of segments is equal, the media sequence number is unchanged,\n  // and this playlist hasn't become the end of the playlist\n\n  const isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;\n  /**\n    * Returns a new main playlist that is the result of merging an\n    * updated media playlist into the original version. If the\n    * updated media playlist does not match any of the playlist\n    * entries in the original main playlist, null is returned.\n    *\n    * @param {Object} main a parsed main M3U8 object\n    * @param {Object} media a parsed media M3U8 object\n    * @return {Object} a new object that represents the original\n    * main playlist with the updated media playlist merged in, or\n    * null if the merge produced no change.\n    */\n\n  const updateMain$1 = (main, newMedia, unchangedCheck = isPlaylistUnchanged) => {\n    const result = merge(main, {});\n    const oldMedia = result.playlists[newMedia.id];\n    if (!oldMedia) {\n      return null;\n    }\n    if (unchangedCheck(oldMedia, newMedia)) {\n      return null;\n    }\n    newMedia.segments = getAllSegments(newMedia);\n    const mergedPlaylist = merge(oldMedia, newMedia); // always use the new media's preload segment\n\n    if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {\n      delete mergedPlaylist.preloadSegment;\n    } // if the update could overlap existing segment information, merge the two segment lists\n\n    if (oldMedia.segments) {\n      if (newMedia.skip) {\n        newMedia.segments = newMedia.segments || []; // add back in objects for skipped segments, so that we merge\n        // old properties into the new segments\n\n        for (let i = 0; i < newMedia.skip.skippedSegments; i++) {\n          newMedia.segments.unshift({\n            skipped: true\n          });\n        }\n      }\n      mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);\n    } // resolve any segment URIs to prevent us from having to do it later\n\n    mergedPlaylist.segments.forEach(segment => {\n      resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n    }); // TODO Right now in the playlists array there are two references to each playlist, one\n    // that is referenced by index, and one by URI. The index reference may no longer be\n    // necessary.\n\n    for (let i = 0; i < result.playlists.length; i++) {\n      if (result.playlists[i].id === newMedia.id) {\n        result.playlists[i] = mergedPlaylist;\n      }\n    }\n    result.playlists[newMedia.id] = mergedPlaylist; // URI reference added for backwards compatibility\n\n    result.playlists[newMedia.uri] = mergedPlaylist; // update media group playlist references.\n\n    forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n      if (!properties.playlists) {\n        return;\n      }\n      for (let i = 0; i < properties.playlists.length; i++) {\n        if (newMedia.id === properties.playlists[i].id) {\n          properties.playlists[i] = mergedPlaylist;\n        }\n      }\n    });\n    return result;\n  };\n  /**\n   * Calculates the time to wait before refreshing a live playlist\n   *\n   * @param {Object} media\n   *        The current media\n   * @param {boolean} update\n   *        True if there were any updates from the last refresh, false otherwise\n   * @return {number}\n   *         The time in ms to wait before refreshing the live playlist\n   */\n\n  const refreshDelay = (media, update) => {\n    const segments = media.segments || [];\n    const lastSegment = segments[segments.length - 1];\n    const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];\n    const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;\n    if (update && lastDuration) {\n      return lastDuration * 1000;\n    } // if the playlist is unchanged since the last reload or last segment duration\n    // cannot be determined, try again after half the target duration\n\n    return (media.partTargetDuration || media.targetDuration || 10) * 500;\n  };\n  /**\n   * Load a playlist from a remote location\n   *\n   * @class PlaylistLoader\n   * @extends Stream\n   * @param {string|Object} src url or object of manifest\n   * @param {boolean} withCredentials the withCredentials xhr option\n   * @class\n   */\n\n  class PlaylistLoader extends EventTarget$1 {\n    constructor(src, vhs, options = {}) {\n      super();\n      if (!src) {\n        throw new Error('A non-empty playlist URL or object is required');\n      }\n      this.logger_ = logger('PlaylistLoader');\n      const {\n        withCredentials = false\n      } = options;\n      this.src = src;\n      this.vhs_ = vhs;\n      this.withCredentials = withCredentials;\n      const vhsOptions = vhs.options_;\n      this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];\n      this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];\n      this.llhls = vhsOptions && vhsOptions.llhls; // initialize the loader state\n\n      this.state = 'HAVE_NOTHING'; // live playlist staleness timeout\n\n      this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);\n      this.on('mediaupdatetimeout', this.handleMediaupdatetimeout_);\n    }\n    handleMediaupdatetimeout_() {\n      if (this.state !== 'HAVE_METADATA') {\n        // only refresh the media playlist if no other activity is going on\n        return;\n      }\n      const media = this.media();\n      let uri = resolveUrl(this.main.uri, media.uri);\n      if (this.llhls) {\n        uri = addLLHLSQueryDirectives(uri, media);\n      }\n      this.state = 'HAVE_CURRENT_METADATA';\n      this.request = this.vhs_.xhr({\n        uri,\n        withCredentials: this.withCredentials\n      }, (error, req) => {\n        // disposed\n        if (!this.request) {\n          return;\n        }\n        if (error) {\n          return this.playlistRequestError(this.request, this.media(), 'HAVE_METADATA');\n        }\n        this.haveMetadata({\n          playlistString: this.request.responseText,\n          url: this.media().uri,\n          id: this.media().id\n        });\n      });\n    }\n    playlistRequestError(xhr, playlist, startingState) {\n      const {\n        uri,\n        id\n      } = playlist; // any in-flight request is now finished\n\n      this.request = null;\n      if (startingState) {\n        this.state = startingState;\n      }\n      this.error = {\n        playlist: this.main.playlists[id],\n        status: xhr.status,\n        message: `HLS playlist request error at URL: ${uri}.`,\n        responseText: xhr.responseText,\n        code: xhr.status >= 500 ? 4 : 2\n      };\n      this.trigger('error');\n    }\n    parseManifest_({\n      url,\n      manifestString\n    }) {\n      return parseManifest({\n        onwarn: ({\n          message\n        }) => this.logger_(`m3u8-parser warn for ${url}: ${message}`),\n        oninfo: ({\n          message\n        }) => this.logger_(`m3u8-parser info for ${url}: ${message}`),\n        manifestString,\n        customTagParsers: this.customTagParsers,\n        customTagMappers: this.customTagMappers,\n        llhls: this.llhls\n      });\n    }\n    /**\n     * Update the playlist loader's state in response to a new or updated playlist.\n     *\n     * @param {string} [playlistString]\n     *        Playlist string (if playlistObject is not provided)\n     * @param {Object} [playlistObject]\n     *        Playlist object (if playlistString is not provided)\n     * @param {string} url\n     *        URL of playlist\n     * @param {string} id\n     *        ID to use for playlist\n     */\n\n    haveMetadata({\n      playlistString,\n      playlistObject,\n      url,\n      id\n    }) {\n      // any in-flight request is now finished\n      this.request = null;\n      this.state = 'HAVE_METADATA';\n      const playlist = playlistObject || this.parseManifest_({\n        url,\n        manifestString: playlistString\n      });\n      playlist.lastRequest = Date.now();\n      setupMediaPlaylist({\n        playlist,\n        uri: url,\n        id\n      }); // merge this playlist into the main manifest\n\n      const update = updateMain$1(this.main, playlist);\n      this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;\n      this.pendingMedia_ = null;\n      if (update) {\n        this.main = update;\n        this.media_ = this.main.playlists[id];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n      this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));\n      this.trigger('loadedplaylist');\n    }\n    /**\n      * Abort any outstanding work and clean up.\n      */\n\n    dispose() {\n      this.trigger('dispose');\n      this.stopRequest();\n      window.clearTimeout(this.mediaUpdateTimeout);\n      window.clearTimeout(this.finalRenditionTimeout);\n      this.off();\n    }\n    stopRequest() {\n      if (this.request) {\n        const oldRequest = this.request;\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n    /**\n      * When called without any arguments, returns the currently\n      * active media playlist. When called with a single argument,\n      * triggers the playlist loader to asynchronously switch to the\n      * specified media playlist. Calling this method while the\n      * loader is in the HAVE_NOTHING causes an error to be emitted\n      * but otherwise has no effect.\n      *\n      * @param {Object=} playlist the parsed media playlist\n      * object to switch to\n      * @param {boolean=} shouldDelay whether we should delay the request by half target duration\n      *\n      * @return {Playlist} the current loaded media\n      */\n\n    media(playlist, shouldDelay) {\n      // getter\n      if (!playlist) {\n        return this.media_;\n      } // setter\n\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      } // find the playlist object if the target playlist has been\n      // specified by URI\n\n      if (typeof playlist === 'string') {\n        if (!this.main.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.main.playlists[playlist];\n      }\n      window.clearTimeout(this.finalRenditionTimeout);\n      if (shouldDelay) {\n        const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1000 || 5 * 1000;\n        this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, playlist, false), delay);\n        return;\n      }\n      const startingState = this.state;\n      const mediaChange = !this.media_ || playlist.id !== this.media_.id;\n      const mainPlaylistRef = this.main.playlists[playlist.id]; // switch to fully loaded playlists immediately\n\n      if (mainPlaylistRef && mainPlaylistRef.endList ||\n      // handle the case of a playlist object (e.g., if using vhs-json with a resolved\n      // media playlist or, for the case of demuxed audio, a resolved audio media group)\n      playlist.endList && playlist.segments.length) {\n        // abort outstanding playlist requests\n        if (this.request) {\n          this.request.onreadystatechange = null;\n          this.request.abort();\n          this.request = null;\n        }\n        this.state = 'HAVE_METADATA';\n        this.media_ = playlist; // trigger media change if the active media has been updated\n\n        if (mediaChange) {\n          this.trigger('mediachanging');\n          if (startingState === 'HAVE_MAIN_MANIFEST') {\n            // The initial playlist was a main manifest, and the first media selected was\n            // also provided (in the form of a resolved playlist object) as part of the\n            // source object (rather than just a URL). Therefore, since the media playlist\n            // doesn't need to be requested, loadedmetadata won't trigger as part of the\n            // normal flow, and needs an explicit trigger here.\n            this.trigger('loadedmetadata');\n          } else {\n            this.trigger('mediachange');\n          }\n        }\n        return;\n      } // We update/set the timeout here so that live playlists\n      // that are not a media change will \"start\" the loader as expected.\n      // We expect that this function will start the media update timeout\n      // cycle again. This also prevents a playlist switch failure from\n      // causing us to stall during live.\n\n      this.updateMediaUpdateTimeout_(refreshDelay(playlist, true)); // switching to the active playlist is a no-op\n\n      if (!mediaChange) {\n        return;\n      }\n      this.state = 'SWITCHING_MEDIA'; // there is already an outstanding playlist request\n\n      if (this.request) {\n        if (playlist.resolvedUri === this.request.url) {\n          // requesting to switch to the same playlist multiple times\n          // has no effect after the first\n          return;\n        }\n        this.request.onreadystatechange = null;\n        this.request.abort();\n        this.request = null;\n      } // request the new playlist\n\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n      this.pendingMedia_ = playlist;\n      this.request = this.vhs_.xhr({\n        uri: playlist.resolvedUri,\n        withCredentials: this.withCredentials\n      }, (error, req) => {\n        // disposed\n        if (!this.request) {\n          return;\n        }\n        playlist.lastRequest = Date.now();\n        playlist.resolvedUri = resolveManifestRedirect(playlist.resolvedUri, req);\n        if (error) {\n          return this.playlistRequestError(this.request, playlist, startingState);\n        }\n        this.haveMetadata({\n          playlistString: req.responseText,\n          url: playlist.uri,\n          id: playlist.id\n        }); // fire loadedmetadata the first time a media playlist is loaded\n\n        if (startingState === 'HAVE_MAIN_MANIFEST') {\n          this.trigger('loadedmetadata');\n        } else {\n          this.trigger('mediachange');\n        }\n      });\n    }\n    /**\n     * pause loading of the playlist\n     */\n\n    pause() {\n      if (this.mediaUpdateTimeout) {\n        window.clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = null;\n      }\n      this.stopRequest();\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      } // Need to restore state now that no activity is happening\n\n      if (this.state === 'SWITCHING_MEDIA') {\n        // if the loader was in the process of switching media, it should either return to\n        // HAVE_MAIN_MANIFEST or HAVE_METADATA depending on if the loader has loaded a media\n        // playlist yet. This is determined by the existence of loader.media_\n        if (this.media_) {\n          this.state = 'HAVE_METADATA';\n        } else {\n          this.state = 'HAVE_MAIN_MANIFEST';\n        }\n      } else if (this.state === 'HAVE_CURRENT_METADATA') {\n        this.state = 'HAVE_METADATA';\n      }\n    }\n    /**\n     * start loading of the playlist\n     */\n\n    load(shouldDelay) {\n      if (this.mediaUpdateTimeout) {\n        window.clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = null;\n      }\n      const media = this.media();\n      if (shouldDelay) {\n        const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1000 : 5 * 1000;\n        this.mediaUpdateTimeout = window.setTimeout(() => {\n          this.mediaUpdateTimeout = null;\n          this.load();\n        }, delay);\n        return;\n      }\n      if (!this.started) {\n        this.start();\n        return;\n      }\n      if (media && !media.endList) {\n        this.trigger('mediaupdatetimeout');\n      } else {\n        this.trigger('loadedplaylist');\n      }\n    }\n    updateMediaUpdateTimeout_(delay) {\n      if (this.mediaUpdateTimeout) {\n        window.clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = null;\n      } // we only have use mediaupdatetimeout for live playlists.\n\n      if (!this.media() || this.media().endList) {\n        return;\n      }\n      this.mediaUpdateTimeout = window.setTimeout(() => {\n        this.mediaUpdateTimeout = null;\n        this.trigger('mediaupdatetimeout');\n        this.updateMediaUpdateTimeout_(delay);\n      }, delay);\n    }\n    /**\n     * start loading of the playlist\n     */\n\n    start() {\n      this.started = true;\n      if (typeof this.src === 'object') {\n        // in the case of an entirely constructed manifest object (meaning there's no actual\n        // manifest on a server), default the uri to the page's href\n        if (!this.src.uri) {\n          this.src.uri = window.location.href;\n        } // resolvedUri is added on internally after the initial request. Since there's no\n        // request for pre-resolved manifests, add on resolvedUri here.\n\n        this.src.resolvedUri = this.src.uri; // Since a manifest object was passed in as the source (instead of a URL), the first\n        // request can be skipped (since the top level of the manifest, at a minimum, is\n        // already available as a parsed manifest object). However, if the manifest object\n        // represents a main playlist, some media playlists may need to be resolved before\n        // the starting segment list is available. Therefore, go directly to setup of the\n        // initial playlist, and let the normal flow continue from there.\n        //\n        // Note that the call to setup is asynchronous, as other sections of VHS may assume\n        // that the first request is asynchronous.\n\n        setTimeout(() => {\n          this.setupInitialPlaylist(this.src);\n        }, 0);\n        return;\n      } // request the specified URL\n\n      this.request = this.vhs_.xhr({\n        uri: this.src,\n        withCredentials: this.withCredentials\n      }, (error, req) => {\n        // disposed\n        if (!this.request) {\n          return;\n        } // clear the loader's request reference\n\n        this.request = null;\n        if (error) {\n          this.error = {\n            status: req.status,\n            message: `HLS playlist request error at URL: ${this.src}.`,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (this.state === 'HAVE_NOTHING') {\n            this.started = false;\n          }\n          return this.trigger('error');\n        }\n        this.src = resolveManifestRedirect(this.src, req);\n        const manifest = this.parseManifest_({\n          manifestString: req.responseText,\n          url: this.src\n        });\n        this.setupInitialPlaylist(manifest);\n      });\n    }\n    srcUri() {\n      return typeof this.src === 'string' ? this.src : this.src.uri;\n    }\n    /**\n     * Given a manifest object that's either a main or media playlist, trigger the proper\n     * events and set the state of the playlist loader.\n     *\n     * If the manifest object represents a main playlist, `loadedplaylist` will be\n     * triggered to allow listeners to select a playlist. If none is selected, the loader\n     * will default to the first one in the playlists array.\n     *\n     * If the manifest object represents a media playlist, `loadedplaylist` will be\n     * triggered followed by `loadedmetadata`, as the only available playlist is loaded.\n     *\n     * In the case of a media playlist, a main playlist object wrapper with one playlist\n     * will be created so that all logic can handle playlists in the same fashion (as an\n     * assumed manifest object schema).\n     *\n     * @param {Object} manifest\n     *        The parsed manifest object\n     */\n\n    setupInitialPlaylist(manifest) {\n      this.state = 'HAVE_MAIN_MANIFEST';\n      if (manifest.playlists) {\n        this.main = manifest;\n        addPropertiesToMain(this.main, this.srcUri()); // If the initial main playlist has playlists wtih segments already resolved,\n        // then resolve URIs in advance, as they are usually done after a playlist request,\n        // which may not happen if the playlist is resolved.\n\n        manifest.playlists.forEach(playlist => {\n          playlist.segments = getAllSegments(playlist);\n          playlist.segments.forEach(segment => {\n            resolveSegmentUris(segment, playlist.resolvedUri);\n          });\n        });\n        this.trigger('loadedplaylist');\n        if (!this.request) {\n          // no media playlist was specifically selected so start\n          // from the first listed one\n          this.media(this.main.playlists[0]);\n        }\n        return;\n      } // In order to support media playlists passed in as vhs-json, the case where the uri\n      // is not provided as part of the manifest should be considered, and an appropriate\n      // default used.\n\n      const uri = this.srcUri() || window.location.href;\n      this.main = mainForMedia(manifest, uri);\n      this.haveMetadata({\n        playlistObject: manifest,\n        url: uri,\n        id: this.main.playlists[0].id\n      });\n      this.trigger('loadedmetadata');\n    }\n  }\n\n  /**\n   * @file xhr.js\n   */\n  const {\n    xhr: videojsXHR\n  } = videojs;\n  const callbackWrapper = function (request, error, response, callback) {\n    const reqResponse = request.responseType === 'arraybuffer' ? request.response : request.responseText;\n    if (!error && reqResponse) {\n      request.responseTime = Date.now();\n      request.roundTripTime = request.responseTime - request.requestTime;\n      request.bytesReceived = reqResponse.byteLength || reqResponse.length;\n      if (!request.bandwidth) {\n        request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\n      }\n    }\n    if (response.headers) {\n      request.responseHeaders = response.headers;\n    } // videojs.xhr now uses a specific code on the error\n    // object to signal that a request has timed out instead\n    // of setting a boolean on the request object\n\n    if (error && error.code === 'ETIMEDOUT') {\n      request.timedout = true;\n    } // videojs.xhr no longer considers status codes outside of 200 and 0\n    // (for file uris) to be errors, but the old XHR did, so emulate that\n    // behavior. Status 206 may be used in response to byterange requests.\n\n    if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\n      error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\n    }\n    callback(error, request);\n  };\n  const xhrFactory = function () {\n    const xhr = function XhrFunction(options, callback) {\n      // Add a default timeout\n      options = merge({\n        timeout: 45e3\n      }, options); // Allow an optional user-specified function to modify the option\n      // object before we construct the xhr request\n\n      const beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;\n      if (beforeRequest && typeof beforeRequest === 'function') {\n        const newOptions = beforeRequest(options);\n        if (newOptions) {\n          options = newOptions;\n        }\n      } // Use the standard videojs.xhr() method unless `videojs.Vhs.xhr` has been overriden\n      // TODO: switch back to videojs.Vhs.xhr.name === 'XhrFunction' when we drop IE11\n\n      const xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;\n      const request = xhrMethod(options, function (error, response) {\n        return callbackWrapper(request, error, response, callback);\n      });\n      const originalAbort = request.abort;\n      request.abort = function () {\n        request.aborted = true;\n        return originalAbort.apply(request, arguments);\n      };\n      request.uri = options.uri;\n      request.requestTime = Date.now();\n      return request;\n    };\n    xhr.original = true;\n    return xhr;\n  };\n  /**\n   * Turns segment byterange into a string suitable for use in\n   * HTTP Range requests\n   *\n   * @param {Object} byterange - an object with two values defining the start and end\n   *                             of a byte-range\n   */\n\n  const byterangeStr = function (byterange) {\n    // `byterangeEnd` is one less than `offset + length` because the HTTP range\n    // header uses inclusive ranges\n    let byterangeEnd;\n    const byterangeStart = byterange.offset;\n    if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n      byterangeEnd = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n    } else {\n      byterangeEnd = byterange.offset + byterange.length - 1;\n    }\n    return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n  };\n  /**\n   * Defines headers for use in the xhr request for a particular segment.\n   *\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   */\n\n  const segmentXhrHeaders = function (segment) {\n    const headers = {};\n    if (segment.byterange) {\n      headers.Range = byterangeStr(segment.byterange);\n    }\n    return headers;\n  };\n\n  /**\n   * @file bin-utils.js\n   */\n\n  /**\n   * convert a TimeRange to text\n   *\n   * @param {TimeRange} range the timerange to use for conversion\n   * @param {number} i the iterator on the range to convert\n   * @return {string} the range in string format\n   */\n\n  const textRange = function (range, i) {\n    return range.start(i) + '-' + range.end(i);\n  };\n  /**\n   * format a number as hex string\n   *\n   * @param {number} e The number\n   * @param {number} i the iterator\n   * @return {string} the hex formatted number as a string\n   */\n\n  const formatHexString = function (e, i) {\n    const value = e.toString(16);\n    return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\n  };\n  const formatAsciiString = function (e) {\n    if (e >= 0x20 && e < 0x7e) {\n      return String.fromCharCode(e);\n    }\n    return '.';\n  };\n  /**\n   * Creates an object for sending to a web worker modifying properties that are TypedArrays\n   * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n   *\n   * @param {Object} message\n   *        Object of properties and values to send to the web worker\n   * @return {Object}\n   *         Modified message with TypedArray values expanded\n   * @function createTransferableMessage\n   */\n\n  const createTransferableMessage = function (message) {\n    const transferable = {};\n    Object.keys(message).forEach(key => {\n      const value = message[key];\n      if (isArrayBufferView(value)) {\n        transferable[key] = {\n          bytes: value.buffer,\n          byteOffset: value.byteOffset,\n          byteLength: value.byteLength\n        };\n      } else {\n        transferable[key] = value;\n      }\n    });\n    return transferable;\n  };\n  /**\n   * Returns a unique string identifier for a media initialization\n   * segment.\n   *\n   * @param {Object} initSegment\n   *        the init segment object.\n   *\n   * @return {string} the generated init segment id\n   */\n\n  const initSegmentId = function (initSegment) {\n    const byterange = initSegment.byterange || {\n      length: Infinity,\n      offset: 0\n    };\n    return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\n  };\n  /**\n   * Returns a unique string identifier for a media segment key.\n   *\n   * @param {Object} key the encryption key\n   * @return {string} the unique id for the media segment key.\n   */\n\n  const segmentKeyId = function (key) {\n    return key.resolvedUri;\n  };\n  /**\n   * utils to help dump binary data to the console\n   *\n   * @param {Array|TypedArray} data\n   *        data to dump to a string\n   *\n   * @return {string} the data as a hex string.\n   */\n\n  const hexDump = data => {\n    const bytes = Array.prototype.slice.call(data);\n    const step = 16;\n    let result = '';\n    let hex;\n    let ascii;\n    for (let j = 0; j < bytes.length / step; j++) {\n      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\n      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\n      result += hex + ' ' + ascii + '\\n';\n    }\n    return result;\n  };\n  const tagDump = ({\n    bytes\n  }) => hexDump(bytes);\n  const textRanges = ranges => {\n    let result = '';\n    let i;\n    for (i = 0; i < ranges.length; i++) {\n      result += textRange(ranges, i) + ' ';\n    }\n    return result;\n  };\n  var utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createTransferableMessage: createTransferableMessage,\n    initSegmentId: initSegmentId,\n    segmentKeyId: segmentKeyId,\n    hexDump: hexDump,\n    tagDump: tagDump,\n    textRanges: textRanges\n  });\n\n  // TODO handle fmp4 case where the timing info is accurate and doesn't involve transmux\n  // 25% was arbitrarily chosen, and may need to be refined over time.\n\n  const SEGMENT_END_FUDGE_PERCENT = 0.25;\n  /**\n   * Converts a player time (any time that can be gotten/set from player.currentTime(),\n   * e.g., any time within player.seekable().start(0) to player.seekable().end(0)) to a\n   * program time (any time referencing the real world (e.g., EXT-X-PROGRAM-DATE-TIME)).\n   *\n   * The containing segment is required as the EXT-X-PROGRAM-DATE-TIME serves as an \"anchor\n   * point\" (a point where we have a mapping from program time to player time, with player\n   * time being the post transmux start of the segment).\n   *\n   * For more details, see [this doc](../../docs/program-time-from-player-time.md).\n   *\n   * @param {number} playerTime the player time\n   * @param {Object} segment the segment which contains the player time\n   * @return {Date} program time\n   */\n\n  const playerTimeToProgramTime = (playerTime, segment) => {\n    if (!segment.dateTimeObject) {\n      // Can't convert without an \"anchor point\" for the program time (i.e., a time that can\n      // be used to map the start of a segment with a real world time).\n      return null;\n    }\n    const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;\n    const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart; // get the start of the content from before old content is prepended\n\n    const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;\n    const offsetFromSegmentStart = playerTime - startOfSegment;\n    return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1000);\n  };\n  const originalSegmentVideoDuration = videoTimingInfo => {\n    return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;\n  };\n  /**\n   * Finds a segment that contains the time requested given as an ISO-8601 string. The\n   * returned segment might be an estimate or an accurate match.\n   *\n   * @param {string} programTime The ISO-8601 programTime to find a match for\n   * @param {Object} playlist A playlist object to search within\n   */\n\n  const findSegmentForProgramTime = (programTime, playlist) => {\n    // Assumptions:\n    //  - verifyProgramDateTimeTags has already been run\n    //  - live streams have been started\n    let dateTimeObject;\n    try {\n      dateTimeObject = new Date(programTime);\n    } catch (e) {\n      return null;\n    }\n    if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n      return null;\n    }\n    let segment = playlist.segments[0];\n    if (dateTimeObject < segment.dateTimeObject) {\n      // Requested time is before stream start.\n      return null;\n    }\n    for (let i = 0; i < playlist.segments.length - 1; i++) {\n      segment = playlist.segments[i];\n      const nextSegmentStart = playlist.segments[i + 1].dateTimeObject;\n      if (dateTimeObject < nextSegmentStart) {\n        break;\n      }\n    }\n    const lastSegment = playlist.segments[playlist.segments.length - 1];\n    const lastSegmentStart = lastSegment.dateTimeObject;\n    const lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;\n    const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1000);\n    if (dateTimeObject > lastSegmentEnd) {\n      // Beyond the end of the stream, or our best guess of the end of the stream.\n      return null;\n    }\n    if (dateTimeObject > lastSegmentStart) {\n      segment = lastSegment;\n    }\n    return {\n      segment,\n      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),\n      // Although, given that all segments have accurate date time objects, the segment\n      // selected should be accurate, unless the video has been transmuxed at some point\n      // (determined by the presence of the videoTimingInfo object), the segment's \"player\n      // time\" (the start time in the player) can't be considered accurate.\n      type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n    };\n  };\n  /**\n   * Finds a segment that contains the given player time(in seconds).\n   *\n   * @param {number} time The player time to find a match for\n   * @param {Object} playlist A playlist object to search within\n   */\n\n  const findSegmentForPlayerTime = (time, playlist) => {\n    // Assumptions:\n    // - there will always be a segment.duration\n    // - we can start from zero\n    // - segments are in time order\n    if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n      return null;\n    }\n    let segmentEnd = 0;\n    let segment;\n    for (let i = 0; i < playlist.segments.length; i++) {\n      segment = playlist.segments[i]; // videoTimingInfo is set after the segment is downloaded and transmuxed, and\n      // should contain the most accurate values we have for the segment's player times.\n      //\n      // Use the accurate transmuxedPresentationEnd value if it is available, otherwise fall\n      // back to an estimate based on the manifest derived (inaccurate) segment.duration, to\n      // calculate an end value.\n\n      segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;\n      if (time <= segmentEnd) {\n        break;\n      }\n    }\n    const lastSegment = playlist.segments[playlist.segments.length - 1];\n    if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {\n      // The time requested is beyond the stream end.\n      return null;\n    }\n    if (time > segmentEnd) {\n      // The time is within or beyond the last segment.\n      //\n      // Check to see if the time is beyond a reasonable guess of the end of the stream.\n      if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {\n        // Technically, because the duration value is only an estimate, the time may still\n        // exist in the last segment, however, there isn't enough information to make even\n        // a reasonable estimate.\n        return null;\n      }\n      segment = lastSegment;\n    }\n    return {\n      segment,\n      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,\n      // Because videoTimingInfo is only set after transmux, it is the only way to get\n      // accurate timing values.\n      type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n    };\n  };\n  /**\n   * Gives the offset of the comparisonTimestamp from the programTime timestamp in seconds.\n   * If the offset returned is positive, the programTime occurs after the\n   * comparisonTimestamp.\n   * If the offset is negative, the programTime occurs before the comparisonTimestamp.\n   *\n   * @param {string} comparisonTimeStamp An ISO-8601 timestamp to compare against\n   * @param {string} programTime The programTime as an ISO-8601 string\n   * @return {number} offset\n   */\n\n  const getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {\n    let segmentDateTime;\n    let programDateTime;\n    try {\n      segmentDateTime = new Date(comparisonTimeStamp);\n      programDateTime = new Date(programTime);\n    } catch (e) {// TODO handle error\n    }\n    const segmentTimeEpoch = segmentDateTime.getTime();\n    const programTimeEpoch = programDateTime.getTime();\n    return (programTimeEpoch - segmentTimeEpoch) / 1000;\n  };\n  /**\n   * Checks that all segments in this playlist have programDateTime tags.\n   *\n   * @param {Object} playlist A playlist object\n   */\n\n  const verifyProgramDateTimeTags = playlist => {\n    if (!playlist.segments || playlist.segments.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < playlist.segments.length; i++) {\n      const segment = playlist.segments[i];\n      if (!segment.dateTimeObject) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Returns the programTime of the media given a playlist and a playerTime.\n   * The playlist must have programDateTime tags for a programDateTime tag to be returned.\n   * If the segments containing the time requested have not been buffered yet, an estimate\n   * may be returned to the callback.\n   *\n   * @param {Object} args\n   * @param {Object} args.playlist A playlist object to search within\n   * @param {number} time A playerTime in seconds\n   * @param {Function} callback(err, programTime)\n   * @return {string} err.message A detailed error message\n   * @return {Object} programTime\n   * @return {number} programTime.mediaSeconds The streamTime in seconds\n   * @return {string} programTime.programDateTime The programTime as an ISO-8601 String\n   */\n\n  const getProgramTime = ({\n    playlist,\n    time = undefined,\n    callback\n  }) => {\n    if (!callback) {\n      throw new Error('getProgramTime: callback must be provided');\n    }\n    if (!playlist || time === undefined) {\n      return callback({\n        message: 'getProgramTime: playlist and time must be provided'\n      });\n    }\n    const matchedSegment = findSegmentForPlayerTime(time, playlist);\n    if (!matchedSegment) {\n      return callback({\n        message: 'valid programTime was not found'\n      });\n    }\n    if (matchedSegment.type === 'estimate') {\n      return callback({\n        message: 'Accurate programTime could not be determined.' + ' Please seek to e.seekTime and try again',\n        seekTime: matchedSegment.estimatedStart\n      });\n    }\n    const programTimeObject = {\n      mediaSeconds: time\n    };\n    const programTime = playerTimeToProgramTime(time, matchedSegment.segment);\n    if (programTime) {\n      programTimeObject.programDateTime = programTime.toISOString();\n    }\n    return callback(null, programTimeObject);\n  };\n  /**\n   * Seeks in the player to a time that matches the given programTime ISO-8601 string.\n   *\n   * @param {Object} args\n   * @param {string} args.programTime A programTime to seek to as an ISO-8601 String\n   * @param {Object} args.playlist A playlist to look within\n   * @param {number} args.retryCount The number of times to try for an accurate seek. Default is 2.\n   * @param {Function} args.seekTo A method to perform a seek\n   * @param {boolean} args.pauseAfterSeek Whether to end in a paused state after seeking. Default is true.\n   * @param {Object} args.tech The tech to seek on\n   * @param {Function} args.callback(err, newTime) A callback to return the new time to\n   * @return {string} err.message A detailed error message\n   * @return {number} newTime The exact time that was seeked to in seconds\n   */\n\n  const seekToProgramTime = ({\n    programTime,\n    playlist,\n    retryCount = 2,\n    seekTo,\n    pauseAfterSeek = true,\n    tech,\n    callback\n  }) => {\n    if (!callback) {\n      throw new Error('seekToProgramTime: callback must be provided');\n    }\n    if (typeof programTime === 'undefined' || !playlist || !seekTo) {\n      return callback({\n        message: 'seekToProgramTime: programTime, seekTo and playlist must be provided'\n      });\n    }\n    if (!playlist.endList && !tech.hasStarted_) {\n      return callback({\n        message: 'player must be playing a live stream to start buffering'\n      });\n    }\n    if (!verifyProgramDateTimeTags(playlist)) {\n      return callback({\n        message: 'programDateTime tags must be provided in the manifest ' + playlist.resolvedUri\n      });\n    }\n    const matchedSegment = findSegmentForProgramTime(programTime, playlist); // no match\n\n    if (!matchedSegment) {\n      return callback({\n        message: `${programTime} was not found in the stream`\n      });\n    }\n    const segment = matchedSegment.segment;\n    const mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);\n    if (matchedSegment.type === 'estimate') {\n      // we've run out of retries\n      if (retryCount === 0) {\n        return callback({\n          message: `${programTime} is not buffered yet. Try again`\n        });\n      }\n      seekTo(matchedSegment.estimatedStart + mediaOffset);\n      tech.one('seeked', () => {\n        seekToProgramTime({\n          programTime,\n          playlist,\n          retryCount: retryCount - 1,\n          seekTo,\n          pauseAfterSeek,\n          tech,\n          callback\n        });\n      });\n      return;\n    } // Since the segment.start value is determined from the buffered end or ending time\n    // of the prior segment, the seekToTime doesn't need to account for any transmuxer\n    // modifications.\n\n    const seekToTime = segment.start + mediaOffset;\n    const seekedCallback = () => {\n      return callback(null, tech.currentTime());\n    }; // listen for seeked event\n\n    tech.one('seeked', seekedCallback); // pause before seeking as video.js will restore this state\n\n    if (pauseAfterSeek) {\n      tech.pause();\n    }\n    seekTo(seekToTime);\n  };\n\n  // which will only happen if the request is complete.\n\n  const callbackOnCompleted = (request, cb) => {\n    if (request.readyState === 4) {\n      return cb();\n    }\n    return;\n  };\n  const containerRequest = (uri, xhr, cb) => {\n    let bytes = [];\n    let id3Offset;\n    let finished = false;\n    const endRequestAndCallback = function (err, req, type, _bytes) {\n      req.abort();\n      finished = true;\n      return cb(err, req, type, _bytes);\n    };\n    const progressListener = function (error, request) {\n      if (finished) {\n        return;\n      }\n      if (error) {\n        return endRequestAndCallback(error, request, '', bytes);\n      } // grap the new part of content that was just downloaded\n\n      const newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length); // add that onto bytes\n\n      bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));\n      id3Offset = id3Offset || getId3Offset(bytes); // we need at least 10 bytes to determine a type\n      // or we need at least two bytes after an id3Offset\n\n      if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {\n        return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n      }\n      const type = detectContainerForBytes(bytes); // if this looks like a ts segment but we don't have enough data\n      // to see the second sync byte, wait until we have enough data\n      // before declaring it ts\n\n      if (type === 'ts' && bytes.length < 188) {\n        return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n      } // this may be an unsynced ts segment\n      // wait for 376 bytes before detecting no container\n\n      if (!type && bytes.length < 376) {\n        return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n      }\n      return endRequestAndCallback(null, request, type, bytes);\n    };\n    const options = {\n      uri,\n      beforeSend(request) {\n        // this forces the browser to pass the bytes to us unprocessed\n        request.overrideMimeType('text/plain; charset=x-user-defined');\n        request.addEventListener('progress', function ({\n          total,\n          loaded\n        }) {\n          return callbackWrapper(request, null, {\n            statusCode: request.status\n          }, progressListener);\n        });\n      }\n    };\n    const request = xhr(options, function (error, response) {\n      return callbackWrapper(request, error, response, progressListener);\n    });\n    return request;\n  };\n  const {\n    EventTarget\n  } = videojs;\n  const dashPlaylistUnchanged = function (a, b) {\n    if (!isPlaylistUnchanged(a, b)) {\n      return false;\n    } // for dash the above check will often return true in scenarios where\n    // the playlist actually has changed because mediaSequence isn't a\n    // dash thing, and we often set it to 1. So if the playlists have the same amount\n    // of segments we return true.\n    // So for dash we need to make sure that the underlying segments are different.\n    // if sidx changed then the playlists are different.\n\n    if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {\n      return false;\n    } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {\n      return false;\n    } // one or the other does not have segments\n    // there was a change.\n\n    if (a.segments && !b.segments || !a.segments && b.segments) {\n      return false;\n    } // neither has segments nothing changed\n\n    if (!a.segments && !b.segments) {\n      return true;\n    } // check segments themselves\n\n    for (let i = 0; i < a.segments.length; i++) {\n      const aSegment = a.segments[i];\n      const bSegment = b.segments[i]; // if uris are different between segments there was a change\n\n      if (aSegment.uri !== bSegment.uri) {\n        return false;\n      } // neither segment has a byterange, there will be no byterange change.\n\n      if (!aSegment.byterange && !bSegment.byterange) {\n        continue;\n      }\n      const aByterange = aSegment.byterange;\n      const bByterange = bSegment.byterange; // if byterange only exists on one of the segments, there was a change.\n\n      if (aByterange && !bByterange || !aByterange && bByterange) {\n        return false;\n      } // if both segments have byterange with different offsets, there was a change.\n\n      if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {\n        return false;\n      }\n    } // if everything was the same with segments, this is the same playlist.\n\n    return true;\n  };\n  /**\n   * Parses the main XML string and updates playlist URI references.\n   *\n   * @param {Object} config\n   *        Object of arguments\n   * @param {string} config.mainXml\n   *        The mpd XML\n   * @param {string} config.srcUrl\n   *        The mpd URL\n   * @param {Date} config.clientOffset\n   *         A time difference between server and client\n   * @param {Object} config.sidxMapping\n   *        SIDX mappings for moof/mdat URIs and byte ranges\n   * @return {Object}\n   *         The parsed mpd manifest object\n   */\n\n  const parseMainXml = ({\n    mainXml,\n    srcUrl,\n    clientOffset,\n    sidxMapping,\n    previousManifest\n  }) => {\n    const manifest = parse(mainXml, {\n      manifestUri: srcUrl,\n      clientOffset,\n      sidxMapping,\n      previousManifest\n    });\n    addPropertiesToMain(manifest, srcUrl);\n    return manifest;\n  };\n  /**\n   * Returns a new main manifest that is the result of merging an updated main manifest\n   * into the original version.\n   *\n   * @param {Object} oldMain\n   *        The old parsed mpd object\n   * @param {Object} newMain\n   *        The updated parsed mpd object\n   * @return {Object}\n   *         A new object representing the original main manifest with the updated media\n   *         playlists merged in\n   */\n\n  const updateMain = (oldMain, newMain, sidxMapping) => {\n    let noChanges = true;\n    let update = merge(oldMain, {\n      // These are top level properties that can be updated\n      duration: newMain.duration,\n      minimumUpdatePeriod: newMain.minimumUpdatePeriod,\n      timelineStarts: newMain.timelineStarts\n    }); // First update the playlists in playlist list\n\n    for (let i = 0; i < newMain.playlists.length; i++) {\n      const playlist = newMain.playlists[i];\n      if (playlist.sidx) {\n        const sidxKey = generateSidxKey(playlist.sidx); // add sidx segments to the playlist if we have all the sidx info already\n\n        if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {\n          addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);\n        }\n      }\n      const playlistUpdate = updateMain$1(update, playlist, dashPlaylistUnchanged);\n      if (playlistUpdate) {\n        update = playlistUpdate;\n        noChanges = false;\n      }\n    } // Then update media group playlists\n\n    forEachMediaGroup(newMain, (properties, type, group, label) => {\n      if (properties.playlists && properties.playlists.length) {\n        const id = properties.playlists[0].id;\n        const playlistUpdate = updateMain$1(update, properties.playlists[0], dashPlaylistUnchanged);\n        if (playlistUpdate) {\n          update = playlistUpdate; // update the playlist reference within media groups\n\n          update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];\n          noChanges = false;\n        }\n      }\n    });\n    if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {\n      noChanges = false;\n    }\n    if (noChanges) {\n      return null;\n    }\n    return update;\n  }; // SIDX should be equivalent if the URI and byteranges of the SIDX match.\n  // If the SIDXs have maps, the two maps should match,\n  // both `a` and `b` missing SIDXs is considered matching.\n  // If `a` or `b` but not both have a map, they aren't matching.\n\n  const equivalentSidx = (a, b) => {\n    const neitherMap = Boolean(!a.map && !b.map);\n    const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);\n    return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;\n  }; // exported for testing\n\n  const compareSidxEntry = (playlists, oldSidxMapping) => {\n    const newSidxMapping = {};\n    for (const id in playlists) {\n      const playlist = playlists[id];\n      const currentSidxInfo = playlist.sidx;\n      if (currentSidxInfo) {\n        const key = generateSidxKey(currentSidxInfo);\n        if (!oldSidxMapping[key]) {\n          break;\n        }\n        const savedSidxInfo = oldSidxMapping[key].sidxInfo;\n        if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {\n          newSidxMapping[key] = oldSidxMapping[key];\n        }\n      }\n    }\n    return newSidxMapping;\n  };\n  /**\n   *  A function that filters out changed items as they need to be requested separately.\n   *\n   *  The method is exported for testing\n   *\n   *  @param {Object} main the parsed mpd XML returned via mpd-parser\n   *  @param {Object} oldSidxMapping the SIDX to compare against\n   */\n\n  const filterChangedSidxMappings = (main, oldSidxMapping) => {\n    const videoSidx = compareSidxEntry(main.playlists, oldSidxMapping);\n    let mediaGroupSidx = videoSidx;\n    forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n      if (properties.playlists && properties.playlists.length) {\n        const playlists = properties.playlists;\n        mediaGroupSidx = merge(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));\n      }\n    });\n    return mediaGroupSidx;\n  };\n  class DashPlaylistLoader extends EventTarget {\n    // DashPlaylistLoader must accept either a src url or a playlist because subsequent\n    // playlist loader setups from media groups will expect to be able to pass a playlist\n    // (since there aren't external URLs to media playlists with DASH)\n    constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {\n      super();\n      this.mainPlaylistLoader_ = mainPlaylistLoader || this;\n      if (!mainPlaylistLoader) {\n        this.isMain_ = true;\n      }\n      const {\n        withCredentials = false\n      } = options;\n      this.vhs_ = vhs;\n      this.withCredentials = withCredentials;\n      if (!srcUrlOrPlaylist) {\n        throw new Error('A non-empty playlist URL or object is required');\n      } // event naming?\n\n      this.on('minimumUpdatePeriod', () => {\n        this.refreshXml_();\n      }); // live playlist staleness timeout\n\n      this.on('mediaupdatetimeout', () => {\n        this.refreshMedia_(this.media().id);\n      });\n      this.state = 'HAVE_NOTHING';\n      this.loadedPlaylists_ = {};\n      this.logger_ = logger('DashPlaylistLoader'); // initialize the loader state\n      // The mainPlaylistLoader will be created with a string\n\n      if (this.isMain_) {\n        this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist; // TODO: reset sidxMapping between period changes\n        // once multi-period is refactored\n\n        this.mainPlaylistLoader_.sidxMapping_ = {};\n      } else {\n        this.childPlaylist_ = srcUrlOrPlaylist;\n      }\n    }\n    requestErrored_(err, request, startingState) {\n      // disposed\n      if (!this.request) {\n        return true;\n      } // pending request is cleared\n\n      this.request = null;\n      if (err) {\n        // use the provided error object or create one\n        // based on the request/response\n        this.error = typeof err === 'object' && !(err instanceof Error) ? err : {\n          status: request.status,\n          message: 'DASH request error at URL: ' + request.uri,\n          response: request.response,\n          // MEDIA_ERR_NETWORK\n          code: 2\n        };\n        if (startingState) {\n          this.state = startingState;\n        }\n        this.trigger('error');\n        return true;\n      }\n    }\n    /**\n     * Verify that the container of the sidx segment can be parsed\n     * and if it can, get and parse that segment.\n     */\n\n    addSidxSegments_(playlist, startingState, cb) {\n      const sidxKey = playlist.sidx && generateSidxKey(playlist.sidx); // playlist lacks sidx or sidx segments were added to this playlist already.\n\n      if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {\n        // keep this function async\n        this.mediaRequest_ = window.setTimeout(() => cb(false), 0);\n        return;\n      } // resolve the segment URL relative to the playlist\n\n      const uri = resolveManifestRedirect(playlist.sidx.resolvedUri);\n      const fin = (err, request) => {\n        if (this.requestErrored_(err, request, startingState)) {\n          return;\n        }\n        const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;\n        let sidx;\n        try {\n          sidx = parseSidx_1(toUint8(request.response).subarray(8));\n        } catch (e) {\n          // sidx parsing failed.\n          this.requestErrored_(e, request, startingState);\n          return;\n        }\n        sidxMapping[sidxKey] = {\n          sidxInfo: playlist.sidx,\n          sidx\n        };\n        addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);\n        return cb(true);\n      };\n      this.request = containerRequest(uri, this.vhs_.xhr, (err, request, container, bytes) => {\n        if (err) {\n          return fin(err, request);\n        }\n        if (!container || container !== 'mp4') {\n          return fin({\n            status: request.status,\n            message: `Unsupported ${container || 'unknown'} container type for sidx segment at URL: ${uri}`,\n            // response is just bytes in this case\n            // but we really don't want to return that.\n            response: '',\n            playlist,\n            internal: true,\n            playlistExclusionDuration: Infinity,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          }, request);\n        } // if we already downloaded the sidx bytes in the container request, use them\n\n        const {\n          offset,\n          length\n        } = playlist.sidx.byterange;\n        if (bytes.length >= length + offset) {\n          return fin(err, {\n            response: bytes.subarray(offset, offset + length),\n            status: request.status,\n            uri: request.uri\n          });\n        } // otherwise request sidx bytes\n\n        this.request = this.vhs_.xhr({\n          uri,\n          responseType: 'arraybuffer',\n          headers: segmentXhrHeaders({\n            byterange: playlist.sidx.byterange\n          })\n        }, fin);\n      });\n    }\n    dispose() {\n      this.trigger('dispose');\n      this.stopRequest();\n      this.loadedPlaylists_ = {};\n      window.clearTimeout(this.minimumUpdatePeriodTimeout_);\n      window.clearTimeout(this.mediaRequest_);\n      window.clearTimeout(this.mediaUpdateTimeout);\n      this.mediaUpdateTimeout = null;\n      this.mediaRequest_ = null;\n      this.minimumUpdatePeriodTimeout_ = null;\n      if (this.mainPlaylistLoader_.createMupOnMedia_) {\n        this.off('loadedmetadata', this.mainPlaylistLoader_.createMupOnMedia_);\n        this.mainPlaylistLoader_.createMupOnMedia_ = null;\n      }\n      this.off();\n    }\n    hasPendingRequest() {\n      return this.request || this.mediaRequest_;\n    }\n    stopRequest() {\n      if (this.request) {\n        const oldRequest = this.request;\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n    media(playlist) {\n      // getter\n      if (!playlist) {\n        return this.media_;\n      } // setter\n\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      }\n      const startingState = this.state; // find the playlist object if the target playlist has been specified by URI\n\n      if (typeof playlist === 'string') {\n        if (!this.mainPlaylistLoader_.main.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.mainPlaylistLoader_.main.playlists[playlist];\n      }\n      const mediaChange = !this.media_ || playlist.id !== this.media_.id; // switch to previously loaded playlists immediately\n\n      if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {\n        this.state = 'HAVE_METADATA';\n        this.media_ = playlist; // trigger media change if the active media has been updated\n\n        if (mediaChange) {\n          this.trigger('mediachanging');\n          this.trigger('mediachange');\n        }\n        return;\n      } // switching to the active playlist is a no-op\n\n      if (!mediaChange) {\n        return;\n      } // switching from an already loaded playlist\n\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n      this.addSidxSegments_(playlist, startingState, sidxChanged => {\n        // everything is ready just continue to haveMetadata\n        this.haveMetadata({\n          startingState,\n          playlist\n        });\n      });\n    }\n    haveMetadata({\n      startingState,\n      playlist\n    }) {\n      this.state = 'HAVE_METADATA';\n      this.loadedPlaylists_[playlist.id] = playlist;\n      this.mediaRequest_ = null; // This will trigger loadedplaylist\n\n      this.refreshMedia_(playlist.id); // fire loadedmetadata the first time a media playlist is loaded\n      // to resolve setup of media groups\n\n      if (startingState === 'HAVE_MAIN_MANIFEST') {\n        this.trigger('loadedmetadata');\n      } else {\n        // trigger media change if the active media has been updated\n        this.trigger('mediachange');\n      }\n    }\n    pause() {\n      if (this.mainPlaylistLoader_.createMupOnMedia_) {\n        this.off('loadedmetadata', this.mainPlaylistLoader_.createMupOnMedia_);\n        this.mainPlaylistLoader_.createMupOnMedia_ = null;\n      }\n      this.stopRequest();\n      window.clearTimeout(this.mediaUpdateTimeout);\n      this.mediaUpdateTimeout = null;\n      if (this.isMain_) {\n        window.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);\n        this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;\n      }\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      }\n    }\n    load(isFinalRendition) {\n      window.clearTimeout(this.mediaUpdateTimeout);\n      this.mediaUpdateTimeout = null;\n      const media = this.media();\n      if (isFinalRendition) {\n        const delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n        this.mediaUpdateTimeout = window.setTimeout(() => this.load(), delay);\n        return;\n      } // because the playlists are internal to the manifest, load should either load the\n      // main manifest, or do nothing but trigger an event\n\n      if (!this.started) {\n        this.start();\n        return;\n      }\n      if (media && !media.endList) {\n        // Check to see if this is the main loader and the MUP was cleared (this happens\n        // when the loader was paused). `media` should be set at this point since one is always\n        // set during `start()`.\n        if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {\n          // Trigger minimumUpdatePeriod to refresh the main manifest\n          this.trigger('minimumUpdatePeriod'); // Since there was no prior minimumUpdatePeriodTimeout it should be recreated\n\n          this.updateMinimumUpdatePeriodTimeout_();\n        }\n        this.trigger('mediaupdatetimeout');\n      } else {\n        this.trigger('loadedplaylist');\n      }\n    }\n    start() {\n      this.started = true; // We don't need to request the main manifest again\n      // Call this asynchronously to match the xhr request behavior below\n\n      if (!this.isMain_) {\n        this.mediaRequest_ = window.setTimeout(() => this.haveMain_(), 0);\n        return;\n      }\n      this.requestMain_((req, mainChanged) => {\n        this.haveMain_();\n        if (!this.hasPendingRequest() && !this.media_) {\n          this.media(this.mainPlaylistLoader_.main.playlists[0]);\n        }\n      });\n    }\n    requestMain_(cb) {\n      this.request = this.vhs_.xhr({\n        uri: this.mainPlaylistLoader_.srcUrl,\n        withCredentials: this.withCredentials\n      }, (error, req) => {\n        if (this.requestErrored_(error, req)) {\n          if (this.state === 'HAVE_NOTHING') {\n            this.started = false;\n          }\n          return;\n        }\n        const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;\n        this.mainPlaylistLoader_.mainXml_ = req.responseText;\n        if (req.responseHeaders && req.responseHeaders.date) {\n          this.mainLoaded_ = Date.parse(req.responseHeaders.date);\n        } else {\n          this.mainLoaded_ = Date.now();\n        }\n        this.mainPlaylistLoader_.srcUrl = resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);\n        if (mainChanged) {\n          this.handleMain_();\n          this.syncClientServerClock_(() => {\n            return cb(req, mainChanged);\n          });\n          return;\n        }\n        return cb(req, mainChanged);\n      });\n    }\n    /**\n     * Parses the main xml for UTCTiming node to sync the client clock to the server\n     * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.\n     *\n     * @param {Function} done\n     *        Function to call when clock sync has completed\n     */\n\n    syncClientServerClock_(done) {\n      const utcTiming = parseUTCTiming(this.mainPlaylistLoader_.mainXml_); // No UTCTiming element found in the mpd. Use Date header from mpd request as the\n      // server clock\n\n      if (utcTiming === null) {\n        this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();\n        return done();\n      }\n      if (utcTiming.method === 'DIRECT') {\n        this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();\n        return done();\n      }\n      this.request = this.vhs_.xhr({\n        uri: resolveUrl(this.mainPlaylistLoader_.srcUrl, utcTiming.value),\n        method: utcTiming.method,\n        withCredentials: this.withCredentials\n      }, (error, req) => {\n        // disposed\n        if (!this.request) {\n          return;\n        }\n        if (error) {\n          // sync request failed, fall back to using date header from mpd\n          // TODO: log warning\n          this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();\n          return done();\n        }\n        let serverTime;\n        if (utcTiming.method === 'HEAD') {\n          if (!req.responseHeaders || !req.responseHeaders.date) {\n            // expected date header not preset, fall back to using date header from mpd\n            // TODO: log warning\n            serverTime = this.mainLoaded_;\n          } else {\n            serverTime = Date.parse(req.responseHeaders.date);\n          }\n        } else {\n          serverTime = Date.parse(req.responseText);\n        }\n        this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();\n        done();\n      });\n    }\n    haveMain_() {\n      this.state = 'HAVE_MAIN_MANIFEST';\n      if (this.isMain_) {\n        // We have the main playlist at this point, so\n        // trigger this to allow PlaylistController\n        // to make an initial playlist selection\n        this.trigger('loadedplaylist');\n      } else if (!this.media_) {\n        // no media playlist was specifically selected so select\n        // the one the child playlist loader was created with\n        this.media(this.childPlaylist_);\n      }\n    }\n    handleMain_() {\n      // clear media request\n      this.mediaRequest_ = null;\n      const oldMain = this.mainPlaylistLoader_.main;\n      let newMain = parseMainXml({\n        mainXml: this.mainPlaylistLoader_.mainXml_,\n        srcUrl: this.mainPlaylistLoader_.srcUrl,\n        clientOffset: this.mainPlaylistLoader_.clientOffset_,\n        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,\n        previousManifest: oldMain\n      }); // if we have an old main to compare the new main against\n\n      if (oldMain) {\n        newMain = updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);\n      } // only update main if we have a new main\n\n      this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;\n      const location = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];\n      if (location && location !== this.mainPlaylistLoader_.srcUrl) {\n        this.mainPlaylistLoader_.srcUrl = location;\n      }\n      if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {\n        this.updateMinimumUpdatePeriodTimeout_();\n      }\n      return Boolean(newMain);\n    }\n    updateMinimumUpdatePeriodTimeout_() {\n      const mpl = this.mainPlaylistLoader_; // cancel any pending creation of mup on media\n      // a new one will be added if needed.\n\n      if (mpl.createMupOnMedia_) {\n        mpl.off('loadedmetadata', mpl.createMupOnMedia_);\n        mpl.createMupOnMedia_ = null;\n      } // clear any pending timeouts\n\n      if (mpl.minimumUpdatePeriodTimeout_) {\n        window.clearTimeout(mpl.minimumUpdatePeriodTimeout_);\n        mpl.minimumUpdatePeriodTimeout_ = null;\n      }\n      let mup = mpl.main && mpl.main.minimumUpdatePeriod; // If the minimumUpdatePeriod has a value of 0, that indicates that the current\n      // MPD has no future validity, so a new one will need to be acquired when new\n      // media segments are to be made available. Thus, we use the target duration\n      // in this case\n\n      if (mup === 0) {\n        if (mpl.media()) {\n          mup = mpl.media().targetDuration * 1000;\n        } else {\n          mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;\n          mpl.one('loadedmetadata', mpl.createMupOnMedia_);\n        }\n      } // if minimumUpdatePeriod is invalid or <= zero, which\n      // can happen when a live video becomes VOD. skip timeout\n      // creation.\n\n      if (typeof mup !== 'number' || mup <= 0) {\n        if (mup < 0) {\n          this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);\n        }\n        return;\n      }\n      this.createMUPTimeout_(mup);\n    }\n    createMUPTimeout_(mup) {\n      const mpl = this.mainPlaylistLoader_;\n      mpl.minimumUpdatePeriodTimeout_ = window.setTimeout(() => {\n        mpl.minimumUpdatePeriodTimeout_ = null;\n        mpl.trigger('minimumUpdatePeriod');\n        mpl.createMUPTimeout_(mup);\n      }, mup);\n    }\n    /**\n     * Sends request to refresh the main xml and updates the parsed main manifest\n     */\n\n    refreshXml_() {\n      this.requestMain_((req, mainChanged) => {\n        if (!mainChanged) {\n          return;\n        }\n        if (this.media_) {\n          this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];\n        } // This will filter out updated sidx info from the mapping\n\n        this.mainPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);\n        this.addSidxSegments_(this.media(), this.state, sidxChanged => {\n          // TODO: do we need to reload the current playlist?\n          this.refreshMedia_(this.media().id);\n        });\n      });\n    }\n    /**\n     * Refreshes the media playlist by re-parsing the main xml and updating playlist\n     * references. If this is an alternate loader, the updated parsed manifest is retrieved\n     * from the main loader.\n     */\n\n    refreshMedia_(mediaID) {\n      if (!mediaID) {\n        throw new Error('refreshMedia_ must take a media id');\n      } // for main we have to reparse the main xml\n      // to re-create segments based on current timing values\n      // which may change media. We only skip updating the main manifest\n      // if this is the first time this.media_ is being set.\n      // as main was just parsed in that case.\n\n      if (this.media_ && this.isMain_) {\n        this.handleMain_();\n      }\n      const playlists = this.mainPlaylistLoader_.main.playlists;\n      const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];\n      if (mediaChanged) {\n        this.media_ = playlists[mediaID];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n      if (!this.mediaUpdateTimeout) {\n        const createMediaUpdateTimeout = () => {\n          if (this.media().endList) {\n            return;\n          }\n          this.mediaUpdateTimeout = window.setTimeout(() => {\n            this.trigger('mediaupdatetimeout');\n            createMediaUpdateTimeout();\n          }, refreshDelay(this.media(), Boolean(mediaChanged)));\n        };\n        createMediaUpdateTimeout();\n      }\n      this.trigger('loadedplaylist');\n    }\n  }\n  var Config = {\n    GOAL_BUFFER_LENGTH: 30,\n    MAX_GOAL_BUFFER_LENGTH: 60,\n    BACK_BUFFER_LENGTH: 30,\n    GOAL_BUFFER_LENGTH_RATE: 1,\n    // 0.5 MB/s\n    INITIAL_BANDWIDTH: 4194304,\n    // A fudge factor to apply to advertised playlist bitrates to account for\n    // temporary flucations in client bandwidth\n    BANDWIDTH_VARIANCE: 1.2,\n    // How much of the buffer must be filled before we consider upswitching\n    BUFFER_LOW_WATER_LINE: 0,\n    MAX_BUFFER_LOW_WATER_LINE: 30,\n    // TODO: Remove this when experimentalBufferBasedABR is removed\n    EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,\n    BUFFER_LOW_WATER_LINE_RATE: 1,\n    // If the buffer is greater than the high water line, we won't switch down\n    BUFFER_HIGH_WATER_LINE: 30\n  };\n  const stringToArrayBuffer = string => {\n    const view = new Uint8Array(new ArrayBuffer(string.length));\n    for (let i = 0; i < string.length; i++) {\n      view[i] = string.charCodeAt(i);\n    }\n    return view.buffer;\n  };\n\n  /* global Blob, BlobBuilder, Worker */\n  // unify worker interface\n  const browserWorkerPolyFill = function (workerObj) {\n    // node only supports on/off\n    workerObj.on = workerObj.addEventListener;\n    workerObj.off = workerObj.removeEventListener;\n    return workerObj;\n  };\n  const createObjectURL = function (str) {\n    try {\n      return URL.createObjectURL(new Blob([str], {\n        type: 'application/javascript'\n      }));\n    } catch (e) {\n      const blob = new BlobBuilder();\n      blob.append(str);\n      return URL.createObjectURL(blob.getBlob());\n    }\n  };\n  const factory = function (code) {\n    return function () {\n      const objectUrl = createObjectURL(code);\n      const worker = browserWorkerPolyFill(new Worker(objectUrl));\n      worker.objURL = objectUrl;\n      const terminate = worker.terminate;\n      worker.on = worker.addEventListener;\n      worker.off = worker.removeEventListener;\n      worker.terminate = function () {\n        URL.revokeObjectURL(objectUrl);\n        return terminate.call(this);\n      };\n      return worker;\n    };\n  };\n  const transform = function (code) {\n    return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};\\n` + 'browserWorkerPolyFill(self);\\n' + code;\n  };\n  const getWorkerString = function (fn) {\n    return fn.toString().replace(/^function.+?{/, '').slice(0, -1);\n  };\n\n  /* rollup-plugin-worker-factory start for worker!/Users/poneill/dev/http-streaming/src/transmuxer-worker.js */\n  const workerCode$1 = transform(getWorkerString(function () {\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * A lightweight readable stream implemention that handles event dispatching.\n     * Objects that inherit from streams should call init in their constructors.\n     */\n\n    var Stream$8 = function () {\n      this.init = function () {\n        var listeners = {};\n        /**\n         * Add a listener for a specified event type.\n         * @param type {string} the event name\n         * @param listener {function} the callback to be invoked when an event of\n         * the specified type occurs\n         */\n\n        this.on = function (type, listener) {\n          if (!listeners[type]) {\n            listeners[type] = [];\n          }\n          listeners[type] = listeners[type].concat(listener);\n        };\n        /**\n         * Remove a listener for a specified event type.\n         * @param type {string} the event name\n         * @param listener {function} a function previously registered for this\n         * type of event through `on`\n         */\n\n        this.off = function (type, listener) {\n          var index;\n          if (!listeners[type]) {\n            return false;\n          }\n          index = listeners[type].indexOf(listener);\n          listeners[type] = listeners[type].slice();\n          listeners[type].splice(index, 1);\n          return index > -1;\n        };\n        /**\n         * Trigger an event of the specified type on this stream. Any additional\n         * arguments to this function are passed as parameters to event listeners.\n         * @param type {string} the event name\n         */\n\n        this.trigger = function (type) {\n          var callbacks, i, length, args;\n          callbacks = listeners[type];\n          if (!callbacks) {\n            return;\n          } // Slicing the arguments on every invocation of this method\n          // can add a significant amount of overhead. Avoid the\n          // intermediate object creation for the common case of a\n          // single callback argument\n\n          if (arguments.length === 2) {\n            length = callbacks.length;\n            for (i = 0; i < length; ++i) {\n              callbacks[i].call(this, arguments[1]);\n            }\n          } else {\n            args = [];\n            i = arguments.length;\n            for (i = 1; i < arguments.length; ++i) {\n              args.push(arguments[i]);\n            }\n            length = callbacks.length;\n            for (i = 0; i < length; ++i) {\n              callbacks[i].apply(this, args);\n            }\n          }\n        };\n        /**\n         * Destroys the stream and cleans up.\n         */\n\n        this.dispose = function () {\n          listeners = {};\n        };\n      };\n    };\n    /**\n     * Forwards all `data` events on this stream to the destination stream. The\n     * destination stream should provide a method `push` to receive the data\n     * events as they arrive.\n     * @param destination {stream} the stream that will receive all `data` events\n     * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n     *                            when the current stream emits a 'done' event\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n     */\n\n    Stream$8.prototype.pipe = function (destination) {\n      this.on('data', function (data) {\n        destination.push(data);\n      });\n      this.on('done', function (flushSource) {\n        destination.flush(flushSource);\n      });\n      this.on('partialdone', function (flushSource) {\n        destination.partialFlush(flushSource);\n      });\n      this.on('endedtimeline', function (flushSource) {\n        destination.endTimeline(flushSource);\n      });\n      this.on('reset', function (flushSource) {\n        destination.reset(flushSource);\n      });\n      return destination;\n    }; // Default stream functions that are expected to be overridden to perform\n    // actual work. These are provided by the prototype as a sort of no-op\n    // implementation so that we don't have to check for their existence in the\n    // `pipe` function above.\n\n    Stream$8.prototype.push = function (data) {\n      this.trigger('data', data);\n    };\n    Stream$8.prototype.flush = function (flushSource) {\n      this.trigger('done', flushSource);\n    };\n    Stream$8.prototype.partialFlush = function (flushSource) {\n      this.trigger('partialdone', flushSource);\n    };\n    Stream$8.prototype.endTimeline = function (flushSource) {\n      this.trigger('endedtimeline', flushSource);\n    };\n    Stream$8.prototype.reset = function (flushSource) {\n      this.trigger('reset', flushSource);\n    };\n    var stream = Stream$8;\n    var MAX_UINT32$1 = Math.pow(2, 32);\n    var getUint64$2 = function (uint8) {\n      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n      var value;\n      if (dv.getBigUint64) {\n        value = dv.getBigUint64(0);\n        if (value < Number.MAX_SAFE_INTEGER) {\n          return Number(value);\n        }\n        return value;\n      }\n      return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\n    };\n    var numbers = {\n      getUint64: getUint64$2,\n      MAX_UINT32: MAX_UINT32$1\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Functions that generate fragmented MP4s suitable for use with Media\n     * Source Extensions.\n     */\n\n    var MAX_UINT32 = numbers.MAX_UINT32;\n    var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n    (function () {\n      var i;\n      types = {\n        avc1: [],\n        // codingname\n        avcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [],\n        // codingname\n        mvex: [],\n        mvhd: [],\n        pasp: [],\n        sdtp: [],\n        smhd: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        styp: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: []\n      }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n      // don't throw an error\n\n      if (typeof Uint8Array === 'undefined') {\n        return;\n      }\n      for (i in types) {\n        if (types.hasOwnProperty(i)) {\n          types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n      MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n      AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n      MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n      VIDEO_HDLR = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0x76, 0x69, 0x64, 0x65,\n      // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n\n      AUDIO_HDLR = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0x73, 0x6f, 0x75, 0x6e,\n      // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n\n      HDLR_TYPES = {\n        video: VIDEO_HDLR,\n        audio: AUDIO_HDLR\n      };\n      DREF = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x01,\n      // entry_count\n      0x00, 0x00, 0x00, 0x0c,\n      // entry_size\n      0x75, 0x72, 0x6c, 0x20,\n      // 'url' type\n      0x00,\n      // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n\n      SMHD = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00,\n      // balance, 0 means centered\n      0x00, 0x00 // reserved\n      ]);\n\n      STCO = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n\n      STSC = STCO;\n      STSZ = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n      ]);\n\n      STTS = STCO;\n      VMHD = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x01,\n      // flags\n      0x00, 0x00,\n      // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n    })();\n\n    box = function (type) {\n      var payload = [],\n        size = 0,\n        i,\n        result,\n        view;\n      for (i = 1; i < arguments.length; i++) {\n        payload.push(arguments[i]);\n      }\n      i = payload.length; // calculate the total size we need to allocate\n\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n      result = new Uint8Array(size + 8);\n      view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n      view.setUint32(0, result.byteLength);\n      result.set(type, 4); // copy the payload into the result\n\n      for (i = 0, size = 8; i < payload.length; i++) {\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n      return result;\n    };\n    dinf = function () {\n      return box(types.dinf, box(types.dref, DREF));\n    };\n    esds = function (track) {\n      return box(types.esds, new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      // ES_Descriptor\n      0x03,\n      // tag, ES_DescrTag\n      0x19,\n      // length\n      0x00, 0x00,\n      // ES_ID\n      0x00,\n      // streamDependenceFlag, URL_flag, reserved, streamPriority\n      // DecoderConfigDescriptor\n      0x04,\n      // tag, DecoderConfigDescrTag\n      0x11,\n      // length\n      0x40,\n      // object type\n      0x15,\n      // streamType\n      0x00, 0x06, 0x00,\n      // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0,\n      // maxBitrate\n      0x00, 0x00, 0xda, 0xc0,\n      // avgBitrate\n      // DecoderSpecificInfo\n      0x05,\n      // tag, DecoderSpecificInfoTag\n      0x02,\n      // length\n      // ISO/IEC 14496-3, AudioSpecificConfig\n      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n      ]));\n    };\n\n    ftyp = function () {\n      return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n    };\n    hdlr = function (type) {\n      return box(types.hdlr, HDLR_TYPES[type]);\n    };\n    mdat = function (data) {\n      return box(types.mdat, data);\n    };\n    mdhd = function (track) {\n      var result = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      0x00, 0x01, 0x5f, 0x90,\n      // timescale, 90,000 \"ticks\" per second\n      track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF,\n      // duration\n      0x55, 0xc4,\n      // 'und' language (undetermined)\n      0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n      // defined. The sample rate can be parsed out of an ADTS header, for\n      // instance.\n\n      if (track.samplerate) {\n        result[12] = track.samplerate >>> 24 & 0xFF;\n        result[13] = track.samplerate >>> 16 & 0xFF;\n        result[14] = track.samplerate >>> 8 & 0xFF;\n        result[15] = track.samplerate & 0xFF;\n      }\n      return box(types.mdhd, result);\n    };\n    mdia = function (track) {\n      return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n    };\n    mfhd = function (sequenceNumber) {\n      return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n      // flags\n      (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n      ]));\n    };\n\n    minf = function (track) {\n      return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n    };\n    moof = function (sequenceNumber, tracks) {\n      var trackFragments = [],\n        i = tracks.length; // build traf boxes for each track fragment\n\n      while (i--) {\n        trackFragments[i] = traf(tracks[i]);\n      }\n      return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n    };\n    /**\n     * Returns a movie box.\n     * @param tracks {array} the tracks associated with this movie\n     * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n     */\n\n    moov = function (tracks) {\n      var i = tracks.length,\n        boxes = [];\n      while (i--) {\n        boxes[i] = trak(tracks[i]);\n      }\n      return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n    };\n    mvex = function (tracks) {\n      var i = tracks.length,\n        boxes = [];\n      while (i--) {\n        boxes[i] = trex(tracks[i]);\n      }\n      return box.apply(null, [types.mvex].concat(boxes));\n    };\n    mvhd = function (duration) {\n      var bytes = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x01,\n      // creation_time\n      0x00, 0x00, 0x00, 0x02,\n      // modification_time\n      0x00, 0x01, 0x5f, 0x90,\n      // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF,\n      // duration\n      0x00, 0x01, 0x00, 0x00,\n      // 1.0 rate\n      0x01, 0x00,\n      // 1.0 volume\n      0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n      // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n\n      return box(types.mvhd, bytes);\n    };\n    sdtp = function (track) {\n      var samples = track.samples || [],\n        bytes = new Uint8Array(4 + samples.length),\n        flags,\n        i; // leave the full box header (4 bytes) all zero\n      // write the sample table\n\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n      return box(types.sdtp, bytes);\n    };\n    stbl = function (track) {\n      return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n    };\n    (function () {\n      var videoSample, audioSample;\n      stsd = function (track) {\n        return box(types.stsd, new Uint8Array([0x00,\n        // version 0\n        0x00, 0x00, 0x00,\n        // flags\n        0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n      };\n      videoSample = function (track) {\n        var sps = track.sps || [],\n          pps = track.pps || [],\n          sequenceParameterSets = [],\n          pictureParameterSets = [],\n          i,\n          avc1Box; // assemble the SPSs\n\n        for (i = 0; i < sps.length; i++) {\n          sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n          sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n          sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n        } // assemble the PPSs\n\n        for (i = 0; i < pps.length; i++) {\n          pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n          pictureParameterSets.push(pps[i].byteLength & 0xFF);\n          pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n        }\n        avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        0x00, 0x00,\n        // pre_defined\n        0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // pre_defined\n        (track.width & 0xff00) >> 8, track.width & 0xff,\n        // width\n        (track.height & 0xff00) >> 8, track.height & 0xff,\n        // height\n        0x00, 0x48, 0x00, 0x00,\n        // horizresolution\n        0x00, 0x48, 0x00, 0x00,\n        // vertresolution\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // frame_count\n        0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // compressorname\n        0x00, 0x18,\n        // depth = 24\n        0x11, 0x11 // pre_defined = -1\n        ]), box(types.avcC, new Uint8Array([0x01,\n        // configurationVersion\n        track.profileIdc,\n        // AVCProfileIndication\n        track.profileCompatibility,\n        // profile_compatibility\n        track.levelIdc,\n        // AVCLevelIndication\n        0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n        ].concat([sps.length],\n        // numOfSequenceParameterSets\n        sequenceParameterSets,\n        // \"SPS\"\n        [pps.length],\n        // numOfPictureParameterSets\n        pictureParameterSets // \"PPS\"\n        ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n        // bufferSizeDB\n        0x00, 0x2d, 0xc6, 0xc0,\n        // maxBitrate\n        0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n        ]))];\n\n        if (track.sarRatio) {\n          var hSpacing = track.sarRatio[0],\n            vSpacing = track.sarRatio[1];\n          avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n        }\n        return box.apply(null, avc1Box);\n      };\n      audioSample = function (track) {\n        return box(types.mp4a, new Uint8Array([\n        // SampleEntry, ISO/IEC 14496-12\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x01,\n        // data_reference_index\n        // AudioSampleEntry, ISO/IEC 14496-12\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        0x00, 0x00, 0x00, 0x00,\n        // reserved\n        (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff,\n        // channelcount\n        (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff,\n        // samplesize\n        0x00, 0x00,\n        // pre_defined\n        0x00, 0x00,\n        // reserved\n        (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n        // MP4AudioSampleEntry, ISO/IEC 14496-14\n        ]), esds(track));\n      };\n    })();\n    tkhd = function (track) {\n      var result = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x07,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00,\n      // modification_time\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n      // track_ID\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF,\n      // duration\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00,\n      // layer\n      0x00, 0x00,\n      // alternate_group\n      0x01, 0x00,\n      // non-audio track volume\n      0x00, 0x00,\n      // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n      // transformation: unity matrix\n      (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00,\n      // width\n      (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n      ]);\n\n      return box(types.tkhd, result);\n    };\n    /**\n     * Generate a track fragment (traf) box. A traf box collects metadata\n     * about tracks in a movie fragment (moof) box.\n     */\n\n    traf = function (track) {\n      var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n      trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x3a,\n      // flags\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n      // track_ID\n      0x00, 0x00, 0x00, 0x01,\n      // sample_description_index\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_duration\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_size\n      0x00, 0x00, 0x00, 0x00 // default_sample_flags\n      ]));\n\n      upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\n      lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\n      trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      // baseMediaDecodeTime\n      upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n      // the containing moof to the first payload byte of the associated\n      // mdat\n\n      dataOffset = 32 +\n      // tfhd\n      20 +\n      // tfdt\n      8 +\n      // traf header\n      16 +\n      // mfhd\n      8 +\n      // moof header\n      8; // mdat header\n      // audio tracks require less metadata\n\n      if (track.type === 'audio') {\n        trackFragmentRun = trun$1(track, dataOffset);\n        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n      } // video tracks should contain an independent and disposable samples\n      // box (sdtp)\n      // generate one and adjust offsets to match\n\n      sampleDependencyTable = sdtp(track);\n      trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n    };\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n\n    trak = function (track) {\n      track.duration = track.duration || 0xffffffff;\n      return box(types.trak, tkhd(track), mdia(track));\n    };\n    trex = function (track) {\n      var result = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n      // track_ID\n      0x00, 0x00, 0x00, 0x01,\n      // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_duration\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]); // the last two bytes of default_sample_flags is the sample\n      // degradation priority, a hint about the importance of this sample\n      // relative to others. Lower the degradation priority for all sample\n      // types other than video.\n\n      if (track.type !== 'video') {\n        result[result.length - 1] = 0x00;\n      }\n      return box(types.trex, result);\n    };\n    (function () {\n      var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n      // duration is present for the first sample, it will be present for\n      // all subsequent samples.\n      // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n      trunHeader = function (samples, offset) {\n        var durationPresent = 0,\n          sizePresent = 0,\n          flagsPresent = 0,\n          compositionTimeOffset = 0; // trun flag constants\n\n        if (samples.length) {\n          if (samples[0].duration !== undefined) {\n            durationPresent = 0x1;\n          }\n          if (samples[0].size !== undefined) {\n            sizePresent = 0x2;\n          }\n          if (samples[0].flags !== undefined) {\n            flagsPresent = 0x4;\n          }\n          if (samples[0].compositionTimeOffset !== undefined) {\n            compositionTimeOffset = 0x8;\n          }\n        }\n        return [0x00,\n        // version 0\n        0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01,\n        // flags\n        (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF,\n        // sample_count\n        (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n        ];\n      };\n\n      videoTrun = function (track, offset) {\n        var bytesOffest, bytes, header, samples, sample, i;\n        samples = track.samples || [];\n        offset += 8 + 12 + 16 * samples.length;\n        header = trunHeader(samples, offset);\n        bytes = new Uint8Array(header.length + samples.length * 16);\n        bytes.set(header);\n        bytesOffest = header.length;\n        for (i = 0; i < samples.length; i++) {\n          sample = samples[i];\n          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n          bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n          bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n          bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n          bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n        }\n\n        return box(types.trun, bytes);\n      };\n      audioTrun = function (track, offset) {\n        var bytes, bytesOffest, header, samples, sample, i;\n        samples = track.samples || [];\n        offset += 8 + 12 + 8 * samples.length;\n        header = trunHeader(samples, offset);\n        bytes = new Uint8Array(header.length + samples.length * 8);\n        bytes.set(header);\n        bytesOffest = header.length;\n        for (i = 0; i < samples.length; i++) {\n          sample = samples[i];\n          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n          bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n        }\n\n        return box(types.trun, bytes);\n      };\n      trun$1 = function (track, offset) {\n        if (track.type === 'audio') {\n          return audioTrun(track, offset);\n        }\n        return videoTrun(track, offset);\n      };\n    })();\n    var mp4Generator = {\n      ftyp: ftyp,\n      mdat: mdat,\n      moof: moof,\n      moov: moov,\n      initSegment: function (tracks) {\n        var fileType = ftyp(),\n          movie = moov(tracks),\n          result;\n        result = new Uint8Array(fileType.byteLength + movie.byteLength);\n        result.set(fileType);\n        result.set(movie, fileType.byteLength);\n        return result;\n      }\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n    // composed of the nal units that make up that frame\n    // Also keep track of cummulative data about the frame from the nal units such\n    // as the frame duration, starting pts, etc.\n\n    var groupNalsIntoFrames = function (nalUnits) {\n      var i,\n        currentNal,\n        currentFrame = [],\n        frames = []; // TODO added for LHLS, make sure this is OK\n\n      frames.byteLength = 0;\n      frames.nalCount = 0;\n      frames.duration = 0;\n      currentFrame.byteLength = 0;\n      for (i = 0; i < nalUnits.length; i++) {\n        currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n        if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n          // Since the very first nal unit is expected to be an AUD\n          // only push to the frames array when currentFrame is not empty\n          if (currentFrame.length) {\n            currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n            frames.byteLength += currentFrame.byteLength;\n            frames.nalCount += currentFrame.length;\n            frames.duration += currentFrame.duration;\n            frames.push(currentFrame);\n          }\n          currentFrame = [currentNal];\n          currentFrame.byteLength = currentNal.data.byteLength;\n          currentFrame.pts = currentNal.pts;\n          currentFrame.dts = currentNal.dts;\n        } else {\n          // Specifically flag key frames for ease of use later\n          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n            currentFrame.keyFrame = true;\n          }\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\n          currentFrame.byteLength += currentNal.data.byteLength;\n          currentFrame.push(currentNal);\n        }\n      } // For the last frame, use the duration of the previous frame if we\n      // have nothing better to go on\n\n      if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n        currentFrame.duration = frames[frames.length - 1].duration;\n      } // Push the final frame\n      // TODO added for LHLS, make sure this is OK\n\n      frames.byteLength += currentFrame.byteLength;\n      frames.nalCount += currentFrame.length;\n      frames.duration += currentFrame.duration;\n      frames.push(currentFrame);\n      return frames;\n    }; // Convert an array of frames into an array of Gop with each Gop being composed\n    // of the frames that make up that Gop\n    // Also keep track of cummulative data about the Gop from the frames such as the\n    // Gop duration, starting pts, etc.\n\n    var groupFramesIntoGops = function (frames) {\n      var i,\n        currentFrame,\n        currentGop = [],\n        gops = []; // We must pre-set some of the values on the Gop since we\n      // keep running totals of these values\n\n      currentGop.byteLength = 0;\n      currentGop.nalCount = 0;\n      currentGop.duration = 0;\n      currentGop.pts = frames[0].pts;\n      currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n      gops.byteLength = 0;\n      gops.nalCount = 0;\n      gops.duration = 0;\n      gops.pts = frames[0].pts;\n      gops.dts = frames[0].dts;\n      for (i = 0; i < frames.length; i++) {\n        currentFrame = frames[i];\n        if (currentFrame.keyFrame) {\n          // Since the very first frame is expected to be an keyframe\n          // only push to the gops array when currentGop is not empty\n          if (currentGop.length) {\n            gops.push(currentGop);\n            gops.byteLength += currentGop.byteLength;\n            gops.nalCount += currentGop.nalCount;\n            gops.duration += currentGop.duration;\n          }\n          currentGop = [currentFrame];\n          currentGop.nalCount = currentFrame.length;\n          currentGop.byteLength = currentFrame.byteLength;\n          currentGop.pts = currentFrame.pts;\n          currentGop.dts = currentFrame.dts;\n          currentGop.duration = currentFrame.duration;\n        } else {\n          currentGop.duration += currentFrame.duration;\n          currentGop.nalCount += currentFrame.length;\n          currentGop.byteLength += currentFrame.byteLength;\n          currentGop.push(currentFrame);\n        }\n      }\n      if (gops.length && currentGop.duration <= 0) {\n        currentGop.duration = gops[gops.length - 1].duration;\n      }\n      gops.byteLength += currentGop.byteLength;\n      gops.nalCount += currentGop.nalCount;\n      gops.duration += currentGop.duration; // push the final Gop\n\n      gops.push(currentGop);\n      return gops;\n    };\n    /*\n     * Search for the first keyframe in the GOPs and throw away all frames\n     * until that keyframe. Then extend the duration of the pulled keyframe\n     * and pull the PTS and DTS of the keyframe so that it covers the time\n     * range of the frames that were disposed.\n     *\n     * @param {Array} gops video GOPs\n     * @returns {Array} modified video GOPs\n     */\n\n    var extendFirstKeyFrame = function (gops) {\n      var currentGop;\n      if (!gops[0][0].keyFrame && gops.length > 1) {\n        // Remove the first GOP\n        currentGop = gops.shift();\n        gops.byteLength -= currentGop.byteLength;\n        gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n        // first gop to cover the time period of the\n        // frames we just removed\n\n        gops[0][0].dts = currentGop.dts;\n        gops[0][0].pts = currentGop.pts;\n        gops[0][0].duration += currentGop.duration;\n      }\n      return gops;\n    };\n    /**\n     * Default sample object\n     * see ISO/IEC 14496-12:2012, section 8.6.4.3\n     */\n\n    var createDefaultSample = function () {\n      return {\n        size: 0,\n        flags: {\n          isLeading: 0,\n          dependsOn: 1,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradationPriority: 0,\n          isNonSyncSample: 1\n        }\n      };\n    };\n    /*\n     * Collates information from a video frame into an object for eventual\n     * entry into an MP4 sample table.\n     *\n     * @param {Object} frame the video frame\n     * @param {Number} dataOffset the byte offset to position the sample\n     * @return {Object} object containing sample table info for a frame\n     */\n\n    var sampleForFrame = function (frame, dataOffset) {\n      var sample = createDefaultSample();\n      sample.dataOffset = dataOffset;\n      sample.compositionTimeOffset = frame.pts - frame.dts;\n      sample.duration = frame.duration;\n      sample.size = 4 * frame.length; // Space for nal unit size\n\n      sample.size += frame.byteLength;\n      if (frame.keyFrame) {\n        sample.flags.dependsOn = 2;\n        sample.flags.isNonSyncSample = 0;\n      }\n      return sample;\n    }; // generate the track's sample table from an array of gops\n\n    var generateSampleTable$1 = function (gops, baseDataOffset) {\n      var h,\n        i,\n        sample,\n        currentGop,\n        currentFrame,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n      for (h = 0; h < gops.length; h++) {\n        currentGop = gops[h];\n        for (i = 0; i < currentGop.length; i++) {\n          currentFrame = currentGop[i];\n          sample = sampleForFrame(currentFrame, dataOffset);\n          dataOffset += sample.size;\n          samples.push(sample);\n        }\n      }\n      return samples;\n    }; // generate the track's raw mdat data from an array of gops\n\n    var concatenateNalData = function (gops) {\n      var h,\n        i,\n        j,\n        currentGop,\n        currentFrame,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = gops.byteLength,\n        numberOfNals = gops.nalCount,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each Gop..\n\n      for (h = 0; h < gops.length; h++) {\n        currentGop = gops[h]; // For each Frame..\n\n        for (i = 0; i < currentGop.length; i++) {\n          currentFrame = currentGop[i]; // For each NAL..\n\n          for (j = 0; j < currentFrame.length; j++) {\n            currentNal = currentFrame[j];\n            view.setUint32(dataOffset, currentNal.data.byteLength);\n            dataOffset += 4;\n            data.set(currentNal.data, dataOffset);\n            dataOffset += currentNal.data.byteLength;\n          }\n        }\n      }\n      return data;\n    }; // generate the track's sample table from a frame\n\n    var generateSampleTableForFrame = function (frame, baseDataOffset) {\n      var sample,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n      sample = sampleForFrame(frame, dataOffset);\n      samples.push(sample);\n      return samples;\n    }; // generate the track's raw mdat data from a frame\n\n    var concatenateNalDataForFrame = function (frame) {\n      var i,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = frame.byteLength,\n        numberOfNals = frame.length,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each NAL..\n\n      for (i = 0; i < frame.length; i++) {\n        currentNal = frame[i];\n        view.setUint32(dataOffset, currentNal.data.byteLength);\n        dataOffset += 4;\n        data.set(currentNal.data, dataOffset);\n        dataOffset += currentNal.data.byteLength;\n      }\n      return data;\n    };\n    var frameUtils$1 = {\n      groupNalsIntoFrames: groupNalsIntoFrames,\n      groupFramesIntoGops: groupFramesIntoGops,\n      extendFirstKeyFrame: extendFirstKeyFrame,\n      generateSampleTable: generateSampleTable$1,\n      concatenateNalData: concatenateNalData,\n      generateSampleTableForFrame: generateSampleTableForFrame,\n      concatenateNalDataForFrame: concatenateNalDataForFrame\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var highPrefix = [33, 16, 5, 32, 164, 27];\n    var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n    var zeroFill = function (count) {\n      var a = [];\n      while (count--) {\n        a.push(0);\n      }\n      return a;\n    };\n    var makeTable = function (metaTable) {\n      return Object.keys(metaTable).reduce(function (obj, key) {\n        obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n          return arr.concat(part);\n        }, []));\n        return obj;\n      }, {});\n    };\n    var silence;\n    var silence_1 = function () {\n      if (!silence) {\n        // Frames-of-silence to use for filling in missing AAC frames\n        var coneOfSilence = {\n          96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n          88200: [highPrefix, [231], zeroFill(170), [56]],\n          64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n          48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n          44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n          32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n          24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n          16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n          12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n          11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n          8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n        };\n        silence = makeTable(coneOfSilence);\n      }\n      return silence;\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var ONE_SECOND_IN_TS$4 = 90000,\n      // 90kHz clock\n      secondsToVideoTs,\n      secondsToAudioTs,\n      videoTsToSeconds,\n      audioTsToSeconds,\n      audioTsToVideoTs,\n      videoTsToAudioTs,\n      metadataTsToSeconds;\n    secondsToVideoTs = function (seconds) {\n      return seconds * ONE_SECOND_IN_TS$4;\n    };\n    secondsToAudioTs = function (seconds, sampleRate) {\n      return seconds * sampleRate;\n    };\n    videoTsToSeconds = function (timestamp) {\n      return timestamp / ONE_SECOND_IN_TS$4;\n    };\n    audioTsToSeconds = function (timestamp, sampleRate) {\n      return timestamp / sampleRate;\n    };\n    audioTsToVideoTs = function (timestamp, sampleRate) {\n      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n    };\n    videoTsToAudioTs = function (timestamp, sampleRate) {\n      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n    };\n    /**\n     * Adjust ID3 tag or caption timing information by the timeline pts values\n     * (if keepOriginalTimestamps is false) and convert to seconds\n     */\n\n    metadataTsToSeconds = function (timestamp, timelineStartPts, keepOriginalTimestamps) {\n      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n    };\n    var clock$2 = {\n      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,\n      secondsToVideoTs: secondsToVideoTs,\n      secondsToAudioTs: secondsToAudioTs,\n      videoTsToSeconds: videoTsToSeconds,\n      audioTsToSeconds: audioTsToSeconds,\n      audioTsToVideoTs: audioTsToVideoTs,\n      videoTsToAudioTs: videoTsToAudioTs,\n      metadataTsToSeconds: metadataTsToSeconds\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var coneOfSilence = silence_1;\n    var clock$1 = clock$2;\n    /**\n     * Sum the `byteLength` properties of the data in each AAC frame\n     */\n\n    var sumFrameByteLengths = function (array) {\n      var i,\n        currentObj,\n        sum = 0; // sum the byteLength's all each nal unit in the frame\n\n      for (i = 0; i < array.length; i++) {\n        currentObj = array[i];\n        sum += currentObj.data.byteLength;\n      }\n      return sum;\n    }; // Possibly pad (prefix) the audio track with silence if appending this track\n    // would lead to the introduction of a gap in the audio buffer\n\n    var prefixWithSilence = function (track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n      var baseMediaDecodeTimeTs,\n        frameDuration = 0,\n        audioGapDuration = 0,\n        audioFillFrameCount = 0,\n        audioFillDuration = 0,\n        silentFrame,\n        i,\n        firstFrame;\n      if (!frames.length) {\n        return;\n      }\n      baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n      frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n      if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n        // insert the shortest possible amount (audio gap or audio to video gap)\n        audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n        audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n        audioFillDuration = audioFillFrameCount * frameDuration;\n      } // don't attempt to fill gaps smaller than a single frame or larger\n      // than a half second\n\n      if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) {\n        return;\n      }\n      silentFrame = coneOfSilence()[track.samplerate];\n      if (!silentFrame) {\n        // we don't have a silent frame pregenerated for the sample rate, so use a frame\n        // from the content instead\n        silentFrame = frames[0].data;\n      }\n      for (i = 0; i < audioFillFrameCount; i++) {\n        firstFrame = frames[0];\n        frames.splice(0, 0, {\n          data: silentFrame,\n          dts: firstFrame.dts - frameDuration,\n          pts: firstFrame.pts - frameDuration\n        });\n      }\n      track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));\n      return audioFillDuration;\n    }; // If the audio segment extends before the earliest allowed dts\n    // value, remove AAC frames until starts at or after the earliest\n    // allowed DTS so that we don't end up with a negative baseMedia-\n    // DecodeTime for the audio track\n\n    var trimAdtsFramesByEarliestDts = function (adtsFrames, track, earliestAllowedDts) {\n      if (track.minSegmentDts >= earliestAllowedDts) {\n        return adtsFrames;\n      } // We will need to recalculate the earliest segment Dts\n\n      track.minSegmentDts = Infinity;\n      return adtsFrames.filter(function (currentFrame) {\n        // If this is an allowed frame, keep it and record it's Dts\n        if (currentFrame.dts >= earliestAllowedDts) {\n          track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n          track.minSegmentPts = track.minSegmentDts;\n          return true;\n        } // Otherwise, discard it\n\n        return false;\n      });\n    }; // generate the track's raw mdat data from an array of frames\n\n    var generateSampleTable = function (frames) {\n      var i,\n        currentFrame,\n        samples = [];\n      for (i = 0; i < frames.length; i++) {\n        currentFrame = frames[i];\n        samples.push({\n          size: currentFrame.data.byteLength,\n          duration: 1024 // For AAC audio, all samples contain 1024 samples\n        });\n      }\n\n      return samples;\n    }; // generate the track's sample table from an array of frames\n\n    var concatenateFrameData = function (frames) {\n      var i,\n        currentFrame,\n        dataOffset = 0,\n        data = new Uint8Array(sumFrameByteLengths(frames));\n      for (i = 0; i < frames.length; i++) {\n        currentFrame = frames[i];\n        data.set(currentFrame.data, dataOffset);\n        dataOffset += currentFrame.data.byteLength;\n      }\n      return data;\n    };\n    var audioFrameUtils$1 = {\n      prefixWithSilence: prefixWithSilence,\n      trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n      generateSampleTable: generateSampleTable,\n      concatenateFrameData: concatenateFrameData\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;\n    /**\n     * Store information about the start and end of the track and the\n     * duration for each frame/sample we process in order to calculate\n     * the baseMediaDecodeTime\n     */\n\n    var collectDtsInfo = function (track, data) {\n      if (typeof data.pts === 'number') {\n        if (track.timelineStartInfo.pts === undefined) {\n          track.timelineStartInfo.pts = data.pts;\n        }\n        if (track.minSegmentPts === undefined) {\n          track.minSegmentPts = data.pts;\n        } else {\n          track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n        }\n        if (track.maxSegmentPts === undefined) {\n          track.maxSegmentPts = data.pts;\n        } else {\n          track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n        }\n      }\n      if (typeof data.dts === 'number') {\n        if (track.timelineStartInfo.dts === undefined) {\n          track.timelineStartInfo.dts = data.dts;\n        }\n        if (track.minSegmentDts === undefined) {\n          track.minSegmentDts = data.dts;\n        } else {\n          track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n        }\n        if (track.maxSegmentDts === undefined) {\n          track.maxSegmentDts = data.dts;\n        } else {\n          track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n        }\n      }\n    };\n    /**\n     * Clear values used to calculate the baseMediaDecodeTime between\n     * tracks\n     */\n\n    var clearDtsInfo = function (track) {\n      delete track.minSegmentDts;\n      delete track.maxSegmentDts;\n      delete track.minSegmentPts;\n      delete track.maxSegmentPts;\n    };\n    /**\n     * Calculate the track's baseMediaDecodeTime based on the earliest\n     * DTS the transmuxer has ever seen and the minimum DTS for the\n     * current track\n     * @param track {object} track metadata configuration\n     * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n\n    var calculateTrackBaseMediaDecodeTime = function (track, keepOriginalTimestamps) {\n      var baseMediaDecodeTime,\n        scale,\n        minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n      if (!keepOriginalTimestamps) {\n        minSegmentDts -= track.timelineStartInfo.dts;\n      } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n      // we want the start of the first segment to be placed\n\n      baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n      baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n      baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n      if (track.type === 'audio') {\n        // Audio has a different clock equal to the sampling_rate so we need to\n        // scale the PTS values into the clock rate of the track\n        scale = track.samplerate / ONE_SECOND_IN_TS$3;\n        baseMediaDecodeTime *= scale;\n        baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n      }\n      return baseMediaDecodeTime;\n    };\n    var trackDecodeInfo$1 = {\n      clearDtsInfo: clearDtsInfo,\n      calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n      collectDtsInfo: collectDtsInfo\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Reads in-band caption information from a video elementary\n     * stream. Captions must follow the CEA-708 standard for injection\n     * into an MPEG-2 transport streams.\n     * @see https://en.wikipedia.org/wiki/CEA-708\n     * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n     */\n    // payload type field to indicate how they are to be\n    // interpreted. CEAS-708 caption content is always transmitted with\n    // payload type 0x04.\n\n    var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n      RBSP_TRAILING_BITS = 128;\n    /**\n      * Parse a supplemental enhancement information (SEI) NAL unit.\n      * Stops parsing once a message of type ITU T T35 has been found.\n      *\n      * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n      * @return {object} the parsed SEI payload\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\n      */\n\n    var parseSei = function (bytes) {\n      var i = 0,\n        result = {\n          payloadType: -1,\n          payloadSize: 0\n        },\n        payloadType = 0,\n        payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n      while (i < bytes.byteLength) {\n        // stop once we have hit the end of the sei_rbsp\n        if (bytes[i] === RBSP_TRAILING_BITS) {\n          break;\n        } // Parse payload type\n\n        while (bytes[i] === 0xFF) {\n          payloadType += 255;\n          i++;\n        }\n        payloadType += bytes[i++]; // Parse payload size\n\n        while (bytes[i] === 0xFF) {\n          payloadSize += 255;\n          i++;\n        }\n        payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n        // there can only ever be one caption message in a frame's sei\n\n        if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n          var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n          if (userIdentifier === 'GA94') {\n            result.payloadType = payloadType;\n            result.payloadSize = payloadSize;\n            result.payload = bytes.subarray(i, i + payloadSize);\n            break;\n          } else {\n            result.payload = void 0;\n          }\n        } // skip the payload and parse the next message\n\n        i += payloadSize;\n        payloadType = 0;\n        payloadSize = 0;\n      }\n      return result;\n    }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n    var parseUserData = function (sei) {\n      // itu_t_t35_contry_code must be 181 (United States) for\n      // captions\n      if (sei.payload[0] !== 181) {\n        return null;\n      } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n      if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n        return null;\n      } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n      if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n        return null;\n      } // finally, user_data_type_code should be 0x03 for caption data\n\n      if (sei.payload[7] !== 0x03) {\n        return null;\n      } // return the user_data_type_structure and strip the trailing\n      // marker bits\n\n      return sei.payload.subarray(8, sei.payload.length - 1);\n    }; // see CEA-708-D, section 4.4\n\n    var parseCaptionPackets = function (pts, userData) {\n      var results = [],\n        i,\n        count,\n        offset,\n        data; // if this is just filler, return immediately\n\n      if (!(userData[0] & 0x40)) {\n        return results;\n      } // parse out the cc_data_1 and cc_data_2 fields\n\n      count = userData[0] & 0x1f;\n      for (i = 0; i < count; i++) {\n        offset = i * 3;\n        data = {\n          type: userData[offset + 2] & 0x03,\n          pts: pts\n        }; // capture cc data when cc_valid is 1\n\n        if (userData[offset + 2] & 0x04) {\n          data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n          results.push(data);\n        }\n      }\n      return results;\n    };\n    var discardEmulationPreventionBytes$1 = function (data) {\n      var length = data.byteLength,\n        emulationPreventionBytesPositions = [],\n        i = 1,\n        newLength,\n        newData; // Find all `Emulation Prevention Bytes`\n\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          emulationPreventionBytesPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      } // If no Emulation Prevention Bytes were found just return the original\n      // array\n\n      if (emulationPreventionBytesPositions.length === 0) {\n        return data;\n      } // Create a new array to hold the NAL unit data\n\n      newLength = length - emulationPreventionBytesPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === emulationPreventionBytesPositions[0]) {\n          // Skip this byte\n          sourceIndex++; // Remove this position index\n\n          emulationPreventionBytesPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n      }\n      return newData;\n    }; // exports\n\n    var captionPacketParser = {\n      parseSei: parseSei,\n      parseUserData: parseUserData,\n      parseCaptionPackets: parseCaptionPackets,\n      discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\n      USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Reads in-band caption information from a video elementary\n     * stream. Captions must follow the CEA-708 standard for injection\n     * into an MPEG-2 transport streams.\n     * @see https://en.wikipedia.org/wiki/CEA-708\n     * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n     */\n    // Link To Transport\n    // -----------------\n\n    var Stream$7 = stream;\n    var cea708Parser = captionPacketParser;\n    var CaptionStream$2 = function (options) {\n      options = options || {};\n      CaptionStream$2.prototype.init.call(this); // parse708captions flag, default to true\n\n      this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n      this.captionPackets_ = [];\n      this.ccStreams_ = [new Cea608Stream(0, 0),\n      // eslint-disable-line no-use-before-define\n      new Cea608Stream(0, 1),\n      // eslint-disable-line no-use-before-define\n      new Cea608Stream(1, 0),\n      // eslint-disable-line no-use-before-define\n      new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n      ];\n\n      if (this.parse708captions_) {\n        this.cc708Stream_ = new Cea708Stream({\n          captionServices: options.captionServices\n        }); // eslint-disable-line no-use-before-define\n      }\n\n      this.reset(); // forward data and done events from CCs to this CaptionStream\n\n      this.ccStreams_.forEach(function (cc) {\n        cc.on('data', this.trigger.bind(this, 'data'));\n        cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n        cc.on('done', this.trigger.bind(this, 'done'));\n      }, this);\n      if (this.parse708captions_) {\n        this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n        this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n        this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n      }\n    };\n    CaptionStream$2.prototype = new Stream$7();\n    CaptionStream$2.prototype.push = function (event) {\n      var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n      if (event.nalUnitType !== 'sei_rbsp') {\n        return;\n      } // parse the sei\n\n      sei = cea708Parser.parseSei(event.escapedRBSP); // no payload data, skip\n\n      if (!sei.payload) {\n        return;\n      } // ignore everything but user_data_registered_itu_t_t35\n\n      if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n        return;\n      } // parse out the user data payload\n\n      userData = cea708Parser.parseUserData(sei); // ignore unrecognized userData\n\n      if (!userData) {\n        return;\n      } // Sometimes, the same segment # will be downloaded twice. To stop the\n      // caption data from being processed twice, we track the latest dts we've\n      // received and ignore everything with a dts before that. However, since\n      // data for a specific dts can be split across packets on either side of\n      // a segment boundary, we need to make sure we *don't* ignore the packets\n      // from the *next* segment that have dts === this.latestDts_. By constantly\n      // tracking the number of packets received with dts === this.latestDts_, we\n      // know how many should be ignored once we start receiving duplicates.\n\n      if (event.dts < this.latestDts_) {\n        // We've started getting older data, so set the flag.\n        this.ignoreNextEqualDts_ = true;\n        return;\n      } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n        this.numSameDts_--;\n        if (!this.numSameDts_) {\n          // We've received the last duplicate packet, time to start processing again\n          this.ignoreNextEqualDts_ = false;\n        }\n        return;\n      } // parse out CC data packets and save them for later\n\n      newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n      this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n      if (this.latestDts_ !== event.dts) {\n        this.numSameDts_ = 0;\n      }\n      this.numSameDts_++;\n      this.latestDts_ = event.dts;\n    };\n    CaptionStream$2.prototype.flushCCStreams = function (flushType) {\n      this.ccStreams_.forEach(function (cc) {\n        return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n      }, this);\n    };\n    CaptionStream$2.prototype.flushStream = function (flushType) {\n      // make sure we actually parsed captions before proceeding\n      if (!this.captionPackets_.length) {\n        this.flushCCStreams(flushType);\n        return;\n      } // In Chrome, the Array#sort function is not stable so add a\n      // presortIndex that we can use to ensure we get a stable-sort\n\n      this.captionPackets_.forEach(function (elem, idx) {\n        elem.presortIndex = idx;\n      }); // sort caption byte-pairs based on their PTS values\n\n      this.captionPackets_.sort(function (a, b) {\n        if (a.pts === b.pts) {\n          return a.presortIndex - b.presortIndex;\n        }\n        return a.pts - b.pts;\n      });\n      this.captionPackets_.forEach(function (packet) {\n        if (packet.type < 2) {\n          // Dispatch packet to the right Cea608Stream\n          this.dispatchCea608Packet(packet);\n        } else {\n          // Dispatch packet to the Cea708Stream\n          this.dispatchCea708Packet(packet);\n        }\n      }, this);\n      this.captionPackets_.length = 0;\n      this.flushCCStreams(flushType);\n    };\n    CaptionStream$2.prototype.flush = function () {\n      return this.flushStream('flush');\n    }; // Only called if handling partial data\n\n    CaptionStream$2.prototype.partialFlush = function () {\n      return this.flushStream('partialFlush');\n    };\n    CaptionStream$2.prototype.reset = function () {\n      this.latestDts_ = null;\n      this.ignoreNextEqualDts_ = false;\n      this.numSameDts_ = 0;\n      this.activeCea608Channel_ = [null, null];\n      this.ccStreams_.forEach(function (ccStream) {\n        ccStream.reset();\n      });\n    }; // From the CEA-608 spec:\n\n    /*\n     * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n     * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n     * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n     * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n     * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n     * to switch to captioning or Text.\n    */\n    // With that in mind, we ignore any data between an XDS control code and a\n    // subsequent closed-captioning control code.\n\n    CaptionStream$2.prototype.dispatchCea608Packet = function (packet) {\n      // NOTE: packet.type is the CEA608 field\n      if (this.setsTextOrXDSActive(packet)) {\n        this.activeCea608Channel_[packet.type] = null;\n      } else if (this.setsChannel1Active(packet)) {\n        this.activeCea608Channel_[packet.type] = 0;\n      } else if (this.setsChannel2Active(packet)) {\n        this.activeCea608Channel_[packet.type] = 1;\n      }\n      if (this.activeCea608Channel_[packet.type] === null) {\n        // If we haven't received anything to set the active channel, or the\n        // packets are Text/XDS data, discard the data; we don't want jumbled\n        // captions\n        return;\n      }\n      this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n    };\n    CaptionStream$2.prototype.setsChannel1Active = function (packet) {\n      return (packet.ccData & 0x7800) === 0x1000;\n    };\n    CaptionStream$2.prototype.setsChannel2Active = function (packet) {\n      return (packet.ccData & 0x7800) === 0x1800;\n    };\n    CaptionStream$2.prototype.setsTextOrXDSActive = function (packet) {\n      return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n    };\n    CaptionStream$2.prototype.dispatchCea708Packet = function (packet) {\n      if (this.parse708captions_) {\n        this.cc708Stream_.push(packet);\n      }\n    }; // ----------------------\n    // Session to Application\n    // ----------------------\n    // This hash maps special and extended character codes to their\n    // proper Unicode equivalent. The first one-byte key is just a\n    // non-standard character code. The two-byte keys that follow are\n    // the extended CEA708 character codes, along with the preceding\n    // 0x10 extended character byte to distinguish these codes from\n    // non-extended character codes. Every CEA708 character code that\n    // is not in this object maps directly to a standard unicode\n    // character code.\n    // The transparent space and non-breaking transparent space are\n    // technically not fully supported since there is no code to\n    // make them transparent, so they have normal non-transparent\n    // stand-ins.\n    // The special closed caption (CC) character isn't a standard\n    // unicode character, so a fairly similar unicode character was\n    // chosen in it's place.\n\n    var CHARACTER_TRANSLATION_708 = {\n      0x7f: 0x266a,\n      // \n      0x1020: 0x20,\n      // Transparent Space\n      0x1021: 0xa0,\n      // Nob-breaking Transparent Space\n      0x1025: 0x2026,\n      // \n      0x102a: 0x0160,\n      // \n      0x102c: 0x0152,\n      // \n      0x1030: 0x2588,\n      // \n      0x1031: 0x2018,\n      // \n      0x1032: 0x2019,\n      // \n      0x1033: 0x201c,\n      // \n      0x1034: 0x201d,\n      // \n      0x1035: 0x2022,\n      // \n      0x1039: 0x2122,\n      // \n      0x103a: 0x0161,\n      // \n      0x103c: 0x0153,\n      // \n      0x103d: 0x2120,\n      // \n      0x103f: 0x0178,\n      // \n      0x1076: 0x215b,\n      // \n      0x1077: 0x215c,\n      // \n      0x1078: 0x215d,\n      // \n      0x1079: 0x215e,\n      // \n      0x107a: 0x23d0,\n      // \n      0x107b: 0x23a4,\n      // \n      0x107c: 0x23a3,\n      // \n      0x107d: 0x23af,\n      // \n      0x107e: 0x23a6,\n      // \n      0x107f: 0x23a1,\n      // \n      0x10a0: 0x3138 //  (CC char)\n    };\n\n    var get708CharFromCode = function (code) {\n      var newCode = CHARACTER_TRANSLATION_708[code] || code;\n      if (code & 0x1000 && code === newCode) {\n        // Invalid extended code\n        return '';\n      }\n      return String.fromCharCode(newCode);\n    };\n    var within708TextBlock = function (b) {\n      return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n    };\n    var Cea708Window = function (windowNum) {\n      this.windowNum = windowNum;\n      this.reset();\n    };\n    Cea708Window.prototype.reset = function () {\n      this.clearText();\n      this.pendingNewLine = false;\n      this.winAttr = {};\n      this.penAttr = {};\n      this.penLoc = {};\n      this.penColor = {}; // These default values are arbitrary,\n      // defineWindow will usually override them\n\n      this.visible = 0;\n      this.rowLock = 0;\n      this.columnLock = 0;\n      this.priority = 0;\n      this.relativePositioning = 0;\n      this.anchorVertical = 0;\n      this.anchorHorizontal = 0;\n      this.anchorPoint = 0;\n      this.rowCount = 1;\n      this.virtualRowCount = this.rowCount + 1;\n      this.columnCount = 41;\n      this.windowStyle = 0;\n      this.penStyle = 0;\n    };\n    Cea708Window.prototype.getText = function () {\n      return this.rows.join('\\n');\n    };\n    Cea708Window.prototype.clearText = function () {\n      this.rows = [''];\n      this.rowIdx = 0;\n    };\n    Cea708Window.prototype.newLine = function (pts) {\n      if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n        this.beforeRowOverflow(pts);\n      }\n      if (this.rows.length > 0) {\n        this.rows.push('');\n        this.rowIdx++;\n      } // Show all virtual rows since there's no visible scrolling\n\n      while (this.rows.length > this.virtualRowCount) {\n        this.rows.shift();\n        this.rowIdx--;\n      }\n    };\n    Cea708Window.prototype.isEmpty = function () {\n      if (this.rows.length === 0) {\n        return true;\n      } else if (this.rows.length === 1) {\n        return this.rows[0] === '';\n      }\n      return false;\n    };\n    Cea708Window.prototype.addText = function (text) {\n      this.rows[this.rowIdx] += text;\n    };\n    Cea708Window.prototype.backspace = function () {\n      if (!this.isEmpty()) {\n        var row = this.rows[this.rowIdx];\n        this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n      }\n    };\n    var Cea708Service = function (serviceNum, encoding, stream) {\n      this.serviceNum = serviceNum;\n      this.text = '';\n      this.currentWindow = new Cea708Window(-1);\n      this.windows = [];\n      this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n      if (typeof encoding === 'string') {\n        this.createTextDecoder(encoding);\n      }\n    };\n    /**\n     * Initialize service windows\n     * Must be run before service use\n     *\n     * @param  {Integer}  pts               PTS value\n     * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n     */\n\n    Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\n      this.startPts = pts;\n      for (var win = 0; win < 8; win++) {\n        this.windows[win] = new Cea708Window(win);\n        if (typeof beforeRowOverflow === 'function') {\n          this.windows[win].beforeRowOverflow = beforeRowOverflow;\n        }\n      }\n    };\n    /**\n     * Set current window of service to be affected by commands\n     *\n     * @param  {Integer} windowNum Window number\n     */\n\n    Cea708Service.prototype.setCurrentWindow = function (windowNum) {\n      this.currentWindow = this.windows[windowNum];\n    };\n    /**\n     * Try to create a TextDecoder if it is natively supported\n     */\n\n    Cea708Service.prototype.createTextDecoder = function (encoding) {\n      if (typeof TextDecoder === 'undefined') {\n        this.stream.trigger('log', {\n          level: 'warn',\n          message: 'The `encoding` option is unsupported without TextDecoder support'\n        });\n      } else {\n        try {\n          this.textDecoder_ = new TextDecoder(encoding);\n        } catch (error) {\n          this.stream.trigger('log', {\n            level: 'warn',\n            message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n          });\n        }\n      }\n    };\n    var Cea708Stream = function (options) {\n      options = options || {};\n      Cea708Stream.prototype.init.call(this);\n      var self = this;\n      var captionServices = options.captionServices || {};\n      var captionServiceEncodings = {};\n      var serviceProps; // Get service encodings from captionServices option block\n\n      Object.keys(captionServices).forEach(serviceName => {\n        serviceProps = captionServices[serviceName];\n        if (/^SERVICE/.test(serviceName)) {\n          captionServiceEncodings[serviceName] = serviceProps.encoding;\n        }\n      });\n      this.serviceEncodings = captionServiceEncodings;\n      this.current708Packet = null;\n      this.services = {};\n      this.push = function (packet) {\n        if (packet.type === 3) {\n          // 708 packet start\n          self.new708Packet();\n          self.add708Bytes(packet);\n        } else {\n          if (self.current708Packet === null) {\n            // This should only happen at the start of a file if there's no packet start.\n            self.new708Packet();\n          }\n          self.add708Bytes(packet);\n        }\n      };\n    };\n    Cea708Stream.prototype = new Stream$7();\n    /**\n     * Push current 708 packet, create new 708 packet.\n     */\n\n    Cea708Stream.prototype.new708Packet = function () {\n      if (this.current708Packet !== null) {\n        this.push708Packet();\n      }\n      this.current708Packet = {\n        data: [],\n        ptsVals: []\n      };\n    };\n    /**\n     * Add pts and both bytes from packet into current 708 packet.\n     */\n\n    Cea708Stream.prototype.add708Bytes = function (packet) {\n      var data = packet.ccData;\n      var byte0 = data >>> 8;\n      var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n      // that service blocks will always line up with byte pairs.\n\n      this.current708Packet.ptsVals.push(packet.pts);\n      this.current708Packet.data.push(byte0);\n      this.current708Packet.data.push(byte1);\n    };\n    /**\n     * Parse completed 708 packet into service blocks and push each service block.\n     */\n\n    Cea708Stream.prototype.push708Packet = function () {\n      var packet708 = this.current708Packet;\n      var packetData = packet708.data;\n      var serviceNum = null;\n      var blockSize = null;\n      var i = 0;\n      var b = packetData[i++];\n      packet708.seq = b >> 6;\n      packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n      for (; i < packetData.length; i++) {\n        b = packetData[i++];\n        serviceNum = b >> 5;\n        blockSize = b & 0x1f; // 0b00011111\n\n        if (serviceNum === 7 && blockSize > 0) {\n          // Extended service num\n          b = packetData[i++];\n          serviceNum = b;\n        }\n        this.pushServiceBlock(serviceNum, i, blockSize);\n        if (blockSize > 0) {\n          i += blockSize - 1;\n        }\n      }\n    };\n    /**\n     * Parse service block, execute commands, read text.\n     *\n     * Note: While many of these commands serve important purposes,\n     * many others just parse out the parameters or attributes, but\n     * nothing is done with them because this is not a full and complete\n     * implementation of the entire 708 spec.\n     *\n     * @param  {Integer} serviceNum Service number\n     * @param  {Integer} start      Start index of the 708 packet data\n     * @param  {Integer} size       Block size\n     */\n\n    Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n      var b;\n      var i = start;\n      var packetData = this.current708Packet.data;\n      var service = this.services[serviceNum];\n      if (!service) {\n        service = this.initService(serviceNum, i);\n      }\n      for (; i < start + size && i < packetData.length; i++) {\n        b = packetData[i];\n        if (within708TextBlock(b)) {\n          i = this.handleText(i, service);\n        } else if (b === 0x18) {\n          i = this.multiByteCharacter(i, service);\n        } else if (b === 0x10) {\n          i = this.extendedCommands(i, service);\n        } else if (0x80 <= b && b <= 0x87) {\n          i = this.setCurrentWindow(i, service);\n        } else if (0x98 <= b && b <= 0x9f) {\n          i = this.defineWindow(i, service);\n        } else if (b === 0x88) {\n          i = this.clearWindows(i, service);\n        } else if (b === 0x8c) {\n          i = this.deleteWindows(i, service);\n        } else if (b === 0x89) {\n          i = this.displayWindows(i, service);\n        } else if (b === 0x8a) {\n          i = this.hideWindows(i, service);\n        } else if (b === 0x8b) {\n          i = this.toggleWindows(i, service);\n        } else if (b === 0x97) {\n          i = this.setWindowAttributes(i, service);\n        } else if (b === 0x90) {\n          i = this.setPenAttributes(i, service);\n        } else if (b === 0x91) {\n          i = this.setPenColor(i, service);\n        } else if (b === 0x92) {\n          i = this.setPenLocation(i, service);\n        } else if (b === 0x8f) {\n          service = this.reset(i, service);\n        } else if (b === 0x08) {\n          // BS: Backspace\n          service.currentWindow.backspace();\n        } else if (b === 0x0c) {\n          // FF: Form feed\n          service.currentWindow.clearText();\n        } else if (b === 0x0d) {\n          // CR: Carriage return\n          service.currentWindow.pendingNewLine = true;\n        } else if (b === 0x0e) {\n          // HCR: Horizontal carriage return\n          service.currentWindow.clearText();\n        } else if (b === 0x8d) {\n          // DLY: Delay, nothing to do\n          i++;\n        } else ;\n      }\n    };\n    /**\n     * Execute an extended command\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.extendedCommands = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[++i];\n      if (within708TextBlock(b)) {\n        i = this.handleText(i, service, {\n          isExtended: true\n        });\n      }\n      return i;\n    };\n    /**\n     * Get PTS value of a given byte index\n     *\n     * @param  {Integer} byteIndex  Index of the byte\n     * @return {Integer}            PTS\n     */\n\n    Cea708Stream.prototype.getPts = function (byteIndex) {\n      // There's 1 pts value per 2 bytes\n      return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n    };\n    /**\n     * Initializes a service\n     *\n     * @param  {Integer} serviceNum Service number\n     * @return {Service}            Initialized service object\n     */\n\n    Cea708Stream.prototype.initService = function (serviceNum, i) {\n      var serviceName = 'SERVICE' + serviceNum;\n      var self = this;\n      var serviceName;\n      var encoding;\n      if (serviceName in this.serviceEncodings) {\n        encoding = this.serviceEncodings[serviceName];\n      }\n      this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n      this.services[serviceNum].init(this.getPts(i), function (pts) {\n        self.flushDisplayed(pts, self.services[serviceNum]);\n      });\n      return this.services[serviceNum];\n    };\n    /**\n     * Execute text writing to current window\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.handleText = function (i, service, options) {\n      var isExtended = options && options.isExtended;\n      var isMultiByte = options && options.isMultiByte;\n      var packetData = this.current708Packet.data;\n      var extended = isExtended ? 0x1000 : 0x0000;\n      var currentByte = packetData[i];\n      var nextByte = packetData[i + 1];\n      var win = service.currentWindow;\n      var char;\n      var charCodeArray; // Use the TextDecoder if one was created for this service\n\n      if (service.textDecoder_ && !isExtended) {\n        if (isMultiByte) {\n          charCodeArray = [currentByte, nextByte];\n          i++;\n        } else {\n          charCodeArray = [currentByte];\n        }\n        char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n      } else {\n        char = get708CharFromCode(extended | currentByte);\n      }\n      if (win.pendingNewLine && !win.isEmpty()) {\n        win.newLine(this.getPts(i));\n      }\n      win.pendingNewLine = false;\n      win.addText(char);\n      return i;\n    };\n    /**\n     * Handle decoding of multibyte character\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.multiByteCharacter = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var firstByte = packetData[i + 1];\n      var secondByte = packetData[i + 2];\n      if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n        i = this.handleText(++i, service, {\n          isMultiByte: true\n        });\n      }\n      return i;\n    };\n    /**\n     * Parse and execute the CW# command.\n     *\n     * Set the current window.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.setCurrentWindow = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[i];\n      var windowNum = b & 0x07;\n      service.setCurrentWindow(windowNum);\n      return i;\n    };\n    /**\n     * Parse and execute the DF# command.\n     *\n     * Define a window and set it as the current window.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.defineWindow = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[i];\n      var windowNum = b & 0x07;\n      service.setCurrentWindow(windowNum);\n      var win = service.currentWindow;\n      b = packetData[++i];\n      win.visible = (b & 0x20) >> 5; // v\n\n      win.rowLock = (b & 0x10) >> 4; // rl\n\n      win.columnLock = (b & 0x08) >> 3; // cl\n\n      win.priority = b & 0x07; // p\n\n      b = packetData[++i];\n      win.relativePositioning = (b & 0x80) >> 7; // rp\n\n      win.anchorVertical = b & 0x7f; // av\n\n      b = packetData[++i];\n      win.anchorHorizontal = b; // ah\n\n      b = packetData[++i];\n      win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n      win.rowCount = b & 0x0f; // rc\n\n      b = packetData[++i];\n      win.columnCount = b & 0x3f; // cc\n\n      b = packetData[++i];\n      win.windowStyle = (b & 0x38) >> 3; // ws\n\n      win.penStyle = b & 0x07; // ps\n      // The spec says there are (rowCount+1) \"virtual rows\"\n\n      win.virtualRowCount = win.rowCount + 1;\n      return i;\n    };\n    /**\n     * Parse and execute the SWA command.\n     *\n     * Set attributes of the current window.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.setWindowAttributes = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[i];\n      var winAttr = service.currentWindow.winAttr;\n      b = packetData[++i];\n      winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n      winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n      winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n      winAttr.fillBlue = b & 0x03; // fb\n\n      b = packetData[++i];\n      winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n      winAttr.borderRed = (b & 0x30) >> 4; // br\n\n      winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n      winAttr.borderBlue = b & 0x03; // bb\n\n      b = packetData[++i];\n      winAttr.borderType += (b & 0x80) >> 5; // bt\n\n      winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n      winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n      winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n      winAttr.justify = b & 0x03; // j\n\n      b = packetData[++i];\n      winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n      winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n      winAttr.displayEffect = b & 0x03; // de\n\n      return i;\n    };\n    /**\n     * Gather text from all displayed windows and push a caption to output.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     */\n\n    Cea708Stream.prototype.flushDisplayed = function (pts, service) {\n      var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n      // display text in the correct order, but sample files so far have not shown any issue.\n\n      for (var winId = 0; winId < 8; winId++) {\n        if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n          displayedText.push(service.windows[winId].getText());\n        }\n      }\n      service.endPts = pts;\n      service.text = displayedText.join('\\n\\n');\n      this.pushCaption(service);\n      service.startPts = pts;\n    };\n    /**\n     * Push a caption to output if the caption contains text.\n     *\n     * @param  {Service} service  The service object to be affected\n     */\n\n    Cea708Stream.prototype.pushCaption = function (service) {\n      if (service.text !== '') {\n        this.trigger('data', {\n          startPts: service.startPts,\n          endPts: service.endPts,\n          text: service.text,\n          stream: 'cc708_' + service.serviceNum\n        });\n        service.text = '';\n        service.startPts = service.endPts;\n      }\n    };\n    /**\n     * Parse and execute the DSW command.\n     *\n     * Set visible property of windows based on the parsed bitmask.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.displayWindows = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[++i];\n      var pts = this.getPts(i);\n      this.flushDisplayed(pts, service);\n      for (var winId = 0; winId < 8; winId++) {\n        if (b & 0x01 << winId) {\n          service.windows[winId].visible = 1;\n        }\n      }\n      return i;\n    };\n    /**\n     * Parse and execute the HDW command.\n     *\n     * Set visible property of windows based on the parsed bitmask.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.hideWindows = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[++i];\n      var pts = this.getPts(i);\n      this.flushDisplayed(pts, service);\n      for (var winId = 0; winId < 8; winId++) {\n        if (b & 0x01 << winId) {\n          service.windows[winId].visible = 0;\n        }\n      }\n      return i;\n    };\n    /**\n     * Parse and execute the TGW command.\n     *\n     * Set visible property of windows based on the parsed bitmask.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.toggleWindows = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[++i];\n      var pts = this.getPts(i);\n      this.flushDisplayed(pts, service);\n      for (var winId = 0; winId < 8; winId++) {\n        if (b & 0x01 << winId) {\n          service.windows[winId].visible ^= 1;\n        }\n      }\n      return i;\n    };\n    /**\n     * Parse and execute the CLW command.\n     *\n     * Clear text of windows based on the parsed bitmask.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.clearWindows = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[++i];\n      var pts = this.getPts(i);\n      this.flushDisplayed(pts, service);\n      for (var winId = 0; winId < 8; winId++) {\n        if (b & 0x01 << winId) {\n          service.windows[winId].clearText();\n        }\n      }\n      return i;\n    };\n    /**\n     * Parse and execute the DLW command.\n     *\n     * Re-initialize windows based on the parsed bitmask.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.deleteWindows = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[++i];\n      var pts = this.getPts(i);\n      this.flushDisplayed(pts, service);\n      for (var winId = 0; winId < 8; winId++) {\n        if (b & 0x01 << winId) {\n          service.windows[winId].reset();\n        }\n      }\n      return i;\n    };\n    /**\n     * Parse and execute the SPA command.\n     *\n     * Set pen attributes of the current window.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.setPenAttributes = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[i];\n      var penAttr = service.currentWindow.penAttr;\n      b = packetData[++i];\n      penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n      penAttr.offset = (b & 0x0c) >> 2; // o\n\n      penAttr.penSize = b & 0x03; // s\n\n      b = packetData[++i];\n      penAttr.italics = (b & 0x80) >> 7; // i\n\n      penAttr.underline = (b & 0x40) >> 6; // u\n\n      penAttr.edgeType = (b & 0x38) >> 3; // et\n\n      penAttr.fontStyle = b & 0x07; // fs\n\n      return i;\n    };\n    /**\n     * Parse and execute the SPC command.\n     *\n     * Set pen color of the current window.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.setPenColor = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[i];\n      var penColor = service.currentWindow.penColor;\n      b = packetData[++i];\n      penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n      penColor.fgRed = (b & 0x30) >> 4; // fr\n\n      penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n      penColor.fgBlue = b & 0x03; // fb\n\n      b = packetData[++i];\n      penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n      penColor.bgRed = (b & 0x30) >> 4; // br\n\n      penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n      penColor.bgBlue = b & 0x03; // bb\n\n      b = packetData[++i];\n      penColor.edgeRed = (b & 0x30) >> 4; // er\n\n      penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n      penColor.edgeBlue = b & 0x03; // eb\n\n      return i;\n    };\n    /**\n     * Parse and execute the SPL command.\n     *\n     * Set pen location of the current window.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Integer}          New index after parsing\n     */\n\n    Cea708Stream.prototype.setPenLocation = function (i, service) {\n      var packetData = this.current708Packet.data;\n      var b = packetData[i];\n      var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n      service.currentWindow.pendingNewLine = true;\n      b = packetData[++i];\n      penLoc.row = b & 0x0f; // r\n\n      b = packetData[++i];\n      penLoc.column = b & 0x3f; // c\n\n      return i;\n    };\n    /**\n     * Execute the RST command.\n     *\n     * Reset service to a clean slate. Re-initialize.\n     *\n     * @param  {Integer} i        Current index in the 708 packet\n     * @param  {Service} service  The service object to be affected\n     * @return {Service}          Re-initialized service\n     */\n\n    Cea708Stream.prototype.reset = function (i, service) {\n      var pts = this.getPts(i);\n      this.flushDisplayed(pts, service);\n      return this.initService(service.serviceNum, i);\n    }; // This hash maps non-ASCII, special, and extended character codes to their\n    // proper Unicode equivalent. The first keys that are only a single byte\n    // are the non-standard ASCII characters, which simply map the CEA608 byte\n    // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n    // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n    // can be performed regardless of the field and data channel on which the\n    // character code was received.\n\n    var CHARACTER_TRANSLATION = {\n      0x2a: 0xe1,\n      // \n      0x5c: 0xe9,\n      // \n      0x5e: 0xed,\n      // \n      0x5f: 0xf3,\n      // \n      0x60: 0xfa,\n      // \n      0x7b: 0xe7,\n      // \n      0x7c: 0xf7,\n      // \n      0x7d: 0xd1,\n      // \n      0x7e: 0xf1,\n      // \n      0x7f: 0x2588,\n      // \n      0x0130: 0xae,\n      // \n      0x0131: 0xb0,\n      // \n      0x0132: 0xbd,\n      // \n      0x0133: 0xbf,\n      // \n      0x0134: 0x2122,\n      // \n      0x0135: 0xa2,\n      // \n      0x0136: 0xa3,\n      // \n      0x0137: 0x266a,\n      // \n      0x0138: 0xe0,\n      // \n      0x0139: 0xa0,\n      //\n      0x013a: 0xe8,\n      // \n      0x013b: 0xe2,\n      // \n      0x013c: 0xea,\n      // \n      0x013d: 0xee,\n      // \n      0x013e: 0xf4,\n      // \n      0x013f: 0xfb,\n      // \n      0x0220: 0xc1,\n      // \n      0x0221: 0xc9,\n      // \n      0x0222: 0xd3,\n      // \n      0x0223: 0xda,\n      // \n      0x0224: 0xdc,\n      // \n      0x0225: 0xfc,\n      // \n      0x0226: 0x2018,\n      // \n      0x0227: 0xa1,\n      // \n      0x0228: 0x2a,\n      // *\n      0x0229: 0x27,\n      // '\n      0x022a: 0x2014,\n      // \n      0x022b: 0xa9,\n      // \n      0x022c: 0x2120,\n      // \n      0x022d: 0x2022,\n      // \n      0x022e: 0x201c,\n      // \n      0x022f: 0x201d,\n      // \n      0x0230: 0xc0,\n      // \n      0x0231: 0xc2,\n      // \n      0x0232: 0xc7,\n      // \n      0x0233: 0xc8,\n      // \n      0x0234: 0xca,\n      // \n      0x0235: 0xcb,\n      // \n      0x0236: 0xeb,\n      // \n      0x0237: 0xce,\n      // \n      0x0238: 0xcf,\n      // \n      0x0239: 0xef,\n      // \n      0x023a: 0xd4,\n      // \n      0x023b: 0xd9,\n      // \n      0x023c: 0xf9,\n      // \n      0x023d: 0xdb,\n      // \n      0x023e: 0xab,\n      // \n      0x023f: 0xbb,\n      // \n      0x0320: 0xc3,\n      // \n      0x0321: 0xe3,\n      // \n      0x0322: 0xcd,\n      // \n      0x0323: 0xcc,\n      // \n      0x0324: 0xec,\n      // \n      0x0325: 0xd2,\n      // \n      0x0326: 0xf2,\n      // \n      0x0327: 0xd5,\n      // \n      0x0328: 0xf5,\n      // \n      0x0329: 0x7b,\n      // {\n      0x032a: 0x7d,\n      // }\n      0x032b: 0x5c,\n      // \\\n      0x032c: 0x5e,\n      // ^\n      0x032d: 0x5f,\n      // _\n      0x032e: 0x7c,\n      // |\n      0x032f: 0x7e,\n      // ~\n      0x0330: 0xc4,\n      // \n      0x0331: 0xe4,\n      // \n      0x0332: 0xd6,\n      // \n      0x0333: 0xf6,\n      // \n      0x0334: 0xdf,\n      // \n      0x0335: 0xa5,\n      // \n      0x0336: 0xa4,\n      // \n      0x0337: 0x2502,\n      // \n      0x0338: 0xc5,\n      // \n      0x0339: 0xe5,\n      // \n      0x033a: 0xd8,\n      // \n      0x033b: 0xf8,\n      // \n      0x033c: 0x250c,\n      // \n      0x033d: 0x2510,\n      // \n      0x033e: 0x2514,\n      // \n      0x033f: 0x2518 // \n    };\n\n    var getCharFromCode = function (code) {\n      if (code === null) {\n        return '';\n      }\n      code = CHARACTER_TRANSLATION[code] || code;\n      return String.fromCharCode(code);\n    }; // the index of the last row in a CEA-608 display buffer\n\n    var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n    // getting it through bit logic.\n\n    var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n    // cells. The \"bottom\" row is the last element in the outer array.\n\n    var createDisplayBuffer = function () {\n      var result = [],\n        i = BOTTOM_ROW + 1;\n      while (i--) {\n        result.push('');\n      }\n      return result;\n    };\n    var Cea608Stream = function (field, dataChannel) {\n      Cea608Stream.prototype.init.call(this);\n      this.field_ = field || 0;\n      this.dataChannel_ = dataChannel || 0;\n      this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n      this.setConstants();\n      this.reset();\n      this.push = function (packet) {\n        var data, swap, char0, char1, text; // remove the parity bits\n\n        data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n        if (data === this.lastControlCode_) {\n          this.lastControlCode_ = null;\n          return;\n        } // Store control codes\n\n        if ((data & 0xf000) === 0x1000) {\n          this.lastControlCode_ = data;\n        } else if (data !== this.PADDING_) {\n          this.lastControlCode_ = null;\n        }\n        char0 = data >>> 8;\n        char1 = data & 0xff;\n        if (data === this.PADDING_) {\n          return;\n        } else if (data === this.RESUME_CAPTION_LOADING_) {\n          this.mode_ = 'popOn';\n        } else if (data === this.END_OF_CAPTION_) {\n          // If an EOC is received while in paint-on mode, the displayed caption\n          // text should be swapped to non-displayed memory as if it was a pop-on\n          // caption. Because of that, we should explicitly switch back to pop-on\n          // mode\n          this.mode_ = 'popOn';\n          this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n          this.flushDisplayed(packet.pts); // flip memory\n\n          swap = this.displayed_;\n          this.displayed_ = this.nonDisplayed_;\n          this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n          this.startPts_ = packet.pts;\n        } else if (data === this.ROLL_UP_2_ROWS_) {\n          this.rollUpRows_ = 2;\n          this.setRollUp(packet.pts);\n        } else if (data === this.ROLL_UP_3_ROWS_) {\n          this.rollUpRows_ = 3;\n          this.setRollUp(packet.pts);\n        } else if (data === this.ROLL_UP_4_ROWS_) {\n          this.rollUpRows_ = 4;\n          this.setRollUp(packet.pts);\n        } else if (data === this.CARRIAGE_RETURN_) {\n          this.clearFormatting(packet.pts);\n          this.flushDisplayed(packet.pts);\n          this.shiftRowsUp_();\n          this.startPts_ = packet.pts;\n        } else if (data === this.BACKSPACE_) {\n          if (this.mode_ === 'popOn') {\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n          } else {\n            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n          }\n        } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n          this.flushDisplayed(packet.pts);\n          this.displayed_ = createDisplayBuffer();\n        } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n          this.nonDisplayed_ = createDisplayBuffer();\n        } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n          if (this.mode_ !== 'paintOn') {\n            // NOTE: This should be removed when proper caption positioning is\n            // implemented\n            this.flushDisplayed(packet.pts);\n            this.displayed_ = createDisplayBuffer();\n          }\n          this.mode_ = 'paintOn';\n          this.startPts_ = packet.pts; // Append special characters to caption text\n        } else if (this.isSpecialCharacter(char0, char1)) {\n          // Bitmask char0 so that we can apply character transformations\n          // regardless of field and data channel.\n          // Then byte-shift to the left and OR with char1 so we can pass the\n          // entire character code to `getCharFromCode`.\n          char0 = (char0 & 0x03) << 8;\n          text = getCharFromCode(char0 | char1);\n          this[this.mode_](packet.pts, text);\n          this.column_++; // Append extended characters to caption text\n        } else if (this.isExtCharacter(char0, char1)) {\n          // Extended characters always follow their \"non-extended\" equivalents.\n          // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n          // decoders are supposed to drop the \"\", while compliant decoders\n          // backspace the \"e\" and insert \"\".\n          // Delete the previous character\n          if (this.mode_ === 'popOn') {\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n          } else {\n            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n          } // Bitmask char0 so that we can apply character transformations\n          // regardless of field and data channel.\n          // Then byte-shift to the left and OR with char1 so we can pass the\n          // entire character code to `getCharFromCode`.\n\n          char0 = (char0 & 0x03) << 8;\n          text = getCharFromCode(char0 | char1);\n          this[this.mode_](packet.pts, text);\n          this.column_++; // Process mid-row codes\n        } else if (this.isMidRowCode(char0, char1)) {\n          // Attributes are not additive, so clear all formatting\n          this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n          // should be replaced with spaces, so add one now\n\n          this[this.mode_](packet.pts, ' ');\n          this.column_++;\n          if ((char1 & 0xe) === 0xe) {\n            this.addFormatting(packet.pts, ['i']);\n          }\n          if ((char1 & 0x1) === 0x1) {\n            this.addFormatting(packet.pts, ['u']);\n          } // Detect offset control codes and adjust cursor\n        } else if (this.isOffsetControlCode(char0, char1)) {\n          // Cursor position is set by indent PAC (see below) in 4-column\n          // increments, with an additional offset code of 1-3 to reach any\n          // of the 32 columns specified by CEA-608. So all we need to do\n          // here is increment the column cursor by the given offset.\n          this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n        } else if (this.isPAC(char0, char1)) {\n          // There's no logic for PAC -> row mapping, so we have to just\n          // find the row code in an array and use its index :(\n          var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n          if (this.mode_ === 'rollUp') {\n            // This implies that the base row is incorrectly set.\n            // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n            // of roll-up rows set.\n            if (row - this.rollUpRows_ + 1 < 0) {\n              row = this.rollUpRows_ - 1;\n            }\n            this.setRollUp(packet.pts, row);\n          }\n          if (row !== this.row_) {\n            // formatting is only persistent for current row\n            this.clearFormatting(packet.pts);\n            this.row_ = row;\n          } // All PACs can apply underline, so detect and apply\n          // (All odd-numbered second bytes set underline)\n\n          if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n            this.addFormatting(packet.pts, ['u']);\n          }\n          if ((data & 0x10) === 0x10) {\n            // We've got an indent level code. Each successive even number\n            // increments the column cursor by 4, so we can get the desired\n            // column position by bit-shifting to the right (to get n/2)\n            // and multiplying by 4.\n            this.column_ = ((data & 0xe) >> 1) * 4;\n          }\n          if (this.isColorPAC(char1)) {\n            // it's a color code, though we only support white, which\n            // can be either normal or italicized. white italics can be\n            // either 0x4e or 0x6e depending on the row, so we just\n            // bitwise-and with 0xe to see if italics should be turned on\n            if ((char1 & 0xe) === 0xe) {\n              this.addFormatting(packet.pts, ['i']);\n            }\n          } // We have a normal character in char0, and possibly one in char1\n        } else if (this.isNormalChar(char0)) {\n          if (char1 === 0x00) {\n            char1 = null;\n          }\n          text = getCharFromCode(char0);\n          text += getCharFromCode(char1);\n          this[this.mode_](packet.pts, text);\n          this.column_ += text.length;\n        } // finish data processing\n      };\n    };\n\n    Cea608Stream.prototype = new Stream$7(); // Trigger a cue point that captures the current state of the\n    // display buffer\n\n    Cea608Stream.prototype.flushDisplayed = function (pts) {\n      var content = this.displayed_ // remove spaces from the start and end of the string\n      .map(function (row, index) {\n        try {\n          return row.trim();\n        } catch (e) {\n          // Ordinarily, this shouldn't happen. However, caption\n          // parsing errors should not throw exceptions and\n          // break playback.\n          this.trigger('log', {\n            level: 'warn',\n            message: 'Skipping a malformed 608 caption at index ' + index + '.'\n          });\n          return '';\n        }\n      }, this) // combine all text rows to display in one cue\n      .join('\\n') // and remove blank rows from the start and end, but not the middle\n      .replace(/^\\n+|\\n+$/g, '');\n      if (content.length) {\n        this.trigger('data', {\n          startPts: this.startPts_,\n          endPts: pts,\n          text: content,\n          stream: this.name_\n        });\n      }\n    };\n    /**\n     * Zero out the data, used for startup and on seek\n     */\n\n    Cea608Stream.prototype.reset = function () {\n      this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n      // actually display captions. If a caption is shifted to a row\n      // with a lower index than this, it is cleared from the display\n      // buffer\n\n      this.topRow_ = 0;\n      this.startPts_ = 0;\n      this.displayed_ = createDisplayBuffer();\n      this.nonDisplayed_ = createDisplayBuffer();\n      this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n      this.column_ = 0;\n      this.row_ = BOTTOM_ROW;\n      this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n      this.formatting_ = [];\n    };\n    /**\n     * Sets up control code and related constants for this instance\n     */\n\n    Cea608Stream.prototype.setConstants = function () {\n      // The following attributes have these uses:\n      // ext_ :    char0 for mid-row codes, and the base for extended\n      //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n      //           extended codes)\n      // control_: char0 for control codes, except byte-shifted to the\n      //           left so that we can do this.control_ | CONTROL_CODE\n      // offset_:  char0 for tab offset codes\n      //\n      // It's also worth noting that control codes, and _only_ control codes,\n      // differ between field 1 and field2. Field 2 control codes are always\n      // their field 1 value plus 1. That's why there's the \"| field\" on the\n      // control value.\n      if (this.dataChannel_ === 0) {\n        this.BASE_ = 0x10;\n        this.EXT_ = 0x11;\n        this.CONTROL_ = (0x14 | this.field_) << 8;\n        this.OFFSET_ = 0x17;\n      } else if (this.dataChannel_ === 1) {\n        this.BASE_ = 0x18;\n        this.EXT_ = 0x19;\n        this.CONTROL_ = (0x1c | this.field_) << 8;\n        this.OFFSET_ = 0x1f;\n      } // Constants for the LSByte command codes recognized by Cea608Stream. This\n      // list is not exhaustive. For a more comprehensive listing and semantics see\n      // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n      // Padding\n\n      this.PADDING_ = 0x0000; // Pop-on Mode\n\n      this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n      this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n      this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n      this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n      this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n      this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n      this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n      this.BACKSPACE_ = this.CONTROL_ | 0x21;\n      this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n      this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n    };\n    /**\n     * Detects if the 2-byte packet data is a special character\n     *\n     * Special characters have a second byte in the range 0x30 to 0x3f,\n     * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n     * data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an special character\n     */\n\n    Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n      return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n    };\n    /**\n     * Detects if the 2-byte packet data is an extended character\n     *\n     * Extended characters have a second byte in the range 0x20 to 0x3f,\n     * with the first byte being 0x12 or 0x13 (for data channel 1) or\n     * 0x1a or 0x1b (for data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an extended character\n     */\n\n    Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n      return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n    };\n    /**\n     * Detects if the 2-byte packet is a mid-row code\n     *\n     * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n     * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n     * channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are a mid-row code\n     */\n\n    Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n      return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n    };\n    /**\n     * Detects if the 2-byte packet is an offset control code\n     *\n     * Offset control codes have a second byte in the range 0x21 to 0x23,\n     * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n     * data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an offset control code\n     */\n\n    Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n      return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n    };\n    /**\n     * Detects if the 2-byte packet is a Preamble Address Code\n     *\n     * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n     * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n     * range 0x40 to 0x7f.\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are a PAC\n     */\n\n    Cea608Stream.prototype.isPAC = function (char0, char1) {\n      return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n    };\n    /**\n     * Detects if a packet's second byte is in the range of a PAC color code\n     *\n     * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n     * 0x60 to 0x6f.\n     *\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the byte is a color PAC\n     */\n\n    Cea608Stream.prototype.isColorPAC = function (char1) {\n      return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n    };\n    /**\n     * Detects if a single byte is in the range of a normal character\n     *\n     * Normal text bytes are in the range 0x20 to 0x7f.\n     *\n     * @param  {Integer} char  The byte\n     * @return {Boolean}       Whether the byte is a normal character\n     */\n\n    Cea608Stream.prototype.isNormalChar = function (char) {\n      return char >= 0x20 && char <= 0x7f;\n    };\n    /**\n     * Configures roll-up\n     *\n     * @param  {Integer} pts         Current PTS\n     * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n     *                               a new position\n     */\n\n    Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n      // Reset the base row to the bottom row when switching modes\n      if (this.mode_ !== 'rollUp') {\n        this.row_ = BOTTOM_ROW;\n        this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n        this.flushDisplayed(pts);\n        this.nonDisplayed_ = createDisplayBuffer();\n        this.displayed_ = createDisplayBuffer();\n      }\n      if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n        // move currently displayed captions (up or down) to the new base row\n        for (var i = 0; i < this.rollUpRows_; i++) {\n          this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n          this.displayed_[this.row_ - i] = '';\n        }\n      }\n      if (newBaseRow === undefined) {\n        newBaseRow = this.row_;\n      }\n      this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n    }; // Adds the opening HTML tag for the passed character to the caption text,\n    // and keeps track of it for later closing\n\n    Cea608Stream.prototype.addFormatting = function (pts, format) {\n      this.formatting_ = this.formatting_.concat(format);\n      var text = format.reduce(function (text, format) {\n        return text + '<' + format + '>';\n      }, '');\n      this[this.mode_](pts, text);\n    }; // Adds HTML closing tags for current formatting to caption text and\n    // clears remembered formatting\n\n    Cea608Stream.prototype.clearFormatting = function (pts) {\n      if (!this.formatting_.length) {\n        return;\n      }\n      var text = this.formatting_.reverse().reduce(function (text, format) {\n        return text + '</' + format + '>';\n      }, '');\n      this.formatting_ = [];\n      this[this.mode_](pts, text);\n    }; // Mode Implementations\n\n    Cea608Stream.prototype.popOn = function (pts, text) {\n      var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n      baseRow += text;\n      this.nonDisplayed_[this.row_] = baseRow;\n    };\n    Cea608Stream.prototype.rollUp = function (pts, text) {\n      var baseRow = this.displayed_[this.row_];\n      baseRow += text;\n      this.displayed_[this.row_] = baseRow;\n    };\n    Cea608Stream.prototype.shiftRowsUp_ = function () {\n      var i; // clear out inactive rows\n\n      for (i = 0; i < this.topRow_; i++) {\n        this.displayed_[i] = '';\n      }\n      for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n        this.displayed_[i] = '';\n      } // shift displayed rows up\n\n      for (i = this.topRow_; i < this.row_; i++) {\n        this.displayed_[i] = this.displayed_[i + 1];\n      } // clear out the bottom row\n\n      this.displayed_[this.row_] = '';\n    };\n    Cea608Stream.prototype.paintOn = function (pts, text) {\n      var baseRow = this.displayed_[this.row_];\n      baseRow += text;\n      this.displayed_[this.row_] = baseRow;\n    }; // exports\n\n    var captionStream = {\n      CaptionStream: CaptionStream$2,\n      Cea608Stream: Cea608Stream,\n      Cea708Stream: Cea708Stream\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var streamTypes = {\n      H264_STREAM_TYPE: 0x1B,\n      ADTS_STREAM_TYPE: 0x0F,\n      METADATA_STREAM_TYPE: 0x15\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Accepts program elementary stream (PES) data events and corrects\n     * decode and presentation time stamps to account for a rollover\n     * of the 33 bit value.\n     */\n\n    var Stream$6 = stream;\n    var MAX_TS = 8589934592;\n    var RO_THRESH = 4294967296;\n    var TYPE_SHARED = 'shared';\n    var handleRollover$1 = function (value, reference) {\n      var direction = 1;\n      if (value > reference) {\n        // If the current timestamp value is greater than our reference timestamp and we detect a\n        // timestamp rollover, this means the roll over is happening in the opposite direction.\n        // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n        // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n        // rollover point. In loading this segment, the timestamp values will be very large,\n        // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n        // the time stamp to be `value - 2^33`.\n        direction = -1;\n      } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n      // cause an incorrect adjustment.\n\n      while (Math.abs(reference - value) > RO_THRESH) {\n        value += direction * MAX_TS;\n      }\n      return value;\n    };\n    var TimestampRolloverStream$1 = function (type) {\n      var lastDTS, referenceDTS;\n      TimestampRolloverStream$1.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n      // video and audio. We could use `undefined` here, but having a string\n      // makes debugging a little clearer.\n\n      this.type_ = type || TYPE_SHARED;\n      this.push = function (data) {\n        // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n        // streams will only accept data that matches their type.\n        if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n          return;\n        }\n        if (referenceDTS === undefined) {\n          referenceDTS = data.dts;\n        }\n        data.dts = handleRollover$1(data.dts, referenceDTS);\n        data.pts = handleRollover$1(data.pts, referenceDTS);\n        lastDTS = data.dts;\n        this.trigger('data', data);\n      };\n      this.flush = function () {\n        referenceDTS = lastDTS;\n        this.trigger('done');\n      };\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline');\n      };\n      this.discontinuity = function () {\n        referenceDTS = void 0;\n        lastDTS = void 0;\n      };\n      this.reset = function () {\n        this.discontinuity();\n        this.trigger('reset');\n      };\n    };\n    TimestampRolloverStream$1.prototype = new Stream$6();\n    var timestampRolloverStream = {\n      TimestampRolloverStream: TimestampRolloverStream$1,\n      handleRollover: handleRollover$1\n    }; // Once IE11 support is dropped, this function should be removed.\n\n    var typedArrayIndexOf$1 = (typedArray, element, fromIndex) => {\n      if (!typedArray) {\n        return -1;\n      }\n      var currentIndex = fromIndex;\n      for (; currentIndex < typedArray.length; currentIndex++) {\n        if (typedArray[currentIndex] === element) {\n          return currentIndex;\n        }\n      }\n      return -1;\n    };\n    var typedArray = {\n      typedArrayIndexOf: typedArrayIndexOf$1\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Accepts program elementary stream (PES) data events and parses out\n     * ID3 metadata from them, if present.\n     * @see http://id3.org/id3v2.3.0\n     */\n\n    var Stream$5 = stream,\n      StreamTypes$3 = streamTypes,\n      typedArrayIndexOf = typedArray.typedArrayIndexOf,\n      // Frames that allow different types of text encoding contain a text\n      // encoding description byte [ID3v2.4.0 section 4.]\n      textEncodingDescriptionByte = {\n        Iso88591: 0x00,\n        // ISO-8859-1, terminated with \\0.\n        Utf16: 0x01,\n        // UTF-16 encoded Unicode BOM, terminated with \\0\\0\n        Utf16be: 0x02,\n        // UTF-16BE encoded Unicode, without BOM, terminated with \\0\\0\n        Utf8: 0x03 // UTF-8 encoded Unicode, terminated with \\0\n      },\n      // return a percent-encoded representation of the specified byte range\n      // @see http://en.wikipedia.org/wiki/Percent-encoding\n      percentEncode$1 = function (bytes, start, end) {\n        var i,\n          result = '';\n        for (i = start; i < end; i++) {\n          result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n        }\n        return result;\n      },\n      // return the string representation of the specified byte range,\n      // interpreted as UTf-8.\n      parseUtf8 = function (bytes, start, end) {\n        return decodeURIComponent(percentEncode$1(bytes, start, end));\n      },\n      // return the string representation of the specified byte range,\n      // interpreted as ISO-8859-1.\n      parseIso88591$1 = function (bytes, start, end) {\n        return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n      },\n      parseSyncSafeInteger$1 = function (data) {\n        return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n      },\n      frameParsers = {\n        'APIC': function (frame) {\n          var i = 1,\n            mimeTypeEndIndex,\n            descriptionEndIndex,\n            LINK_MIME_TYPE = '-->';\n          if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n            // ignore frames with unrecognized character encodings\n            return;\n          } // parsing fields [ID3v2.4.0 section 4.14.]\n\n          mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);\n          if (mimeTypeEndIndex < 0) {\n            // malformed frame\n            return;\n          } // parsing Mime type field (terminated with \\0)\n\n          frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);\n          i = mimeTypeEndIndex + 1; // parsing 1-byte Picture Type field\n\n          frame.pictureType = frame.data[i];\n          i++;\n          descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);\n          if (descriptionEndIndex < 0) {\n            // malformed frame\n            return;\n          } // parsing Description field (terminated with \\0)\n\n          frame.description = parseUtf8(frame.data, i, descriptionEndIndex);\n          i = descriptionEndIndex + 1;\n          if (frame.mimeType === LINK_MIME_TYPE) {\n            // parsing Picture Data field as URL (always represented as ISO-8859-1 [ID3v2.4.0 section 4.])\n            frame.url = parseIso88591$1(frame.data, i, frame.data.length);\n          } else {\n            // parsing Picture Data field as binary data\n            frame.pictureData = frame.data.subarray(i, frame.data.length);\n          }\n        },\n        'T*': function (frame) {\n          if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n            // ignore frames with unrecognized character encodings\n            return;\n          } // parse text field, do not include null terminator in the frame value\n          // frames that allow different types of encoding contain terminated text [ID3v2.4.0 section 4.]\n\n          frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\\0*$/, ''); // text information frames supports multiple strings, stored as a terminator separated list [ID3v2.4.0 section 4.2.]\n\n          frame.values = frame.value.split('\\0');\n        },\n        'TXXX': function (frame) {\n          var descriptionEndIndex;\n          if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n            // ignore frames with unrecognized character encodings\n            return;\n          }\n          descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n          if (descriptionEndIndex === -1) {\n            return;\n          } // parse the text fields\n\n          frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // do not include the null terminator in the tag value\n          // frames that allow different types of encoding contain terminated text\n          // [ID3v2.4.0 section 4.]\n\n          frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0*$/, '');\n          frame.data = frame.value;\n        },\n        'W*': function (frame) {\n          // parse URL field; URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n          // if the value is followed by a string termination all the following information should be ignored [ID3v2.4.0 section 4.3]\n          frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\\0.*$/, '');\n        },\n        'WXXX': function (frame) {\n          var descriptionEndIndex;\n          if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n            // ignore frames with unrecognized character encodings\n            return;\n          }\n          descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n          if (descriptionEndIndex === -1) {\n            return;\n          } // parse the description and URL fields\n\n          frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n          // if the value is followed by a string termination all the following information\n          // should be ignored [ID3v2.4.0 section 4.3]\n\n          frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0.*$/, '');\n        },\n        'PRIV': function (frame) {\n          var i;\n          for (i = 0; i < frame.data.length; i++) {\n            if (frame.data[i] === 0) {\n              // parse the description and URL fields\n              frame.owner = parseIso88591$1(frame.data, 0, i);\n              break;\n            }\n          }\n          frame.privateData = frame.data.subarray(i + 1);\n          frame.data = frame.privateData;\n        }\n      },\n      MetadataStream;\n    MetadataStream = function (options) {\n      var settings = {\n          // the bytes of the program-level descriptor field in MP2T\n          // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n          // program element descriptors\"\n          descriptor: options && options.descriptor\n        },\n        // the total size in bytes of the ID3 tag being parsed\n        tagSize = 0,\n        // tag data that is not complete enough to be parsed\n        buffer = [],\n        // the total number of bytes currently in the buffer\n        bufferSize = 0,\n        i;\n      MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n      // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n      this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);\n      if (settings.descriptor) {\n        for (i = 0; i < settings.descriptor.length; i++) {\n          this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n        }\n      }\n      this.push = function (chunk) {\n        var tag, frameStart, frameSize, frame, i, frameHeader;\n        if (chunk.type !== 'timed-metadata') {\n          return;\n        } // if data_alignment_indicator is set in the PES header,\n        // we must have the start of a new ID3 tag. Assume anything\n        // remaining in the buffer was malformed and throw it out\n\n        if (chunk.dataAlignmentIndicator) {\n          bufferSize = 0;\n          buffer.length = 0;\n        } // ignore events that don't look like ID3 data\n\n        if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n          this.trigger('log', {\n            level: 'warn',\n            message: 'Skipping unrecognized metadata packet'\n          });\n          return;\n        } // add this chunk to the data we've collected so far\n\n        buffer.push(chunk);\n        bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n        if (buffer.length === 1) {\n          // the frame size is transmitted as a 28-bit integer in the\n          // last four bytes of the ID3 header.\n          // The most significant bit of each byte is dropped and the\n          // results concatenated to recover the actual value.\n          tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n          // convenient for our comparisons to include it\n\n          tagSize += 10;\n        } // if the entire frame has not arrived, wait for more data\n\n        if (bufferSize < tagSize) {\n          return;\n        } // collect the entire frame so it can be parsed\n\n        tag = {\n          data: new Uint8Array(tagSize),\n          frames: [],\n          pts: buffer[0].pts,\n          dts: buffer[0].dts\n        };\n        for (i = 0; i < tagSize;) {\n          tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n          i += buffer[0].data.byteLength;\n          bufferSize -= buffer[0].data.byteLength;\n          buffer.shift();\n        } // find the start of the first frame and the end of the tag\n\n        frameStart = 10;\n        if (tag.data[5] & 0x40) {\n          // advance the frame start past the extended header\n          frameStart += 4; // header size field\n\n          frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14)); // clip any padding off the end\n\n          tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));\n        } // parse one or more ID3 frames\n        // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n        do {\n          // determine the number of bytes in this frame\n          frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));\n          if (frameSize < 1) {\n            this.trigger('log', {\n              level: 'warn',\n              message: 'Malformed ID3 frame encountered. Skipping remaining metadata parsing.'\n            }); // If the frame is malformed, don't parse any further frames but allow previous valid parsed frames\n            // to be sent along.\n\n            break;\n          }\n          frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n          frame = {\n            id: frameHeader,\n            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n          };\n          frame.key = frame.id; // parse frame values\n\n          if (frameParsers[frame.id]) {\n            // use frame specific parser\n            frameParsers[frame.id](frame);\n          } else if (frame.id[0] === 'T') {\n            // use text frame generic parser\n            frameParsers['T*'](frame);\n          } else if (frame.id[0] === 'W') {\n            // use URL link frame generic parser\n            frameParsers['W*'](frame);\n          } // handle the special PRIV frame used to indicate the start\n          // time for raw AAC data\n\n          if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.data,\n              size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n            size *= 4;\n            size += d[7] & 0x03;\n            frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n            // on the value of this frame\n            // we couldn't have known the appropriate pts and dts before\n            // parsing this ID3 tag so set those values now\n\n            if (tag.pts === undefined && tag.dts === undefined) {\n              tag.pts = frame.timeStamp;\n              tag.dts = frame.timeStamp;\n            }\n            this.trigger('timestamp', frame);\n          }\n          tag.frames.push(frame);\n          frameStart += 10; // advance past the frame header\n\n          frameStart += frameSize; // advance past the frame body\n        } while (frameStart < tagSize);\n        this.trigger('data', tag);\n      };\n    };\n    MetadataStream.prototype = new Stream$5();\n    var metadataStream = MetadataStream;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * A stream-based mp2t to mp4 converter. This utility can be used to\n     * deliver mp4s to a SourceBuffer on platforms that support native\n     * Media Source Extensions.\n     */\n\n    var Stream$4 = stream,\n      CaptionStream$1 = captionStream,\n      StreamTypes$2 = streamTypes,\n      TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\n\n    var TransportPacketStream, TransportParseStream, ElementaryStream; // constants\n\n    var MP2T_PACKET_LENGTH$1 = 188,\n      // bytes\n      SYNC_BYTE$1 = 0x47;\n    /**\n     * Splits an incoming stream of binary data into MPEG-2 Transport\n     * Stream packets.\n     */\n\n    TransportPacketStream = function () {\n      var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\n        bytesInBuffer = 0;\n      TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n      /**\n       * Split a stream of data into M2TS packets\n      **/\n\n      this.push = function (bytes) {\n        var startIndex = 0,\n          endIndex = MP2T_PACKET_LENGTH$1,\n          everything; // If there are bytes remaining from the last segment, prepend them to the\n        // bytes that were pushed in\n\n        if (bytesInBuffer) {\n          everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n          everything.set(buffer.subarray(0, bytesInBuffer));\n          everything.set(bytes, bytesInBuffer);\n          bytesInBuffer = 0;\n        } else {\n          everything = bytes;\n        } // While we have enough data for a packet\n\n        while (endIndex < everything.byteLength) {\n          // Look for a pair of start and end sync bytes in the data..\n          if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\n            // We found a packet so emit it and jump one whole packet forward in\n            // the stream\n            this.trigger('data', everything.subarray(startIndex, endIndex));\n            startIndex += MP2T_PACKET_LENGTH$1;\n            endIndex += MP2T_PACKET_LENGTH$1;\n            continue;\n          } // If we get here, we have somehow become de-synchronized and we need to step\n          // forward one byte at a time until we find a pair of sync bytes that denote\n          // a packet\n\n          startIndex++;\n          endIndex++;\n        } // If there was some data left over at the end of the segment that couldn't\n        // possibly be a whole packet, keep it because it might be the start of a packet\n        // that continues in the next segment\n\n        if (startIndex < everything.byteLength) {\n          buffer.set(everything.subarray(startIndex), 0);\n          bytesInBuffer = everything.byteLength - startIndex;\n        }\n      };\n      /**\n       * Passes identified M2TS packets to the TransportParseStream to be parsed\n      **/\n\n      this.flush = function () {\n        // If the buffer contains a whole packet when we are being flushed, emit it\n        // and empty the buffer. Otherwise hold onto the data because it may be\n        // important for decoding the next segment\n        if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\n          this.trigger('data', buffer);\n          bytesInBuffer = 0;\n        }\n        this.trigger('done');\n      };\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline');\n      };\n      this.reset = function () {\n        bytesInBuffer = 0;\n        this.trigger('reset');\n      };\n    };\n    TransportPacketStream.prototype = new Stream$4();\n    /**\n     * Accepts an MP2T TransportPacketStream and emits data events with parsed\n     * forms of the individual transport stream packets.\n     */\n\n    TransportParseStream = function () {\n      var parsePsi, parsePat, parsePmt, self;\n      TransportParseStream.prototype.init.call(this);\n      self = this;\n      this.packetsWaitingForPmt = [];\n      this.programMapTable = undefined;\n      parsePsi = function (payload, psi) {\n        var offset = 0; // PSI packets may be split into multiple sections and those\n        // sections may be split into multiple packets. If a PSI\n        // section starts in this packet, the payload_unit_start_indicator\n        // will be true and the first byte of the payload will indicate\n        // the offset from the current position to the start of the\n        // section.\n\n        if (psi.payloadUnitStartIndicator) {\n          offset += payload[offset] + 1;\n        }\n        if (psi.type === 'pat') {\n          parsePat(payload.subarray(offset), psi);\n        } else {\n          parsePmt(payload.subarray(offset), psi);\n        }\n      };\n      parsePat = function (payload, pat) {\n        pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n        pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n        // skip the PSI header and parse the first PMT entry\n\n        self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n        pat.pmtPid = self.pmtPid;\n      };\n      /**\n       * Parse out the relevant fields of a Program Map Table (PMT).\n       * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n       * packet. The first byte in this array should be the table_id\n       * field.\n       * @param pmt {object} the object that should be decorated with\n       * fields parsed from the PMT.\n       */\n\n      parsePmt = function (payload, pmt) {\n        var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n        // take effect. We don't believe this should ever be the case\n        // for HLS but we'll ignore \"forward\" PMT declarations if we see\n        // them. Future PMT declarations have the current_next_indicator\n        // set to zero.\n\n        if (!(payload[5] & 0x01)) {\n          return;\n        } // overwrite any existing program map table\n\n        self.programMapTable = {\n          video: null,\n          audio: null,\n          'timed-metadata': {}\n        }; // the mapping table ends at the end of the current section\n\n        sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n        tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n        // long the program info descriptors are\n\n        programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n        offset = 12 + programInfoLength;\n        while (offset < tableEnd) {\n          var streamType = payload[offset];\n          var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n          // TODO: should this be done for metadata too? for now maintain behavior of\n          //       multiple metadata streams\n\n          if (streamType === StreamTypes$2.H264_STREAM_TYPE && self.programMapTable.video === null) {\n            self.programMapTable.video = pid;\n          } else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n            self.programMapTable.audio = pid;\n          } else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) {\n            // map pid to stream type for metadata streams\n            self.programMapTable['timed-metadata'][pid] = streamType;\n          } // move to the next table entry\n          // skip past the elementary stream descriptors, if present\n\n          offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n        } // record the map on the packet as well\n\n        pmt.programMapTable = self.programMapTable;\n      };\n      /**\n       * Deliver a new MP2T packet to the next stream in the pipeline.\n       */\n\n      this.push = function (packet) {\n        var result = {},\n          offset = 4;\n        result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n        result.pid = packet[1] & 0x1f;\n        result.pid <<= 8;\n        result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n        // fifth byte of the TS packet header. The adaptation field is\n        // used to add stuffing to PES packets that don't fill a complete\n        // TS packet, and to specify some forms of timing and control data\n        // that we do not currently use.\n\n        if ((packet[3] & 0x30) >>> 4 > 0x01) {\n          offset += packet[offset] + 1;\n        } // parse the rest of the packet based on the type\n\n        if (result.pid === 0) {\n          result.type = 'pat';\n          parsePsi(packet.subarray(offset), result);\n          this.trigger('data', result);\n        } else if (result.pid === this.pmtPid) {\n          result.type = 'pmt';\n          parsePsi(packet.subarray(offset), result);\n          this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n          while (this.packetsWaitingForPmt.length) {\n            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n          }\n        } else if (this.programMapTable === undefined) {\n          // When we have not seen a PMT yet, defer further processing of\n          // PES packets until one has been parsed\n          this.packetsWaitingForPmt.push([packet, offset, result]);\n        } else {\n          this.processPes_(packet, offset, result);\n        }\n      };\n      this.processPes_ = function (packet, offset, result) {\n        // set the appropriate stream type\n        if (result.pid === this.programMapTable.video) {\n          result.streamType = StreamTypes$2.H264_STREAM_TYPE;\n        } else if (result.pid === this.programMapTable.audio) {\n          result.streamType = StreamTypes$2.ADTS_STREAM_TYPE;\n        } else {\n          // if not video or audio, it is timed-metadata or unknown\n          // if unknown, streamType will be undefined\n          result.streamType = this.programMapTable['timed-metadata'][result.pid];\n        }\n        result.type = 'pes';\n        result.data = packet.subarray(offset);\n        this.trigger('data', result);\n      };\n    };\n    TransportParseStream.prototype = new Stream$4();\n    TransportParseStream.STREAM_TYPES = {\n      h264: 0x1b,\n      adts: 0x0f\n    };\n    /**\n     * Reconsistutes program elementary stream (PES) packets from parsed\n     * transport stream packets. That is, if you pipe an\n     * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n     * events will be events which capture the bytes for individual PES\n     * packets plus relevant metadata that has been extracted from the\n     * container.\n     */\n\n    ElementaryStream = function () {\n      var self = this,\n        segmentHadPmt = false,\n        // PES packet fragments\n        video = {\n          data: [],\n          size: 0\n        },\n        audio = {\n          data: [],\n          size: 0\n        },\n        timedMetadata = {\n          data: [],\n          size: 0\n        },\n        programMapTable,\n        parsePes = function (payload, pes) {\n          var ptsDtsFlags;\n          const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n          pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n          // that are frame data that is continuing from the previous fragment. This\n          // is to check that the pes data is the start of a new pes payload\n\n          if (startPrefix !== 1) {\n            return;\n          } // get the packet length, this will be 0 for video\n\n          pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n          pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n          // and a DTS value. Determine what combination of values is\n          // available to work with.\n\n          ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n          // performs all bitwise operations on 32-bit integers but javascript\n          // supports a much greater range (52-bits) of integer using standard\n          // mathematical operations.\n          // We construct a 31-bit value using bitwise operators over the 31\n          // most significant bits and then multiply by 4 (equal to a left-shift\n          // of 2) before we add the final 2 least significant bits of the\n          // timestamp (equal to an OR.)\n\n          if (ptsDtsFlags & 0xC0) {\n            // the PTS and DTS are not written out directly. For information\n            // on how they are encoded, see\n            // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n            pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n            pes.pts *= 4; // Left shift by 2\n\n            pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n            pes.dts = pes.pts;\n            if (ptsDtsFlags & 0x40) {\n              pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n              pes.dts *= 4; // Left shift by 2\n\n              pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n            }\n          } // the data section starts immediately after the PES header.\n          // pes_header_data_length specifies the number of header bytes\n          // that follow the last byte of the field.\n\n          pes.data = payload.subarray(9 + payload[8]);\n        },\n        /**\n          * Pass completely parsed PES packets to the next stream in the pipeline\n         **/\n        flushStream = function (stream, type, forceFlush) {\n          var packetData = new Uint8Array(stream.size),\n            event = {\n              type: type\n            },\n            i = 0,\n            offset = 0,\n            packetFlushable = false,\n            fragment; // do nothing if there is not enough buffered data for a complete\n          // PES header\n\n          if (!stream.data.length || stream.size < 9) {\n            return;\n          }\n          event.trackId = stream.data[0].pid; // reassemble the packet\n\n          for (i = 0; i < stream.data.length; i++) {\n            fragment = stream.data[i];\n            packetData.set(fragment.data, offset);\n            offset += fragment.data.byteLength;\n          } // parse assembled packet's PES header\n\n          parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n          // check that there is enough stream data to fill the packet\n\n          packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n          if (forceFlush || packetFlushable) {\n            stream.size = 0;\n            stream.data.length = 0;\n          } // only emit packets that are complete. this is to avoid assembling\n          // incomplete PES packets due to poor segmentation\n\n          if (packetFlushable) {\n            self.trigger('data', event);\n          }\n        };\n      ElementaryStream.prototype.init.call(this);\n      /**\n       * Identifies M2TS packet types and parses PES packets using metadata\n       * parsed from the PMT\n       **/\n\n      this.push = function (data) {\n        ({\n          pat: function () {// we have to wait for the PMT to arrive as well before we\n            // have any meaningful metadata\n          },\n          pes: function () {\n            var stream, streamType;\n            switch (data.streamType) {\n              case StreamTypes$2.H264_STREAM_TYPE:\n                stream = video;\n                streamType = 'video';\n                break;\n              case StreamTypes$2.ADTS_STREAM_TYPE:\n                stream = audio;\n                streamType = 'audio';\n                break;\n              case StreamTypes$2.METADATA_STREAM_TYPE:\n                stream = timedMetadata;\n                streamType = 'timed-metadata';\n                break;\n              default:\n                // ignore unknown stream types\n                return;\n            } // if a new packet is starting, we can flush the completed\n            // packet\n\n            if (data.payloadUnitStartIndicator) {\n              flushStream(stream, streamType, true);\n            } // buffer this fragment until we are sure we've received the\n            // complete payload\n\n            stream.data.push(data);\n            stream.size += data.data.byteLength;\n          },\n          pmt: function () {\n            var event = {\n              type: 'metadata',\n              tracks: []\n            };\n            programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n            if (programMapTable.video !== null) {\n              event.tracks.push({\n                timelineStartInfo: {\n                  baseMediaDecodeTime: 0\n                },\n                id: +programMapTable.video,\n                codec: 'avc',\n                type: 'video'\n              });\n            }\n            if (programMapTable.audio !== null) {\n              event.tracks.push({\n                timelineStartInfo: {\n                  baseMediaDecodeTime: 0\n                },\n                id: +programMapTable.audio,\n                codec: 'adts',\n                type: 'audio'\n              });\n            }\n            segmentHadPmt = true;\n            self.trigger('data', event);\n          }\n        })[data.type]();\n      };\n      this.reset = function () {\n        video.size = 0;\n        video.data.length = 0;\n        audio.size = 0;\n        audio.data.length = 0;\n        this.trigger('reset');\n      };\n      /**\n       * Flush any remaining input. Video PES packets may be of variable\n       * length. Normally, the start of a new video packet can trigger the\n       * finalization of the previous packet. That is not possible if no\n       * more video is forthcoming, however. In that case, some other\n       * mechanism (like the end of the file) has to be employed. When it is\n       * clear that no additional data is forthcoming, calling this method\n       * will flush the buffered packets.\n       */\n\n      this.flushStreams_ = function () {\n        // !!THIS ORDER IS IMPORTANT!!\n        // video first then audio\n        flushStream(video, 'video');\n        flushStream(audio, 'audio');\n        flushStream(timedMetadata, 'timed-metadata');\n      };\n      this.flush = function () {\n        // if on flush we haven't had a pmt emitted\n        // and we have a pmt to emit. emit the pmt\n        // so that we trigger a trackinfo downstream.\n        if (!segmentHadPmt && programMapTable) {\n          var pmt = {\n            type: 'metadata',\n            tracks: []\n          }; // translate audio and video streams to tracks\n\n          if (programMapTable.video !== null) {\n            pmt.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.video,\n              codec: 'avc',\n              type: 'video'\n            });\n          }\n          if (programMapTable.audio !== null) {\n            pmt.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.audio,\n              codec: 'adts',\n              type: 'audio'\n            });\n          }\n          self.trigger('data', pmt);\n        }\n        segmentHadPmt = false;\n        this.flushStreams_();\n        this.trigger('done');\n      };\n    };\n    ElementaryStream.prototype = new Stream$4();\n    var m2ts$1 = {\n      PAT_PID: 0x0000,\n      MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\n      TransportPacketStream: TransportPacketStream,\n      TransportParseStream: TransportParseStream,\n      ElementaryStream: ElementaryStream,\n      TimestampRolloverStream: TimestampRolloverStream,\n      CaptionStream: CaptionStream$1.CaptionStream,\n      Cea608Stream: CaptionStream$1.Cea608Stream,\n      Cea708Stream: CaptionStream$1.Cea708Stream,\n      MetadataStream: metadataStream\n    };\n    for (var type in StreamTypes$2) {\n      if (StreamTypes$2.hasOwnProperty(type)) {\n        m2ts$1[type] = StreamTypes$2[type];\n      }\n    }\n    var m2ts_1 = m2ts$1;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var Stream$3 = stream;\n    var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;\n    var AdtsStream$1;\n    var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    /*\n     * Accepts a ElementaryStream and emits data events with parsed\n     * AAC Audio Frames of the individual packets. Input audio in ADTS\n     * format is unpacked and re-emitted as AAC frames.\n     *\n     * @see http://wiki.multimedia.cx/index.php?title=ADTS\n     * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n     */\n\n    AdtsStream$1 = function (handlePartialSegments) {\n      var buffer,\n        frameNum = 0;\n      AdtsStream$1.prototype.init.call(this);\n      this.skipWarn_ = function (start, end) {\n        this.trigger('log', {\n          level: 'warn',\n          message: `adts skiping bytes ${start} to ${end} in frame ${frameNum} outside syncword`\n        });\n      };\n      this.push = function (packet) {\n        var i = 0,\n          frameLength,\n          protectionSkipBytes,\n          oldBuffer,\n          sampleCount,\n          adtsFrameDuration;\n        if (!handlePartialSegments) {\n          frameNum = 0;\n        }\n        if (packet.type !== 'audio') {\n          // ignore non-audio data\n          return;\n        } // Prepend any data in the buffer to the input data so that we can parse\n        // aac frames the cross a PES packet boundary\n\n        if (buffer && buffer.length) {\n          oldBuffer = buffer;\n          buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n          buffer.set(oldBuffer);\n          buffer.set(packet.data, oldBuffer.byteLength);\n        } else {\n          buffer = packet.data;\n        } // unpack any ADTS frames which have been fully received\n        // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n        var skip; // We use i + 7 here because we want to be able to parse the entire header.\n        // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n        while (i + 7 < buffer.length) {\n          // Look for the start of an ADTS header..\n          if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n            if (typeof skip !== 'number') {\n              skip = i;\n            } // If a valid header was not found,  jump one forward and attempt to\n            // find a valid ADTS header starting at the next byte\n\n            i++;\n            continue;\n          }\n          if (typeof skip === 'number') {\n            this.skipWarn_(skip, i);\n            skip = null;\n          } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n          // end of the ADTS header\n\n          protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n          // end of the sync sequence\n          // NOTE: frame length includes the size of the header\n\n          frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n          sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n          adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n          // then we have to wait for more data\n\n          if (buffer.byteLength - i < frameLength) {\n            break;\n          } // Otherwise, deliver the complete AAC frame\n\n          this.trigger('data', {\n            pts: packet.pts + frameNum * adtsFrameDuration,\n            dts: packet.dts + frameNum * adtsFrameDuration,\n            sampleCount: sampleCount,\n            audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n            samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\n            samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n            samplesize: 16,\n            // data is the frame without it's header\n            data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n          });\n          frameNum++;\n          i += frameLength;\n        }\n        if (typeof skip === 'number') {\n          this.skipWarn_(skip, i);\n          skip = null;\n        } // remove processed bytes from the buffer.\n\n        buffer = buffer.subarray(i);\n      };\n      this.flush = function () {\n        frameNum = 0;\n        this.trigger('done');\n      };\n      this.reset = function () {\n        buffer = void 0;\n        this.trigger('reset');\n      };\n      this.endTimeline = function () {\n        buffer = void 0;\n        this.trigger('endedtimeline');\n      };\n    };\n    AdtsStream$1.prototype = new Stream$3();\n    var adts = AdtsStream$1;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var ExpGolomb$1;\n    /**\n     * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n     * scheme used by h264.\n     */\n\n    ExpGolomb$1 = function (workingData) {\n      var\n        // the number of bytes left to examine in workingData\n        workingBytesAvailable = workingData.byteLength,\n        // the current word being examined\n        workingWord = 0,\n        // :uint\n        // the number of bits left to examine in the current word\n        workingBitsAvailable = 0; // :uint;\n      // ():uint\n\n      this.length = function () {\n        return 8 * workingBytesAvailable;\n      }; // ():uint\n\n      this.bitsAvailable = function () {\n        return 8 * workingBytesAvailable + workingBitsAvailable;\n      }; // ():void\n\n      this.loadWord = function () {\n        var position = workingData.byteLength - workingBytesAvailable,\n          workingBytes = new Uint8Array(4),\n          availableBytes = Math.min(4, workingBytesAvailable);\n        if (availableBytes === 0) {\n          throw new Error('no bytes available');\n        }\n        workingBytes.set(workingData.subarray(position, position + availableBytes));\n        workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n        workingBitsAvailable = availableBytes * 8;\n        workingBytesAvailable -= availableBytes;\n      }; // (count:int):void\n\n      this.skipBits = function (count) {\n        var skipBytes; // :int\n\n        if (workingBitsAvailable > count) {\n          workingWord <<= count;\n          workingBitsAvailable -= count;\n        } else {\n          count -= workingBitsAvailable;\n          skipBytes = Math.floor(count / 8);\n          count -= skipBytes * 8;\n          workingBytesAvailable -= skipBytes;\n          this.loadWord();\n          workingWord <<= count;\n          workingBitsAvailable -= count;\n        }\n      }; // (size:int):uint\n\n      this.readBits = function (size) {\n        var bits = Math.min(workingBitsAvailable, size),\n          // :uint\n          valu = workingWord >>> 32 - bits; // :uint\n        // if size > 31, handle error\n\n        workingBitsAvailable -= bits;\n        if (workingBitsAvailable > 0) {\n          workingWord <<= bits;\n        } else if (workingBytesAvailable > 0) {\n          this.loadWord();\n        }\n        bits = size - bits;\n        if (bits > 0) {\n          return valu << bits | this.readBits(bits);\n        }\n        return valu;\n      }; // ():uint\n\n      this.skipLeadingZeros = function () {\n        var leadingZeroCount; // :uint\n\n        for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n          if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n            // the first bit of working word is 1\n            workingWord <<= leadingZeroCount;\n            workingBitsAvailable -= leadingZeroCount;\n            return leadingZeroCount;\n          }\n        } // we exhausted workingWord and still have not found a 1\n\n        this.loadWord();\n        return leadingZeroCount + this.skipLeadingZeros();\n      }; // ():void\n\n      this.skipUnsignedExpGolomb = function () {\n        this.skipBits(1 + this.skipLeadingZeros());\n      }; // ():void\n\n      this.skipExpGolomb = function () {\n        this.skipBits(1 + this.skipLeadingZeros());\n      }; // ():uint\n\n      this.readUnsignedExpGolomb = function () {\n        var clz = this.skipLeadingZeros(); // :uint\n\n        return this.readBits(clz + 1) - 1;\n      }; // ():int\n\n      this.readExpGolomb = function () {\n        var valu = this.readUnsignedExpGolomb(); // :int\n\n        if (0x01 & valu) {\n          // the number is odd if the low order bit is set\n          return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        }\n\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      }; // Some convenience functions\n      // :Boolean\n\n      this.readBoolean = function () {\n        return this.readBits(1) === 1;\n      }; // ():int\n\n      this.readUnsignedByte = function () {\n        return this.readBits(8);\n      };\n      this.loadWord();\n    };\n    var expGolomb = ExpGolomb$1;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var Stream$2 = stream;\n    var ExpGolomb = expGolomb;\n    var H264Stream$1, NalByteStream;\n    var PROFILES_WITH_OPTIONAL_SPS_DATA;\n    /**\n     * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n     */\n\n    NalByteStream = function () {\n      var syncPoint = 0,\n        i,\n        buffer;\n      NalByteStream.prototype.init.call(this);\n      /*\n       * Scans a byte stream and triggers a data event with the NAL units found.\n       * @param {Object} data Event received from H264Stream\n       * @param {Uint8Array} data.data The h264 byte stream to be scanned\n       *\n       * @see H264Stream.push\n       */\n\n      this.push = function (data) {\n        var swapBuffer;\n        if (!buffer) {\n          buffer = data.data;\n        } else {\n          swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n          swapBuffer.set(buffer);\n          swapBuffer.set(data.data, buffer.byteLength);\n          buffer = swapBuffer;\n        }\n        var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n        // scan for NAL unit boundaries\n        // a match looks like this:\n        // 0 0 1 .. NAL .. 0 0 1\n        // ^ sync point        ^ i\n        // or this:\n        // 0 0 1 .. NAL .. 0 0 0\n        // ^ sync point        ^ i\n        // advance the sync point to a NAL start, if necessary\n\n        for (; syncPoint < len - 3; syncPoint++) {\n          if (buffer[syncPoint + 2] === 1) {\n            // the sync point is properly aligned\n            i = syncPoint + 5;\n            break;\n          }\n        }\n        while (i < len) {\n          // look at the current byte to determine if we've hit the end of\n          // a NAL unit boundary\n          switch (buffer[i]) {\n            case 0:\n              // skip past non-sync sequences\n              if (buffer[i - 1] !== 0) {\n                i += 2;\n                break;\n              } else if (buffer[i - 2] !== 0) {\n                i++;\n                break;\n              } // deliver the NAL unit if it isn't empty\n\n              if (syncPoint + 3 !== i - 2) {\n                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n              } // drop trailing zeroes\n\n              do {\n                i++;\n              } while (buffer[i] !== 1 && i < len);\n              syncPoint = i - 2;\n              i += 3;\n              break;\n            case 1:\n              // skip past non-sync sequences\n              if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n                i += 3;\n                break;\n              } // deliver the NAL unit\n\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n              syncPoint = i - 2;\n              i += 3;\n              break;\n            default:\n              // the current byte isn't a one or zero, so it cannot be part\n              // of a sync sequence\n              i += 3;\n              break;\n          }\n        } // filter out the NAL units that were delivered\n\n        buffer = buffer.subarray(syncPoint);\n        i -= syncPoint;\n        syncPoint = 0;\n      };\n      this.reset = function () {\n        buffer = null;\n        syncPoint = 0;\n        this.trigger('reset');\n      };\n      this.flush = function () {\n        // deliver the last buffered NAL unit\n        if (buffer && buffer.byteLength > 3) {\n          this.trigger('data', buffer.subarray(syncPoint + 3));\n        } // reset the stream state\n\n        buffer = null;\n        syncPoint = 0;\n        this.trigger('done');\n      };\n      this.endTimeline = function () {\n        this.flush();\n        this.trigger('endedtimeline');\n      };\n    };\n    NalByteStream.prototype = new Stream$2(); // values of profile_idc that indicate additional fields are included in the SPS\n    // see Recommendation ITU-T H.264 (4/2013),\n    // 7.3.2.1.1 Sequence parameter set data syntax\n\n    PROFILES_WITH_OPTIONAL_SPS_DATA = {\n      100: true,\n      110: true,\n      122: true,\n      244: true,\n      44: true,\n      83: true,\n      86: true,\n      118: true,\n      128: true,\n      // TODO: the three profiles below don't\n      // appear to have sps data in the specificiation anymore?\n      138: true,\n      139: true,\n      134: true\n    };\n    /**\n     * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n     * events.\n     */\n\n    H264Stream$1 = function () {\n      var nalByteStream = new NalByteStream(),\n        self,\n        trackId,\n        currentPts,\n        currentDts,\n        discardEmulationPreventionBytes,\n        readSequenceParameterSet,\n        skipScalingList;\n      H264Stream$1.prototype.init.call(this);\n      self = this;\n      /*\n       * Pushes a packet from a stream onto the NalByteStream\n       *\n       * @param {Object} packet - A packet received from a stream\n       * @param {Uint8Array} packet.data - The raw bytes of the packet\n       * @param {Number} packet.dts - Decode timestamp of the packet\n       * @param {Number} packet.pts - Presentation timestamp of the packet\n       * @param {Number} packet.trackId - The id of the h264 track this packet came from\n       * @param {('video'|'audio')} packet.type - The type of packet\n       *\n       */\n\n      this.push = function (packet) {\n        if (packet.type !== 'video') {\n          return;\n        }\n        trackId = packet.trackId;\n        currentPts = packet.pts;\n        currentDts = packet.dts;\n        nalByteStream.push(packet);\n      };\n      /*\n       * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n       * for the NALUs to the next stream component.\n       * Also, preprocess caption and sequence parameter NALUs.\n       *\n       * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n       * @see NalByteStream.push\n       */\n\n      nalByteStream.on('data', function (data) {\n        var event = {\n          trackId: trackId,\n          pts: currentPts,\n          dts: currentDts,\n          data: data,\n          nalUnitTypeCode: data[0] & 0x1f\n        };\n        switch (event.nalUnitTypeCode) {\n          case 0x05:\n            event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n            break;\n          case 0x06:\n            event.nalUnitType = 'sei_rbsp';\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n            break;\n          case 0x07:\n            event.nalUnitType = 'seq_parameter_set_rbsp';\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n            event.config = readSequenceParameterSet(event.escapedRBSP);\n            break;\n          case 0x08:\n            event.nalUnitType = 'pic_parameter_set_rbsp';\n            break;\n          case 0x09:\n            event.nalUnitType = 'access_unit_delimiter_rbsp';\n            break;\n        } // This triggers data on the H264Stream\n\n        self.trigger('data', event);\n      });\n      nalByteStream.on('done', function () {\n        self.trigger('done');\n      });\n      nalByteStream.on('partialdone', function () {\n        self.trigger('partialdone');\n      });\n      nalByteStream.on('reset', function () {\n        self.trigger('reset');\n      });\n      nalByteStream.on('endedtimeline', function () {\n        self.trigger('endedtimeline');\n      });\n      this.flush = function () {\n        nalByteStream.flush();\n      };\n      this.partialFlush = function () {\n        nalByteStream.partialFlush();\n      };\n      this.reset = function () {\n        nalByteStream.reset();\n      };\n      this.endTimeline = function () {\n        nalByteStream.endTimeline();\n      };\n      /**\n       * Advance the ExpGolomb decoder past a scaling list. The scaling\n       * list is optionally transmitted as part of a sequence parameter\n       * set and is not relevant to transmuxing.\n       * @param count {number} the number of entries in this scaling list\n       * @param expGolombDecoder {object} an ExpGolomb pointed to the\n       * start of a scaling list\n       * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n       */\n\n      skipScalingList = function (count, expGolombDecoder) {\n        var lastScale = 8,\n          nextScale = 8,\n          j,\n          deltaScale;\n        for (j = 0; j < count; j++) {\n          if (nextScale !== 0) {\n            deltaScale = expGolombDecoder.readExpGolomb();\n            nextScale = (lastScale + deltaScale + 256) % 256;\n          }\n          lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n      };\n      /**\n       * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n       * Sequence Payload\"\n       * @param data {Uint8Array} the bytes of a RBSP from a NAL\n       * unit\n       * @return {Uint8Array} the RBSP without any Emulation\n       * Prevention Bytes\n       */\n\n      discardEmulationPreventionBytes = function (data) {\n        var length = data.byteLength,\n          emulationPreventionBytesPositions = [],\n          i = 1,\n          newLength,\n          newData; // Find all `Emulation Prevention Bytes`\n\n        while (i < length - 2) {\n          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n            emulationPreventionBytesPositions.push(i + 2);\n            i += 2;\n          } else {\n            i++;\n          }\n        } // If no Emulation Prevention Bytes were found just return the original\n        // array\n\n        if (emulationPreventionBytesPositions.length === 0) {\n          return data;\n        } // Create a new array to hold the NAL unit data\n\n        newLength = length - emulationPreventionBytesPositions.length;\n        newData = new Uint8Array(newLength);\n        var sourceIndex = 0;\n        for (i = 0; i < newLength; sourceIndex++, i++) {\n          if (sourceIndex === emulationPreventionBytesPositions[0]) {\n            // Skip this byte\n            sourceIndex++; // Remove this position index\n\n            emulationPreventionBytesPositions.shift();\n          }\n          newData[i] = data[sourceIndex];\n        }\n        return newData;\n      };\n      /**\n       * Read a sequence parameter set and return some interesting video\n       * properties. A sequence parameter set is the H264 metadata that\n       * describes the properties of upcoming video frames.\n       * @param data {Uint8Array} the bytes of a sequence parameter set\n       * @return {object} an object with configuration parsed from the\n       * sequence parameter set, including the dimensions of the\n       * associated video frames.\n       */\n\n      readSequenceParameterSet = function (data) {\n        var frameCropLeftOffset = 0,\n          frameCropRightOffset = 0,\n          frameCropTopOffset = 0,\n          frameCropBottomOffset = 0,\n          expGolombDecoder,\n          profileIdc,\n          levelIdc,\n          profileCompatibility,\n          chromaFormatIdc,\n          picOrderCntType,\n          numRefFramesInPicOrderCntCycle,\n          picWidthInMbsMinus1,\n          picHeightInMapUnitsMinus1,\n          frameMbsOnlyFlag,\n          scalingListCount,\n          sarRatio = [1, 1],\n          aspectRatioIdc,\n          i;\n        expGolombDecoder = new ExpGolomb(data);\n        profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n        profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n        levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n        // some profiles have more optional data we don't need\n\n        if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n          chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n          if (chromaFormatIdc === 3) {\n            expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n          }\n\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n          expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n          if (expGolombDecoder.readBoolean()) {\n            // seq_scaling_matrix_present_flag\n            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n            for (i = 0; i < scalingListCount; i++) {\n              if (expGolombDecoder.readBoolean()) {\n                // seq_scaling_list_present_flag[ i ]\n                if (i < 6) {\n                  skipScalingList(16, expGolombDecoder);\n                } else {\n                  skipScalingList(64, expGolombDecoder);\n                }\n              }\n            }\n          }\n        }\n        expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n        picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n        if (picOrderCntType === 0) {\n          expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n          expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n          expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n          expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n          numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n            expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n          }\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n        expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n        picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n        frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n        if (frameMbsOnlyFlag === 0) {\n          expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n        }\n\n        expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n        if (expGolombDecoder.readBoolean()) {\n          // frame_cropping_flag\n          frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n        }\n        if (expGolombDecoder.readBoolean()) {\n          // vui_parameters_present_flag\n          if (expGolombDecoder.readBoolean()) {\n            // aspect_ratio_info_present_flag\n            aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n            switch (aspectRatioIdc) {\n              case 1:\n                sarRatio = [1, 1];\n                break;\n              case 2:\n                sarRatio = [12, 11];\n                break;\n              case 3:\n                sarRatio = [10, 11];\n                break;\n              case 4:\n                sarRatio = [16, 11];\n                break;\n              case 5:\n                sarRatio = [40, 33];\n                break;\n              case 6:\n                sarRatio = [24, 11];\n                break;\n              case 7:\n                sarRatio = [20, 11];\n                break;\n              case 8:\n                sarRatio = [32, 11];\n                break;\n              case 9:\n                sarRatio = [80, 33];\n                break;\n              case 10:\n                sarRatio = [18, 11];\n                break;\n              case 11:\n                sarRatio = [15, 11];\n                break;\n              case 12:\n                sarRatio = [64, 33];\n                break;\n              case 13:\n                sarRatio = [160, 99];\n                break;\n              case 14:\n                sarRatio = [4, 3];\n                break;\n              case 15:\n                sarRatio = [3, 2];\n                break;\n              case 16:\n                sarRatio = [2, 1];\n                break;\n              case 255:\n                {\n                  sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                  break;\n                }\n            }\n            if (sarRatio) {\n              sarRatio[0] / sarRatio[1];\n            }\n          }\n        }\n        return {\n          profileIdc: profileIdc,\n          levelIdc: levelIdc,\n          profileCompatibility: profileCompatibility,\n          width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n          // sar is sample aspect ratio\n          sarRatio: sarRatio\n        };\n      };\n    };\n    H264Stream$1.prototype = new Stream$2();\n    var h264 = {\n      H264Stream: H264Stream$1,\n      NalByteStream: NalByteStream\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Utilities to detect basic properties and metadata about Aac data.\n     */\n\n    var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    var parseId3TagSize = function (header, byteIndex) {\n      var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n        flags = header[byteIndex + 5],\n        footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n      returnSize = returnSize >= 0 ? returnSize : 0;\n      if (footerPresent) {\n        return returnSize + 20;\n      }\n      return returnSize + 10;\n    };\n    var getId3Offset = function (data, offset) {\n      if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n        return offset;\n      }\n      offset += parseId3TagSize(data, offset);\n      return getId3Offset(data, offset);\n    }; // TODO: use vhs-utils\n\n    var isLikelyAacData$1 = function (data) {\n      var offset = getId3Offset(data, 0);\n      return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 &&\n      // verify that the 2 layer bits are 0, aka this\n      // is not mp3 data but aac data.\n      (data[offset + 1] & 0x16) === 0x10;\n    };\n    var parseSyncSafeInteger = function (data) {\n      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n    }; // return a percent-encoded representation of the specified byte range\n    // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n    var percentEncode = function (bytes, start, end) {\n      var i,\n        result = '';\n      for (i = start; i < end; i++) {\n        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n      }\n      return result;\n    }; // return the string representation of the specified byte range,\n    // interpreted as ISO-8859-1.\n\n    var parseIso88591 = function (bytes, start, end) {\n      return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n    };\n\n    var parseAdtsSize = function (header, byteIndex) {\n      var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n        middle = header[byteIndex + 4] << 3,\n        highTwo = header[byteIndex + 3] & 0x3 << 11;\n      return highTwo | middle | lowThree;\n    };\n    var parseType$4 = function (header, byteIndex) {\n      if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n        return 'timed-metadata';\n      } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n        return 'audio';\n      }\n      return null;\n    };\n    var parseSampleRate = function (packet) {\n      var i = 0;\n      while (i + 5 < packet.length) {\n        if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n          // If a valid header was not found,  jump one forward and attempt to\n          // find a valid ADTS header starting at the next byte\n          i++;\n          continue;\n        }\n        return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n      }\n      return null;\n    };\n    var parseAacTimestamp = function (packet) {\n      var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n      frameStart = 10;\n      if (packet[5] & 0x40) {\n        // advance the frame start past the extended header\n        frameStart += 4; // header size field\n\n        frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n      } // parse one or more ID3 frames\n      // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n      do {\n        // determine the number of bytes in this frame\n        frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n        if (frameSize < 1) {\n          return null;\n        }\n        frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n        if (frameHeader === 'PRIV') {\n          frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n          for (var i = 0; i < frame.byteLength; i++) {\n            if (frame[i] === 0) {\n              var owner = parseIso88591(frame, 0, i);\n              if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n                var d = frame.subarray(i + 1);\n                var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n                size *= 4;\n                size += d[7] & 0x03;\n                return size;\n              }\n              break;\n            }\n          }\n        }\n        frameStart += 10; // advance past the frame header\n\n        frameStart += frameSize; // advance past the frame body\n      } while (frameStart < packet.byteLength);\n      return null;\n    };\n    var utils = {\n      isLikelyAacData: isLikelyAacData$1,\n      parseId3TagSize: parseId3TagSize,\n      parseAdtsSize: parseAdtsSize,\n      parseType: parseType$4,\n      parseSampleRate: parseSampleRate,\n      parseAacTimestamp: parseAacTimestamp\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * A stream-based aac to mp4 converter. This utility can be used to\n     * deliver mp4s to a SourceBuffer on platforms that support native\n     * Media Source Extensions.\n     */\n\n    var Stream$1 = stream;\n    var aacUtils = utils; // Constants\n\n    var AacStream$1;\n    /**\n     * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n     */\n\n    AacStream$1 = function () {\n      var everything = new Uint8Array(),\n        timeStamp = 0;\n      AacStream$1.prototype.init.call(this);\n      this.setTimestamp = function (timestamp) {\n        timeStamp = timestamp;\n      };\n      this.push = function (bytes) {\n        var frameSize = 0,\n          byteIndex = 0,\n          bytesLeft,\n          chunk,\n          packet,\n          tempLength; // If there are bytes remaining from the last segment, prepend them to the\n        // bytes that were pushed in\n\n        if (everything.length) {\n          tempLength = everything.length;\n          everything = new Uint8Array(bytes.byteLength + tempLength);\n          everything.set(everything.subarray(0, tempLength));\n          everything.set(bytes, tempLength);\n        } else {\n          everything = bytes;\n        }\n        while (everything.length - byteIndex >= 3) {\n          if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n            // Exit early because we don't have enough to parse\n            // the ID3 tag header\n            if (everything.length - byteIndex < 10) {\n              break;\n            } // check framesize\n\n            frameSize = aacUtils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n            // Add to byteIndex to support multiple ID3 tags in sequence\n\n            if (byteIndex + frameSize > everything.length) {\n              break;\n            }\n            chunk = {\n              type: 'timed-metadata',\n              data: everything.subarray(byteIndex, byteIndex + frameSize)\n            };\n            this.trigger('data', chunk);\n            byteIndex += frameSize;\n            continue;\n          } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n            // Exit early because we don't have enough to parse\n            // the ADTS frame header\n            if (everything.length - byteIndex < 7) {\n              break;\n            }\n            frameSize = aacUtils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n\n            if (byteIndex + frameSize > everything.length) {\n              break;\n            }\n            packet = {\n              type: 'audio',\n              data: everything.subarray(byteIndex, byteIndex + frameSize),\n              pts: timeStamp,\n              dts: timeStamp\n            };\n            this.trigger('data', packet);\n            byteIndex += frameSize;\n            continue;\n          }\n          byteIndex++;\n        }\n        bytesLeft = everything.length - byteIndex;\n        if (bytesLeft > 0) {\n          everything = everything.subarray(byteIndex);\n        } else {\n          everything = new Uint8Array();\n        }\n      };\n      this.reset = function () {\n        everything = new Uint8Array();\n        this.trigger('reset');\n      };\n      this.endTimeline = function () {\n        everything = new Uint8Array();\n        this.trigger('endedtimeline');\n      };\n    };\n    AacStream$1.prototype = new Stream$1();\n    var aac = AacStream$1;\n    var AUDIO_PROPERTIES$1 = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n    var audioProperties = AUDIO_PROPERTIES$1;\n    var VIDEO_PROPERTIES$1 = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n    var videoProperties = VIDEO_PROPERTIES$1;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * A stream-based mp2t to mp4 converter. This utility can be used to\n     * deliver mp4s to a SourceBuffer on platforms that support native\n     * Media Source Extensions.\n     */\n\n    var Stream = stream;\n    var mp4 = mp4Generator;\n    var frameUtils = frameUtils$1;\n    var audioFrameUtils = audioFrameUtils$1;\n    var trackDecodeInfo = trackDecodeInfo$1;\n    var m2ts = m2ts_1;\n    var clock = clock$2;\n    var AdtsStream = adts;\n    var H264Stream = h264.H264Stream;\n    var AacStream = aac;\n    var isLikelyAacData = utils.isLikelyAacData;\n    var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;\n    var AUDIO_PROPERTIES = audioProperties;\n    var VIDEO_PROPERTIES = videoProperties; // object types\n\n    var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n    var retriggerForStream = function (key, event) {\n      event.stream = key;\n      this.trigger('log', event);\n    };\n    var addPipelineLogRetriggers = function (transmuxer, pipeline) {\n      var keys = Object.keys(pipeline);\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]; // skip non-stream keys and headOfPipeline\n        // which is just a duplicate\n\n        if (key === 'headOfPipeline' || !pipeline[key].on) {\n          continue;\n        }\n        pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n      }\n    };\n    /**\n     * Compare two arrays (even typed) for same-ness\n     */\n\n    var arrayEquals = function (a, b) {\n      var i;\n      if (a.length !== b.length) {\n        return false;\n      } // compare the value of each element in the array\n\n      for (i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n      return true;\n    };\n    var generateSegmentTimingInfo = function (baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n      var ptsOffsetFromDts = startPts - startDts,\n        decodeDuration = endDts - startDts,\n        presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n      // however, the player time values will reflect a start from the baseMediaDecodeTime.\n      // In order to provide relevant values for the player times, base timing info on the\n      // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n      return {\n        start: {\n          dts: baseMediaDecodeTime,\n          pts: baseMediaDecodeTime + ptsOffsetFromDts\n        },\n        end: {\n          dts: baseMediaDecodeTime + decodeDuration,\n          pts: baseMediaDecodeTime + presentationDuration\n        },\n        prependedContentDuration: prependedContentDuration,\n        baseMediaDecodeTime: baseMediaDecodeTime\n      };\n    };\n    /**\n     * Constructs a single-track, ISO BMFF media segment from AAC data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     * @param track {object} track metadata configuration\n     * @param options {object} transmuxer options object\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n\n    AudioSegmentStream = function (track, options) {\n      var adtsFrames = [],\n        sequenceNumber,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity;\n      options = options || {};\n      sequenceNumber = options.firstSequenceNumber || 0;\n      AudioSegmentStream.prototype.init.call(this);\n      this.push = function (data) {\n        trackDecodeInfo.collectDtsInfo(track, data);\n        if (track) {\n          AUDIO_PROPERTIES.forEach(function (prop) {\n            track[prop] = data[prop];\n          });\n        } // buffer audio data until end() is called\n\n        adtsFrames.push(data);\n      };\n      this.setEarliestDts = function (earliestDts) {\n        earliestAllowedDts = earliestDts;\n      };\n      this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        videoBaseMediaDecodeTime = baseMediaDecodeTime;\n      };\n      this.setAudioAppendStart = function (timestamp) {\n        audioAppendStartTs = timestamp;\n      };\n      this.flush = function () {\n        var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n        if (adtsFrames.length === 0) {\n          this.trigger('done', 'AudioSegmentStream');\n          return;\n        }\n        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n        videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n        // samples (that is, adts frames) in the audio data\n\n        track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n        mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n        adtsFrames = [];\n        moof = mp4.moof(sequenceNumber, [track]);\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n        sequenceNumber++;\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        trackDecodeInfo.clearDtsInfo(track);\n        frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n        // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n        // valid use-case where an init segment/data should be triggered without associated\n        // frames. Leaving for now, but should be looked into.\n\n        if (frames.length) {\n          segmentDuration = frames.length * frameDuration;\n          this.trigger('segmentTimingInfo', generateSegmentTimingInfo(\n          // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n          // frame info is in video clock cycles. Convert to match expectation of\n          // listeners (that all timestamps will be based on video clock cycles).\n          clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),\n          // frame times are already in video clock, as is segment duration\n          frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n          this.trigger('timingInfo', {\n            start: frames[0].pts,\n            end: frames[0].pts + segmentDuration\n          });\n        }\n        this.trigger('data', {\n          track: track,\n          boxes: boxes\n        });\n        this.trigger('done', 'AudioSegmentStream');\n      };\n      this.reset = function () {\n        trackDecodeInfo.clearDtsInfo(track);\n        adtsFrames = [];\n        this.trigger('reset');\n      };\n    };\n    AudioSegmentStream.prototype = new Stream();\n    /**\n     * Constructs a single-track, ISO BMFF media segment from H264 data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     * @param track {object} track metadata configuration\n     * @param options {object} transmuxer options object\n     * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n     *        gopsToAlignWith list when attempting to align gop pts\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n\n    VideoSegmentStream = function (track, options) {\n      var sequenceNumber,\n        nalUnits = [],\n        gopsToAlignWith = [],\n        config,\n        pps;\n      options = options || {};\n      sequenceNumber = options.firstSequenceNumber || 0;\n      VideoSegmentStream.prototype.init.call(this);\n      delete track.minPTS;\n      this.gopCache_ = [];\n      /**\n        * Constructs a ISO BMFF segment given H264 nalUnits\n        * @param {Object} nalUnit A data event representing a nalUnit\n        * @param {String} nalUnit.nalUnitType\n        * @param {Object} nalUnit.config Properties for a mp4 track\n        * @param {Uint8Array} nalUnit.data The nalUnit bytes\n        * @see lib/codecs/h264.js\n       **/\n\n      this.push = function (nalUnit) {\n        trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n        if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n          config = nalUnit.config;\n          track.sps = [nalUnit.data];\n          VIDEO_PROPERTIES.forEach(function (prop) {\n            track[prop] = config[prop];\n          }, this);\n        }\n        if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n          pps = nalUnit.data;\n          track.pps = [nalUnit.data];\n        } // buffer video until flush() is called\n\n        nalUnits.push(nalUnit);\n      };\n      /**\n        * Pass constructed ISO BMFF track and boxes on to the\n        * next stream in the pipeline\n       **/\n\n      this.flush = function () {\n        var frames,\n          gopForFusion,\n          gops,\n          moof,\n          mdat,\n          boxes,\n          prependedContentDuration = 0,\n          firstGop,\n          lastGop; // Throw away nalUnits at the start of the byte stream until\n        // we find the first AUD\n\n        while (nalUnits.length) {\n          if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n            break;\n          }\n          nalUnits.shift();\n        } // Return early if no video data has been observed\n\n        if (nalUnits.length === 0) {\n          this.resetStream_();\n          this.trigger('done', 'VideoSegmentStream');\n          return;\n        } // Organize the raw nal-units into arrays that represent\n        // higher-level constructs such as frames and gops\n        // (group-of-pictures)\n\n        frames = frameUtils.groupNalsIntoFrames(nalUnits);\n        gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n        // a problem since MSE (on Chrome) requires a leading keyframe.\n        //\n        // We have two approaches to repairing this situation:\n        // 1) GOP-FUSION:\n        //    This is where we keep track of the GOPS (group-of-pictures)\n        //    from previous fragments and attempt to find one that we can\n        //    prepend to the current fragment in order to create a valid\n        //    fragment.\n        // 2) KEYFRAME-PULLING:\n        //    Here we search for the first keyframe in the fragment and\n        //    throw away all the frames between the start of the fragment\n        //    and that keyframe. We then extend the duration and pull the\n        //    PTS of the keyframe forward so that it covers the time range\n        //    of the frames that were disposed of.\n        //\n        // #1 is far prefereable over #2 which can cause \"stuttering\" but\n        // requires more things to be just right.\n\n        if (!gops[0][0].keyFrame) {\n          // Search for a gop for fusion from our gopCache\n          gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n          if (gopForFusion) {\n            // in order to provide more accurate timing information about the segment, save\n            // the number of seconds prepended to the original segment due to GOP fusion\n            prependedContentDuration = gopForFusion.duration;\n            gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n            // new gop at the beginning\n\n            gops.byteLength += gopForFusion.byteLength;\n            gops.nalCount += gopForFusion.nalCount;\n            gops.pts = gopForFusion.pts;\n            gops.dts = gopForFusion.dts;\n            gops.duration += gopForFusion.duration;\n          } else {\n            // If we didn't find a candidate gop fall back to keyframe-pulling\n            gops = frameUtils.extendFirstKeyFrame(gops);\n          }\n        } // Trim gops to align with gopsToAlignWith\n\n        if (gopsToAlignWith.length) {\n          var alignedGops;\n          if (options.alignGopsAtEnd) {\n            alignedGops = this.alignGopsAtEnd_(gops);\n          } else {\n            alignedGops = this.alignGopsAtStart_(gops);\n          }\n          if (!alignedGops) {\n            // save all the nals in the last GOP into the gop cache\n            this.gopCache_.unshift({\n              gop: gops.pop(),\n              pps: track.pps,\n              sps: track.sps\n            }); // Keep a maximum of 6 GOPs in the cache\n\n            this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n            nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n            this.resetStream_();\n            this.trigger('done', 'VideoSegmentStream');\n            return;\n          } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n          // when recalculated before sending off to CoalesceStream\n\n          trackDecodeInfo.clearDtsInfo(track);\n          gops = alignedGops;\n        }\n        trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n        // samples (that is, frames) in the video data\n\n        track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n        mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        this.trigger('processedGopsInfo', gops.map(function (gop) {\n          return {\n            pts: gop.pts,\n            dts: gop.dts,\n            byteLength: gop.byteLength\n          };\n        }));\n        firstGop = gops[0];\n        lastGop = gops[gops.length - 1];\n        this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n        this.trigger('timingInfo', {\n          start: gops[0].pts,\n          end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n        }); // save all the nals in the last GOP into the gop cache\n\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        }); // Keep a maximum of 6 GOPs in the cache\n\n        this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n        nalUnits = [];\n        this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n        this.trigger('timelineStartInfo', track.timelineStartInfo);\n        moof = mp4.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n        // throwing away hundreds of media segment fragments\n\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n        sequenceNumber++;\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        this.trigger('data', {\n          track: track,\n          boxes: boxes\n        });\n        this.resetStream_(); // Continue with the flush process now\n\n        this.trigger('done', 'VideoSegmentStream');\n      };\n      this.reset = function () {\n        this.resetStream_();\n        nalUnits = [];\n        this.gopCache_.length = 0;\n        gopsToAlignWith.length = 0;\n        this.trigger('reset');\n      };\n      this.resetStream_ = function () {\n        trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n        // for instance, when we are rendition switching\n\n        config = undefined;\n        pps = undefined;\n      }; // Search for a candidate Gop for gop-fusion from the gop cache and\n      // return it or return null if no good candidate was found\n\n      this.getGopForFusion_ = function (nalUnit) {\n        var halfSecond = 45000,\n          // Half-a-second in a 90khz clock\n          allowableOverlap = 10000,\n          // About 3 frames @ 30fps\n          nearestDistance = Infinity,\n          dtsDistance,\n          nearestGopObj,\n          currentGop,\n          currentGopObj,\n          i; // Search for the GOP nearest to the beginning of this nal unit\n\n        for (i = 0; i < this.gopCache_.length; i++) {\n          currentGopObj = this.gopCache_[i];\n          currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n          if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n            continue;\n          } // Reject Gops that would require a negative baseMediaDecodeTime\n\n          if (currentGop.dts < track.timelineStartInfo.dts) {\n            continue;\n          } // The distance between the end of the gop and the start of the nalUnit\n\n          dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n          // a half-second of the nal unit\n\n          if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n            // Always use the closest GOP we found if there is more than\n            // one candidate\n            if (!nearestGopObj || nearestDistance > dtsDistance) {\n              nearestGopObj = currentGopObj;\n              nearestDistance = dtsDistance;\n            }\n          }\n        }\n        if (nearestGopObj) {\n          return nearestGopObj.gop;\n        }\n        return null;\n      }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n      // of gopsToAlignWith starting from the START of the list\n\n      this.alignGopsAtStart_ = function (gops) {\n        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n        byteLength = gops.byteLength;\n        nalCount = gops.nalCount;\n        duration = gops.duration;\n        alignIndex = gopIndex = 0;\n        while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n          align = gopsToAlignWith[alignIndex];\n          gop = gops[gopIndex];\n          if (align.pts === gop.pts) {\n            break;\n          }\n          if (gop.pts > align.pts) {\n            // this current gop starts after the current gop we want to align on, so increment\n            // align index\n            alignIndex++;\n            continue;\n          } // current gop starts before the current gop we want to align on. so increment gop\n          // index\n\n          gopIndex++;\n          byteLength -= gop.byteLength;\n          nalCount -= gop.nalCount;\n          duration -= gop.duration;\n        }\n        if (gopIndex === 0) {\n          // no gops to trim\n          return gops;\n        }\n        if (gopIndex === gops.length) {\n          // all gops trimmed, skip appending all gops\n          return null;\n        }\n        alignedGops = gops.slice(gopIndex);\n        alignedGops.byteLength = byteLength;\n        alignedGops.duration = duration;\n        alignedGops.nalCount = nalCount;\n        alignedGops.pts = alignedGops[0].pts;\n        alignedGops.dts = alignedGops[0].dts;\n        return alignedGops;\n      }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n      // of gopsToAlignWith starting from the END of the list\n\n      this.alignGopsAtEnd_ = function (gops) {\n        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n        alignIndex = gopsToAlignWith.length - 1;\n        gopIndex = gops.length - 1;\n        alignEndIndex = null;\n        matchFound = false;\n        while (alignIndex >= 0 && gopIndex >= 0) {\n          align = gopsToAlignWith[alignIndex];\n          gop = gops[gopIndex];\n          if (align.pts === gop.pts) {\n            matchFound = true;\n            break;\n          }\n          if (align.pts > gop.pts) {\n            alignIndex--;\n            continue;\n          }\n          if (alignIndex === gopsToAlignWith.length - 1) {\n            // gop.pts is greater than the last alignment candidate. If no match is found\n            // by the end of this loop, we still want to append gops that come after this\n            // point\n            alignEndIndex = gopIndex;\n          }\n          gopIndex--;\n        }\n        if (!matchFound && alignEndIndex === null) {\n          return null;\n        }\n        var trimIndex;\n        if (matchFound) {\n          trimIndex = gopIndex;\n        } else {\n          trimIndex = alignEndIndex;\n        }\n        if (trimIndex === 0) {\n          return gops;\n        }\n        var alignedGops = gops.slice(trimIndex);\n        var metadata = alignedGops.reduce(function (total, gop) {\n          total.byteLength += gop.byteLength;\n          total.duration += gop.duration;\n          total.nalCount += gop.nalCount;\n          return total;\n        }, {\n          byteLength: 0,\n          duration: 0,\n          nalCount: 0\n        });\n        alignedGops.byteLength = metadata.byteLength;\n        alignedGops.duration = metadata.duration;\n        alignedGops.nalCount = metadata.nalCount;\n        alignedGops.pts = alignedGops[0].pts;\n        alignedGops.dts = alignedGops[0].dts;\n        return alignedGops;\n      };\n      this.alignGopsWith = function (newGopsToAlignWith) {\n        gopsToAlignWith = newGopsToAlignWith;\n      };\n    };\n    VideoSegmentStream.prototype = new Stream();\n    /**\n     * A Stream that can combine multiple streams (ie. audio & video)\n     * into a single output segment for MSE. Also supports audio-only\n     * and video-only streams.\n     * @param options {object} transmuxer options object\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at media timeline start.\n     */\n\n    CoalesceStream = function (options, metadataStream) {\n      // Number of Tracks per output segment\n      // If greater than 1, we combine multiple\n      // tracks into a single segment\n      this.numberOfTracks = 0;\n      this.metadataStream = metadataStream;\n      options = options || {};\n      if (typeof options.remux !== 'undefined') {\n        this.remuxTracks = !!options.remux;\n      } else {\n        this.remuxTracks = true;\n      }\n      if (typeof options.keepOriginalTimestamps === 'boolean') {\n        this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n      } else {\n        this.keepOriginalTimestamps = false;\n      }\n      this.pendingTracks = [];\n      this.videoTrack = null;\n      this.pendingBoxes = [];\n      this.pendingCaptions = [];\n      this.pendingMetadata = [];\n      this.pendingBytes = 0;\n      this.emittedTracks = 0;\n      CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n      this.push = function (output) {\n        // buffer incoming captions until the associated video segment\n        // finishes\n        if (output.text) {\n          return this.pendingCaptions.push(output);\n        } // buffer incoming id3 tags until the final flush\n\n        if (output.frames) {\n          return this.pendingMetadata.push(output);\n        } // Add this track to the list of pending tracks and store\n        // important information required for the construction of\n        // the final segment\n\n        this.pendingTracks.push(output.track);\n        this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n        // We unshift audio and push video because\n        // as of Chrome 75 when switching from\n        // one init segment to another if the video\n        // mdat does not appear after the audio mdat\n        // only audio will play for the duration of our transmux.\n\n        if (output.track.type === 'video') {\n          this.videoTrack = output.track;\n          this.pendingBoxes.push(output.boxes);\n        }\n        if (output.track.type === 'audio') {\n          this.audioTrack = output.track;\n          this.pendingBoxes.unshift(output.boxes);\n        }\n      };\n    };\n    CoalesceStream.prototype = new Stream();\n    CoalesceStream.prototype.flush = function (flushSource) {\n      var offset = 0,\n        event = {\n          captions: [],\n          captionStreams: {},\n          metadata: [],\n          info: {}\n        },\n        caption,\n        id3,\n        initSegment,\n        timelineStartPts = 0,\n        i;\n      if (this.pendingTracks.length < this.numberOfTracks) {\n        if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n          // Return because we haven't received a flush from a data-generating\n          // portion of the segment (meaning that we have only recieved meta-data\n          // or captions.)\n          return;\n        } else if (this.remuxTracks) {\n          // Return until we have enough tracks from the pipeline to remux (if we\n          // are remuxing audio and video into a single MP4)\n          return;\n        } else if (this.pendingTracks.length === 0) {\n          // In the case where we receive a flush without any data having been\n          // received we consider it an emitted track for the purposes of coalescing\n          // `done` events.\n          // We do this for the case where there is an audio and video track in the\n          // segment but no audio data. (seen in several playlists with alternate\n          // audio tracks and no audio present in the main TS segments.)\n          this.emittedTracks++;\n          if (this.emittedTracks >= this.numberOfTracks) {\n            this.trigger('done');\n            this.emittedTracks = 0;\n          }\n          return;\n        }\n      }\n      if (this.videoTrack) {\n        timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n        VIDEO_PROPERTIES.forEach(function (prop) {\n          event.info[prop] = this.videoTrack[prop];\n        }, this);\n      } else if (this.audioTrack) {\n        timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n        AUDIO_PROPERTIES.forEach(function (prop) {\n          event.info[prop] = this.audioTrack[prop];\n        }, this);\n      }\n      if (this.videoTrack || this.audioTrack) {\n        if (this.pendingTracks.length === 1) {\n          event.type = this.pendingTracks[0].type;\n        } else {\n          event.type = 'combined';\n        }\n        this.emittedTracks += this.pendingTracks.length;\n        initSegment = mp4.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n        event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n        // and track definitions\n\n        event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n        event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n        for (i = 0; i < this.pendingBoxes.length; i++) {\n          event.data.set(this.pendingBoxes[i], offset);\n          offset += this.pendingBoxes[i].byteLength;\n        } // Translate caption PTS times into second offsets to match the\n        // video timeline for the segment, and add track info\n\n        for (i = 0; i < this.pendingCaptions.length; i++) {\n          caption = this.pendingCaptions[i];\n          caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n          caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n          event.captionStreams[caption.stream] = true;\n          event.captions.push(caption);\n        } // Translate ID3 frame PTS times into second offsets to match the\n        // video timeline for the segment\n\n        for (i = 0; i < this.pendingMetadata.length; i++) {\n          id3 = this.pendingMetadata[i];\n          id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n          event.metadata.push(id3);\n        } // We add this to every single emitted segment even though we only need\n        // it for the first\n\n        event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n        this.pendingTracks.length = 0;\n        this.videoTrack = null;\n        this.pendingBoxes.length = 0;\n        this.pendingCaptions.length = 0;\n        this.pendingBytes = 0;\n        this.pendingMetadata.length = 0; // Emit the built segment\n        // We include captions and ID3 tags for backwards compatibility,\n        // ideally we should send only video and audio in the data event\n\n        this.trigger('data', event); // Emit each caption to the outside world\n        // Ideally, this would happen immediately on parsing captions,\n        // but we need to ensure that video data is sent back first\n        // so that caption timing can be adjusted to match video timing\n\n        for (i = 0; i < event.captions.length; i++) {\n          caption = event.captions[i];\n          this.trigger('caption', caption);\n        } // Emit each id3 tag to the outside world\n        // Ideally, this would happen immediately on parsing the tag,\n        // but we need to ensure that video data is sent back first\n        // so that ID3 frame timing can be adjusted to match video timing\n\n        for (i = 0; i < event.metadata.length; i++) {\n          id3 = event.metadata[i];\n          this.trigger('id3Frame', id3);\n        }\n      } // Only emit `done` if all tracks have been flushed and emitted\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n    };\n    CoalesceStream.prototype.setRemux = function (val) {\n      this.remuxTracks = val;\n    };\n    /**\n     * A Stream that expects MP2T binary data as input and produces\n     * corresponding media segments, suitable for use with Media Source\n     * Extension (MSE) implementations that support the ISO BMFF byte\n     * stream format, like Chrome.\n     */\n\n    Transmuxer = function (options) {\n      var self = this,\n        hasFlushed = true,\n        videoTrack,\n        audioTrack;\n      Transmuxer.prototype.init.call(this);\n      options = options || {};\n      this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n      this.transmuxPipeline_ = {};\n      this.setupAacPipeline = function () {\n        var pipeline = {};\n        this.transmuxPipeline_ = pipeline;\n        pipeline.type = 'aac';\n        pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n        pipeline.aacStream = new AacStream();\n        pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n        pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n        pipeline.adtsStream = new AdtsStream();\n        pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n        pipeline.headOfPipeline = pipeline.aacStream;\n        pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n        pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n        pipeline.metadataStream.on('timestamp', function (frame) {\n          pipeline.aacStream.setTimestamp(frame.timeStamp);\n        });\n        pipeline.aacStream.on('data', function (data) {\n          if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n            return;\n          }\n          audioTrack = audioTrack || {\n            timelineStartInfo: {\n              baseMediaDecodeTime: self.baseMediaDecodeTime\n            },\n            codec: 'adts',\n            type: 'audio'\n          }; // hook up the audio segment stream to the first track with aac data\n\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n          pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n          pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n          self.trigger('trackinfo', {\n            hasAudio: !!audioTrack,\n            hasVideo: !!videoTrack\n          });\n        }); // Re-emit any data coming from the coalesce stream to the outside world\n\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n        addPipelineLogRetriggers(this, pipeline);\n      };\n      this.setupTsPipeline = function () {\n        var pipeline = {};\n        this.transmuxPipeline_ = pipeline;\n        pipeline.type = 'ts';\n        pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n        pipeline.packetStream = new m2ts.TransportPacketStream();\n        pipeline.parseStream = new m2ts.TransportParseStream();\n        pipeline.elementaryStream = new m2ts.ElementaryStream();\n        pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream();\n        pipeline.adtsStream = new AdtsStream();\n        pipeline.h264Stream = new H264Stream();\n        pipeline.captionStream = new m2ts.CaptionStream(options);\n        pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n        pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n        pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n        // demux the streams\n\n        pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n        pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n        pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n        pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n        pipeline.elementaryStream.on('data', function (data) {\n          var i;\n          if (data.type === 'metadata') {\n            i = data.tracks.length; // scan the tracks listed in the metadata\n\n            while (i--) {\n              if (!videoTrack && data.tracks[i].type === 'video') {\n                videoTrack = data.tracks[i];\n                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n              } else if (!audioTrack && data.tracks[i].type === 'audio') {\n                audioTrack = data.tracks[i];\n                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n              }\n            } // hook up the video segment stream to the first track with h264 data\n\n            if (videoTrack && !pipeline.videoSegmentStream) {\n              pipeline.coalesceStream.numberOfTracks++;\n              pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n              pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n              pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n                // When video emits timelineStartInfo data after a flush, we forward that\n                // info to the AudioSegmentStream, if it exists, because video timeline\n                // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n                // because this is a particularly subtle form of timestamp alteration.\n                if (audioTrack && !options.keepOriginalTimestamps) {\n                  audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                  // very earliest DTS we have seen in video because Chrome will\n                  // interpret any video track with a baseMediaDecodeTime that is\n                  // non-zero as a gap.\n\n                  pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n                }\n              });\n              pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n              pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n              pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n                if (audioTrack) {\n                  pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n                }\n              });\n              pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n              pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n            }\n            if (audioTrack && !pipeline.audioSegmentStream) {\n              // hook up the audio segment stream to the first track with aac data\n              pipeline.coalesceStream.numberOfTracks++;\n              pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n              pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n              pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n              pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n              pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n            } // emit pmt info\n\n            self.trigger('trackinfo', {\n              hasAudio: !!audioTrack,\n              hasVideo: !!videoTrack\n            });\n          }\n        }); // Re-emit any data coming from the coalesce stream to the outside world\n\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n        pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n          id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n          self.trigger('id3Frame', id3Frame);\n        });\n        pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n        addPipelineLogRetriggers(this, pipeline);\n      }; // hook up the segment streams once track metadata is delivered\n\n      this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        var pipeline = this.transmuxPipeline_;\n        if (!options.keepOriginalTimestamps) {\n          this.baseMediaDecodeTime = baseMediaDecodeTime;\n        }\n        if (audioTrack) {\n          audioTrack.timelineStartInfo.dts = undefined;\n          audioTrack.timelineStartInfo.pts = undefined;\n          trackDecodeInfo.clearDtsInfo(audioTrack);\n          if (pipeline.audioTimestampRolloverStream) {\n            pipeline.audioTimestampRolloverStream.discontinuity();\n          }\n        }\n        if (videoTrack) {\n          if (pipeline.videoSegmentStream) {\n            pipeline.videoSegmentStream.gopCache_ = [];\n          }\n          videoTrack.timelineStartInfo.dts = undefined;\n          videoTrack.timelineStartInfo.pts = undefined;\n          trackDecodeInfo.clearDtsInfo(videoTrack);\n          pipeline.captionStream.reset();\n        }\n        if (pipeline.timestampRolloverStream) {\n          pipeline.timestampRolloverStream.discontinuity();\n        }\n      };\n      this.setAudioAppendStart = function (timestamp) {\n        if (audioTrack) {\n          this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n        }\n      };\n      this.setRemux = function (val) {\n        var pipeline = this.transmuxPipeline_;\n        options.remux = val;\n        if (pipeline && pipeline.coalesceStream) {\n          pipeline.coalesceStream.setRemux(val);\n        }\n      };\n      this.alignGopsWith = function (gopsToAlignWith) {\n        if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n          this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n        }\n      };\n      this.getLogTrigger_ = function (key) {\n        var self = this;\n        return function (event) {\n          event.stream = key;\n          self.trigger('log', event);\n        };\n      }; // feed incoming data to the front of the parsing pipeline\n\n      this.push = function (data) {\n        if (hasFlushed) {\n          var isAac = isLikelyAacData(data);\n          if (isAac && this.transmuxPipeline_.type !== 'aac') {\n            this.setupAacPipeline();\n          } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n            this.setupTsPipeline();\n          }\n          hasFlushed = false;\n        }\n        this.transmuxPipeline_.headOfPipeline.push(data);\n      }; // flush any buffered data\n\n      this.flush = function () {\n        hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n        this.transmuxPipeline_.headOfPipeline.flush();\n      };\n      this.endTimeline = function () {\n        this.transmuxPipeline_.headOfPipeline.endTimeline();\n      };\n      this.reset = function () {\n        if (this.transmuxPipeline_.headOfPipeline) {\n          this.transmuxPipeline_.headOfPipeline.reset();\n        }\n      }; // Caption data has to be reset when seeking outside buffered range\n\n      this.resetCaptions = function () {\n        if (this.transmuxPipeline_.captionStream) {\n          this.transmuxPipeline_.captionStream.reset();\n        }\n      };\n    };\n    Transmuxer.prototype = new Stream();\n    var transmuxer = {\n      Transmuxer: Transmuxer,\n      VideoSegmentStream: VideoSegmentStream,\n      AudioSegmentStream: AudioSegmentStream,\n      AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n      VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n      // exported for testing\n      generateSegmentTimingInfo: generateSegmentTimingInfo\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n\n    var toUnsigned$3 = function (value) {\n      return value >>> 0;\n    };\n    var toHexString$1 = function (value) {\n      return ('00' + value.toString(16)).slice(-2);\n    };\n    var bin = {\n      toUnsigned: toUnsigned$3,\n      toHexString: toHexString$1\n    };\n    var parseType$3 = function (buffer) {\n      var result = '';\n      result += String.fromCharCode(buffer[0]);\n      result += String.fromCharCode(buffer[1]);\n      result += String.fromCharCode(buffer[2]);\n      result += String.fromCharCode(buffer[3]);\n      return result;\n    };\n    var parseType_1 = parseType$3;\n    var toUnsigned$2 = bin.toUnsigned;\n    var parseType$2 = parseType_1;\n    var findBox$2 = function (data, path) {\n      var results = [],\n        i,\n        size,\n        type,\n        end,\n        subresults;\n      if (!path.length) {\n        // short-circuit the search for empty paths\n        return null;\n      }\n      for (i = 0; i < data.byteLength;) {\n        size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n        type = parseType$2(data.subarray(i + 4, i + 8));\n        end = size > 1 ? i + size : data.byteLength;\n        if (type === path[0]) {\n          if (path.length === 1) {\n            // this is the end of the path and we've found the box we were\n            // looking for\n            results.push(data.subarray(i + 8, end));\n          } else {\n            // recursively search for the next box along the path\n            subresults = findBox$2(data.subarray(i + 8, end), path.slice(1));\n            if (subresults.length) {\n              results = results.concat(subresults);\n            }\n          }\n        }\n        i = end;\n      } // we've finished searching all of data\n\n      return results;\n    };\n    var findBox_1 = findBox$2;\n    var toUnsigned$1 = bin.toUnsigned;\n    var getUint64$1 = numbers.getUint64;\n    var tfdt = function (data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n      if (result.version === 1) {\n        result.baseMediaDecodeTime = getUint64$1(data.subarray(4));\n      } else {\n        result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\n      }\n      return result;\n    };\n    var parseTfdt$2 = tfdt;\n    var parseSampleFlags$1 = function (flags) {\n      return {\n        isLeading: (flags[0] & 0x0c) >>> 2,\n        dependsOn: flags[0] & 0x03,\n        isDependedOn: (flags[1] & 0xc0) >>> 6,\n        hasRedundancy: (flags[1] & 0x30) >>> 4,\n        paddingValue: (flags[1] & 0x0e) >>> 1,\n        isNonSyncSample: flags[1] & 0x01,\n        degradationPriority: flags[2] << 8 | flags[3]\n      };\n    };\n    var parseSampleFlags_1 = parseSampleFlags$1;\n    var parseSampleFlags = parseSampleFlags_1;\n    var trun = function (data) {\n      var result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n        dataOffsetPresent = result.flags[2] & 0x01,\n        // compare with 2nd byte of 0x1\n        firstSampleFlagsPresent = result.flags[2] & 0x04,\n        // compare with 2nd byte of 0x4\n        sampleDurationPresent = result.flags[1] & 0x01,\n        // compare with 2nd byte of 0x100\n        sampleSizePresent = result.flags[1] & 0x02,\n        // compare with 2nd byte of 0x200\n        sampleFlagsPresent = result.flags[1] & 0x04,\n        // compare with 2nd byte of 0x400\n        sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n        // compare with 2nd byte of 0x800\n        sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n      if (dataOffsetPresent) {\n        // 32 bit signed integer\n        result.dataOffset = view.getInt32(offset);\n        offset += 4;\n      } // Overrides the flags for the first sample only. The order of\n      // optional values will be: duration, size, compositionTimeOffset\n\n      if (firstSampleFlagsPresent && sampleCount) {\n        sample = {\n          flags: parseSampleFlags(data.subarray(offset, offset + 4))\n        };\n        offset += 4;\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          if (result.version === 1) {\n            sample.compositionTimeOffset = view.getInt32(offset);\n          } else {\n            sample.compositionTimeOffset = view.getUint32(offset);\n          }\n          offset += 4;\n        }\n        result.samples.push(sample);\n        sampleCount--;\n      }\n      while (sampleCount--) {\n        sample = {};\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          if (result.version === 1) {\n            sample.compositionTimeOffset = view.getInt32(offset);\n          } else {\n            sample.compositionTimeOffset = view.getUint32(offset);\n          }\n          offset += 4;\n        }\n        result.samples.push(sample);\n      }\n      return result;\n    };\n    var parseTrun$2 = trun;\n    var tfhd = function (data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          trackId: view.getUint32(4)\n        },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof = result.flags[0] & 0x020000,\n        i;\n      i = 8;\n      if (baseDataOffsetPresent) {\n        i += 4; // truncate top 4 bytes\n        // FIXME: should we read the full 64 bits?\n\n        result.baseDataOffset = view.getUint32(12);\n        i += 4;\n      }\n      if (sampleDescriptionIndexPresent) {\n        result.sampleDescriptionIndex = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleDurationPresent) {\n        result.defaultSampleDuration = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleSizePresent) {\n        result.defaultSampleSize = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleFlagsPresent) {\n        result.defaultSampleFlags = view.getUint32(i);\n      }\n      if (durationIsEmpty) {\n        result.durationIsEmpty = true;\n      }\n      if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n        result.baseDataOffsetIsMoof = true;\n      }\n      return result;\n    };\n    var parseTfhd$2 = tfhd;\n    var win;\n    if (typeof window !== \"undefined\") {\n      win = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n      win = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n      win = self;\n    } else {\n      win = {};\n    }\n    var window_1 = win;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Reads in-band CEA-708 captions out of FMP4 segments.\n     * @see https://en.wikipedia.org/wiki/CEA-708\n     */\n\n    var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\n    var CaptionStream = captionStream.CaptionStream;\n    var findBox$1 = findBox_1;\n    var parseTfdt$1 = parseTfdt$2;\n    var parseTrun$1 = parseTrun$2;\n    var parseTfhd$1 = parseTfhd$2;\n    var window$2 = window_1;\n    /**\n      * Maps an offset in the mdat to a sample based on the the size of the samples.\n      * Assumes that `parseSamples` has been called first.\n      *\n      * @param {Number} offset - The offset into the mdat\n      * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n      * @return {?Object} The matching sample, or null if no match was found.\n      *\n      * @see ISO-BMFF-12/2015, Section 8.8.8\n     **/\n\n    var mapToSample = function (offset, samples) {\n      var approximateOffset = offset;\n      for (var i = 0; i < samples.length; i++) {\n        var sample = samples[i];\n        if (approximateOffset < sample.size) {\n          return sample;\n        }\n        approximateOffset -= sample.size;\n      }\n      return null;\n    };\n    /**\n      * Finds SEI nal units contained in a Media Data Box.\n      * Assumes that `parseSamples` has been called first.\n      *\n      * @param {Uint8Array} avcStream - The bytes of the mdat\n      * @param {Object[]} samples - The samples parsed out by `parseSamples`\n      * @param {Number} trackId - The trackId of this video track\n      * @return {Object[]} seiNals - the parsed SEI NALUs found.\n      *   The contents of the seiNal should match what is expected by\n      *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n      *\n      * @see ISO-BMFF-12/2015, Section 8.1.1\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\n     **/\n\n    var findSeiNals = function (avcStream, samples, trackId) {\n      var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = {\n          logs: [],\n          seiNals: []\n        },\n        seiNal,\n        i,\n        length,\n        lastMatchedSample;\n      for (i = 0; i + 4 < avcStream.length; i += length) {\n        length = avcView.getUint32(i);\n        i += 4; // Bail if this doesn't appear to be an H264 stream\n\n        if (length <= 0) {\n          continue;\n        }\n        switch (avcStream[i] & 0x1F) {\n          case 0x06:\n            var data = avcStream.subarray(i + 1, i + 1 + length);\n            var matchingSample = mapToSample(i, samples);\n            seiNal = {\n              nalUnitType: 'sei_rbsp',\n              size: length,\n              data: data,\n              escapedRBSP: discardEmulationPreventionBytes(data),\n              trackId: trackId\n            };\n            if (matchingSample) {\n              seiNal.pts = matchingSample.pts;\n              seiNal.dts = matchingSample.dts;\n              lastMatchedSample = matchingSample;\n            } else if (lastMatchedSample) {\n              // If a matching sample cannot be found, use the last\n              // sample's values as they should be as close as possible\n              seiNal.pts = lastMatchedSample.pts;\n              seiNal.dts = lastMatchedSample.dts;\n            } else {\n              result.logs.push({\n                level: 'warn',\n                message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n              });\n              break;\n            }\n            result.seiNals.push(seiNal);\n            break;\n        }\n      }\n      return result;\n    };\n    /**\n      * Parses sample information out of Track Run Boxes and calculates\n      * the absolute presentation and decode timestamps of each sample.\n      *\n      * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n      * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\n          @see ISO-BMFF-12/2015, Section 8.8.12\n      * @param {Object} tfhd - The parsed Track Fragment Header\n      *   @see inspect.parseTfhd\n      * @return {Object[]} the parsed samples\n      *\n      * @see ISO-BMFF-12/2015, Section 8.8.8\n     **/\n\n    var parseSamples = function (truns, baseMediaDecodeTime, tfhd) {\n      var currentDts = baseMediaDecodeTime;\n      var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n      var defaultSampleSize = tfhd.defaultSampleSize || 0;\n      var trackId = tfhd.trackId;\n      var allSamples = [];\n      truns.forEach(function (trun) {\n        // Note: We currently do not parse the sample table as well\n        // as the trun. It's possible some sources will require this.\n        // moov > trak > mdia > minf > stbl\n        var trackRun = parseTrun$1(trun);\n        var samples = trackRun.samples;\n        samples.forEach(function (sample) {\n          if (sample.duration === undefined) {\n            sample.duration = defaultSampleDuration;\n          }\n          if (sample.size === undefined) {\n            sample.size = defaultSampleSize;\n          }\n          sample.trackId = trackId;\n          sample.dts = currentDts;\n          if (sample.compositionTimeOffset === undefined) {\n            sample.compositionTimeOffset = 0;\n          }\n          if (typeof currentDts === 'bigint') {\n            sample.pts = currentDts + window$2.BigInt(sample.compositionTimeOffset);\n            currentDts += window$2.BigInt(sample.duration);\n          } else {\n            sample.pts = currentDts + sample.compositionTimeOffset;\n            currentDts += sample.duration;\n          }\n        });\n        allSamples = allSamples.concat(samples);\n      });\n      return allSamples;\n    };\n    /**\n      * Parses out caption nals from an FMP4 segment's video tracks.\n      *\n      * @param {Uint8Array} segment - The bytes of a single segment\n      * @param {Number} videoTrackId - The trackId of a video track in the segment\n      * @return {Object.<Number, Object[]>} A mapping of video trackId to\n      *   a list of seiNals found in that track\n     **/\n\n    var parseCaptionNals = function (segment, videoTrackId) {\n      // To get the samples\n      var trafs = findBox$1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n      var mdats = findBox$1(segment, ['mdat']);\n      var captionNals = {};\n      var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n      mdats.forEach(function (mdat, index) {\n        var matchingTraf = trafs[index];\n        mdatTrafPairs.push({\n          mdat: mdat,\n          traf: matchingTraf\n        });\n      });\n      mdatTrafPairs.forEach(function (pair) {\n        var mdat = pair.mdat;\n        var traf = pair.traf;\n        var tfhd = findBox$1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n        var headerInfo = parseTfhd$1(tfhd[0]);\n        var trackId = headerInfo.trackId;\n        var tfdt = findBox$1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n        var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt$1(tfdt[0]).baseMediaDecodeTime : 0;\n        var truns = findBox$1(traf, ['trun']);\n        var samples;\n        var result; // Only parse video data for the chosen video track\n\n        if (videoTrackId === trackId && truns.length > 0) {\n          samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n          result = findSeiNals(mdat, samples, trackId);\n          if (!captionNals[trackId]) {\n            captionNals[trackId] = {\n              seiNals: [],\n              logs: []\n            };\n          }\n          captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n          captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n        }\n      });\n      return captionNals;\n    };\n    /**\n      * Parses out inband captions from an MP4 container and returns\n      * caption objects that can be used by WebVTT and the TextTrack API.\n      * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n      * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n      * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n      *\n      * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n      * @param {Number} trackId - The id of the video track to parse\n      * @param {Number} timescale - The timescale for the video track from the init segment\n      *\n      * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n      * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n      * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n      * @return {String} parsedCaptions[].text - The visible content of the caption\n     **/\n\n    var parseEmbeddedCaptions = function (segment, trackId, timescale) {\n      var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n      if (trackId === null) {\n        return null;\n      }\n      captionNals = parseCaptionNals(segment, trackId);\n      var trackNals = captionNals[trackId] || {};\n      return {\n        seiNals: trackNals.seiNals,\n        logs: trackNals.logs,\n        timescale: timescale\n      };\n    };\n    /**\n      * Converts SEI NALUs into captions that can be used by video.js\n     **/\n\n    var CaptionParser = function () {\n      var isInitialized = false;\n      var captionStream; // Stores segments seen before trackId and timescale are set\n\n      var segmentCache; // Stores video track ID of the track being parsed\n\n      var trackId; // Stores the timescale of the track being parsed\n\n      var timescale; // Stores captions parsed so far\n\n      var parsedCaptions; // Stores whether we are receiving partial data or not\n\n      var parsingPartial;\n      /**\n        * A method to indicate whether a CaptionParser has been initalized\n        * @returns {Boolean}\n       **/\n\n      this.isInitialized = function () {\n        return isInitialized;\n      };\n      /**\n        * Initializes the underlying CaptionStream, SEI NAL parsing\n        * and management, and caption collection\n       **/\n\n      this.init = function (options) {\n        captionStream = new CaptionStream();\n        isInitialized = true;\n        parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n        captionStream.on('data', function (event) {\n          // Convert to seconds in the source's timescale\n          event.startTime = event.startPts / timescale;\n          event.endTime = event.endPts / timescale;\n          parsedCaptions.captions.push(event);\n          parsedCaptions.captionStreams[event.stream] = true;\n        });\n        captionStream.on('log', function (log) {\n          parsedCaptions.logs.push(log);\n        });\n      };\n      /**\n        * Determines if a new video track will be selected\n        * or if the timescale changed\n        * @return {Boolean}\n       **/\n\n      this.isNewInit = function (videoTrackIds, timescales) {\n        if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n          return false;\n        }\n        return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n      };\n      /**\n        * Parses out SEI captions and interacts with underlying\n        * CaptionStream to return dispatched captions\n        *\n        * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n        * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n        * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n        * @see parseEmbeddedCaptions\n        * @see m2ts/caption-stream.js\n       **/\n\n      this.parse = function (segment, videoTrackIds, timescales) {\n        var parsedData;\n        if (!this.isInitialized()) {\n          return null; // This is not likely to be a video segment\n        } else if (!videoTrackIds || !timescales) {\n          return null;\n        } else if (this.isNewInit(videoTrackIds, timescales)) {\n          // Use the first video track only as there is no\n          // mechanism to switch to other video tracks\n          trackId = videoTrackIds[0];\n          timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n          // data until we have one.\n          // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n        } else if (trackId === null || !timescale) {\n          segmentCache.push(segment);\n          return null;\n        } // Now that a timescale and trackId is set, parse cached segments\n\n        while (segmentCache.length > 0) {\n          var cachedSegment = segmentCache.shift();\n          this.parse(cachedSegment, videoTrackIds, timescales);\n        }\n        parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n        if (parsedData && parsedData.logs) {\n          parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n        }\n        if (parsedData === null || !parsedData.seiNals) {\n          if (parsedCaptions.logs.length) {\n            return {\n              logs: parsedCaptions.logs,\n              captions: [],\n              captionStreams: []\n            };\n          }\n          return null;\n        }\n        this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n        this.flushStream();\n        return parsedCaptions;\n      };\n      /**\n        * Pushes SEI NALUs onto CaptionStream\n        * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n        * Assumes that `parseCaptionNals` has been called first\n        * @see m2ts/caption-stream.js\n        **/\n\n      this.pushNals = function (nals) {\n        if (!this.isInitialized() || !nals || nals.length === 0) {\n          return null;\n        }\n        nals.forEach(function (nal) {\n          captionStream.push(nal);\n        });\n      };\n      /**\n        * Flushes underlying CaptionStream to dispatch processed, displayable captions\n        * @see m2ts/caption-stream.js\n       **/\n\n      this.flushStream = function () {\n        if (!this.isInitialized()) {\n          return null;\n        }\n        if (!parsingPartial) {\n          captionStream.flush();\n        } else {\n          captionStream.partialFlush();\n        }\n      };\n      /**\n        * Reset caption buckets for new data\n       **/\n\n      this.clearParsedCaptions = function () {\n        parsedCaptions.captions = [];\n        parsedCaptions.captionStreams = {};\n        parsedCaptions.logs = [];\n      };\n      /**\n        * Resets underlying CaptionStream\n        * @see m2ts/caption-stream.js\n       **/\n\n      this.resetCaptionStream = function () {\n        if (!this.isInitialized()) {\n          return null;\n        }\n        captionStream.reset();\n      };\n      /**\n        * Convenience method to clear all captions flushed from the\n        * CaptionStream and still being parsed\n        * @see m2ts/caption-stream.js\n       **/\n\n      this.clearAllCaptions = function () {\n        this.clearParsedCaptions();\n        this.resetCaptionStream();\n      };\n      /**\n        * Reset caption parser\n       **/\n\n      this.reset = function () {\n        segmentCache = [];\n        trackId = null;\n        timescale = null;\n        if (!parsedCaptions) {\n          parsedCaptions = {\n            captions: [],\n            // CC1, CC2, CC3, CC4\n            captionStreams: {},\n            logs: []\n          };\n        } else {\n          this.clearParsedCaptions();\n        }\n        this.resetCaptionStream();\n      };\n      this.reset();\n    };\n    var captionParser = CaptionParser;\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Utilities to detect basic properties and metadata about MP4s.\n     */\n\n    var toUnsigned = bin.toUnsigned;\n    var toHexString = bin.toHexString;\n    var findBox = findBox_1;\n    var parseType$1 = parseType_1;\n    var parseTfhd = parseTfhd$2;\n    var parseTrun = parseTrun$2;\n    var parseTfdt = parseTfdt$2;\n    var getUint64 = numbers.getUint64;\n    var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;\n    var window$1 = window_1;\n    /**\n     * Parses an MP4 initialization segment and extracts the timescale\n     * values for any declared tracks. Timescale values indicate the\n     * number of clock ticks per second to assume for time-based values\n     * elsewhere in the MP4.\n     *\n     * To determine the start time of an MP4, you need two pieces of\n     * information: the timescale unit and the earliest base media decode\n     * time. Multiple timescales can be specified within an MP4 but the\n     * base media decode time is always expressed in the timescale from\n     * the media header box for the track:\n     * ```\n     * moov > trak > mdia > mdhd.timescale\n     * ```\n     * @param init {Uint8Array} the bytes of the init segment\n     * @return {object} a hash of track ids to timescale values or null if\n     * the init segment is malformed.\n     */\n\n    timescale = function (init) {\n      var result = {},\n        traks = findBox(init, ['moov', 'trak']); // mdhd timescale\n\n      return traks.reduce(function (result, trak) {\n        var tkhd, version, index, id, mdhd;\n        tkhd = findBox(trak, ['tkhd'])[0];\n        if (!tkhd) {\n          return null;\n        }\n        version = tkhd[0];\n        index = version === 0 ? 12 : 20;\n        id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n        mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n        if (!mdhd) {\n          return null;\n        }\n        version = mdhd[0];\n        index = version === 0 ? 12 : 20;\n        result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n        return result;\n      }, result);\n    };\n    /**\n     * Determine the base media decode start time, in seconds, for an MP4\n     * fragment. If multiple fragments are specified, the earliest time is\n     * returned.\n     *\n     * The base media decode time can be parsed from track fragment\n     * metadata:\n     * ```\n     * moof > traf > tfdt.baseMediaDecodeTime\n     * ```\n     * It requires the timescale value from the mdhd to interpret.\n     *\n     * @param timescale {object} a hash of track ids to timescale values.\n     * @return {number} the earliest base media decode start time for the\n     * fragment, in seconds\n     */\n\n    startTime = function (timescale, fragment) {\n      var trafs; // we need info from two childrend of each track fragment box\n\n      trafs = findBox(fragment, ['moof', 'traf']); // determine the start times for each track\n\n      var lowestTime = trafs.reduce(function (acc, traf) {\n        var tfhd = findBox(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n        var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n        var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n        var tfdt = findBox(traf, ['tfdt'])[0];\n        var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\n        var baseTime; // version 1 is 64 bit\n\n        if (tfdt[0] === 1) {\n          baseTime = getUint64(tfdt.subarray(4, 12));\n        } else {\n          baseTime = dv.getUint32(4);\n        } // convert base time to seconds if it is a valid number.\n\n        let seconds;\n        if (typeof baseTime === 'bigint') {\n          seconds = baseTime / window$1.BigInt(scale);\n        } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\n          seconds = baseTime / scale;\n        }\n        if (seconds < Number.MAX_SAFE_INTEGER) {\n          seconds = Number(seconds);\n        }\n        if (seconds < acc) {\n          acc = seconds;\n        }\n        return acc;\n      }, Infinity);\n      return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\n    };\n    /**\n     * Determine the composition start, in seconds, for an MP4\n     * fragment.\n     *\n     * The composition start time of a fragment can be calculated using the base\n     * media decode time, composition time offset, and timescale, as follows:\n     *\n     * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n     *\n     * All of the aforementioned information is contained within a media fragment's\n     * `traf` box, except for timescale info, which comes from the initialization\n     * segment, so a track id (also contained within a `traf`) is also necessary to\n     * associate it with a timescale\n     *\n     *\n     * @param timescales {object} - a hash of track ids to timescale values.\n     * @param fragment {Unit8Array} - the bytes of a media segment\n     * @return {number} the composition start time for the fragment, in seconds\n     **/\n\n    compositionStartTime = function (timescales, fragment) {\n      var trafBoxes = findBox(fragment, ['moof', 'traf']);\n      var baseMediaDecodeTime = 0;\n      var compositionTimeOffset = 0;\n      var trackId;\n      if (trafBoxes && trafBoxes.length) {\n        // The spec states that track run samples contained within a `traf` box are contiguous, but\n        // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n        // We will assume that they are, so we only need the first to calculate start time.\n        var tfhd = findBox(trafBoxes[0], ['tfhd'])[0];\n        var trun = findBox(trafBoxes[0], ['trun'])[0];\n        var tfdt = findBox(trafBoxes[0], ['tfdt'])[0];\n        if (tfhd) {\n          var parsedTfhd = parseTfhd(tfhd);\n          trackId = parsedTfhd.trackId;\n        }\n        if (tfdt) {\n          var parsedTfdt = parseTfdt(tfdt);\n          baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n        }\n        if (trun) {\n          var parsedTrun = parseTrun(trun);\n          if (parsedTrun.samples && parsedTrun.samples.length) {\n            compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n          }\n        }\n      } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n      // specified.\n\n      var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n      if (typeof baseMediaDecodeTime === 'bigint') {\n        compositionTimeOffset = window$1.BigInt(compositionTimeOffset);\n        timescale = window$1.BigInt(timescale);\n      }\n      var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n      if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\n        result = Number(result);\n      }\n      return result;\n    };\n    /**\n      * Find the trackIds of the video tracks in this source.\n      * Found by parsing the Handler Reference and Track Header Boxes:\n      *   moov > trak > mdia > hdlr\n      *   moov > trak > tkhd\n      *\n      * @param {Uint8Array} init - The bytes of the init segment for this source\n      * @return {Number[]} A list of trackIds\n      *\n      * @see ISO-BMFF-12/2015, Section 8.4.3\n     **/\n\n    getVideoTrackIds = function (init) {\n      var traks = findBox(init, ['moov', 'trak']);\n      var videoTrackIds = [];\n      traks.forEach(function (trak) {\n        var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n        var tkhds = findBox(trak, ['tkhd']);\n        hdlrs.forEach(function (hdlr, index) {\n          var handlerType = parseType$1(hdlr.subarray(8, 12));\n          var tkhd = tkhds[index];\n          var view;\n          var version;\n          var trackId;\n          if (handlerType === 'vide') {\n            view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n            version = view.getUint8(0);\n            trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n            videoTrackIds.push(trackId);\n          }\n        });\n      });\n      return videoTrackIds;\n    };\n    getTimescaleFromMediaHeader = function (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n    };\n    /**\n     * Get all the video, audio, and hint tracks from a non fragmented\n     * mp4 segment\n     */\n\n    getTracks = function (init) {\n      var traks = findBox(init, ['moov', 'trak']);\n      var tracks = [];\n      traks.forEach(function (trak) {\n        var track = {};\n        var tkhd = findBox(trak, ['tkhd'])[0];\n        var view, tkhdVersion; // id\n\n        if (tkhd) {\n          view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n          tkhdVersion = view.getUint8(0);\n          track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n        }\n        var hdlr = findBox(trak, ['mdia', 'hdlr'])[0]; // type\n\n        if (hdlr) {\n          var type = parseType$1(hdlr.subarray(8, 12));\n          if (type === 'vide') {\n            track.type = 'video';\n          } else if (type === 'soun') {\n            track.type = 'audio';\n          } else {\n            track.type = type;\n          }\n        } // codec\n\n        var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n        if (stsd) {\n          var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n          track.codec = parseType$1(sampleDescriptions.subarray(4, 8));\n          var codecBox = findBox(sampleDescriptions, [track.codec])[0];\n          var codecConfig, codecConfigType;\n          if (codecBox) {\n            // https://tools.ietf.org/html/rfc6381#section-3.3\n            if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n              // we don't need anything but the \"config\" parameter of the\n              // avc1 codecBox\n              codecConfig = codecBox.subarray(78);\n              codecConfigType = parseType$1(codecConfig.subarray(4, 8));\n              if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n                track.codec += '.'; // left padded with zeroes for single digit hex\n                // profile idc\n\n                track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n                track.codec += toHexString(codecConfig[10]); // level idc\n\n                track.codec += toHexString(codecConfig[11]);\n              } else {\n                // TODO: show a warning that we couldn't parse the codec\n                // and are using the default\n                track.codec = 'avc1.4d400d';\n              }\n            } else if (/^mp4[a,v]$/i.test(track.codec)) {\n              // we do not need anything but the streamDescriptor of the mp4a codecBox\n              codecConfig = codecBox.subarray(28);\n              codecConfigType = parseType$1(codecConfig.subarray(4, 8));\n              if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n                track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n                track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n              } else {\n                // TODO: show a warning that we couldn't parse the codec\n                // and are using the default\n                track.codec = 'mp4a.40.2';\n              }\n            } else {\n              // flac, opus, etc\n              track.codec = track.codec.toLowerCase();\n            }\n          }\n        }\n        var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n        if (mdhd) {\n          track.timescale = getTimescaleFromMediaHeader(mdhd);\n        }\n        tracks.push(track);\n      });\n      return tracks;\n    };\n    var probe$2 = {\n      // export mp4 inspector's findBox and parseType for backwards compatibility\n      findBox: findBox,\n      parseType: parseType$1,\n      timescale: timescale,\n      startTime: startTime,\n      compositionStartTime: compositionStartTime,\n      videoTrackIds: getVideoTrackIds,\n      tracks: getTracks,\n      getTimescaleFromMediaHeader: getTimescaleFromMediaHeader\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Utilities to detect basic properties and metadata about TS Segments.\n     */\n\n    var StreamTypes$1 = streamTypes;\n    var parsePid = function (packet) {\n      var pid = packet[1] & 0x1f;\n      pid <<= 8;\n      pid |= packet[2];\n      return pid;\n    };\n    var parsePayloadUnitStartIndicator = function (packet) {\n      return !!(packet[1] & 0x40);\n    };\n    var parseAdaptionField = function (packet) {\n      var offset = 0; // if an adaption field is present, its length is specified by the\n      // fifth byte of the TS packet header. The adaptation field is\n      // used to add stuffing to PES packets that don't fill a complete\n      // TS packet, and to specify some forms of timing and control data\n      // that we do not currently use.\n\n      if ((packet[3] & 0x30) >>> 4 > 0x01) {\n        offset += packet[4] + 1;\n      }\n      return offset;\n    };\n    var parseType = function (packet, pmtPid) {\n      var pid = parsePid(packet);\n      if (pid === 0) {\n        return 'pat';\n      } else if (pid === pmtPid) {\n        return 'pmt';\n      } else if (pmtPid) {\n        return 'pes';\n      }\n      return null;\n    };\n    var parsePat = function (packet) {\n      var pusi = parsePayloadUnitStartIndicator(packet);\n      var offset = 4 + parseAdaptionField(packet);\n      if (pusi) {\n        offset += packet[offset] + 1;\n      }\n      return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n    };\n    var parsePmt = function (packet) {\n      var programMapTable = {};\n      var pusi = parsePayloadUnitStartIndicator(packet);\n      var payloadOffset = 4 + parseAdaptionField(packet);\n      if (pusi) {\n        payloadOffset += packet[payloadOffset] + 1;\n      } // PMTs can be sent ahead of the time when they should actually\n      // take effect. We don't believe this should ever be the case\n      // for HLS but we'll ignore \"forward\" PMT declarations if we see\n      // them. Future PMT declarations have the current_next_indicator\n      // set to zero.\n\n      if (!(packet[payloadOffset + 5] & 0x01)) {\n        return;\n      }\n      var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n      sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n      tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n\n      programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n      var offset = 12 + programInfoLength;\n      while (offset < tableEnd) {\n        var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n        programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n\n        offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n      }\n      return programMapTable;\n    };\n    var parsePesType = function (packet, programMapTable) {\n      var pid = parsePid(packet);\n      var type = programMapTable[pid];\n      switch (type) {\n        case StreamTypes$1.H264_STREAM_TYPE:\n          return 'video';\n        case StreamTypes$1.ADTS_STREAM_TYPE:\n          return 'audio';\n        case StreamTypes$1.METADATA_STREAM_TYPE:\n          return 'timed-metadata';\n        default:\n          return null;\n      }\n    };\n    var parsePesTime = function (packet) {\n      var pusi = parsePayloadUnitStartIndicator(packet);\n      if (!pusi) {\n        return null;\n      }\n      var offset = 4 + parseAdaptionField(packet);\n      if (offset >= packet.byteLength) {\n        // From the H 222.0 MPEG-TS spec\n        // \"For transport stream packets carrying PES packets, stuffing is needed when there\n        //  is insufficient PES packet data to completely fill the transport stream packet\n        //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n        //  the sum of the lengths of the data elements in it, so that the payload bytes\n        //  remaining after the adaptation field exactly accommodates the available PES packet\n        //  data.\"\n        //\n        // If the offset is >= the length of the packet, then the packet contains no data\n        // and instead is just adaption field stuffing bytes\n        return null;\n      }\n      var pes = null;\n      var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n\n      ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n\n      if (ptsDtsFlags & 0xC0) {\n        pes = {}; // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n        pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n        pes.pts *= 4; // Left shift by 2\n\n        pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n        pes.dts = pes.pts;\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n\n          pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      }\n\n      return pes;\n    };\n    var parseNalUnitType = function (type) {\n      switch (type) {\n        case 0x05:\n          return 'slice_layer_without_partitioning_rbsp_idr';\n        case 0x06:\n          return 'sei_rbsp';\n        case 0x07:\n          return 'seq_parameter_set_rbsp';\n        case 0x08:\n          return 'pic_parameter_set_rbsp';\n        case 0x09:\n          return 'access_unit_delimiter_rbsp';\n        default:\n          return null;\n      }\n    };\n    var videoPacketContainsKeyFrame = function (packet) {\n      var offset = 4 + parseAdaptionField(packet);\n      var frameBuffer = packet.subarray(offset);\n      var frameI = 0;\n      var frameSyncPoint = 0;\n      var foundKeyFrame = false;\n      var nalType; // advance the sync point to a NAL start, if necessary\n\n      for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n        if (frameBuffer[frameSyncPoint + 2] === 1) {\n          // the sync point is properly aligned\n          frameI = frameSyncPoint + 5;\n          break;\n        }\n      }\n      while (frameI < frameBuffer.byteLength) {\n        // look at the current byte to determine if we've hit the end of\n        // a NAL unit boundary\n        switch (frameBuffer[frameI]) {\n          case 0:\n            // skip past non-sync sequences\n            if (frameBuffer[frameI - 1] !== 0) {\n              frameI += 2;\n              break;\n            } else if (frameBuffer[frameI - 2] !== 0) {\n              frameI++;\n              break;\n            }\n            if (frameSyncPoint + 3 !== frameI - 2) {\n              nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n              if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                foundKeyFrame = true;\n              }\n            } // drop trailing zeroes\n\n            do {\n              frameI++;\n            } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n            frameSyncPoint = frameI - 2;\n            frameI += 3;\n            break;\n          case 1:\n            // skip past non-sync sequences\n            if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n              frameI += 3;\n              break;\n            }\n            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n              foundKeyFrame = true;\n            }\n            frameSyncPoint = frameI - 2;\n            frameI += 3;\n            break;\n          default:\n            // the current byte isn't a one or zero, so it cannot be part\n            // of a sync sequence\n            frameI += 3;\n            break;\n        }\n      }\n      frameBuffer = frameBuffer.subarray(frameSyncPoint);\n      frameI -= frameSyncPoint;\n      frameSyncPoint = 0; // parse the final nal\n\n      if (frameBuffer && frameBuffer.byteLength > 3) {\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n      }\n      return foundKeyFrame;\n    };\n    var probe$1 = {\n      parseType: parseType,\n      parsePat: parsePat,\n      parsePmt: parsePmt,\n      parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n      parsePesType: parsePesType,\n      parsePesTime: parsePesTime,\n      videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n    };\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     *\n     * Parse mpeg2 transport stream packets to extract basic timing information\n     */\n\n    var StreamTypes = streamTypes;\n    var handleRollover = timestampRolloverStream.handleRollover;\n    var probe = {};\n    probe.ts = probe$1;\n    probe.aac = utils;\n    var ONE_SECOND_IN_TS = clock$2.ONE_SECOND_IN_TS;\n    var MP2T_PACKET_LENGTH = 188,\n      // bytes\n      SYNC_BYTE = 0x47;\n    /**\n     * walks through segment data looking for pat and pmt packets to parse out\n     * program map table information\n     */\n\n    var parsePsi_ = function (bytes, pmt) {\n      var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type;\n      while (endIndex < bytes.byteLength) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n          // We found a packet\n          packet = bytes.subarray(startIndex, endIndex);\n          type = probe.ts.parseType(packet, pmt.pid);\n          switch (type) {\n            case 'pat':\n              pmt.pid = probe.ts.parsePat(packet);\n              break;\n            case 'pmt':\n              var table = probe.ts.parsePmt(packet);\n              pmt.table = pmt.table || {};\n              Object.keys(table).forEach(function (key) {\n                pmt.table[key] = table[key];\n              });\n              break;\n          }\n          startIndex += MP2T_PACKET_LENGTH;\n          endIndex += MP2T_PACKET_LENGTH;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n        startIndex++;\n        endIndex++;\n      }\n    };\n    /**\n     * walks through the segment data from the start and end to get timing information\n     * for the first and last audio pes packets\n     */\n\n    var parseAudioPes_ = function (bytes, pmt, result) {\n      var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed;\n      var endLoop = false; // Start walking from start of segment to get first audio packet\n\n      while (endIndex <= bytes.byteLength) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n          // We found a packet\n          packet = bytes.subarray(startIndex, endIndex);\n          type = probe.ts.parseType(packet, pmt.pid);\n          switch (type) {\n            case 'pes':\n              pesType = probe.ts.parsePesType(packet, pmt.table);\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n              if (pesType === 'audio' && pusi) {\n                parsed = probe.ts.parsePesTime(packet);\n                if (parsed) {\n                  parsed.type = 'audio';\n                  result.audio.push(parsed);\n                  endLoop = true;\n                }\n              }\n              break;\n          }\n          if (endLoop) {\n            break;\n          }\n          startIndex += MP2T_PACKET_LENGTH;\n          endIndex += MP2T_PACKET_LENGTH;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n        startIndex++;\n        endIndex++;\n      } // Start walking from end of segment to get last audio packet\n\n      endIndex = bytes.byteLength;\n      startIndex = endIndex - MP2T_PACKET_LENGTH;\n      endLoop = false;\n      while (startIndex >= 0) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n          // We found a packet\n          packet = bytes.subarray(startIndex, endIndex);\n          type = probe.ts.parseType(packet, pmt.pid);\n          switch (type) {\n            case 'pes':\n              pesType = probe.ts.parsePesType(packet, pmt.table);\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n              if (pesType === 'audio' && pusi) {\n                parsed = probe.ts.parsePesTime(packet);\n                if (parsed) {\n                  parsed.type = 'audio';\n                  result.audio.push(parsed);\n                  endLoop = true;\n                }\n              }\n              break;\n          }\n          if (endLoop) {\n            break;\n          }\n          startIndex -= MP2T_PACKET_LENGTH;\n          endIndex -= MP2T_PACKET_LENGTH;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n        startIndex--;\n        endIndex--;\n      }\n    };\n    /**\n     * walks through the segment data from the start and end to get timing information\n     * for the first and last video pes packets as well as timing information for the first\n     * key frame.\n     */\n\n    var parseVideoPes_ = function (bytes, pmt, result) {\n      var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed,\n        frame,\n        i,\n        pes;\n      var endLoop = false;\n      var currentFrame = {\n        data: [],\n        size: 0\n      }; // Start walking from start of segment to get first video packet\n\n      while (endIndex < bytes.byteLength) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n          // We found a packet\n          packet = bytes.subarray(startIndex, endIndex);\n          type = probe.ts.parseType(packet, pmt.pid);\n          switch (type) {\n            case 'pes':\n              pesType = probe.ts.parsePesType(packet, pmt.table);\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n              if (pesType === 'video') {\n                if (pusi && !endLoop) {\n                  parsed = probe.ts.parsePesTime(packet);\n                  if (parsed) {\n                    parsed.type = 'video';\n                    result.video.push(parsed);\n                    endLoop = true;\n                  }\n                }\n                if (!result.firstKeyFrame) {\n                  if (pusi) {\n                    if (currentFrame.size !== 0) {\n                      frame = new Uint8Array(currentFrame.size);\n                      i = 0;\n                      while (currentFrame.data.length) {\n                        pes = currentFrame.data.shift();\n                        frame.set(pes, i);\n                        i += pes.byteLength;\n                      }\n                      if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                        var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                        // the keyframe seems to work fine with HLS playback\n                        // and definitely preferable to a crash with TypeError...\n\n                        if (firstKeyFrame) {\n                          result.firstKeyFrame = firstKeyFrame;\n                          result.firstKeyFrame.type = 'video';\n                        } else {\n                          // eslint-disable-next-line\n                          console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                        }\n                      }\n                      currentFrame.size = 0;\n                    }\n                  }\n                  currentFrame.data.push(packet);\n                  currentFrame.size += packet.byteLength;\n                }\n              }\n              break;\n          }\n          if (endLoop && result.firstKeyFrame) {\n            break;\n          }\n          startIndex += MP2T_PACKET_LENGTH;\n          endIndex += MP2T_PACKET_LENGTH;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n        startIndex++;\n        endIndex++;\n      } // Start walking from end of segment to get last video packet\n\n      endIndex = bytes.byteLength;\n      startIndex = endIndex - MP2T_PACKET_LENGTH;\n      endLoop = false;\n      while (startIndex >= 0) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n          // We found a packet\n          packet = bytes.subarray(startIndex, endIndex);\n          type = probe.ts.parseType(packet, pmt.pid);\n          switch (type) {\n            case 'pes':\n              pesType = probe.ts.parsePesType(packet, pmt.table);\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n              if (pesType === 'video' && pusi) {\n                parsed = probe.ts.parsePesTime(packet);\n                if (parsed) {\n                  parsed.type = 'video';\n                  result.video.push(parsed);\n                  endLoop = true;\n                }\n              }\n              break;\n          }\n          if (endLoop) {\n            break;\n          }\n          startIndex -= MP2T_PACKET_LENGTH;\n          endIndex -= MP2T_PACKET_LENGTH;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n        startIndex--;\n        endIndex--;\n      }\n    };\n    /**\n     * Adjusts the timestamp information for the segment to account for\n     * rollover and convert to seconds based on pes packet timescale (90khz clock)\n     */\n\n    var adjustTimestamp_ = function (segmentInfo, baseTimestamp) {\n      if (segmentInfo.audio && segmentInfo.audio.length) {\n        var audioBaseTimestamp = baseTimestamp;\n        if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n          audioBaseTimestamp = segmentInfo.audio[0].dts;\n        }\n        segmentInfo.audio.forEach(function (info) {\n          info.dts = handleRollover(info.dts, audioBaseTimestamp);\n          info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n          info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n          info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n        });\n      }\n      if (segmentInfo.video && segmentInfo.video.length) {\n        var videoBaseTimestamp = baseTimestamp;\n        if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n          videoBaseTimestamp = segmentInfo.video[0].dts;\n        }\n        segmentInfo.video.forEach(function (info) {\n          info.dts = handleRollover(info.dts, videoBaseTimestamp);\n          info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n          info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n          info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n        });\n        if (segmentInfo.firstKeyFrame) {\n          var frame = segmentInfo.firstKeyFrame;\n          frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n          frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n          frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n          frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n        }\n      }\n    };\n    /**\n     * inspects the aac data stream for start and end time information\n     */\n\n    var inspectAac_ = function (bytes) {\n      var endLoop = false,\n        audioCount = 0,\n        sampleRate = null,\n        timestamp = null,\n        frameSize = 0,\n        byteIndex = 0,\n        packet;\n      while (bytes.length - byteIndex >= 3) {\n        var type = probe.aac.parseType(bytes, byteIndex);\n        switch (type) {\n          case 'timed-metadata':\n            // Exit early because we don't have enough to parse\n            // the ID3 tag header\n            if (bytes.length - byteIndex < 10) {\n              endLoop = true;\n              break;\n            }\n            frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n\n            if (frameSize > bytes.length) {\n              endLoop = true;\n              break;\n            }\n            if (timestamp === null) {\n              packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n              timestamp = probe.aac.parseAacTimestamp(packet);\n            }\n            byteIndex += frameSize;\n            break;\n          case 'audio':\n            // Exit early because we don't have enough to parse\n            // the ADTS frame header\n            if (bytes.length - byteIndex < 7) {\n              endLoop = true;\n              break;\n            }\n            frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n\n            if (frameSize > bytes.length) {\n              endLoop = true;\n              break;\n            }\n            if (sampleRate === null) {\n              packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n              sampleRate = probe.aac.parseSampleRate(packet);\n            }\n            audioCount++;\n            byteIndex += frameSize;\n            break;\n          default:\n            byteIndex++;\n            break;\n        }\n        if (endLoop) {\n          return null;\n        }\n      }\n      if (sampleRate === null || timestamp === null) {\n        return null;\n      }\n      var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n      var result = {\n        audio: [{\n          type: 'audio',\n          dts: timestamp,\n          pts: timestamp\n        }, {\n          type: 'audio',\n          dts: timestamp + audioCount * 1024 * audioTimescale,\n          pts: timestamp + audioCount * 1024 * audioTimescale\n        }]\n      };\n      return result;\n    };\n    /**\n     * inspects the transport stream segment data for start and end time information\n     * of the audio and video tracks (when present) as well as the first key frame's\n     * start time.\n     */\n\n    var inspectTs_ = function (bytes) {\n      var pmt = {\n        pid: null,\n        table: null\n      };\n      var result = {};\n      parsePsi_(bytes, pmt);\n      for (var pid in pmt.table) {\n        if (pmt.table.hasOwnProperty(pid)) {\n          var type = pmt.table[pid];\n          switch (type) {\n            case StreamTypes.H264_STREAM_TYPE:\n              result.video = [];\n              parseVideoPes_(bytes, pmt, result);\n              if (result.video.length === 0) {\n                delete result.video;\n              }\n              break;\n            case StreamTypes.ADTS_STREAM_TYPE:\n              result.audio = [];\n              parseAudioPes_(bytes, pmt, result);\n              if (result.audio.length === 0) {\n                delete result.audio;\n              }\n              break;\n          }\n        }\n      }\n      return result;\n    };\n    /**\n     * Inspects segment byte data and returns an object with start and end timing information\n     *\n     * @param {Uint8Array} bytes The segment byte data\n     * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n     *  timestamps for rollover. This value must be in 90khz clock.\n     * @return {Object} Object containing start and end frame timing info of segment.\n     */\n\n    var inspect = function (bytes, baseTimestamp) {\n      var isAacData = probe.aac.isLikelyAacData(bytes);\n      var result;\n      if (isAacData) {\n        result = inspectAac_(bytes);\n      } else {\n        result = inspectTs_(bytes);\n      }\n      if (!result || !result.audio && !result.video) {\n        return null;\n      }\n      adjustTimestamp_(result, baseTimestamp);\n      return result;\n    };\n    var tsInspector = {\n      inspect: inspect,\n      parseAudioPes_: parseAudioPes_\n    };\n    /* global self */\n\n    /**\n     * Re-emits transmuxer events by converting them into messages to the\n     * world outside the worker.\n     *\n     * @param {Object} transmuxer the transmuxer to wire events on\n     * @private\n     */\n\n    const wireTransmuxerEvents = function (self, transmuxer) {\n      transmuxer.on('data', function (segment) {\n        // transfer ownership of the underlying ArrayBuffer\n        // instead of doing a copy to save memory\n        // ArrayBuffers are transferable but generic TypedArrays are not\n        // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n        const initArray = segment.initSegment;\n        segment.initSegment = {\n          data: initArray.buffer,\n          byteOffset: initArray.byteOffset,\n          byteLength: initArray.byteLength\n        };\n        const typedArray = segment.data;\n        segment.data = typedArray.buffer;\n        self.postMessage({\n          action: 'data',\n          segment,\n          byteOffset: typedArray.byteOffset,\n          byteLength: typedArray.byteLength\n        }, [segment.data]);\n      });\n      transmuxer.on('done', function (data) {\n        self.postMessage({\n          action: 'done'\n        });\n      });\n      transmuxer.on('gopInfo', function (gopInfo) {\n        self.postMessage({\n          action: 'gopInfo',\n          gopInfo\n        });\n      });\n      transmuxer.on('videoSegmentTimingInfo', function (timingInfo) {\n        const videoSegmentTimingInfo = {\n          start: {\n            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),\n            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)\n          },\n          end: {\n            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),\n            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)\n          },\n          baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\n        };\n        if (timingInfo.prependedContentDuration) {\n          videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);\n        }\n        self.postMessage({\n          action: 'videoSegmentTimingInfo',\n          videoSegmentTimingInfo\n        });\n      });\n      transmuxer.on('audioSegmentTimingInfo', function (timingInfo) {\n        // Note that all times for [audio/video]SegmentTimingInfo events are in video clock\n        const audioSegmentTimingInfo = {\n          start: {\n            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),\n            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)\n          },\n          end: {\n            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),\n            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)\n          },\n          baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\n        };\n        if (timingInfo.prependedContentDuration) {\n          audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);\n        }\n        self.postMessage({\n          action: 'audioSegmentTimingInfo',\n          audioSegmentTimingInfo\n        });\n      });\n      transmuxer.on('id3Frame', function (id3Frame) {\n        self.postMessage({\n          action: 'id3Frame',\n          id3Frame\n        });\n      });\n      transmuxer.on('caption', function (caption) {\n        self.postMessage({\n          action: 'caption',\n          caption\n        });\n      });\n      transmuxer.on('trackinfo', function (trackInfo) {\n        self.postMessage({\n          action: 'trackinfo',\n          trackInfo\n        });\n      });\n      transmuxer.on('audioTimingInfo', function (audioTimingInfo) {\n        // convert to video TS since we prioritize video time over audio\n        self.postMessage({\n          action: 'audioTimingInfo',\n          audioTimingInfo: {\n            start: clock$2.videoTsToSeconds(audioTimingInfo.start),\n            end: clock$2.videoTsToSeconds(audioTimingInfo.end)\n          }\n        });\n      });\n      transmuxer.on('videoTimingInfo', function (videoTimingInfo) {\n        self.postMessage({\n          action: 'videoTimingInfo',\n          videoTimingInfo: {\n            start: clock$2.videoTsToSeconds(videoTimingInfo.start),\n            end: clock$2.videoTsToSeconds(videoTimingInfo.end)\n          }\n        });\n      });\n      transmuxer.on('log', function (log) {\n        self.postMessage({\n          action: 'log',\n          log\n        });\n      });\n    };\n    /**\n     * All incoming messages route through this hash. If no function exists\n     * to handle an incoming message, then we ignore the message.\n     *\n     * @class MessageHandlers\n     * @param {Object} options the options to initialize with\n     */\n\n    class MessageHandlers {\n      constructor(self, options) {\n        this.options = options || {};\n        this.self = self;\n        this.init();\n      }\n      /**\n       * initialize our web worker and wire all the events.\n       */\n\n      init() {\n        if (this.transmuxer) {\n          this.transmuxer.dispose();\n        }\n        this.transmuxer = new transmuxer.Transmuxer(this.options);\n        wireTransmuxerEvents(this.self, this.transmuxer);\n      }\n      pushMp4Captions(data) {\n        if (!this.captionParser) {\n          this.captionParser = new captionParser();\n          this.captionParser.init();\n        }\n        const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n        const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);\n        this.self.postMessage({\n          action: 'mp4Captions',\n          captions: parsed && parsed.captions || [],\n          logs: parsed && parsed.logs || [],\n          data: segment.buffer\n        }, [segment.buffer]);\n      }\n      probeMp4StartTime({\n        timescales,\n        data\n      }) {\n        const startTime = probe$2.startTime(timescales, data);\n        this.self.postMessage({\n          action: 'probeMp4StartTime',\n          startTime,\n          data\n        }, [data.buffer]);\n      }\n      probeMp4Tracks({\n        data\n      }) {\n        const tracks = probe$2.tracks(data);\n        this.self.postMessage({\n          action: 'probeMp4Tracks',\n          tracks,\n          data\n        }, [data.buffer]);\n      }\n      /**\n       * Probe an mpeg2-ts segment to determine the start time of the segment in it's\n       * internal \"media time,\" as well as whether it contains video and/or audio.\n       *\n       * @private\n       * @param {Uint8Array} bytes - segment bytes\n       * @param {number} baseStartTime\n       *        Relative reference timestamp used when adjusting frame timestamps for rollover.\n       *        This value should be in seconds, as it's converted to a 90khz clock within the\n       *        function body.\n       * @return {Object} The start time of the current segment in \"media time\" as well as\n       *                  whether it contains video and/or audio\n       */\n\n      probeTs({\n        data,\n        baseStartTime\n      }) {\n        const tsStartTime = typeof baseStartTime === 'number' && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;\n        const timeInfo = tsInspector.inspect(data, tsStartTime);\n        let result = null;\n        if (timeInfo) {\n          result = {\n            // each type's time info comes back as an array of 2 times, start and end\n            hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,\n            hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false\n          };\n          if (result.hasVideo) {\n            result.videoStart = timeInfo.video[0].ptsTime;\n          }\n          if (result.hasAudio) {\n            result.audioStart = timeInfo.audio[0].ptsTime;\n          }\n        }\n        this.self.postMessage({\n          action: 'probeTs',\n          result,\n          data\n        }, [data.buffer]);\n      }\n      clearAllMp4Captions() {\n        if (this.captionParser) {\n          this.captionParser.clearAllCaptions();\n        }\n      }\n      clearParsedMp4Captions() {\n        if (this.captionParser) {\n          this.captionParser.clearParsedCaptions();\n        }\n      }\n      /**\n       * Adds data (a ts segment) to the start of the transmuxer pipeline for\n       * processing.\n       *\n       * @param {ArrayBuffer} data data to push into the muxer\n       */\n\n      push(data) {\n        // Cast array buffer to correct type for transmuxer\n        const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n        this.transmuxer.push(segment);\n      }\n      /**\n       * Recreate the transmuxer so that the next segment added via `push`\n       * start with a fresh transmuxer.\n       */\n\n      reset() {\n        this.transmuxer.reset();\n      }\n      /**\n       * Set the value that will be used as the `baseMediaDecodeTime` time for the\n       * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n       * set relative to the first based on the PTS values.\n       *\n       * @param {Object} data used to set the timestamp offset in the muxer\n       */\n\n      setTimestampOffset(data) {\n        const timestampOffset = data.timestampOffset || 0;\n        this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));\n      }\n      setAudioAppendStart(data) {\n        this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));\n      }\n      setRemux(data) {\n        this.transmuxer.setRemux(data.remux);\n      }\n      /**\n       * Forces the pipeline to finish processing the last segment and emit it's\n       * results.\n       *\n       * @param {Object} data event data, not really used\n       */\n\n      flush(data) {\n        this.transmuxer.flush(); // transmuxed done action is fired after both audio/video pipelines are flushed\n\n        self.postMessage({\n          action: 'done',\n          type: 'transmuxed'\n        });\n      }\n      endTimeline() {\n        this.transmuxer.endTimeline(); // transmuxed endedtimeline action is fired after both audio/video pipelines end their\n        // timelines\n\n        self.postMessage({\n          action: 'endedtimeline',\n          type: 'transmuxed'\n        });\n      }\n      alignGopsWith(data) {\n        this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n      }\n    }\n    /**\n     * Our web worker interface so that things can talk to mux.js\n     * that will be running in a web worker. the scope is passed to this by\n     * webworkify.\n     *\n     * @param {Object} self the scope for the web worker\n     */\n\n    self.onmessage = function (event) {\n      if (event.data.action === 'init' && event.data.options) {\n        this.messageHandlers = new MessageHandlers(self, event.data.options);\n        return;\n      }\n      if (!this.messageHandlers) {\n        this.messageHandlers = new MessageHandlers(self);\n      }\n      if (event.data && event.data.action && event.data.action !== 'init') {\n        if (this.messageHandlers[event.data.action]) {\n          this.messageHandlers[event.data.action](event.data);\n        }\n      }\n    };\n  }));\n  var TransmuxWorker = factory(workerCode$1);\n  /* rollup-plugin-worker-factory end for worker!/Users/poneill/dev/http-streaming/src/transmuxer-worker.js */\n\n  const handleData_ = (event, transmuxedData, callback) => {\n    const {\n      type,\n      initSegment,\n      captions,\n      captionStreams,\n      metadata,\n      videoFrameDtsTime,\n      videoFramePtsTime\n    } = event.data.segment;\n    transmuxedData.buffer.push({\n      captions,\n      captionStreams,\n      metadata\n    });\n    const boxes = event.data.segment.boxes || {\n      data: event.data.segment.data\n    };\n    const result = {\n      type,\n      // cast ArrayBuffer to TypedArray\n      data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),\n      initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)\n    };\n    if (typeof videoFrameDtsTime !== 'undefined') {\n      result.videoFrameDtsTime = videoFrameDtsTime;\n    }\n    if (typeof videoFramePtsTime !== 'undefined') {\n      result.videoFramePtsTime = videoFramePtsTime;\n    }\n    callback(result);\n  };\n  const handleDone_ = ({\n    transmuxedData,\n    callback\n  }) => {\n    // Previously we only returned data on data events,\n    // not on done events. Clear out the buffer to keep that consistent.\n    transmuxedData.buffer = []; // all buffers should have been flushed from the muxer, so start processing anything we\n    // have received\n\n    callback(transmuxedData);\n  };\n  const handleGopInfo_ = (event, transmuxedData) => {\n    transmuxedData.gopInfo = event.data.gopInfo;\n  };\n  const processTransmux = options => {\n    const {\n      transmuxer,\n      bytes,\n      audioAppendStart,\n      gopsToAlignWith,\n      remux,\n      onData,\n      onTrackInfo,\n      onAudioTimingInfo,\n      onVideoTimingInfo,\n      onVideoSegmentTimingInfo,\n      onAudioSegmentTimingInfo,\n      onId3,\n      onCaptions,\n      onDone,\n      onEndedTimeline,\n      onTransmuxerLog,\n      isEndOfTimeline\n    } = options;\n    const transmuxedData = {\n      buffer: []\n    };\n    let waitForEndedTimelineEvent = isEndOfTimeline;\n    const handleMessage = event => {\n      if (transmuxer.currentTransmux !== options) {\n        // disposed\n        return;\n      }\n      if (event.data.action === 'data') {\n        handleData_(event, transmuxedData, onData);\n      }\n      if (event.data.action === 'trackinfo') {\n        onTrackInfo(event.data.trackInfo);\n      }\n      if (event.data.action === 'gopInfo') {\n        handleGopInfo_(event, transmuxedData);\n      }\n      if (event.data.action === 'audioTimingInfo') {\n        onAudioTimingInfo(event.data.audioTimingInfo);\n      }\n      if (event.data.action === 'videoTimingInfo') {\n        onVideoTimingInfo(event.data.videoTimingInfo);\n      }\n      if (event.data.action === 'videoSegmentTimingInfo') {\n        onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);\n      }\n      if (event.data.action === 'audioSegmentTimingInfo') {\n        onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);\n      }\n      if (event.data.action === 'id3Frame') {\n        onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);\n      }\n      if (event.data.action === 'caption') {\n        onCaptions(event.data.caption);\n      }\n      if (event.data.action === 'endedtimeline') {\n        waitForEndedTimelineEvent = false;\n        onEndedTimeline();\n      }\n      if (event.data.action === 'log') {\n        onTransmuxerLog(event.data.log);\n      } // wait for the transmuxed event since we may have audio and video\n\n      if (event.data.type !== 'transmuxed') {\n        return;\n      } // If the \"endedtimeline\" event has not yet fired, and this segment represents the end\n      // of a timeline, that means there may still be data events before the segment\n      // processing can be considerred complete. In that case, the final event should be\n      // an \"endedtimeline\" event with the type \"transmuxed.\"\n\n      if (waitForEndedTimelineEvent) {\n        return;\n      }\n      transmuxer.onmessage = null;\n      handleDone_({\n        transmuxedData,\n        callback: onDone\n      });\n      /* eslint-disable no-use-before-define */\n\n      dequeue(transmuxer);\n      /* eslint-enable */\n    };\n\n    transmuxer.onmessage = handleMessage;\n    if (audioAppendStart) {\n      transmuxer.postMessage({\n        action: 'setAudioAppendStart',\n        appendStart: audioAppendStart\n      });\n    } // allow empty arrays to be passed to clear out GOPs\n\n    if (Array.isArray(gopsToAlignWith)) {\n      transmuxer.postMessage({\n        action: 'alignGopsWith',\n        gopsToAlignWith\n      });\n    }\n    if (typeof remux !== 'undefined') {\n      transmuxer.postMessage({\n        action: 'setRemux',\n        remux\n      });\n    }\n    if (bytes.byteLength) {\n      const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;\n      const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;\n      transmuxer.postMessage({\n        action: 'push',\n        // Send the typed-array of data as an ArrayBuffer so that\n        // it can be sent as a \"Transferable\" and avoid the costly\n        // memory copy\n        data: buffer,\n        // To recreate the original typed-array, we need information\n        // about what portion of the ArrayBuffer it was a view into\n        byteOffset,\n        byteLength: bytes.byteLength\n      }, [buffer]);\n    }\n    if (isEndOfTimeline) {\n      transmuxer.postMessage({\n        action: 'endTimeline'\n      });\n    } // even if we didn't push any bytes, we have to make sure we flush in case we reached\n    // the end of the segment\n\n    transmuxer.postMessage({\n      action: 'flush'\n    });\n  };\n  const dequeue = transmuxer => {\n    transmuxer.currentTransmux = null;\n    if (transmuxer.transmuxQueue.length) {\n      transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();\n      if (typeof transmuxer.currentTransmux === 'function') {\n        transmuxer.currentTransmux();\n      } else {\n        processTransmux(transmuxer.currentTransmux);\n      }\n    }\n  };\n  const processAction = (transmuxer, action) => {\n    transmuxer.postMessage({\n      action\n    });\n    dequeue(transmuxer);\n  };\n  const enqueueAction = (action, transmuxer) => {\n    if (!transmuxer.currentTransmux) {\n      transmuxer.currentTransmux = action;\n      processAction(transmuxer, action);\n      return;\n    }\n    transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));\n  };\n  const reset = transmuxer => {\n    enqueueAction('reset', transmuxer);\n  };\n  const endTimeline = transmuxer => {\n    enqueueAction('endTimeline', transmuxer);\n  };\n  const transmux = options => {\n    if (!options.transmuxer.currentTransmux) {\n      options.transmuxer.currentTransmux = options;\n      processTransmux(options);\n      return;\n    }\n    options.transmuxer.transmuxQueue.push(options);\n  };\n  const createTransmuxer = options => {\n    const transmuxer = new TransmuxWorker();\n    transmuxer.currentTransmux = null;\n    transmuxer.transmuxQueue = [];\n    const term = transmuxer.terminate;\n    transmuxer.terminate = () => {\n      transmuxer.currentTransmux = null;\n      transmuxer.transmuxQueue.length = 0;\n      return term.call(transmuxer);\n    };\n    transmuxer.postMessage({\n      action: 'init',\n      options\n    });\n    return transmuxer;\n  };\n  var segmentTransmuxer = {\n    reset,\n    endTimeline,\n    transmux,\n    createTransmuxer\n  };\n  const workerCallback = function (options) {\n    const transmuxer = options.transmuxer;\n    const endAction = options.endAction || options.action;\n    const callback = options.callback;\n    const message = _extends$1({}, options, {\n      endAction: null,\n      transmuxer: null,\n      callback: null\n    });\n    const listenForEndEvent = event => {\n      if (event.data.action !== endAction) {\n        return;\n      }\n      transmuxer.removeEventListener('message', listenForEndEvent); // transfer ownership of bytes back to us.\n\n      if (event.data.data) {\n        event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);\n        if (options.data) {\n          options.data = event.data.data;\n        }\n      }\n      callback(event.data);\n    };\n    transmuxer.addEventListener('message', listenForEndEvent);\n    if (options.data) {\n      const isArrayBuffer = options.data instanceof ArrayBuffer;\n      message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;\n      message.byteLength = options.data.byteLength;\n      const transfers = [isArrayBuffer ? options.data : options.data.buffer];\n      transmuxer.postMessage(message, transfers);\n    } else {\n      transmuxer.postMessage(message);\n    }\n  };\n  const REQUEST_ERRORS = {\n    FAILURE: 2,\n    TIMEOUT: -101,\n    ABORTED: -102\n  };\n  /**\n   * Abort all requests\n   *\n   * @param {Object} activeXhrs - an object that tracks all XHR requests\n   */\n\n  const abortAll = activeXhrs => {\n    activeXhrs.forEach(xhr => {\n      xhr.abort();\n    });\n  };\n  /**\n   * Gather important bandwidth stats once a request has completed\n   *\n   * @param {Object} request - the XHR request from which to gather stats\n   */\n\n  const getRequestStats = request => {\n    return {\n      bandwidth: request.bandwidth,\n      bytesReceived: request.bytesReceived || 0,\n      roundTripTime: request.roundTripTime || 0\n    };\n  };\n  /**\n   * If possible gather bandwidth stats as a request is in\n   * progress\n   *\n   * @param {Event} progressEvent - an event object from an XHR's progress event\n   */\n\n  const getProgressStats = progressEvent => {\n    const request = progressEvent.target;\n    const roundTripTime = Date.now() - request.requestTime;\n    const stats = {\n      bandwidth: Infinity,\n      bytesReceived: 0,\n      roundTripTime: roundTripTime || 0\n    };\n    stats.bytesReceived = progressEvent.loaded; // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n    // because we should only use bandwidth stats on progress to determine when\n    // abort a request early due to insufficient bandwidth\n\n    stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n    return stats;\n  };\n  /**\n   * Handle all error conditions in one place and return an object\n   * with all the information\n   *\n   * @param {Error|null} error - if non-null signals an error occured with the XHR\n   * @param {Object} request -  the XHR request that possibly generated the error\n   */\n\n  const handleErrors = (error, request) => {\n    if (request.timedout) {\n      return {\n        status: request.status,\n        message: 'HLS request timed-out at URL: ' + request.uri,\n        code: REQUEST_ERRORS.TIMEOUT,\n        xhr: request\n      };\n    }\n    if (request.aborted) {\n      return {\n        status: request.status,\n        message: 'HLS request aborted at URL: ' + request.uri,\n        code: REQUEST_ERRORS.ABORTED,\n        xhr: request\n      };\n    }\n    if (error) {\n      return {\n        status: request.status,\n        message: 'HLS request errored at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      };\n    }\n    if (request.responseType === 'arraybuffer' && request.response.byteLength === 0) {\n      return {\n        status: request.status,\n        message: 'Empty HLS response at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      };\n    }\n    return null;\n  };\n  /**\n   * Handle responses for key data and convert the key data to the correct format\n   * for the decryption step later\n   *\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   * @param {Array} objects - objects to add the key bytes to.\n   * @param {Function} finishProcessingFn - a callback to execute to continue processing\n   *                                        this request\n   */\n\n  const handleKeyResponse = (segment, objects, finishProcessingFn) => (error, request) => {\n    const response = request.response;\n    const errorObj = handleErrors(error, request);\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n    if (response.byteLength !== 16) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Invalid HLS key at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n    const view = new DataView(response);\n    const bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n    for (let i = 0; i < objects.length; i++) {\n      objects[i].bytes = bytes;\n    }\n    return finishProcessingFn(null, segment);\n  };\n  const parseInitSegment = (segment, callback) => {\n    const type = detectContainerForBytes(segment.map.bytes); // TODO: We should also handle ts init segments here, but we\n    // only know how to parse mp4 init segments at the moment\n\n    if (type !== 'mp4') {\n      const uri = segment.map.resolvedUri || segment.map.uri;\n      return callback({\n        internal: true,\n        message: `Found unsupported ${type || 'unknown'} container for initialization segment at URL: ${uri}`,\n        code: REQUEST_ERRORS.FAILURE\n      });\n    }\n    workerCallback({\n      action: 'probeMp4Tracks',\n      data: segment.map.bytes,\n      transmuxer: segment.transmuxer,\n      callback: ({\n        tracks,\n        data\n      }) => {\n        // transfer bytes back to us\n        segment.map.bytes = data;\n        tracks.forEach(function (track) {\n          segment.map.tracks = segment.map.tracks || {}; // only support one track of each type for now\n\n          if (segment.map.tracks[track.type]) {\n            return;\n          }\n          segment.map.tracks[track.type] = track;\n          if (typeof track.id === 'number' && track.timescale) {\n            segment.map.timescales = segment.map.timescales || {};\n            segment.map.timescales[track.id] = track.timescale;\n          }\n        });\n        return callback(null);\n      }\n    });\n  };\n  /**\n   * Handle init-segment responses\n   *\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   * @param {Function} finishProcessingFn - a callback to execute to continue processing\n   *                                        this request\n   */\n\n  const handleInitSegmentResponse = ({\n    segment,\n    finishProcessingFn\n  }) => (error, request) => {\n    const errorObj = handleErrors(error, request);\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n    const bytes = new Uint8Array(request.response); // init segment is encypted, we will have to wait\n    // until the key request is done to decrypt.\n\n    if (segment.map.key) {\n      segment.map.encryptedBytes = bytes;\n      return finishProcessingFn(null, segment);\n    }\n    segment.map.bytes = bytes;\n    parseInitSegment(segment, function (parseError) {\n      if (parseError) {\n        parseError.xhr = request;\n        parseError.status = request.status;\n        return finishProcessingFn(parseError, segment);\n      }\n      finishProcessingFn(null, segment);\n    });\n  };\n  /**\n   * Response handler for segment-requests being sure to set the correct\n   * property depending on whether the segment is encryped or not\n   * Also records and keeps track of stats that are used for ABR purposes\n   *\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   * @param {Function} finishProcessingFn - a callback to execute to continue processing\n   *                                        this request\n   */\n\n  const handleSegmentResponse = ({\n    segment,\n    finishProcessingFn,\n    responseType\n  }) => (error, request) => {\n    const errorObj = handleErrors(error, request);\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n    const newBytes =\n    // although responseText \"should\" exist, this guard serves to prevent an error being\n    // thrown for two primary cases:\n    // 1. the mime type override stops working, or is not implemented for a specific\n    //    browser\n    // 2. when using mock XHR libraries like sinon that do not allow the override behavior\n    responseType === 'arraybuffer' || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));\n    segment.stats = getRequestStats(request);\n    if (segment.key) {\n      segment.encryptedBytes = new Uint8Array(newBytes);\n    } else {\n      segment.bytes = new Uint8Array(newBytes);\n    }\n    return finishProcessingFn(null, segment);\n  };\n  const transmuxAndNotify = ({\n    segment,\n    bytes,\n    trackInfoFn,\n    timingInfoFn,\n    videoSegmentTimingInfoFn,\n    audioSegmentTimingInfoFn,\n    id3Fn,\n    captionsFn,\n    isEndOfTimeline,\n    endedTimelineFn,\n    dataFn,\n    doneFn,\n    onTransmuxerLog\n  }) => {\n    const fmp4Tracks = segment.map && segment.map.tracks || {};\n    const isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video); // Keep references to each function so we can null them out after we're done with them.\n    // One reason for this is that in the case of full segments, we want to trust start\n    // times from the probe, rather than the transmuxer.\n\n    let audioStartFn = timingInfoFn.bind(null, segment, 'audio', 'start');\n    const audioEndFn = timingInfoFn.bind(null, segment, 'audio', 'end');\n    let videoStartFn = timingInfoFn.bind(null, segment, 'video', 'start');\n    const videoEndFn = timingInfoFn.bind(null, segment, 'video', 'end');\n    const finish = () => transmux({\n      bytes,\n      transmuxer: segment.transmuxer,\n      audioAppendStart: segment.audioAppendStart,\n      gopsToAlignWith: segment.gopsToAlignWith,\n      remux: isMuxed,\n      onData: result => {\n        result.type = result.type === 'combined' ? 'video' : result.type;\n        dataFn(segment, result);\n      },\n      onTrackInfo: trackInfo => {\n        if (trackInfoFn) {\n          if (isMuxed) {\n            trackInfo.isMuxed = true;\n          }\n          trackInfoFn(segment, trackInfo);\n        }\n      },\n      onAudioTimingInfo: audioTimingInfo => {\n        // we only want the first start value we encounter\n        if (audioStartFn && typeof audioTimingInfo.start !== 'undefined') {\n          audioStartFn(audioTimingInfo.start);\n          audioStartFn = null;\n        } // we want to continually update the end time\n\n        if (audioEndFn && typeof audioTimingInfo.end !== 'undefined') {\n          audioEndFn(audioTimingInfo.end);\n        }\n      },\n      onVideoTimingInfo: videoTimingInfo => {\n        // we only want the first start value we encounter\n        if (videoStartFn && typeof videoTimingInfo.start !== 'undefined') {\n          videoStartFn(videoTimingInfo.start);\n          videoStartFn = null;\n        } // we want to continually update the end time\n\n        if (videoEndFn && typeof videoTimingInfo.end !== 'undefined') {\n          videoEndFn(videoTimingInfo.end);\n        }\n      },\n      onVideoSegmentTimingInfo: videoSegmentTimingInfo => {\n        videoSegmentTimingInfoFn(videoSegmentTimingInfo);\n      },\n      onAudioSegmentTimingInfo: audioSegmentTimingInfo => {\n        audioSegmentTimingInfoFn(audioSegmentTimingInfo);\n      },\n      onId3: (id3Frames, dispatchType) => {\n        id3Fn(segment, id3Frames, dispatchType);\n      },\n      onCaptions: captions => {\n        captionsFn(segment, [captions]);\n      },\n      isEndOfTimeline,\n      onEndedTimeline: () => {\n        endedTimelineFn();\n      },\n      onTransmuxerLog,\n      onDone: result => {\n        if (!doneFn) {\n          return;\n        }\n        result.type = result.type === 'combined' ? 'video' : result.type;\n        doneFn(null, segment, result);\n      }\n    }); // In the transmuxer, we don't yet have the ability to extract a \"proper\" start time.\n    // Meaning cached frame data may corrupt our notion of where this segment\n    // really starts. To get around this, probe for the info needed.\n\n    workerCallback({\n      action: 'probeTs',\n      transmuxer: segment.transmuxer,\n      data: bytes,\n      baseStartTime: segment.baseStartTime,\n      callback: data => {\n        segment.bytes = bytes = data.data;\n        const probeResult = data.result;\n        if (probeResult) {\n          trackInfoFn(segment, {\n            hasAudio: probeResult.hasAudio,\n            hasVideo: probeResult.hasVideo,\n            isMuxed\n          });\n          trackInfoFn = null;\n          if (probeResult.hasAudio && !isMuxed) {\n            audioStartFn(probeResult.audioStart);\n          }\n          if (probeResult.hasVideo) {\n            videoStartFn(probeResult.videoStart);\n          }\n          audioStartFn = null;\n          videoStartFn = null;\n        }\n        finish();\n      }\n    });\n  };\n  const handleSegmentBytes = ({\n    segment,\n    bytes,\n    trackInfoFn,\n    timingInfoFn,\n    videoSegmentTimingInfoFn,\n    audioSegmentTimingInfoFn,\n    id3Fn,\n    captionsFn,\n    isEndOfTimeline,\n    endedTimelineFn,\n    dataFn,\n    doneFn,\n    onTransmuxerLog\n  }) => {\n    let bytesAsUint8Array = new Uint8Array(bytes); // TODO:\n    // We should have a handler that fetches the number of bytes required\n    // to check if something is fmp4. This will allow us to save bandwidth\n    // because we can only exclude a playlist and abort requests\n    // by codec after trackinfo triggers.\n\n    if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {\n      segment.isFmp4 = true;\n      const {\n        tracks\n      } = segment.map;\n      const trackInfo = {\n        isFmp4: true,\n        hasVideo: !!tracks.video,\n        hasAudio: !!tracks.audio\n      }; // if we have a audio track, with a codec that is not set to\n      // encrypted audio\n\n      if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== 'enca') {\n        trackInfo.audioCodec = tracks.audio.codec;\n      } // if we have a video track, with a codec that is not set to\n      // encrypted video\n\n      if (tracks.video && tracks.video.codec && tracks.video.codec !== 'encv') {\n        trackInfo.videoCodec = tracks.video.codec;\n      }\n      if (tracks.video && tracks.audio) {\n        trackInfo.isMuxed = true;\n      } // since we don't support appending fmp4 data on progress, we know we have the full\n      // segment here\n\n      trackInfoFn(segment, trackInfo); // The probe doesn't provide the segment end time, so only callback with the start\n      // time. The end time can be roughly calculated by the receiver using the duration.\n      //\n      // Note that the start time returned by the probe reflects the baseMediaDecodeTime, as\n      // that is the true start of the segment (where the playback engine should begin\n      // decoding).\n\n      const finishLoading = captions => {\n        // if the track still has audio at this point it is only possible\n        // for it to be audio only. See `tracks.video && tracks.audio` if statement\n        // above.\n        // we make sure to use segment.bytes here as that\n        dataFn(segment, {\n          data: bytesAsUint8Array,\n          type: trackInfo.hasAudio && !trackInfo.isMuxed ? 'audio' : 'video'\n        });\n        if (captions && captions.length) {\n          captionsFn(segment, captions);\n        }\n        doneFn(null, segment, {});\n      };\n      workerCallback({\n        action: 'probeMp4StartTime',\n        timescales: segment.map.timescales,\n        data: bytesAsUint8Array,\n        transmuxer: segment.transmuxer,\n        callback: ({\n          data,\n          startTime\n        }) => {\n          // transfer bytes back to us\n          bytes = data.buffer;\n          segment.bytes = bytesAsUint8Array = data;\n          if (trackInfo.hasAudio && !trackInfo.isMuxed) {\n            timingInfoFn(segment, 'audio', 'start', startTime);\n          }\n          if (trackInfo.hasVideo) {\n            timingInfoFn(segment, 'video', 'start', startTime);\n          } // Run through the CaptionParser in case there are captions.\n          // Initialize CaptionParser if it hasn't been yet\n\n          if (!tracks.video || !data.byteLength || !segment.transmuxer) {\n            finishLoading();\n            return;\n          }\n          workerCallback({\n            action: 'pushMp4Captions',\n            endAction: 'mp4Captions',\n            transmuxer: segment.transmuxer,\n            data: bytesAsUint8Array,\n            timescales: segment.map.timescales,\n            trackIds: [tracks.video.id],\n            callback: message => {\n              // transfer bytes back to us\n              bytes = message.data.buffer;\n              segment.bytes = bytesAsUint8Array = message.data;\n              message.logs.forEach(function (log) {\n                onTransmuxerLog(merge(log, {\n                  stream: 'mp4CaptionParser'\n                }));\n              });\n              finishLoading(message.captions);\n            }\n          });\n        }\n      });\n      return;\n    } // VTT or other segments that don't need processing\n\n    if (!segment.transmuxer) {\n      doneFn(null, segment, {});\n      return;\n    }\n    if (typeof segment.container === 'undefined') {\n      segment.container = detectContainerForBytes(bytesAsUint8Array);\n    }\n    if (segment.container !== 'ts' && segment.container !== 'aac') {\n      trackInfoFn(segment, {\n        hasAudio: false,\n        hasVideo: false\n      });\n      doneFn(null, segment, {});\n      return;\n    } // ts or aac\n\n    transmuxAndNotify({\n      segment,\n      bytes,\n      trackInfoFn,\n      timingInfoFn,\n      videoSegmentTimingInfoFn,\n      audioSegmentTimingInfoFn,\n      id3Fn,\n      captionsFn,\n      isEndOfTimeline,\n      endedTimelineFn,\n      dataFn,\n      doneFn,\n      onTransmuxerLog\n    });\n  };\n  const decrypt = function ({\n    id,\n    key,\n    encryptedBytes,\n    decryptionWorker\n  }, callback) {\n    const decryptionHandler = event => {\n      if (event.data.source === id) {\n        decryptionWorker.removeEventListener('message', decryptionHandler);\n        const decrypted = event.data.decrypted;\n        callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));\n      }\n    };\n    decryptionWorker.addEventListener('message', decryptionHandler);\n    let keyBytes;\n    if (key.bytes.slice) {\n      keyBytes = key.bytes.slice();\n    } else {\n      keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));\n    } // incrementally decrypt the bytes\n\n    decryptionWorker.postMessage(createTransferableMessage({\n      source: id,\n      encrypted: encryptedBytes,\n      key: keyBytes,\n      iv: key.iv\n    }), [encryptedBytes.buffer, keyBytes.buffer]);\n  };\n  /**\n   * Decrypt the segment via the decryption web worker\n   *\n   * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n   *                                       routines\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   * @param {Function} trackInfoFn - a callback that receives track info\n   * @param {Function} timingInfoFn - a callback that receives timing info\n   * @param {Function} videoSegmentTimingInfoFn\n   *                   a callback that receives video timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {Function} audioSegmentTimingInfoFn\n   *                   a callback that receives audio timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {boolean}  isEndOfTimeline\n   *                   true if this segment represents the last segment in a timeline\n   * @param {Function} endedTimelineFn\n   *                   a callback made when a timeline is ended, will only be called if\n   *                   isEndOfTimeline is true\n   * @param {Function} dataFn - a callback that is executed when segment bytes are available\n   *                            and ready to use\n   * @param {Function} doneFn - a callback that is executed after decryption has completed\n   */\n\n  const decryptSegment = ({\n    decryptionWorker,\n    segment,\n    trackInfoFn,\n    timingInfoFn,\n    videoSegmentTimingInfoFn,\n    audioSegmentTimingInfoFn,\n    id3Fn,\n    captionsFn,\n    isEndOfTimeline,\n    endedTimelineFn,\n    dataFn,\n    doneFn,\n    onTransmuxerLog\n  }) => {\n    decrypt({\n      id: segment.requestId,\n      key: segment.key,\n      encryptedBytes: segment.encryptedBytes,\n      decryptionWorker\n    }, decryptedBytes => {\n      segment.bytes = decryptedBytes;\n      handleSegmentBytes({\n        segment,\n        bytes: segment.bytes,\n        trackInfoFn,\n        timingInfoFn,\n        videoSegmentTimingInfoFn,\n        audioSegmentTimingInfoFn,\n        id3Fn,\n        captionsFn,\n        isEndOfTimeline,\n        endedTimelineFn,\n        dataFn,\n        doneFn,\n        onTransmuxerLog\n      });\n    });\n  };\n  /**\n   * This function waits for all XHRs to finish (with either success or failure)\n   * before continueing processing via it's callback. The function gathers errors\n   * from each request into a single errors array so that the error status for\n   * each request can be examined later.\n   *\n   * @param {Object} activeXhrs - an object that tracks all XHR requests\n   * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n   *                                       routines\n   * @param {Function} trackInfoFn - a callback that receives track info\n   * @param {Function} timingInfoFn - a callback that receives timing info\n   * @param {Function} videoSegmentTimingInfoFn\n   *                   a callback that receives video timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {Function} audioSegmentTimingInfoFn\n   *                   a callback that receives audio timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {Function} id3Fn - a callback that receives ID3 metadata\n   * @param {Function} captionsFn - a callback that receives captions\n   * @param {boolean}  isEndOfTimeline\n   *                   true if this segment represents the last segment in a timeline\n   * @param {Function} endedTimelineFn\n   *                   a callback made when a timeline is ended, will only be called if\n   *                   isEndOfTimeline is true\n   * @param {Function} dataFn - a callback that is executed when segment bytes are available\n   *                            and ready to use\n   * @param {Function} doneFn - a callback that is executed after all resources have been\n   *                            downloaded and any decryption completed\n   */\n\n  const waitForCompletion = ({\n    activeXhrs,\n    decryptionWorker,\n    trackInfoFn,\n    timingInfoFn,\n    videoSegmentTimingInfoFn,\n    audioSegmentTimingInfoFn,\n    id3Fn,\n    captionsFn,\n    isEndOfTimeline,\n    endedTimelineFn,\n    dataFn,\n    doneFn,\n    onTransmuxerLog\n  }) => {\n    let count = 0;\n    let didError = false;\n    return (error, segment) => {\n      if (didError) {\n        return;\n      }\n      if (error) {\n        didError = true; // If there are errors, we have to abort any outstanding requests\n\n        abortAll(activeXhrs); // Even though the requests above are aborted, and in theory we could wait until we\n        // handle the aborted events from those requests, there are some cases where we may\n        // never get an aborted event. For instance, if the network connection is lost and\n        // there were two requests, the first may have triggered an error immediately, while\n        // the second request remains unsent. In that case, the aborted algorithm will not\n        // trigger an abort: see https://xhr.spec.whatwg.org/#the-abort()-method\n        //\n        // We also can't rely on the ready state of the XHR, since the request that\n        // triggered the connection error may also show as a ready state of 0 (unsent).\n        // Therefore, we have to finish this group of requests immediately after the first\n        // seen error.\n\n        return doneFn(error, segment);\n      }\n      count += 1;\n      if (count === activeXhrs.length) {\n        const segmentFinish = function () {\n          if (segment.encryptedBytes) {\n            return decryptSegment({\n              decryptionWorker,\n              segment,\n              trackInfoFn,\n              timingInfoFn,\n              videoSegmentTimingInfoFn,\n              audioSegmentTimingInfoFn,\n              id3Fn,\n              captionsFn,\n              isEndOfTimeline,\n              endedTimelineFn,\n              dataFn,\n              doneFn,\n              onTransmuxerLog\n            });\n          } // Otherwise, everything is ready just continue\n\n          handleSegmentBytes({\n            segment,\n            bytes: segment.bytes,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn,\n            doneFn,\n            onTransmuxerLog\n          });\n        }; // Keep track of when *all* of the requests have completed\n\n        segment.endOfAllRequests = Date.now();\n        if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {\n          return decrypt({\n            decryptionWorker,\n            // add -init to the \"id\" to differentiate between segment\n            // and init segment decryption, just in case they happen\n            // at the same time at some point in the future.\n            id: segment.requestId + '-init',\n            encryptedBytes: segment.map.encryptedBytes,\n            key: segment.map.key\n          }, decryptedBytes => {\n            segment.map.bytes = decryptedBytes;\n            parseInitSegment(segment, parseError => {\n              if (parseError) {\n                abortAll(activeXhrs);\n                return doneFn(parseError, segment);\n              }\n              segmentFinish();\n            });\n          });\n        }\n        segmentFinish();\n      }\n    };\n  };\n  /**\n   * Calls the abort callback if any request within the batch was aborted. Will only call\n   * the callback once per batch of requests, even if multiple were aborted.\n   *\n   * @param {Object} loadendState - state to check to see if the abort function was called\n   * @param {Function} abortFn - callback to call for abort\n   */\n\n  const handleLoadEnd = ({\n    loadendState,\n    abortFn\n  }) => event => {\n    const request = event.target;\n    if (request.aborted && abortFn && !loadendState.calledAbortFn) {\n      abortFn();\n      loadendState.calledAbortFn = true;\n    }\n  };\n  /**\n   * Simple progress event callback handler that gathers some stats before\n   * executing a provided callback with the `segment` object\n   *\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   * @param {Function} progressFn - a callback that is executed each time a progress event\n   *                                is received\n   * @param {Function} trackInfoFn - a callback that receives track info\n   * @param {Function} timingInfoFn - a callback that receives timing info\n   * @param {Function} videoSegmentTimingInfoFn\n   *                   a callback that receives video timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {Function} audioSegmentTimingInfoFn\n   *                   a callback that receives audio timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {boolean}  isEndOfTimeline\n   *                   true if this segment represents the last segment in a timeline\n   * @param {Function} endedTimelineFn\n   *                   a callback made when a timeline is ended, will only be called if\n   *                   isEndOfTimeline is true\n   * @param {Function} dataFn - a callback that is executed when segment bytes are available\n   *                            and ready to use\n   * @param {Event} event - the progress event object from XMLHttpRequest\n   */\n\n  const handleProgress = ({\n    segment,\n    progressFn,\n    trackInfoFn,\n    timingInfoFn,\n    videoSegmentTimingInfoFn,\n    audioSegmentTimingInfoFn,\n    id3Fn,\n    captionsFn,\n    isEndOfTimeline,\n    endedTimelineFn,\n    dataFn\n  }) => event => {\n    const request = event.target;\n    if (request.aborted) {\n      return;\n    }\n    segment.stats = merge(segment.stats, getProgressStats(event)); // record the time that we receive the first byte of data\n\n    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n      segment.stats.firstBytesReceivedAt = Date.now();\n    }\n    return progressFn(event, segment);\n  };\n  /**\n   * Load all resources and does any processing necessary for a media-segment\n   *\n   * Features:\n   *   decrypts the media-segment if it has a key uri and an iv\n   *   aborts *all* requests if *any* one request fails\n   *\n   * The segment object, at minimum, has the following format:\n   * {\n   *   resolvedUri: String,\n   *   [transmuxer]: Object,\n   *   [byterange]: {\n   *     offset: Number,\n   *     length: Number\n   *   },\n   *   [key]: {\n   *     resolvedUri: String\n   *     [byterange]: {\n   *       offset: Number,\n   *       length: Number\n   *     },\n   *     iv: {\n   *       bytes: Uint32Array\n   *     }\n   *   },\n   *   [map]: {\n   *     resolvedUri: String,\n   *     [byterange]: {\n   *       offset: Number,\n   *       length: Number\n   *     },\n   *     [bytes]: Uint8Array\n   *   }\n   * }\n   * ...where [name] denotes optional properties\n   *\n   * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n   * @param {Object} xhrOptions - the base options to provide to all xhr requests\n   * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n   *                                       decryption routines\n   * @param {Object} segment - a simplified copy of the segmentInfo object\n   *                           from SegmentLoader\n   * @param {Function} abortFn - a callback called (only once) if any piece of a request was\n   *                             aborted\n   * @param {Function} progressFn - a callback that receives progress events from the main\n   *                                segment's xhr request\n   * @param {Function} trackInfoFn - a callback that receives track info\n   * @param {Function} timingInfoFn - a callback that receives timing info\n   * @param {Function} videoSegmentTimingInfoFn\n   *                   a callback that receives video timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {Function} audioSegmentTimingInfoFn\n   *                   a callback that receives audio timing info based on media times and\n   *                   any adjustments made by the transmuxer\n   * @param {Function} id3Fn - a callback that receives ID3 metadata\n   * @param {Function} captionsFn - a callback that receives captions\n   * @param {boolean}  isEndOfTimeline\n   *                   true if this segment represents the last segment in a timeline\n   * @param {Function} endedTimelineFn\n   *                   a callback made when a timeline is ended, will only be called if\n   *                   isEndOfTimeline is true\n   * @param {Function} dataFn - a callback that receives data from the main segment's xhr\n   *                            request, transmuxed if needed\n   * @param {Function} doneFn - a callback that is executed only once all requests have\n   *                            succeeded or failed\n   * @return {Function} a function that, when invoked, immediately aborts all\n   *                     outstanding requests\n   */\n\n  const mediaSegmentRequest = ({\n    xhr,\n    xhrOptions,\n    decryptionWorker,\n    segment,\n    abortFn,\n    progressFn,\n    trackInfoFn,\n    timingInfoFn,\n    videoSegmentTimingInfoFn,\n    audioSegmentTimingInfoFn,\n    id3Fn,\n    captionsFn,\n    isEndOfTimeline,\n    endedTimelineFn,\n    dataFn,\n    doneFn,\n    onTransmuxerLog\n  }) => {\n    const activeXhrs = [];\n    const finishProcessingFn = waitForCompletion({\n      activeXhrs,\n      decryptionWorker,\n      trackInfoFn,\n      timingInfoFn,\n      videoSegmentTimingInfoFn,\n      audioSegmentTimingInfoFn,\n      id3Fn,\n      captionsFn,\n      isEndOfTimeline,\n      endedTimelineFn,\n      dataFn,\n      doneFn,\n      onTransmuxerLog\n    }); // optionally, request the decryption key\n\n    if (segment.key && !segment.key.bytes) {\n      const objects = [segment.key];\n      if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {\n        objects.push(segment.map.key);\n      }\n      const keyRequestOptions = merge(xhrOptions, {\n        uri: segment.key.resolvedUri,\n        responseType: 'arraybuffer'\n      });\n      const keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);\n      const keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n      activeXhrs.push(keyXhr);\n    } // optionally, request the associated media init segment\n\n    if (segment.map && !segment.map.bytes) {\n      const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);\n      if (differentMapKey) {\n        const mapKeyRequestOptions = merge(xhrOptions, {\n          uri: segment.map.key.resolvedUri,\n          responseType: 'arraybuffer'\n        });\n        const mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);\n        const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);\n        activeXhrs.push(mapKeyXhr);\n      }\n      const initSegmentOptions = merge(xhrOptions, {\n        uri: segment.map.resolvedUri,\n        responseType: 'arraybuffer',\n        headers: segmentXhrHeaders(segment.map)\n      });\n      const initSegmentRequestCallback = handleInitSegmentResponse({\n        segment,\n        finishProcessingFn\n      });\n      const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n      activeXhrs.push(initSegmentXhr);\n    }\n    const segmentRequestOptions = merge(xhrOptions, {\n      uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,\n      responseType: 'arraybuffer',\n      headers: segmentXhrHeaders(segment)\n    });\n    const segmentRequestCallback = handleSegmentResponse({\n      segment,\n      finishProcessingFn,\n      responseType: segmentRequestOptions.responseType\n    });\n    const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n    segmentXhr.addEventListener('progress', handleProgress({\n      segment,\n      progressFn,\n      trackInfoFn,\n      timingInfoFn,\n      videoSegmentTimingInfoFn,\n      audioSegmentTimingInfoFn,\n      id3Fn,\n      captionsFn,\n      isEndOfTimeline,\n      endedTimelineFn,\n      dataFn\n    }));\n    activeXhrs.push(segmentXhr); // since all parts of the request must be considered, but should not make callbacks\n    // multiple times, provide a shared state object\n\n    const loadendState = {};\n    activeXhrs.forEach(activeXhr => {\n      activeXhr.addEventListener('loadend', handleLoadEnd({\n        loadendState,\n        abortFn\n      }));\n    });\n    return () => abortAll(activeXhrs);\n  };\n\n  /**\n   * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\n   * codec strings, or translating codec strings into objects that can be examined.\n   */\n  const logFn$1 = logger('CodecUtils');\n  /**\n   * Returns a set of codec strings parsed from the playlist or the default\n   * codec strings if no codecs were specified in the playlist\n   *\n   * @param {Playlist} media the current media playlist\n   * @return {Object} an object with the video and audio codecs\n   */\n\n  const getCodecs = function (media) {\n    // if the codecs were explicitly specified, use them instead of the\n    // defaults\n    const mediaAttributes = media.attributes || {};\n    if (mediaAttributes.CODECS) {\n      return parseCodecs(mediaAttributes.CODECS);\n    }\n  };\n  const isMaat = (main, media) => {\n    const mediaAttributes = media.attributes || {};\n    return main && main.mediaGroups && main.mediaGroups.AUDIO && mediaAttributes.AUDIO && main.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n  };\n  const isMuxed = (main, media) => {\n    if (!isMaat(main, media)) {\n      return true;\n    }\n    const mediaAttributes = media.attributes || {};\n    const audioGroup = main.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n    for (const groupId in audioGroup) {\n      // If an audio group has a URI (the case for HLS, as HLS will use external playlists),\n      // or there are listed playlists (the case for DASH, as the manifest will have already\n      // provided all of the details necessary to generate the audio playlist, as opposed to\n      // HLS' externally requested playlists), then the content is demuxed.\n      if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const unwrapCodecList = function (codecList) {\n    const codecs = {};\n    codecList.forEach(({\n      mediaType,\n      type,\n      details\n    }) => {\n      codecs[mediaType] = codecs[mediaType] || [];\n      codecs[mediaType].push(translateLegacyCodec(`${type}${details}`));\n    });\n    Object.keys(codecs).forEach(function (mediaType) {\n      if (codecs[mediaType].length > 1) {\n        logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(', ')}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);\n        codecs[mediaType] = null;\n        return;\n      }\n      codecs[mediaType] = codecs[mediaType][0];\n    });\n    return codecs;\n  };\n  const codecCount = function (codecObj) {\n    let count = 0;\n    if (codecObj.audio) {\n      count++;\n    }\n    if (codecObj.video) {\n      count++;\n    }\n    return count;\n  };\n  /**\n   * Calculates the codec strings for a working configuration of\n   * SourceBuffers to play variant streams in a main playlist. If\n   * there is no possible working configuration, an empty object will be\n   * returned.\n   *\n   * @param main {Object} the m3u8 object for the main playlist\n   * @param media {Object} the m3u8 object for the variant playlist\n   * @return {Object} the codec strings.\n   *\n   * @private\n   */\n\n  const codecsForPlaylist = function (main, media) {\n    const mediaAttributes = media.attributes || {};\n    const codecInfo = unwrapCodecList(getCodecs(media) || []); // HLS with multiple-audio tracks must always get an audio codec.\n    // Put another way, there is no way to have a video-only multiple-audio HLS!\n\n    if (isMaat(main, media) && !codecInfo.audio) {\n      if (!isMuxed(main, media)) {\n        // It is possible for codecs to be specified on the audio media group playlist but\n        // not on the rendition playlist. This is mostly the case for DASH, where audio and\n        // video are always separate (and separately specified).\n        const defaultCodecs = unwrapCodecList(codecsFromDefault(main, mediaAttributes.AUDIO) || []);\n        if (defaultCodecs.audio) {\n          codecInfo.audio = defaultCodecs.audio;\n        }\n      }\n    }\n    return codecInfo;\n  };\n  const logFn = logger('PlaylistSelector');\n  const representationToString = function (representation) {\n    if (!representation || !representation.playlist) {\n      return;\n    }\n    const playlist = representation.playlist;\n    return JSON.stringify({\n      id: playlist.id,\n      bandwidth: representation.bandwidth,\n      width: representation.width,\n      height: representation.height,\n      codecs: playlist.attributes && playlist.attributes.CODECS || ''\n    });\n  }; // Utilities\n\n  /**\n   * Returns the CSS value for the specified property on an element\n   * using `getComputedStyle`. Firefox has a long-standing issue where\n   * getComputedStyle() may return null when running in an iframe with\n   * `display: none`.\n   *\n   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n   * @param {HTMLElement} el the htmlelement to work on\n   * @param {string} the proprety to get the style for\n   */\n\n  const safeGetComputedStyle = function (el, property) {\n    if (!el) {\n      return '';\n    }\n    const result = window.getComputedStyle(el);\n    if (!result) {\n      return '';\n    }\n    return result[property];\n  };\n  /**\n   * Resuable stable sort function\n   *\n   * @param {Playlists} array\n   * @param {Function} sortFn Different comparators\n   * @function stableSort\n   */\n\n  const stableSort = function (array, sortFn) {\n    const newArray = array.slice();\n    array.sort(function (left, right) {\n      const cmp = sortFn(left, right);\n      if (cmp === 0) {\n        return newArray.indexOf(left) - newArray.indexOf(right);\n      }\n      return cmp;\n    });\n  };\n  /**\n   * A comparator function to sort two playlist object by bandwidth.\n   *\n   * @param {Object} left a media playlist object\n   * @param {Object} right a media playlist object\n   * @return {number} Greater than zero if the bandwidth attribute of\n   * left is greater than the corresponding attribute of right. Less\n   * than zero if the bandwidth of right is greater than left and\n   * exactly zero if the two are equal.\n   */\n\n  const comparePlaylistBandwidth = function (left, right) {\n    let leftBandwidth;\n    let rightBandwidth;\n    if (left.attributes.BANDWIDTH) {\n      leftBandwidth = left.attributes.BANDWIDTH;\n    }\n    leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\n    if (right.attributes.BANDWIDTH) {\n      rightBandwidth = right.attributes.BANDWIDTH;\n    }\n    rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\n    return leftBandwidth - rightBandwidth;\n  };\n  /**\n   * A comparator function to sort two playlist object by resolution (width).\n   *\n   * @param {Object} left a media playlist object\n   * @param {Object} right a media playlist object\n   * @return {number} Greater than zero if the resolution.width attribute of\n   * left is greater than the corresponding attribute of right. Less\n   * than zero if the resolution.width of right is greater than left and\n   * exactly zero if the two are equal.\n   */\n\n  const comparePlaylistResolution = function (left, right) {\n    let leftWidth;\n    let rightWidth;\n    if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n      leftWidth = left.attributes.RESOLUTION.width;\n    }\n    leftWidth = leftWidth || window.Number.MAX_VALUE;\n    if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n      rightWidth = right.attributes.RESOLUTION.width;\n    }\n    rightWidth = rightWidth || window.Number.MAX_VALUE; // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n    // have the same media dimensions/ resolution\n\n    if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n      return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n    }\n    return leftWidth - rightWidth;\n  };\n  /**\n   * Chooses the appropriate media playlist based on bandwidth and player size\n   *\n   * @param {Object} main\n   *        Object representation of the main manifest\n   * @param {number} playerBandwidth\n   *        Current calculated bandwidth of the player\n   * @param {number} playerWidth\n   *        Current width of the player element (should account for the device pixel ratio)\n   * @param {number} playerHeight\n   *        Current height of the player element (should account for the device pixel ratio)\n   * @param {boolean} limitRenditionByPlayerDimensions\n   *        True if the player width and height should be used during the selection, false otherwise\n   * @param {Object} playlistController\n   *        the current playlistController object\n   * @return {Playlist} the highest bitrate playlist less than the\n   * currently detected bandwidth, accounting for some amount of\n   * bandwidth variance\n   */\n\n  let simpleSelector = function (main, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {\n    // If we end up getting called before `main` is available, exit early\n    if (!main) {\n      return;\n    }\n    const options = {\n      bandwidth: playerBandwidth,\n      width: playerWidth,\n      height: playerHeight,\n      limitRenditionByPlayerDimensions\n    };\n    let playlists = main.playlists; // if playlist is audio only, select between currently active audio group playlists.\n\n    if (Playlist.isAudioOnly(main)) {\n      playlists = playlistController.getAudioTrackPlaylists_(); // add audioOnly to options so that we log audioOnly: true\n      // at the buttom of this function for debugging.\n\n      options.audioOnly = true;\n    } // convert the playlists to an intermediary representation to make comparisons easier\n\n    let sortedPlaylistReps = playlists.map(playlist => {\n      let bandwidth;\n      const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n      const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n      bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;\n      bandwidth = bandwidth || window.Number.MAX_VALUE;\n      return {\n        bandwidth,\n        width,\n        height,\n        playlist\n      };\n    });\n    stableSort(sortedPlaylistReps, (left, right) => left.bandwidth - right.bandwidth); // filter out any playlists that have been excluded due to\n    // incompatible configurations\n\n    sortedPlaylistReps = sortedPlaylistReps.filter(rep => !Playlist.isIncompatible(rep.playlist)); // filter out any playlists that have been disabled manually through the representations\n    // api or excluded temporarily due to playback errors.\n\n    let enabledPlaylistReps = sortedPlaylistReps.filter(rep => Playlist.isEnabled(rep.playlist));\n    if (!enabledPlaylistReps.length) {\n      // if there are no enabled playlists, then they have all been excluded or disabled\n      // by the user through the representations api. In this case, ignore exclusion and\n      // fallback to what the user wants by using playlists the user has not disabled.\n      enabledPlaylistReps = sortedPlaylistReps.filter(rep => !Playlist.isDisabled(rep.playlist));\n    } // filter out any variant that has greater effective bitrate\n    // than the current estimated bandwidth\n\n    const bandwidthPlaylistReps = enabledPlaylistReps.filter(rep => rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth);\n    let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1]; // get all of the renditions with the same (highest) bandwidth\n    // and then taking the very first element\n\n    const bandwidthBestRep = bandwidthPlaylistReps.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0]; // if we're not going to limit renditions by player size, make an early decision.\n\n    if (limitRenditionByPlayerDimensions === false) {\n      const chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n      if (chosenRep && chosenRep.playlist) {\n        let type = 'sortedPlaylistReps';\n        if (bandwidthBestRep) {\n          type = 'bandwidthBestRep';\n        }\n        if (enabledPlaylistReps[0]) {\n          type = 'enabledPlaylistReps';\n        }\n        logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);\n        return chosenRep.playlist;\n      }\n      logFn('could not choose a playlist with options', options);\n      return null;\n    } // filter out playlists without resolution information\n\n    const haveResolution = bandwidthPlaylistReps.filter(rep => rep.width && rep.height); // sort variants by resolution\n\n    stableSort(haveResolution, (left, right) => left.width - right.width); // if we have the exact resolution as the player use it\n\n    const resolutionBestRepList = haveResolution.filter(rep => rep.width === playerWidth && rep.height === playerHeight);\n    highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1]; // ensure that we pick the highest bandwidth variant that have exact resolution\n\n    const resolutionBestRep = resolutionBestRepList.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];\n    let resolutionPlusOneList;\n    let resolutionPlusOneSmallest;\n    let resolutionPlusOneRep; // find the smallest variant that is larger than the player\n    // if there is no match of exact resolution\n\n    if (!resolutionBestRep) {\n      resolutionPlusOneList = haveResolution.filter(rep => rep.width > playerWidth || rep.height > playerHeight); // find all the variants have the same smallest resolution\n\n      resolutionPlusOneSmallest = resolutionPlusOneList.filter(rep => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height); // ensure that we also pick the highest bandwidth variant that\n      // is just-larger-than the video player\n\n      highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n      resolutionPlusOneRep = resolutionPlusOneSmallest.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];\n    }\n    let leastPixelDiffRep; // If this selector proves to be better than others,\n    // resolutionPlusOneRep and resolutionBestRep and all\n    // the code involving them should be removed.\n\n    if (playlistController.leastPixelDiffSelector) {\n      // find the variant that is closest to the player's pixel size\n      const leastPixelDiffList = haveResolution.map(rep => {\n        rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);\n        return rep;\n      }); // get the highest bandwidth, closest resolution playlist\n\n      stableSort(leastPixelDiffList, (left, right) => {\n        // sort by highest bandwidth if pixelDiff is the same\n        if (left.pixelDiff === right.pixelDiff) {\n          return right.bandwidth - left.bandwidth;\n        }\n        return left.pixelDiff - right.pixelDiff;\n      });\n      leastPixelDiffRep = leastPixelDiffList[0];\n    } // fallback chain of variants\n\n    const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n    if (chosenRep && chosenRep.playlist) {\n      let type = 'sortedPlaylistReps';\n      if (leastPixelDiffRep) {\n        type = 'leastPixelDiffRep';\n      } else if (resolutionPlusOneRep) {\n        type = 'resolutionPlusOneRep';\n      } else if (resolutionBestRep) {\n        type = 'resolutionBestRep';\n      } else if (bandwidthBestRep) {\n        type = 'bandwidthBestRep';\n      } else if (enabledPlaylistReps[0]) {\n        type = 'enabledPlaylistReps';\n      }\n      logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);\n      return chosenRep.playlist;\n    }\n    logFn('could not choose a playlist with options', options);\n    return null;\n  };\n\n  /**\n   * Chooses the appropriate media playlist based on the most recent\n   * bandwidth estimate and the player size.\n   *\n   * Expects to be called within the context of an instance of VhsHandler\n   *\n   * @return {Playlist} the highest bitrate playlist less than the\n   * currently detected bandwidth, accounting for some amount of\n   * bandwidth variance\n   */\n\n  const lastBandwidthSelector = function () {\n    const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n    return simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);\n  };\n  /**\n   * Chooses the appropriate media playlist based on an\n   * exponential-weighted moving average of the bandwidth after\n   * filtering for player size.\n   *\n   * Expects to be called within the context of an instance of VhsHandler\n   *\n   * @param {number} decay - a number between 0 and 1. Higher values of\n   * this parameter will cause previous bandwidth estimates to lose\n   * significance more quickly.\n   * @return {Function} a function which can be invoked to create a new\n   * playlist selector function.\n   * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n   */\n\n  const movingAverageBandwidthSelector = function (decay) {\n    let average = -1;\n    let lastSystemBandwidth = -1;\n    if (decay < 0 || decay > 1) {\n      throw new Error('Moving average bandwidth decay must be between 0 and 1.');\n    }\n    return function () {\n      const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n      if (average < 0) {\n        average = this.systemBandwidth;\n        lastSystemBandwidth = this.systemBandwidth;\n      } // stop the average value from decaying for every 250ms\n      // when the systemBandwidth is constant\n      // and\n      // stop average from setting to a very low value when the\n      // systemBandwidth becomes 0 in case of chunk cancellation\n\n      if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {\n        average = decay * this.systemBandwidth + (1 - decay) * average;\n        lastSystemBandwidth = this.systemBandwidth;\n      }\n      return simpleSelector(this.playlists.main, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);\n    };\n  };\n  /**\n   * Chooses the appropriate media playlist based on the potential to rebuffer\n   *\n   * @param {Object} settings\n   *        Object of information required to use this selector\n   * @param {Object} settings.main\n   *        Object representation of the main manifest\n   * @param {number} settings.currentTime\n   *        The current time of the player\n   * @param {number} settings.bandwidth\n   *        Current measured bandwidth\n   * @param {number} settings.duration\n   *        Duration of the media\n   * @param {number} settings.segmentDuration\n   *        Segment duration to be used in round trip time calculations\n   * @param {number} settings.timeUntilRebuffer\n   *        Time left in seconds until the player has to rebuffer\n   * @param {number} settings.currentTimeline\n   *        The current timeline segments are being loaded from\n   * @param {SyncController} settings.syncController\n   *        SyncController for determining if we have a sync point for a given playlist\n   * @return {Object|null}\n   *         {Object} return.playlist\n   *         The highest bandwidth playlist with the least amount of rebuffering\n   *         {Number} return.rebufferingImpact\n   *         The amount of time in seconds switching to this playlist will rebuffer. A\n   *         negative value means that switching will cause zero rebuffering.\n   */\n\n  const minRebufferMaxBandwidthSelector = function (settings) {\n    const {\n      main,\n      currentTime,\n      bandwidth,\n      duration,\n      segmentDuration,\n      timeUntilRebuffer,\n      currentTimeline,\n      syncController\n    } = settings; // filter out any playlists that have been excluded due to\n    // incompatible configurations\n\n    const compatiblePlaylists = main.playlists.filter(playlist => !Playlist.isIncompatible(playlist)); // filter out any playlists that have been disabled manually through the representations\n    // api or excluded temporarily due to playback errors.\n\n    let enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);\n    if (!enabledPlaylists.length) {\n      // if there are no enabled playlists, then they have all been excluded or disabled\n      // by the user through the representations api. In this case, ignore exclusion and\n      // fallback to what the user wants by using playlists the user has not disabled.\n      enabledPlaylists = compatiblePlaylists.filter(playlist => !Playlist.isDisabled(playlist));\n    }\n    const bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));\n    const rebufferingEstimates = bandwidthPlaylists.map(playlist => {\n      const syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime); // If there is no sync point for this playlist, switching to it will require a\n      // sync request first. This will double the request time\n\n      const numRequests = syncPoint ? 1 : 2;\n      const requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n      const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n      return {\n        playlist,\n        rebufferingImpact\n      };\n    });\n    const noRebufferingPlaylists = rebufferingEstimates.filter(estimate => estimate.rebufferingImpact <= 0); // Sort by bandwidth DESC\n\n    stableSort(noRebufferingPlaylists, (a, b) => comparePlaylistBandwidth(b.playlist, a.playlist));\n    if (noRebufferingPlaylists.length) {\n      return noRebufferingPlaylists[0];\n    }\n    stableSort(rebufferingEstimates, (a, b) => a.rebufferingImpact - b.rebufferingImpact);\n    return rebufferingEstimates[0] || null;\n  };\n  /**\n   * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n   * one with video.  If no renditions with video exist, return the lowest audio rendition.\n   *\n   * Expects to be called within the context of an instance of VhsHandler\n   *\n   * @return {Object|null}\n   *         {Object} return.playlist\n   *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n   *         exists pick the lowest audio rendition.\n   */\n\n  const lowestBitrateCompatibleVariantSelector = function () {\n    // filter out any playlists that have been excluded due to\n    // incompatible configurations or playback errors\n    const playlists = this.playlists.main.playlists.filter(Playlist.isEnabled); // Sort ascending by bitrate\n\n    stableSort(playlists, (a, b) => comparePlaylistBandwidth(a, b)); // Parse and assume that playlists with no video codec have no video\n    // (this is not necessarily true, although it is generally true).\n    //\n    // If an entire manifest has no valid videos everything will get filtered\n    // out.\n\n    const playlistsWithVideo = playlists.filter(playlist => !!codecsForPlaylist(this.playlists.main, playlist).video);\n    return playlistsWithVideo[0] || null;\n  };\n\n  /**\n   * Combine all segments into a single Uint8Array\n   *\n   * @param {Object} segmentObj\n   * @return {Uint8Array} concatenated bytes\n   * @private\n   */\n  const concatSegments = segmentObj => {\n    let offset = 0;\n    let tempBuffer;\n    if (segmentObj.bytes) {\n      tempBuffer = new Uint8Array(segmentObj.bytes); // combine the individual segments into one large typed-array\n\n      segmentObj.segments.forEach(segment => {\n        tempBuffer.set(segment, offset);\n        offset += segment.byteLength;\n      });\n    }\n    return tempBuffer;\n  };\n\n  /**\n   * @file text-tracks.js\n   */\n  /**\n   * Create captions text tracks on video.js if they do not exist\n   *\n   * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n   * @param {Object} tech the video.js tech\n   * @param {Object} captionStream the caption stream to create\n   * @private\n   */\n\n  const createCaptionsTrackIfNotExists = function (inbandTextTracks, tech, captionStream) {\n    if (!inbandTextTracks[captionStream]) {\n      tech.trigger({\n        type: 'usage',\n        name: 'vhs-608'\n      });\n      let instreamId = captionStream; // we need to translate SERVICEn for 708 to how mux.js currently labels them\n\n      if (/^cc708_/.test(captionStream)) {\n        instreamId = 'SERVICE' + captionStream.split('_')[1];\n      }\n      const track = tech.textTracks().getTrackById(instreamId);\n      if (track) {\n        // Resuse an existing track with a CC# id because this was\n        // very likely created by videojs-contrib-hls from information\n        // in the m3u8 for us to use\n        inbandTextTracks[captionStream] = track;\n      } else {\n        // This section gets called when we have caption services that aren't specified in the manifest.\n        // Manifest level caption services are handled in media-groups.js under CLOSED-CAPTIONS.\n        const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\n        let label = captionStream;\n        let language = captionStream;\n        let def = false;\n        const captionService = captionServices[instreamId];\n        if (captionService) {\n          label = captionService.label;\n          language = captionService.language;\n          def = captionService.default;\n        } // Otherwise, create a track with the default `CC#` label and\n        // without a language\n\n        inbandTextTracks[captionStream] = tech.addRemoteTextTrack({\n          kind: 'captions',\n          id: instreamId,\n          // TODO: investigate why this doesn't seem to turn the caption on by default\n          default: def,\n          label,\n          language\n        }, false).track;\n      }\n    }\n  };\n  /**\n   * Add caption text track data to a source handler given an array of captions\n   *\n   * @param {Object}\n   *   @param {Object} inbandTextTracks the inband text tracks\n   *   @param {number} timestampOffset the timestamp offset of the source buffer\n   *   @param {Array} captionArray an array of caption data\n   * @private\n   */\n\n  const addCaptionData = function ({\n    inbandTextTracks,\n    captionArray,\n    timestampOffset\n  }) {\n    if (!captionArray) {\n      return;\n    }\n    const Cue = window.WebKitDataCue || window.VTTCue;\n    captionArray.forEach(caption => {\n      const track = caption.stream;\n      inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));\n    });\n  };\n  /**\n   * Define properties on a cue for backwards compatability,\n   * but warn the user that the way that they are using it\n   * is depricated and will be removed at a later date.\n   *\n   * @param {Cue} cue the cue to add the properties on\n   * @private\n   */\n\n  const deprecateOldCue = function (cue) {\n    Object.defineProperties(cue.frame, {\n      id: {\n        get() {\n          videojs.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n          return cue.value.key;\n        }\n      },\n      value: {\n        get() {\n          videojs.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n          return cue.value.data;\n        }\n      },\n      privateData: {\n        get() {\n          videojs.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n          return cue.value.data;\n        }\n      }\n    });\n  };\n  /**\n   * Add metadata text track data to a source handler given an array of metadata\n   *\n   * @param {Object}\n   *   @param {Object} inbandTextTracks the inband text tracks\n   *   @param {Array} metadataArray an array of meta data\n   *   @param {number} timestampOffset the timestamp offset of the source buffer\n   *   @param {number} videoDuration the duration of the video\n   * @private\n   */\n\n  const addMetadata = ({\n    inbandTextTracks,\n    metadataArray,\n    timestampOffset,\n    videoDuration\n  }) => {\n    if (!metadataArray) {\n      return;\n    }\n    const Cue = window.WebKitDataCue || window.VTTCue;\n    const metadataTrack = inbandTextTracks.metadataTrack_;\n    if (!metadataTrack) {\n      return;\n    }\n    metadataArray.forEach(metadata => {\n      const time = metadata.cueTime + timestampOffset; // if time isn't a finite number between 0 and Infinity, like NaN,\n      // ignore this bit of metadata.\n      // This likely occurs when you have an non-timed ID3 tag like TIT2,\n      // which is the \"Title/Songname/Content description\" frame\n\n      if (typeof time !== 'number' || window.isNaN(time) || time < 0 || !(time < Infinity)) {\n        return;\n      }\n      metadata.frames.forEach(frame => {\n        const cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n        cue.frame = frame;\n        cue.value = frame;\n        deprecateOldCue(cue);\n        metadataTrack.addCue(cue);\n      });\n    });\n    if (!metadataTrack.cues || !metadataTrack.cues.length) {\n      return;\n    } // Updating the metadeta cues so that\n    // the endTime of each cue is the startTime of the next cue\n    // the endTime of last cue is the duration of the video\n\n    const cues = metadataTrack.cues;\n    const cuesArray = []; // Create a copy of the TextTrackCueList...\n    // ...disregarding cues with a falsey value\n\n    for (let i = 0; i < cues.length; i++) {\n      if (cues[i]) {\n        cuesArray.push(cues[i]);\n      }\n    } // Group cues by their startTime value\n\n    const cuesGroupedByStartTime = cuesArray.reduce((obj, cue) => {\n      const timeSlot = obj[cue.startTime] || [];\n      timeSlot.push(cue);\n      obj[cue.startTime] = timeSlot;\n      return obj;\n    }, {}); // Sort startTimes by ascending order\n\n    const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort((a, b) => Number(a) - Number(b)); // Map each cue group's endTime to the next group's startTime\n\n    sortedStartTimes.forEach((startTime, idx) => {\n      const cueGroup = cuesGroupedByStartTime[startTime];\n      const nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration; // Map each cue's endTime the next group's startTime\n\n      cueGroup.forEach(cue => {\n        cue.endTime = nextTime;\n      });\n    });\n  };\n  /**\n   * Create metadata text track on video.js if it does not exist\n   *\n   * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n   * @param {string} dispatchType the inband metadata track dispatch type\n   * @param {Object} tech the video.js tech\n   * @private\n   */\n\n  const createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {\n    if (inbandTextTracks.metadataTrack_) {\n      return;\n    }\n    inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'Timed Metadata'\n    }, false).track;\n    inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;\n  };\n  /**\n   * Remove cues from a track on video.js.\n   *\n   * @param {Double} start start of where we should remove the cue\n   * @param {Double} end end of where the we should remove the cue\n   * @param {Object} track the text track to remove the cues from\n   * @private\n   */\n\n  const removeCuesFromTrack = function (start, end, track) {\n    let i;\n    let cue;\n    if (!track) {\n      return;\n    }\n    if (!track.cues) {\n      return;\n    }\n    i = track.cues.length;\n    while (i--) {\n      cue = track.cues[i]; // Remove any cue within the provided start and end time\n\n      if (cue.startTime >= start && cue.endTime <= end) {\n        track.removeCue(cue);\n      }\n    }\n  };\n  /**\n   * Remove duplicate cues from a track on video.js (a cue is considered a\n   * duplicate if it has the same time interval and text as another)\n   *\n   * @param {Object} track the text track to remove the duplicate cues from\n   * @private\n   */\n\n  const removeDuplicateCuesFromTrack = function (track) {\n    const cues = track.cues;\n    if (!cues) {\n      return;\n    }\n    for (let i = 0; i < cues.length; i++) {\n      const duplicates = [];\n      let occurrences = 0;\n      for (let j = 0; j < cues.length; j++) {\n        if (cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text) {\n          occurrences++;\n          if (occurrences > 1) {\n            duplicates.push(cues[j]);\n          }\n        }\n      }\n      if (duplicates.length) {\n        duplicates.forEach(dupe => track.removeCue(dupe));\n      }\n    }\n  };\n\n  /**\n   * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n   * front of current time.\n   *\n   * @param {Array} buffer\n   *        The current buffer of gop information\n   * @param {number} currentTime\n   *        The current time\n   * @param {Double} mapping\n   *        Offset to map display time to stream presentation time\n   * @return {Array}\n   *         List of gops considered safe to append over\n   */\n\n  const gopsSafeToAlignWith = (buffer, currentTime, mapping) => {\n    if (typeof currentTime === 'undefined' || currentTime === null || !buffer.length) {\n      return [];\n    } // pts value for current time + 3 seconds to give a bit more wiggle room\n\n    const currentTimePts = Math.ceil((currentTime - mapping + 3) * clock_1);\n    let i;\n    for (i = 0; i < buffer.length; i++) {\n      if (buffer[i].pts > currentTimePts) {\n        break;\n      }\n    }\n    return buffer.slice(i);\n  };\n  /**\n   * Appends gop information (timing and byteLength) received by the transmuxer for the\n   * gops appended in the last call to appendBuffer\n   *\n   * @param {Array} buffer\n   *        The current buffer of gop information\n   * @param {Array} gops\n   *        List of new gop information\n   * @param {boolean} replace\n   *        If true, replace the buffer with the new gop information. If false, append the\n   *        new gop information to the buffer in the right location of time.\n   * @return {Array}\n   *         Updated list of gop information\n   */\n\n  const updateGopBuffer = (buffer, gops, replace) => {\n    if (!gops.length) {\n      return buffer;\n    }\n    if (replace) {\n      // If we are in safe append mode, then completely overwrite the gop buffer\n      // with the most recent appeneded data. This will make sure that when appending\n      // future segments, we only try to align with gops that are both ahead of current\n      // time and in the last segment appended.\n      return gops.slice();\n    }\n    const start = gops[0].pts;\n    let i = 0;\n    for (i; i < buffer.length; i++) {\n      if (buffer[i].pts >= start) {\n        break;\n      }\n    }\n    return buffer.slice(0, i).concat(gops);\n  };\n  /**\n   * Removes gop information in buffer that overlaps with provided start and end\n   *\n   * @param {Array} buffer\n   *        The current buffer of gop information\n   * @param {Double} start\n   *        position to start the remove at\n   * @param {Double} end\n   *        position to end the remove at\n   * @param {Double} mapping\n   *        Offset to map display time to stream presentation time\n   */\n\n  const removeGopBuffer = (buffer, start, end, mapping) => {\n    const startPts = Math.ceil((start - mapping) * clock_1);\n    const endPts = Math.ceil((end - mapping) * clock_1);\n    const updatedBuffer = buffer.slice();\n    let i = buffer.length;\n    while (i--) {\n      if (buffer[i].pts <= endPts) {\n        break;\n      }\n    }\n    if (i === -1) {\n      // no removal because end of remove range is before start of buffer\n      return updatedBuffer;\n    }\n    let j = i + 1;\n    while (j--) {\n      if (buffer[j].pts <= startPts) {\n        break;\n      }\n    } // clamp remove range start to 0 index\n\n    j = Math.max(j, 0);\n    updatedBuffer.splice(j, i - j + 1);\n    return updatedBuffer;\n  };\n  const shallowEqual = function (a, b) {\n    // if both are undefined\n    // or one or the other is undefined\n    // they are not equal\n    if (!a && !b || !a && b || a && !b) {\n      return false;\n    } // they are the same object and thus, equal\n\n    if (a === b) {\n      return true;\n    } // sort keys so we can make sure they have\n    // all the same keys later.\n\n    const akeys = Object.keys(a).sort();\n    const bkeys = Object.keys(b).sort(); // different number of keys, not equal\n\n    if (akeys.length !== bkeys.length) {\n      return false;\n    }\n    for (let i = 0; i < akeys.length; i++) {\n      const key = akeys[i]; // different sorted keys, not equal\n\n      if (key !== bkeys[i]) {\n        return false;\n      } // different values, not equal\n\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  // https://www.w3.org/TR/WebIDL-1/#quotaexceedederror\n  const QUOTA_EXCEEDED_ERR = 22;\n\n  /**\n   * The segment loader has no recourse except to fetch a segment in the\n   * current playlist and use the internal timestamps in that segment to\n   * generate a syncPoint. This function returns a good candidate index\n   * for that process.\n   *\n   * @param {Array} segments - the segments array from a playlist.\n   * @return {number} An index of a segment from the playlist to load\n   */\n\n  const getSyncSegmentCandidate = function (currentTimeline, segments, targetTime) {\n    segments = segments || [];\n    const timelineSegments = [];\n    let time = 0;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (currentTimeline === segment.timeline) {\n        timelineSegments.push(i);\n        time += segment.duration;\n        if (time > targetTime) {\n          return i;\n        }\n      }\n    }\n    if (timelineSegments.length === 0) {\n      return 0;\n    } // default to the last timeline segment\n\n    return timelineSegments[timelineSegments.length - 1];\n  }; // In the event of a quota exceeded error, keep at least one second of back buffer. This\n  // number was arbitrarily chosen and may be updated in the future, but seemed reasonable\n  // as a start to prevent any potential issues with removing content too close to the\n  // playhead.\n\n  const MIN_BACK_BUFFER = 1; // in ms\n\n  const CHECK_BUFFER_DELAY = 500;\n  const finite = num => typeof num === 'number' && isFinite(num); // With most content hovering around 30fps, if a segment has a duration less than a half\n  // frame at 30fps or one frame at 60fps, the bandwidth and throughput calculations will\n  // not accurately reflect the rest of the content.\n\n  const MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;\n  const illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {\n    // Although these checks should most likely cover non 'main' types, for now it narrows\n    // the scope of our checks.\n    if (loaderType !== 'main' || !startingMedia || !trackInfo) {\n      return null;\n    }\n    if (!trackInfo.hasAudio && !trackInfo.hasVideo) {\n      return 'Neither audio nor video found in segment.';\n    }\n    if (startingMedia.hasVideo && !trackInfo.hasVideo) {\n      return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n    }\n    if (!startingMedia.hasVideo && trackInfo.hasVideo) {\n      return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n    }\n    return null;\n  };\n  /**\n   * Calculates a time value that is safe to remove from the back buffer without interrupting\n   * playback.\n   *\n   * @param {TimeRange} seekable\n   *        The current seekable range\n   * @param {number} currentTime\n   *        The current time of the player\n   * @param {number} targetDuration\n   *        The target duration of the current playlist\n   * @return {number}\n   *         Time that is safe to remove from the back buffer without interrupting playback\n   */\n\n  const safeBackBufferTrimTime = (seekable, currentTime, targetDuration) => {\n    // 30 seconds before the playhead provides a safe default for trimming.\n    //\n    // Choosing a reasonable default is particularly important for high bitrate content and\n    // VOD videos/live streams with large windows, as the buffer may end up overfilled and\n    // throw an APPEND_BUFFER_ERR.\n    let trimTime = currentTime - Config.BACK_BUFFER_LENGTH;\n    if (seekable.length) {\n      // Some live playlists may have a shorter window of content than the full allowed back\n      // buffer. For these playlists, don't save content that's no longer within the window.\n      trimTime = Math.max(trimTime, seekable.start(0));\n    } // Don't remove within target duration of the current time to avoid the possibility of\n    // removing the GOP currently being played, as removing it can cause playback stalls.\n\n    const maxTrimTime = currentTime - targetDuration;\n    return Math.min(maxTrimTime, trimTime);\n  };\n  const segmentInfoString = segmentInfo => {\n    const {\n      startOfSegment,\n      duration,\n      segment,\n      part,\n      playlist: {\n        mediaSequence: seq,\n        id,\n        segments = []\n      },\n      mediaIndex: index,\n      partIndex,\n      timeline\n    } = segmentInfo;\n    const segmentLen = segments.length - 1;\n    let selection = 'mediaIndex/partIndex increment';\n    if (segmentInfo.getMediaInfoForTime) {\n      selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`;\n    } else if (segmentInfo.isSyncRequest) {\n      selection = 'getSyncSegmentCandidate (isSyncRequest)';\n    }\n    if (segmentInfo.independent) {\n      selection += ` with independent ${segmentInfo.independent}`;\n    }\n    const hasPartIndex = typeof partIndex === 'number';\n    const name = segmentInfo.segment.uri ? 'segment' : 'pre-segment';\n    const zeroBasedPartCount = hasPartIndex ? getKnownPartCount({\n      preloadSegment: segment\n    }) - 1 : 0;\n    return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : '') + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : '') + ` startOfSegment [${startOfSegment}]` + ` duration [${duration}]` + ` timeline [${timeline}]` + ` selected by [${selection}]` + ` playlist [${id}]`;\n  };\n  const timingInfoPropertyForMedia = mediaType => `${mediaType}TimingInfo`;\n  /**\n   * Returns the timestamp offset to use for the segment.\n   *\n   * @param {number} segmentTimeline\n   *        The timeline of the segment\n   * @param {number} currentTimeline\n   *        The timeline currently being followed by the loader\n   * @param {number} startOfSegment\n   *        The estimated segment start\n   * @param {TimeRange[]} buffered\n   *        The loader's buffer\n   * @param {boolean} overrideCheck\n   *        If true, no checks are made to see if the timestamp offset value should be set,\n   *        but sets it directly to a value.\n   *\n   * @return {number|null}\n   *         Either a number representing a new timestamp offset, or null if the segment is\n   *         part of the same timeline\n   */\n\n  const timestampOffsetForSegment = ({\n    segmentTimeline,\n    currentTimeline,\n    startOfSegment,\n    buffered,\n    overrideCheck\n  }) => {\n    // Check to see if we are crossing a discontinuity to see if we need to set the\n    // timestamp offset on the transmuxer and source buffer.\n    //\n    // Previously, we changed the timestampOffset if the start of this segment was less than\n    // the currently set timestampOffset, but this isn't desirable as it can produce bad\n    // behavior, especially around long running live streams.\n    if (!overrideCheck && segmentTimeline === currentTimeline) {\n      return null;\n    } // When changing renditions, it's possible to request a segment on an older timeline. For\n    // instance, given two renditions with the following:\n    //\n    // #EXTINF:10\n    // segment1\n    // #EXT-X-DISCONTINUITY\n    // #EXTINF:10\n    // segment2\n    // #EXTINF:10\n    // segment3\n    //\n    // And the current player state:\n    //\n    // current time: 8\n    // buffer: 0 => 20\n    //\n    // The next segment on the current rendition would be segment3, filling the buffer from\n    // 20s onwards. However, if a rendition switch happens after segment2 was requested,\n    // then the next segment to be requested will be segment1 from the new rendition in\n    // order to fill time 8 and onwards. Using the buffered end would result in repeated\n    // content (since it would position segment1 of the new rendition starting at 20s). This\n    // case can be identified when the new segment's timeline is a prior value. Instead of\n    // using the buffered end, the startOfSegment can be used, which, hopefully, will be\n    // more accurate to the actual start time of the segment.\n\n    if (segmentTimeline < currentTimeline) {\n      return startOfSegment;\n    } // segmentInfo.startOfSegment used to be used as the timestamp offset, however, that\n    // value uses the end of the last segment if it is available. While this value\n    // should often be correct, it's better to rely on the buffered end, as the new\n    // content post discontinuity should line up with the buffered end as if it were\n    // time 0 for the new content.\n\n    return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;\n  };\n  /**\n   * Returns whether or not the loader should wait for a timeline change from the timeline\n   * change controller before processing the segment.\n   *\n   * Primary timing in VHS goes by video. This is different from most media players, as\n   * audio is more often used as the primary timing source. For the foreseeable future, VHS\n   * will continue to use video as the primary timing source, due to the current logic and\n   * expectations built around it.\n\n   * Since the timing follows video, in order to maintain sync, the video loader is\n   * responsible for setting both audio and video source buffer timestamp offsets.\n   *\n   * Setting different values for audio and video source buffers could lead to\n   * desyncing. The following examples demonstrate some of the situations where this\n   * distinction is important. Note that all of these cases involve demuxed content. When\n   * content is muxed, the audio and video are packaged together, therefore syncing\n   * separate media playlists is not an issue.\n   *\n   * CASE 1: Audio prepares to load a new timeline before video:\n   *\n   * Timeline:       0                 1\n   * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n   * Audio Loader:                     ^\n   * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n   * Video Loader              ^\n   *\n   * In the above example, the audio loader is preparing to load the 6th segment, the first\n   * after a discontinuity, while the video loader is still loading the 5th segment, before\n   * the discontinuity.\n   *\n   * If the audio loader goes ahead and loads and appends the 6th segment before the video\n   * loader crosses the discontinuity, then when appended, the 6th audio segment will use\n   * the timestamp offset from timeline 0. This will likely lead to desyncing. In addition,\n   * the audio loader must provide the audioAppendStart value to trim the content in the\n   * transmuxer, and that value relies on the audio timestamp offset. Since the audio\n   * timestamp offset is set by the video (main) loader, the audio loader shouldn't load the\n   * segment until that value is provided.\n   *\n   * CASE 2: Video prepares to load a new timeline before audio:\n   *\n   * Timeline:       0                 1\n   * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n   * Audio Loader:             ^\n   * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n   * Video Loader                      ^\n   *\n   * In the above example, the video loader is preparing to load the 6th segment, the first\n   * after a discontinuity, while the audio loader is still loading the 5th segment, before\n   * the discontinuity.\n   *\n   * If the video loader goes ahead and loads and appends the 6th segment, then once the\n   * segment is loaded and processed, both the video and audio timestamp offsets will be\n   * set, since video is used as the primary timing source. This is to ensure content lines\n   * up appropriately, as any modifications to the video timing are reflected by audio when\n   * the video loader sets the audio and video timestamp offsets to the same value. However,\n   * setting the timestamp offset for audio before audio has had a chance to change\n   * timelines will likely lead to desyncing, as the audio loader will append segment 5 with\n   * a timestamp intended to apply to segments from timeline 1 rather than timeline 0.\n   *\n   * CASE 3: When seeking, audio prepares to load a new timeline before video\n   *\n   * Timeline:       0                 1\n   * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n   * Audio Loader:           ^\n   * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n   * Video Loader            ^\n   *\n   * In the above example, both audio and video loaders are loading segments from timeline\n   * 0, but imagine that the seek originated from timeline 1.\n   *\n   * When seeking to a new timeline, the timestamp offset will be set based on the expected\n   * segment start of the loaded video segment. In order to maintain sync, the audio loader\n   * must wait for the video loader to load its segment and update both the audio and video\n   * timestamp offsets before it may load and append its own segment. This is the case\n   * whether the seek results in a mismatched segment request (e.g., the audio loader\n   * chooses to load segment 3 and the video loader chooses to load segment 4) or the\n   * loaders choose to load the same segment index from each playlist, as the segments may\n   * not be aligned perfectly, even for matching segment indexes.\n   *\n   * @param {Object} timelinechangeController\n   * @param {number} currentTimeline\n   *        The timeline currently being followed by the loader\n   * @param {number} segmentTimeline\n   *        The timeline of the segment being loaded\n   * @param {('main'|'audio')} loaderType\n   *        The loader type\n   * @param {boolean} audioDisabled\n   *        Whether the audio is disabled for the loader. This should only be true when the\n   *        loader may have muxed audio in its segment, but should not append it, e.g., for\n   *        the main loader when an alternate audio playlist is active.\n   *\n   * @return {boolean}\n   *         Whether the loader should wait for a timeline change from the timeline change\n   *         controller before processing the segment\n   */\n\n  const shouldWaitForTimelineChange = ({\n    timelineChangeController,\n    currentTimeline,\n    segmentTimeline,\n    loaderType,\n    audioDisabled\n  }) => {\n    if (currentTimeline === segmentTimeline) {\n      return false;\n    }\n    if (loaderType === 'audio') {\n      const lastMainTimelineChange = timelineChangeController.lastTimelineChange({\n        type: 'main'\n      }); // Audio loader should wait if:\n      //\n      // * main hasn't had a timeline change yet (thus has not loaded its first segment)\n      // * main hasn't yet changed to the timeline audio is looking to load\n\n      return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;\n    } // The main loader only needs to wait for timeline changes if there's demuxed audio.\n    // Otherwise, there's nothing to wait for, since audio would be muxed into the main\n    // loader's segments (or the content is audio/video only and handled by the main\n    // loader).\n\n    if (loaderType === 'main' && audioDisabled) {\n      const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({\n        type: 'audio'\n      }); // Main loader should wait for the audio loader if audio is not pending a timeline\n      // change to the current timeline.\n      //\n      // Since the main loader is responsible for setting the timestamp offset for both\n      // audio and video, the main loader must wait for audio to be about to change to its\n      // timeline before setting the offset, otherwise, if audio is behind in loading,\n      // segments from the previous timeline would be adjusted by the new timestamp offset.\n      //\n      // This requirement means that video will not cross a timeline until the audio is\n      // about to cross to it, so that way audio and video will always cross the timeline\n      // together.\n      //\n      // In addition to normal timeline changes, these rules also apply to the start of a\n      // stream (going from a non-existent timeline, -1, to timeline 0). It's important\n      // that these rules apply to the first timeline change because if they did not, it's\n      // possible that the main loader will cross two timelines before the audio loader has\n      // crossed one. Logic may be implemented to handle the startup as a special case, but\n      // it's easier to simply treat all timeline changes the same.\n\n      if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  };\n  const mediaDuration = timingInfos => {\n    let maxDuration = 0;\n    ['video', 'audio'].forEach(function (type) {\n      const typeTimingInfo = timingInfos[`${type}TimingInfo`];\n      if (!typeTimingInfo) {\n        return;\n      }\n      const {\n        start,\n        end\n      } = typeTimingInfo;\n      let duration;\n      if (typeof start === 'bigint' || typeof end === 'bigint') {\n        duration = window.BigInt(end) - window.BigInt(start);\n      } else if (typeof start === 'number' && typeof end === 'number') {\n        duration = end - start;\n      }\n      if (typeof duration !== 'undefined' && duration > maxDuration) {\n        maxDuration = duration;\n      }\n    }); // convert back to a number if it is lower than MAX_SAFE_INTEGER\n    // as we only need BigInt when we are above that.\n\n    if (typeof maxDuration === 'bigint' && maxDuration < Number.MAX_SAFE_INTEGER) {\n      maxDuration = Number(maxDuration);\n    }\n    return maxDuration;\n  };\n  const segmentTooLong = ({\n    segmentDuration,\n    maxDuration\n  }) => {\n    // 0 duration segments are most likely due to metadata only segments or a lack of\n    // information.\n    if (!segmentDuration) {\n      return false;\n    } // For HLS:\n    //\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1\n    // The EXTINF duration of each Media Segment in the Playlist\n    // file, when rounded to the nearest integer, MUST be less than or equal\n    // to the target duration; longer segments can trigger playback stalls\n    // or other errors.\n    //\n    // For DASH, the mpd-parser uses the largest reported segment duration as the target\n    // duration. Although that reported duration is occasionally approximate (i.e., not\n    // exact), a strict check may report that a segment is too long more often in DASH.\n\n    return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;\n  };\n  const getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {\n    // Right now we aren't following DASH's timing model exactly, so only perform\n    // this check for HLS content.\n    if (sourceType !== 'hls') {\n      return null;\n    }\n    const segmentDuration = mediaDuration({\n      audioTimingInfo: segmentInfo.audioTimingInfo,\n      videoTimingInfo: segmentInfo.videoTimingInfo\n    }); // Don't report if we lack information.\n    //\n    // If the segment has a duration of 0 it is either a lack of information or a\n    // metadata only segment and shouldn't be reported here.\n\n    if (!segmentDuration) {\n      return null;\n    }\n    const targetDuration = segmentInfo.playlist.targetDuration;\n    const isSegmentWayTooLong = segmentTooLong({\n      segmentDuration,\n      maxDuration: targetDuration * 2\n    });\n    const isSegmentSlightlyTooLong = segmentTooLong({\n      segmentDuration,\n      maxDuration: targetDuration\n    });\n    const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} ` + `from playlist ${segmentInfo.playlist.id} ` + `has a duration of ${segmentDuration} ` + `when the reported duration is ${segmentInfo.duration} ` + `and the target duration is ${targetDuration}. ` + 'For HLS content, a duration in excess of the target duration may result in ' + 'playback issues. See the HLS specification section on EXT-X-TARGETDURATION for ' + 'more details: ' + 'https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1';\n    if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {\n      return {\n        severity: isSegmentWayTooLong ? 'warn' : 'info',\n        message: segmentTooLongMessage\n      };\n    }\n    return null;\n  };\n  /**\n   * An object that manages segment loading and appending.\n   *\n   * @class SegmentLoader\n   * @param {Object} options required and optional options\n   * @extends videojs.EventTarget\n   */\n\n  class SegmentLoader extends videojs.EventTarget {\n    constructor(settings, options = {}) {\n      super(); // check pre-conditions\n\n      if (!settings) {\n        throw new TypeError('Initialization settings are required');\n      }\n      if (typeof settings.currentTime !== 'function') {\n        throw new TypeError('No currentTime getter specified');\n      }\n      if (!settings.mediaSource) {\n        throw new TypeError('No MediaSource specified');\n      } // public properties\n\n      this.bandwidth = settings.bandwidth;\n      this.throughput = {\n        rate: 0,\n        count: 0\n      };\n      this.roundTrip = NaN;\n      this.resetStats_();\n      this.mediaIndex = null;\n      this.partIndex = null; // private settings\n\n      this.hasPlayed_ = settings.hasPlayed;\n      this.currentTime_ = settings.currentTime;\n      this.seekable_ = settings.seekable;\n      this.seeking_ = settings.seeking;\n      this.duration_ = settings.duration;\n      this.mediaSource_ = settings.mediaSource;\n      this.vhs_ = settings.vhs;\n      this.loaderType_ = settings.loaderType;\n      this.currentMediaInfo_ = void 0;\n      this.startingMediaInfo_ = void 0;\n      this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n      this.goalBufferLength_ = settings.goalBufferLength;\n      this.sourceType_ = settings.sourceType;\n      this.sourceUpdater_ = settings.sourceUpdater;\n      this.inbandTextTracks_ = settings.inbandTextTracks;\n      this.state_ = 'INIT';\n      this.timelineChangeController_ = settings.timelineChangeController;\n      this.shouldSaveSegmentTimingInfo_ = true;\n      this.parse708captions_ = settings.parse708captions;\n      this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;\n      this.captionServices_ = settings.captionServices;\n      this.exactManifestTimings = settings.exactManifestTimings; // private instance variables\n\n      this.checkBufferTimeout_ = null;\n      this.error_ = void 0;\n      this.currentTimeline_ = -1;\n      this.pendingSegment_ = null;\n      this.xhrOptions_ = null;\n      this.pendingSegments_ = [];\n      this.audioDisabled_ = false;\n      this.isPendingTimestampOffset_ = false; // TODO possibly move gopBuffer and timeMapping info to a separate controller\n\n      this.gopBuffer_ = [];\n      this.timeMapping_ = 0;\n      this.safeAppend_ = videojs.browser.IE_VERSION >= 11;\n      this.appendInitSegment_ = {\n        audio: true,\n        video: true\n      };\n      this.playlistOfLastInitSegment_ = {\n        audio: null,\n        video: null\n      };\n      this.callQueue_ = []; // If the segment loader prepares to load a segment, but does not have enough\n      // information yet to start the loading process (e.g., if the audio loader wants to\n      // load a segment from the next timeline but the main loader hasn't yet crossed that\n      // timeline), then the load call will be added to the queue until it is ready to be\n      // processed.\n\n      this.loadQueue_ = [];\n      this.metadataQueue_ = {\n        id3: [],\n        caption: []\n      };\n      this.waitingOnRemove_ = false;\n      this.quotaExceededErrorRetryTimeout_ = null; // Fragmented mp4 playback\n\n      this.activeInitSegmentId_ = null;\n      this.initSegments_ = {}; // HLSe playback\n\n      this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;\n      this.keyCache_ = {};\n      this.decrypter_ = settings.decrypter; // Manages the tracking and generation of sync-points, mappings\n      // between a time in the display time and a segment index within\n      // a playlist\n\n      this.syncController_ = settings.syncController;\n      this.syncPoint_ = {\n        segmentIndex: 0,\n        time: 0\n      };\n      this.transmuxer_ = this.createTransmuxer_();\n      this.triggerSyncInfoUpdate_ = () => this.trigger('syncinfoupdate');\n      this.syncController_.on('syncinfoupdate', this.triggerSyncInfoUpdate_);\n      this.mediaSource_.addEventListener('sourceopen', () => {\n        if (!this.isEndOfStream_()) {\n          this.ended_ = false;\n        }\n      }); // ...for determining the fetch location\n\n      this.fetchAtBuffer_ = false;\n      this.logger_ = logger(`SegmentLoader[${this.loaderType_}]`);\n      Object.defineProperty(this, 'state', {\n        get() {\n          return this.state_;\n        },\n        set(newState) {\n          if (newState !== this.state_) {\n            this.logger_(`${this.state_} -> ${newState}`);\n            this.state_ = newState;\n            this.trigger('statechange');\n          }\n        }\n      });\n      this.sourceUpdater_.on('ready', () => {\n        if (this.hasEnoughInfoToAppend_()) {\n          this.processCallQueue_();\n        }\n      }); // Only the main loader needs to listen for pending timeline changes, as the main\n      // loader should wait for audio to be ready to change its timeline so that both main\n      // and audio timelines change together. For more details, see the\n      // shouldWaitForTimelineChange function.\n\n      if (this.loaderType_ === 'main') {\n        this.timelineChangeController_.on('pendingtimelinechange', () => {\n          if (this.hasEnoughInfoToAppend_()) {\n            this.processCallQueue_();\n          }\n        });\n      } // The main loader only listens on pending timeline changes, but the audio loader,\n      // since its loads follow main, needs to listen on timeline changes. For more details,\n      // see the shouldWaitForTimelineChange function.\n\n      if (this.loaderType_ === 'audio') {\n        this.timelineChangeController_.on('timelinechange', () => {\n          if (this.hasEnoughInfoToLoad_()) {\n            this.processLoadQueue_();\n          }\n          if (this.hasEnoughInfoToAppend_()) {\n            this.processCallQueue_();\n          }\n        });\n      }\n    }\n    createTransmuxer_() {\n      return segmentTransmuxer.createTransmuxer({\n        remux: false,\n        alignGopsAtEnd: this.safeAppend_,\n        keepOriginalTimestamps: true,\n        parse708captions: this.parse708captions_,\n        captionServices: this.captionServices_\n      });\n    }\n    /**\n     * reset all of our media stats\n     *\n     * @private\n     */\n\n    resetStats_() {\n      this.mediaBytesTransferred = 0;\n      this.mediaRequests = 0;\n      this.mediaRequestsAborted = 0;\n      this.mediaRequestsTimedout = 0;\n      this.mediaRequestsErrored = 0;\n      this.mediaTransferDuration = 0;\n      this.mediaSecondsLoaded = 0;\n      this.mediaAppends = 0;\n    }\n    /**\n     * dispose of the SegmentLoader and reset to the default state\n     */\n\n    dispose() {\n      this.trigger('dispose');\n      this.state = 'DISPOSED';\n      this.pause();\n      this.abort_();\n      if (this.transmuxer_) {\n        this.transmuxer_.terminate();\n      }\n      this.resetStats_();\n      if (this.checkBufferTimeout_) {\n        window.clearTimeout(this.checkBufferTimeout_);\n      }\n      if (this.syncController_ && this.triggerSyncInfoUpdate_) {\n        this.syncController_.off('syncinfoupdate', this.triggerSyncInfoUpdate_);\n      }\n      this.off();\n    }\n    setAudio(enable) {\n      this.audioDisabled_ = !enable;\n      if (enable) {\n        this.appendInitSegment_.audio = true;\n      } else {\n        // remove current track audio if it gets disabled\n        this.sourceUpdater_.removeAudio(0, this.duration_());\n      }\n    }\n    /**\n     * abort anything that is currently doing on with the SegmentLoader\n     * and reset to a default state\n     */\n\n    abort() {\n      if (this.state !== 'WAITING') {\n        if (this.pendingSegment_) {\n          this.pendingSegment_ = null;\n        }\n        return;\n      }\n      this.abort_(); // We aborted the requests we were waiting on, so reset the loader's state to READY\n      // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n      // when the request is aborted. This will prevent the loader from being stuck in the\n      // WAITING state indefinitely.\n\n      this.state = 'READY'; // don't wait for buffer check timeouts to begin fetching the\n      // next segment\n\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n    /**\n     * abort all pending xhr requests and null any pending segements\n     *\n     * @private\n     */\n\n    abort_() {\n      if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {\n        this.pendingSegment_.abortRequests();\n      } // clear out the segment being processed\n\n      this.pendingSegment_ = null;\n      this.callQueue_ = [];\n      this.loadQueue_ = [];\n      this.metadataQueue_.id3 = [];\n      this.metadataQueue_.caption = [];\n      this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);\n      this.waitingOnRemove_ = false;\n      window.clearTimeout(this.quotaExceededErrorRetryTimeout_);\n      this.quotaExceededErrorRetryTimeout_ = null;\n    }\n    checkForAbort_(requestId) {\n      // If the state is APPENDING, then aborts will not modify the state, meaning the first\n      // callback that happens should reset the state to READY so that loading can continue.\n      if (this.state === 'APPENDING' && !this.pendingSegment_) {\n        this.state = 'READY';\n        return true;\n      }\n      if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * set an error on the segment loader and null out any pending segements\n     *\n     * @param {Error} error the error to set on the SegmentLoader\n     * @return {Error} the error that was set or that is currently set\n     */\n\n    error(error) {\n      if (typeof error !== 'undefined') {\n        this.logger_('error occurred:', error);\n        this.error_ = error;\n      }\n      this.pendingSegment_ = null;\n      return this.error_;\n    }\n    endOfStream() {\n      this.ended_ = true;\n      if (this.transmuxer_) {\n        // need to clear out any cached data to prepare for the new segment\n        segmentTransmuxer.reset(this.transmuxer_);\n      }\n      this.gopBuffer_.length = 0;\n      this.pause();\n      this.trigger('ended');\n    }\n    /**\n     * Indicates which time ranges are buffered\n     *\n     * @return {TimeRange}\n     *         TimeRange object representing the current buffered ranges\n     */\n\n    buffered_() {\n      const trackInfo = this.getMediaInfo_();\n      if (!this.sourceUpdater_ || !trackInfo) {\n        return createTimeRanges();\n      }\n      if (this.loaderType_ === 'main') {\n        const {\n          hasAudio,\n          hasVideo,\n          isMuxed\n        } = trackInfo;\n        if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) {\n          return this.sourceUpdater_.buffered();\n        }\n        if (hasVideo) {\n          return this.sourceUpdater_.videoBuffered();\n        }\n      } // One case that can be ignored for now is audio only with alt audio,\n      // as we don't yet have proper support for that.\n\n      return this.sourceUpdater_.audioBuffered();\n    }\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n\n    initSegmentForMap(map, set = false) {\n      if (!map) {\n        return null;\n      }\n      const id = initSegmentId(map);\n      let storedMap = this.initSegments_[id];\n      if (set && !storedMap && map.bytes) {\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: map.bytes,\n          tracks: map.tracks,\n          timescales: map.timescales\n        };\n      }\n      return storedMap || map;\n    }\n    /**\n     * Gets and sets key for the provided key\n     *\n     * @param {Object} key\n     *        The key object representing the key to get or set\n     * @param {boolean=} set\n     *        If true, the key for the provided key should be saved\n     * @return {Object}\n     *         Key object for desired key\n     */\n\n    segmentKey(key, set = false) {\n      if (!key) {\n        return null;\n      }\n      const id = segmentKeyId(key);\n      let storedKey = this.keyCache_[id]; // TODO: We should use the HTTP Expires header to invalidate our cache per\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.3\n\n      if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) {\n        this.keyCache_[id] = storedKey = {\n          resolvedUri: key.resolvedUri,\n          bytes: key.bytes\n        };\n      }\n      const result = {\n        resolvedUri: (storedKey || key).resolvedUri\n      };\n      if (storedKey) {\n        result.bytes = storedKey.bytes;\n      }\n      return result;\n    }\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {boolean} True if the all configuration is ready for loading\n     * @private\n     */\n\n    couldBeginLoading_() {\n      return this.playlist_ && !this.paused();\n    }\n    /**\n     * load a playlist and start to fill the buffer\n     */\n\n    load() {\n      // un-pause\n      this.monitorBuffer_(); // if we don't have a playlist yet, keep waiting for one to be\n      // specified\n\n      if (!this.playlist_) {\n        return;\n      } // if all the configuration is ready, initialize and begin loading\n\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      } // if we're in the middle of processing a segment already, don't\n      // kick off an additional segment request\n\n      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n        return;\n      }\n      this.state = 'READY';\n    }\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n\n    init_() {\n      this.state = 'READY'; // if this is the audio segment loader, and it hasn't been inited before, then any old\n      // audio data from the muxed content should be removed\n\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n    /**\n     * set a playlist on the segment loader\n     *\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\n     */\n\n    playlist(newPlaylist, options = {}) {\n      if (!newPlaylist) {\n        return;\n      }\n      const oldPlaylist = this.playlist_;\n      const segmentInfo = this.pendingSegment_;\n      this.playlist_ = newPlaylist;\n      this.xhrOptions_ = options; // when we haven't started playing yet, the start of a live playlist\n      // is always our zero-time so force a sync update each time the playlist\n      // is refreshed from the server\n      //\n      // Use the INIT state to determine if playback has started, as the playlist sync info\n      // should be fixed once requests begin (as sync points are generated based on sync\n      // info), but not before then.\n\n      if (this.state === 'INIT') {\n        newPlaylist.syncInfo = {\n          mediaSequence: newPlaylist.mediaSequence,\n          time: 0\n        }; // Setting the date time mapping means mapping the program date time (if available)\n        // to time 0 on the player's timeline. The playlist's syncInfo serves a similar\n        // purpose, mapping the initial mediaSequence to time zero. Since the syncInfo can\n        // be updated as the playlist is refreshed before the loader starts loading, the\n        // program date time mapping needs to be updated as well.\n        //\n        // This mapping is only done for the main loader because a program date time should\n        // map equivalently between playlists.\n\n        if (this.loaderType_ === 'main') {\n          this.syncController_.setDateTimeMappingForStart(newPlaylist);\n        }\n      }\n      let oldId = null;\n      if (oldPlaylist) {\n        if (oldPlaylist.id) {\n          oldId = oldPlaylist.id;\n        } else if (oldPlaylist.uri) {\n          oldId = oldPlaylist.uri;\n        }\n      }\n      this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`); // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n      // in LIVE, we always want to update with new playlists (including refreshes)\n\n      this.trigger('syncinfoupdate'); // if we were unpaused but waiting for a playlist, start\n      // buffering now\n\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n        if (this.mediaIndex !== null) {\n          // we must reset/resync the segment loader when we switch renditions and\n          // the segment loader is already synced to the previous rendition\n          // on playlist changes we want it to be possible to fetch\n          // at the buffer for vod but not for live. So we use resetLoader\n          // for live and resyncLoader for vod. We want this because\n          // if a playlist uses independent and non-independent segments/parts the\n          // buffer may not accurately reflect the next segment that we should try\n          // downloading.\n          if (!newPlaylist.endList) {\n            this.resetLoader();\n          } else {\n            this.resyncLoader();\n          }\n        }\n        this.currentMediaInfo_ = void 0;\n        this.trigger('playlistupdate'); // the rest of this function depends on `oldPlaylist` being defined\n\n        return;\n      } // we reloaded the same playlist so we are in a live scenario\n      // and we will likely need to adjust the mediaIndex\n\n      const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n      this.logger_(`live window shift [${mediaSequenceDiff}]`); // update the mediaIndex on the SegmentLoader\n      // this is important because we can abort a request and this value must be\n      // equal to the last appended mediaIndex\n\n      if (this.mediaIndex !== null) {\n        this.mediaIndex -= mediaSequenceDiff; // this can happen if we are going to load the first segment, but get a playlist\n        // update during that. mediaIndex would go from 0 to -1 if mediaSequence in the\n        // new playlist was incremented by 1.\n\n        if (this.mediaIndex < 0) {\n          this.mediaIndex = null;\n          this.partIndex = null;\n        } else {\n          const segment = this.playlist_.segments[this.mediaIndex]; // partIndex should remain the same for the same segment\n          // unless parts fell off of the playlist for this segment.\n          // In that case we need to reset partIndex and resync\n\n          if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {\n            const mediaIndex = this.mediaIndex;\n            this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);\n            this.resetLoader(); // We want to throw away the partIndex and the data associated with it,\n            // as the part was dropped from our current playlists segment.\n            // The mediaIndex will still be valid so keep that around.\n\n            this.mediaIndex = mediaIndex;\n          }\n        }\n      } // update the mediaIndex on the SegmentInfo object\n      // this is important because we will update this.mediaIndex with this value\n      // in `handleAppendsDone_` after the segment has been successfully appended\n\n      if (segmentInfo) {\n        segmentInfo.mediaIndex -= mediaSequenceDiff;\n        if (segmentInfo.mediaIndex < 0) {\n          segmentInfo.mediaIndex = null;\n          segmentInfo.partIndex = null;\n        } else {\n          // we need to update the referenced segment so that timing information is\n          // saved for the new playlist's segment, however, if the segment fell off the\n          // playlist, we can leave the old reference and just lose the timing info\n          if (segmentInfo.mediaIndex >= 0) {\n            segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n          }\n          if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {\n            segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];\n          }\n        }\n      }\n      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n    }\n    /**\n     * Prevent the loader from fetching additional segments. If there\n     * is a segment request outstanding, it will finish processing\n     * before the loader halts. A segment loader can be unpaused by\n     * calling load().\n     */\n\n    pause() {\n      if (this.checkBufferTimeout_) {\n        window.clearTimeout(this.checkBufferTimeout_);\n        this.checkBufferTimeout_ = null;\n      }\n    }\n    /**\n     * Returns whether the segment loader is fetching additional\n     * segments when given the opportunity. This property can be\n     * modified through calls to pause() and load().\n     */\n\n    paused() {\n      return this.checkBufferTimeout_ === null;\n    }\n    /**\n     * Delete all the buffered data and reset the SegmentLoader\n     *\n     * @param {Function} [done] an optional callback to be executed when the remove\n     * operation is complete\n     */\n\n    resetEverything(done) {\n      this.ended_ = false;\n      this.appendInitSegment_ = {\n        audio: true,\n        video: true\n      };\n      this.resetLoader(); // remove from 0, the earliest point, to Infinity, to signify removal of everything.\n      // VTT Segment Loader doesn't need to do anything but in the regular SegmentLoader,\n      // we then clamp the value to duration if necessary.\n\n      this.remove(0, Infinity, done); // clears fmp4 captions\n\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({\n          action: 'clearAllMp4Captions'\n        }); // reset the cache in the transmuxer\n\n        this.transmuxer_.postMessage({\n          action: 'reset'\n        });\n      }\n    }\n    /**\n     * Force the SegmentLoader to resync and start loading around the currentTime instead\n     * of starting at the end of the buffer\n     *\n     * Useful for fast quality changes\n     */\n\n    resetLoader() {\n      this.fetchAtBuffer_ = false;\n      this.resyncLoader();\n    }\n    /**\n     * Force the SegmentLoader to restart synchronization and make a conservative guess\n     * before returning to the simple walk-forward method\n     */\n\n    resyncLoader() {\n      if (this.transmuxer_) {\n        // need to clear out any cached data to prepare for the new segment\n        segmentTransmuxer.reset(this.transmuxer_);\n      }\n      this.mediaIndex = null;\n      this.partIndex = null;\n      this.syncPoint_ = null;\n      this.isPendingTimestampOffset_ = false;\n      this.callQueue_ = [];\n      this.loadQueue_ = [];\n      this.metadataQueue_.id3 = [];\n      this.metadataQueue_.caption = [];\n      this.abort();\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({\n          action: 'clearParsedMp4Captions'\n        });\n      }\n    }\n    /**\n     * Remove any data in the source buffer between start and end times\n     *\n     * @param {number} start - the start time of the region to remove from the buffer\n     * @param {number} end - the end time of the region to remove from the buffer\n     * @param {Function} [done] - an optional callback to be executed when the remove\n     * @param {boolean} force - force all remove operations to happen\n     * operation is complete\n     */\n\n    remove(start, end, done = () => {}, force = false) {\n      // clamp end to duration if we need to remove everything.\n      // This is due to a browser bug that causes issues if we remove to Infinity.\n      // videojs/videojs-contrib-hls#1225\n      if (end === Infinity) {\n        end = this.duration_();\n      } // skip removes that would throw an error\n      // commonly happens during a rendition switch at the start of a video\n      // from start 0 to end 0\n\n      if (end <= start) {\n        this.logger_('skipping remove because end ${end} is <= start ${start}');\n        return;\n      }\n      if (!this.sourceUpdater_ || !this.getMediaInfo_()) {\n        this.logger_('skipping remove because no source updater or starting media info'); // nothing to remove if we haven't processed any media\n\n        return;\n      } // set it to one to complete this function's removes\n\n      let removesRemaining = 1;\n      const removeFinished = () => {\n        removesRemaining--;\n        if (removesRemaining === 0) {\n          done();\n        }\n      };\n      if (force || !this.audioDisabled_) {\n        removesRemaining++;\n        this.sourceUpdater_.removeAudio(start, end, removeFinished);\n      } // While it would be better to only remove video if the main loader has video, this\n      // should be safe with audio only as removeVideo will call back even if there's no\n      // video buffer.\n      //\n      // In theory we can check to see if there's video before calling the remove, but in\n      // the event that we're switching between renditions and from video to audio only\n      // (when we add support for that), we may need to clear the video contents despite\n      // what the new media will contain.\n\n      if (force || this.loaderType_ === 'main') {\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n        removesRemaining++;\n        this.sourceUpdater_.removeVideo(start, end, removeFinished);\n      } // remove any captions and ID3 tags\n\n      for (const track in this.inbandTextTracks_) {\n        removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);\n      }\n      removeCuesFromTrack(start, end, this.segmentMetadataTrack_); // finished this function's removes\n\n      removeFinished();\n    }\n    /**\n     * (re-)schedule monitorBufferTick_ to run as soon as possible\n     *\n     * @private\n     */\n\n    monitorBuffer_() {\n      if (this.checkBufferTimeout_) {\n        window.clearTimeout(this.checkBufferTimeout_);\n      }\n      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1);\n    }\n    /**\n     * As long as the SegmentLoader is in the READY state, periodically\n     * invoke fillBuffer_().\n     *\n     * @private\n     */\n\n    monitorBufferTick_() {\n      if (this.state === 'READY') {\n        this.fillBuffer_();\n      }\n      if (this.checkBufferTimeout_) {\n        window.clearTimeout(this.checkBufferTimeout_);\n      }\n      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n    }\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n\n    fillBuffer_() {\n      // TODO since the source buffer maintains a queue, and we shouldn't call this function\n      // except when we're ready for the next segment, this check can most likely be removed\n      if (this.sourceUpdater_.updating()) {\n        return;\n      } // see if we need to begin loading immediately\n\n      const segmentInfo = this.chooseNextRequest_();\n      if (!segmentInfo) {\n        return;\n      }\n      if (typeof segmentInfo.timestampOffset === 'number') {\n        this.isPendingTimestampOffset_ = false;\n        this.timelineChangeController_.pendingTimelineChange({\n          type: this.loaderType_,\n          from: this.currentTimeline_,\n          to: segmentInfo.timeline\n        });\n      }\n      this.loadSegment_(segmentInfo);\n    }\n    /**\n     * Determines if we should call endOfStream on the media source based\n     * on the state of the buffer or if appened segment was the final\n     * segment in the playlist.\n     *\n     * @param {number} [mediaIndex] the media index of segment we last appended\n     * @param {Object} [playlist] a media playlist object\n     * @return {boolean} do we need to call endOfStream on the MediaSource\n     */\n\n    isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {\n      if (!playlist || !this.mediaSource_) {\n        return false;\n      }\n      const segment = typeof mediaIndex === 'number' && playlist.segments[mediaIndex]; // mediaIndex is zero based but length is 1 based\n\n      const appendedLastSegment = mediaIndex + 1 === playlist.segments.length; // true if there are no parts, or this is the last part.\n\n      const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length; // if we've buffered to the end of the video, we need to call endOfStream\n      // so that MediaSources can trigger the `ended` event when it runs out of\n      // buffered data instead of waiting for me\n\n      return playlist.endList && this.mediaSource_.readyState === 'open' && appendedLastSegment && appendedLastPart;\n    }\n    /**\n     * Determines what request should be made given current segment loader state.\n     *\n     * @return {Object} a request object that describes the segment/part to load\n     */\n\n    chooseNextRequest_() {\n      const buffered = this.buffered_();\n      const bufferedEnd = lastBufferedEnd(buffered) || 0;\n      const bufferedTime = timeAheadOf(buffered, this.currentTime_());\n      const preloaded = !this.hasPlayed_() && bufferedTime >= 1;\n      const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();\n      const segments = this.playlist_.segments; // return no segment if:\n      // 1. we don't have segments\n      // 2. The video has not yet played and we already downloaded a segment\n      // 3. we already have enough buffered time\n\n      if (!segments.length || preloaded || haveEnoughBuffer) {\n        return null;\n      }\n      this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      const next = {\n        partIndex: null,\n        mediaIndex: null,\n        startOfSegment: null,\n        playlist: this.playlist_,\n        isSyncRequest: Boolean(!this.syncPoint_)\n      };\n      if (next.isSyncRequest) {\n        next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);\n      } else if (this.mediaIndex !== null) {\n        const segment = segments[this.mediaIndex];\n        const partIndex = typeof this.partIndex === 'number' ? this.partIndex : -1;\n        next.startOfSegment = segment.end ? segment.end : bufferedEnd;\n        if (segment.parts && segment.parts[partIndex + 1]) {\n          next.mediaIndex = this.mediaIndex;\n          next.partIndex = partIndex + 1;\n        } else {\n          next.mediaIndex = this.mediaIndex + 1;\n        }\n      } else {\n        // Find the segment containing the end of the buffer or current time.\n        const {\n          segmentIndex,\n          startTime,\n          partIndex\n        } = Playlist.getMediaInfoForTime({\n          exactManifestTimings: this.exactManifestTimings,\n          playlist: this.playlist_,\n          currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),\n          startingPartIndex: this.syncPoint_.partIndex,\n          startingSegmentIndex: this.syncPoint_.segmentIndex,\n          startTime: this.syncPoint_.time\n        });\n        next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${bufferedEnd}` : `currentTime ${this.currentTime_()}`;\n        next.mediaIndex = segmentIndex;\n        next.startOfSegment = startTime;\n        next.partIndex = partIndex;\n      }\n      const nextSegment = segments[next.mediaIndex];\n      let nextPart = nextSegment && typeof next.partIndex === 'number' && nextSegment.parts && nextSegment.parts[next.partIndex]; // if the next segment index is invalid or\n      // the next partIndex is invalid do not choose a next segment.\n\n      if (!nextSegment || typeof next.partIndex === 'number' && !nextPart) {\n        return null;\n      } // if the next segment has parts, and we don't have a partIndex.\n      // Set partIndex to 0\n\n      if (typeof next.partIndex !== 'number' && nextSegment.parts) {\n        next.partIndex = 0;\n        nextPart = nextSegment.parts[0];\n      } // if we have no buffered data then we need to make sure\n      // that the next part we append is \"independent\" if possible.\n      // So we check if the previous part is independent, and request\n      // it if it is.\n\n      if (!bufferedTime && nextPart && !nextPart.independent) {\n        if (next.partIndex === 0) {\n          const lastSegment = segments[next.mediaIndex - 1];\n          const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];\n          if (lastSegmentLastPart && lastSegmentLastPart.independent) {\n            next.mediaIndex -= 1;\n            next.partIndex = lastSegment.parts.length - 1;\n            next.independent = 'previous segment';\n          }\n        } else if (nextSegment.parts[next.partIndex - 1].independent) {\n          next.partIndex -= 1;\n          next.independent = 'previous part';\n        }\n      }\n      const ended = this.mediaSource_ && this.mediaSource_.readyState === 'ended'; // do not choose a next segment if all of the following:\n      // 1. this is the last segment in the playlist\n      // 2. end of stream has been called on the media source already\n      // 3. the player is not seeking\n\n      if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {\n        return null;\n      }\n      return this.generateSegmentInfo_(next);\n    }\n    generateSegmentInfo_(options) {\n      const {\n        independent,\n        playlist,\n        mediaIndex,\n        startOfSegment,\n        isSyncRequest,\n        partIndex,\n        forceTimestampOffset,\n        getMediaInfoForTime\n      } = options;\n      const segment = playlist.segments[mediaIndex];\n      const part = typeof partIndex === 'number' && segment.parts[partIndex];\n      const segmentInfo = {\n        requestId: 'segment-loader-' + Math.random(),\n        // resolve the segment URL relative to the playlist\n        uri: part && part.resolvedUri || segment.resolvedUri,\n        // the segment's mediaIndex at the time it was requested\n        mediaIndex,\n        partIndex: part ? partIndex : null,\n        // whether or not to update the SegmentLoader's state with this\n        // segment's mediaIndex\n        isSyncRequest,\n        startOfSegment,\n        // the segment's playlist\n        playlist,\n        // unencrypted bytes of the segment\n        bytes: null,\n        // when a key is defined for this segment, the encrypted bytes\n        encryptedBytes: null,\n        // The target timestampOffset for this segment when we append it\n        // to the source buffer\n        timestampOffset: null,\n        // The timeline that the segment is in\n        timeline: segment.timeline,\n        // The expected duration of the segment in seconds\n        duration: part && part.duration || segment.duration,\n        // retain the segment in case the playlist updates while doing an async process\n        segment,\n        part,\n        byteLength: 0,\n        transmuxer: this.transmuxer_,\n        // type of getMediaInfoForTime that was used to get this segment\n        getMediaInfoForTime,\n        independent\n      };\n      const overrideCheck = typeof forceTimestampOffset !== 'undefined' ? forceTimestampOffset : this.isPendingTimestampOffset_;\n      segmentInfo.timestampOffset = this.timestampOffsetForSegment_({\n        segmentTimeline: segment.timeline,\n        currentTimeline: this.currentTimeline_,\n        startOfSegment,\n        buffered: this.buffered_(),\n        overrideCheck\n      });\n      const audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());\n      if (typeof audioBufferedEnd === 'number') {\n        // since the transmuxer is using the actual timing values, but the buffer is\n        // adjusted by the timestamp offset, we must adjust the value here\n        segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();\n      }\n      if (this.sourceUpdater_.videoBuffered().length) {\n        segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_,\n        // since the transmuxer is using the actual timing values, but the time is\n        // adjusted by the timestmap offset, we must adjust the value here\n        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);\n      }\n      return segmentInfo;\n    } // get the timestampoffset for a segment,\n    // added so that vtt segment loader can override and prevent\n    // adding timestamp offsets.\n\n    timestampOffsetForSegment_(options) {\n      return timestampOffsetForSegment(options);\n    }\n    /**\n     * Determines if the network has enough bandwidth to complete the current segment\n     * request in a timely manner. If not, the request will be aborted early and bandwidth\n     * updated to trigger a playlist switch.\n     *\n     * @param {Object} stats\n     *        Object containing stats about the request timing and size\n     * @private\n     */\n\n    earlyAbortWhenNeeded_(stats) {\n      if (this.vhs_.tech_.paused() ||\n      // Don't abort if the current playlist is on the lowestEnabledRendition\n      // TODO: Replace using timeout with a boolean indicating whether this playlist is\n      //       the lowestEnabledRendition.\n      !this.xhrOptions_.timeout ||\n      // Don't abort if we have no bandwidth information to estimate segment sizes\n      !this.playlist_.attributes.BANDWIDTH) {\n        return;\n      } // Wait at least 1 second since the first byte of data has been received before\n      // using the calculated bandwidth from the progress event to allow the bitrate\n      // to stabilize\n\n      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n        return;\n      }\n      const currentTime = this.currentTime_();\n      const measuredBandwidth = stats.bandwidth;\n      const segmentDuration = this.pendingSegment_.duration;\n      const requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived); // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n      // if we are only left with less than 1 second when the request completes.\n      // A negative timeUntilRebuffering indicates we are already rebuffering\n\n      const timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1; // Only consider aborting early if the estimated time to finish the download\n      // is larger than the estimated time until the player runs out of forward buffer\n\n      if (requestTimeRemaining <= timeUntilRebuffer$1) {\n        return;\n      }\n      const switchCandidate = minRebufferMaxBandwidthSelector({\n        main: this.vhs_.playlists.main,\n        currentTime,\n        bandwidth: measuredBandwidth,\n        duration: this.duration_(),\n        segmentDuration,\n        timeUntilRebuffer: timeUntilRebuffer$1,\n        currentTimeline: this.currentTimeline_,\n        syncController: this.syncController_\n      });\n      if (!switchCandidate) {\n        return;\n      }\n      const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;\n      const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n      let minimumTimeSaving = 0.5; // If we are already rebuffering, increase the amount of variance we add to the\n      // potential round trip time of the new request so that we are not too aggressive\n      // with switching to a playlist that might save us a fraction of a second.\n\n      if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {\n        minimumTimeSaving = 1;\n      }\n      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n        return;\n      } // set the bandwidth to that of the desired playlist being sure to scale by\n      // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n      // don't trigger a bandwidthupdate as the bandwidth is artifial\n\n      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;\n      this.trigger('earlyabort');\n    }\n    handleAbort_(segmentInfo) {\n      this.logger_(`Aborting ${segmentInfoString(segmentInfo)}`);\n      this.mediaRequestsAborted += 1;\n    }\n    /**\n     * XHR `progress` event handler\n     *\n     * @param {Event}\n     *        The XHR `progress` event\n     * @param {Object} simpleSegment\n     *        A simplified segment object copy\n     * @private\n     */\n\n    handleProgress_(event, simpleSegment) {\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      }\n      this.trigger('progress');\n    }\n    handleTrackInfo_(simpleSegment, trackInfo) {\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      }\n      if (this.checkForIllegalMediaSwitch(trackInfo)) {\n        return;\n      }\n      trackInfo = trackInfo || {}; // When we have track info, determine what media types this loader is dealing with.\n      // Guard against cases where we're not getting track info at all until we are\n      // certain that all streams will provide it.\n\n      if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {\n        this.appendInitSegment_ = {\n          audio: true,\n          video: true\n        };\n        this.startingMediaInfo_ = trackInfo;\n        this.currentMediaInfo_ = trackInfo;\n        this.logger_('trackinfo update', trackInfo);\n        this.trigger('trackinfo');\n      } // trackinfo may cause an abort if the trackinfo\n      // causes a codec change to an unsupported codec.\n\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      } // set trackinfo on the pending segment so that\n      // it can append.\n\n      this.pendingSegment_.trackInfo = trackInfo; // check if any calls were waiting on the track info\n\n      if (this.hasEnoughInfoToAppend_()) {\n        this.processCallQueue_();\n      }\n    }\n    handleTimingInfo_(simpleSegment, mediaType, timeType, time) {\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      }\n      const segmentInfo = this.pendingSegment_;\n      const timingInfoProperty = timingInfoPropertyForMedia(mediaType);\n      segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};\n      segmentInfo[timingInfoProperty][timeType] = time;\n      this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`); // check if any calls were waiting on the timing info\n\n      if (this.hasEnoughInfoToAppend_()) {\n        this.processCallQueue_();\n      }\n    }\n    handleCaptions_(simpleSegment, captionData) {\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      } // This could only happen with fmp4 segments, but\n      // should still not happen in general\n\n      if (captionData.length === 0) {\n        this.logger_('SegmentLoader received no captions from a caption event');\n        return;\n      }\n      const segmentInfo = this.pendingSegment_; // Wait until we have some video data so that caption timing\n      // can be adjusted by the timestamp offset\n\n      if (!segmentInfo.hasAppendedData_) {\n        this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));\n        return;\n      }\n      const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();\n      const captionTracks = {}; // get total start/end and captions for each track/stream\n\n      captionData.forEach(caption => {\n        // caption.stream is actually a track name...\n        // set to the existing values in tracks or default values\n        captionTracks[caption.stream] = captionTracks[caption.stream] || {\n          // Infinity, as any other value will be less than this\n          startTime: Infinity,\n          captions: [],\n          // 0 as an other value will be more than this\n          endTime: 0\n        };\n        const captionTrack = captionTracks[caption.stream];\n        captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);\n        captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);\n        captionTrack.captions.push(caption);\n      });\n      Object.keys(captionTracks).forEach(trackName => {\n        const {\n          startTime,\n          endTime,\n          captions\n        } = captionTracks[trackName];\n        const inbandTextTracks = this.inbandTextTracks_;\n        this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);\n        createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName); // clear out any cues that start and end at the same time period for the same track.\n        // We do this because a rendition change that also changes the timescale for captions\n        // will result in captions being re-parsed for certain segments. If we add them again\n        // without clearing we will have two of the same captions visible.\n\n        removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);\n        addCaptionData({\n          captionArray: captions,\n          inbandTextTracks,\n          timestampOffset\n        });\n      }); // Reset stored captions since we added parsed\n      // captions to a text track at this point\n\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({\n          action: 'clearParsedMp4Captions'\n        });\n      }\n    }\n    handleId3_(simpleSegment, id3Frames, dispatchType) {\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      }\n      const segmentInfo = this.pendingSegment_; // we need to have appended data in order for the timestamp offset to be set\n\n      if (!segmentInfo.hasAppendedData_) {\n        this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));\n        return;\n      }\n      const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(); // There's potentially an issue where we could double add metadata if there's a muxed\n      // audio/video source with a metadata track, and an alt audio with a metadata track.\n      // However, this probably won't happen, and if it does it can be handled then.\n\n      createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);\n      addMetadata({\n        inbandTextTracks: this.inbandTextTracks_,\n        metadataArray: id3Frames,\n        timestampOffset,\n        videoDuration: this.duration_()\n      });\n    }\n    processMetadataQueue_() {\n      this.metadataQueue_.id3.forEach(fn => fn());\n      this.metadataQueue_.caption.forEach(fn => fn());\n      this.metadataQueue_.id3 = [];\n      this.metadataQueue_.caption = [];\n    }\n    processCallQueue_() {\n      const callQueue = this.callQueue_; // Clear out the queue before the queued functions are run, since some of the\n      // functions may check the length of the load queue and default to pushing themselves\n      // back onto the queue.\n\n      this.callQueue_ = [];\n      callQueue.forEach(fun => fun());\n    }\n    processLoadQueue_() {\n      const loadQueue = this.loadQueue_; // Clear out the queue before the queued functions are run, since some of the\n      // functions may check the length of the load queue and default to pushing themselves\n      // back onto the queue.\n\n      this.loadQueue_ = [];\n      loadQueue.forEach(fun => fun());\n    }\n    /**\n     * Determines whether the loader has enough info to load the next segment.\n     *\n     * @return {boolean}\n     *         Whether or not the loader has enough info to load the next segment\n     */\n\n    hasEnoughInfoToLoad_() {\n      // Since primary timing goes by video, only the audio loader potentially needs to wait\n      // to load.\n      if (this.loaderType_ !== 'audio') {\n        return true;\n      }\n      const segmentInfo = this.pendingSegment_; // A fill buffer must have already run to establish a pending segment before there's\n      // enough info to load.\n\n      if (!segmentInfo) {\n        return false;\n      } // The first segment can and should be loaded immediately so that source buffers are\n      // created together (before appending). Source buffer creation uses the presence of\n      // audio and video data to determine whether to create audio/video source buffers, and\n      // uses processed (transmuxed or parsed) media to determine the types required.\n\n      if (!this.getCurrentMediaInfo_()) {\n        return true;\n      }\n      if (\n      // Technically, instead of waiting to load a segment on timeline changes, a segment\n      // can be requested and downloaded and only wait before it is transmuxed or parsed.\n      // But in practice, there are a few reasons why it is better to wait until a loader\n      // is ready to append that segment before requesting and downloading:\n      //\n      // 1. Because audio and main loaders cross discontinuities together, if this loader\n      //    is waiting for the other to catch up, then instead of requesting another\n      //    segment and using up more bandwidth, by not yet loading, more bandwidth is\n      //    allotted to the loader currently behind.\n      // 2. media-segment-request doesn't have to have logic to consider whether a segment\n      // is ready to be processed or not, isolating the queueing behavior to the loader.\n      // 3. The audio loader bases some of its segment properties on timing information\n      //    provided by the main loader, meaning that, if the logic for waiting on\n      //    processing was in media-segment-request, then it would also need to know how\n      //    to re-generate the segment information after the main loader caught up.\n      shouldWaitForTimelineChange({\n        timelineChangeController: this.timelineChangeController_,\n        currentTimeline: this.currentTimeline_,\n        segmentTimeline: segmentInfo.timeline,\n        loaderType: this.loaderType_,\n        audioDisabled: this.audioDisabled_\n      })) {\n        return false;\n      }\n      return true;\n    }\n    getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {\n      return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;\n    }\n    getMediaInfo_(segmentInfo = this.pendingSegment_) {\n      return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;\n    }\n    hasEnoughInfoToAppend_() {\n      if (!this.sourceUpdater_.ready()) {\n        return false;\n      } // If content needs to be removed or the loader is waiting on an append reattempt,\n      // then no additional content should be appended until the prior append is resolved.\n\n      if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {\n        return false;\n      }\n      const segmentInfo = this.pendingSegment_;\n      const trackInfo = this.getCurrentMediaInfo_(); // no segment to append any data for or\n      // we do not have information on this specific\n      // segment yet\n\n      if (!segmentInfo || !trackInfo) {\n        return false;\n      }\n      const {\n        hasAudio,\n        hasVideo,\n        isMuxed\n      } = trackInfo;\n      if (hasVideo && !segmentInfo.videoTimingInfo) {\n        return false;\n      } // muxed content only relies on video timing information for now.\n\n      if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) {\n        return false;\n      }\n      if (shouldWaitForTimelineChange({\n        timelineChangeController: this.timelineChangeController_,\n        currentTimeline: this.currentTimeline_,\n        segmentTimeline: segmentInfo.timeline,\n        loaderType: this.loaderType_,\n        audioDisabled: this.audioDisabled_\n      })) {\n        return false;\n      }\n      return true;\n    }\n    handleData_(simpleSegment, result) {\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\n      if (this.checkForAbort_(simpleSegment.requestId)) {\n        return;\n      } // If there's anything in the call queue, then this data came later and should be\n      // executed after the calls currently queued.\n\n      if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {\n        this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));\n        return;\n      }\n      const segmentInfo = this.pendingSegment_; // update the time mapping so we can translate from display time to media time\n\n      this.setTimeMapping_(segmentInfo.timeline); // for tracking overall stats\n\n      this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment); // Note that the state isn't changed from loading to appending. This is because abort\n      // logic may change behavior depending on the state, and changing state too early may\n      // inflate our estimates of bandwidth. In the future this should be re-examined to\n      // note more granular states.\n      // don't process and append data if the mediaSource is closed\n\n      if (this.mediaSource_.readyState === 'closed') {\n        return;\n      } // if this request included an initialization segment, save that data\n      // to the initSegment cache\n\n      if (simpleSegment.map) {\n        simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true); // move over init segment properties to media request\n\n        segmentInfo.segment.map = simpleSegment.map;\n      } // if this request included a segment key, save that data in the cache\n\n      if (simpleSegment.key) {\n        this.segmentKey(simpleSegment.key, true);\n      }\n      segmentInfo.isFmp4 = simpleSegment.isFmp4;\n      segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n      if (segmentInfo.isFmp4) {\n        this.trigger('fmp4');\n        segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;\n      } else {\n        const trackInfo = this.getCurrentMediaInfo_();\n        const useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\n        let firstVideoFrameTimeForData;\n        if (useVideoTimingInfo) {\n          firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;\n        } // Segment loader knows more about segment timing than the transmuxer (in certain\n        // aspects), so make any changes required for a more accurate start time.\n        // Don't set the end time yet, as the segment may not be finished processing.\n\n        segmentInfo.timingInfo.start = this.trueSegmentStart_({\n          currentStart: segmentInfo.timingInfo.start,\n          playlist: segmentInfo.playlist,\n          mediaIndex: segmentInfo.mediaIndex,\n          currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),\n          useVideoTimingInfo,\n          firstVideoFrameTimeForData,\n          videoTimingInfo: segmentInfo.videoTimingInfo,\n          audioTimingInfo: segmentInfo.audioTimingInfo\n        });\n      } // Init segments for audio and video only need to be appended in certain cases. Now\n      // that data is about to be appended, we can check the final cases to determine\n      // whether we should append an init segment.\n\n      this.updateAppendInitSegmentStatus(segmentInfo, result.type); // Timestamp offset should be updated once we get new data and have its timing info,\n      // as we use the start of the segment to offset the best guess (playlist provided)\n      // timestamp offset.\n\n      this.updateSourceBufferTimestampOffset_(segmentInfo); // if this is a sync request we need to determine whether it should\n      // be appended or not.\n\n      if (segmentInfo.isSyncRequest) {\n        // first save/update our timing info for this segment.\n        // this is what allows us to choose an accurate segment\n        // and the main reason we make a sync request.\n        this.updateTimingInfoEnd_(segmentInfo);\n        this.syncController_.saveSegmentTimingInfo({\n          segmentInfo,\n          shouldSaveTimelineMapping: this.loaderType_ === 'main'\n        });\n        const next = this.chooseNextRequest_(); // If the sync request isn't the segment that would be requested next\n        // after taking into account its timing info, do not append it.\n\n        if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {\n          this.logger_('sync segment was incorrect, not appending');\n          return;\n        } // otherwise append it like any other segment as our guess was correct.\n\n        this.logger_('sync segment was correct, appending');\n      } // Save some state so that in the future anything waiting on first append (and/or\n      // timestamp offset(s)) can process immediately. While the extra state isn't optimal,\n      // we need some notion of whether the timestamp offset or other relevant information\n      // has had a chance to be set.\n\n      segmentInfo.hasAppendedData_ = true; // Now that the timestamp offset should be set, we can append any waiting ID3 tags.\n\n      this.processMetadataQueue_();\n      this.appendData_(segmentInfo, result);\n    }\n    updateAppendInitSegmentStatus(segmentInfo, type) {\n      // alt audio doesn't manage timestamp offset\n      if (this.loaderType_ === 'main' && typeof segmentInfo.timestampOffset === 'number' &&\n      // in the case that we're handling partial data, we don't want to append an init\n      // segment for each chunk\n      !segmentInfo.changedTimestampOffset) {\n        // if the timestamp offset changed, the timeline may have changed, so we have to re-\n        // append init segments\n        this.appendInitSegment_ = {\n          audio: true,\n          video: true\n        };\n      }\n      if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {\n        // make sure we append init segment on playlist changes, in case the media config\n        // changed\n        this.appendInitSegment_[type] = true;\n      }\n    }\n    getInitSegmentAndUpdateState_({\n      type,\n      initSegment,\n      map,\n      playlist\n    }) {\n      // \"The EXT-X-MAP tag specifies how to obtain the Media Initialization Section\n      // (Section 3) required to parse the applicable Media Segments.  It applies to every\n      // Media Segment that appears after it in the Playlist until the next EXT-X-MAP tag\n      // or until the end of the playlist.\"\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.5\n      if (map) {\n        const id = initSegmentId(map);\n        if (this.activeInitSegmentId_ === id) {\n          // don't need to re-append the init segment if the ID matches\n          return null;\n        } // a map-specified init segment takes priority over any transmuxed (or otherwise\n        // obtained) init segment\n        //\n        // this also caches the init segment for later use\n\n        initSegment = this.initSegmentForMap(map, true).bytes;\n        this.activeInitSegmentId_ = id;\n      } // We used to always prepend init segments for video, however, that shouldn't be\n      // necessary. Instead, we should only append on changes, similar to what we've always\n      // done for audio. This is more important (though may not be that important) for\n      // frame-by-frame appending for LHLS, simply because of the increased quantity of\n      // appends.\n\n      if (initSegment && this.appendInitSegment_[type]) {\n        // Make sure we track the playlist that we last used for the init segment, so that\n        // we can re-append the init segment in the event that we get data from a new\n        // playlist. Discontinuities and track changes are handled in other sections.\n        this.playlistOfLastInitSegment_[type] = playlist; // Disable future init segment appends for this type. Until a change is necessary.\n\n        this.appendInitSegment_[type] = false; // we need to clear out the fmp4 active init segment id, since\n        // we are appending the muxer init segment\n\n        this.activeInitSegmentId_ = null;\n        return initSegment;\n      }\n      return null;\n    }\n    handleQuotaExceededError_({\n      segmentInfo,\n      type,\n      bytes\n    }, error) {\n      const audioBuffered = this.sourceUpdater_.audioBuffered();\n      const videoBuffered = this.sourceUpdater_.videoBuffered(); // For now we're ignoring any notion of gaps in the buffer, but they, in theory,\n      // should be cleared out during the buffer removals. However, log in case it helps\n      // debug.\n\n      if (audioBuffered.length > 1) {\n        this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: ' + timeRangesToArray(audioBuffered).join(', '));\n      }\n      if (videoBuffered.length > 1) {\n        this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: ' + timeRangesToArray(videoBuffered).join(', '));\n      }\n      const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;\n      const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;\n      const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;\n      const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;\n      if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {\n        // Can't remove enough buffer to make room for new segment (or the browser doesn't\n        // allow for appends of segments this size). In the future, it may be possible to\n        // split up the segment and append in pieces, but for now, error out this playlist\n        // in an attempt to switch to a more manageable rendition.\n        this.logger_('On QUOTA_EXCEEDED_ERR, single segment too large to append to ' + 'buffer, triggering an error. ' + `Appended byte length: ${bytes.byteLength}, ` + `audio buffer: ${timeRangesToArray(audioBuffered).join(', ')}, ` + `video buffer: ${timeRangesToArray(videoBuffered).join(', ')}, `);\n        this.error({\n          message: 'Quota exceeded error with append of a single segment of content',\n          excludeUntil: Infinity\n        });\n        this.trigger('error');\n        return;\n      } // To try to resolve the quota exceeded error, clear back buffer and retry. This means\n      // that the segment-loader should block on future events until this one is handled, so\n      // that it doesn't keep moving onto further segments. Adding the call to the call\n      // queue will prevent further appends until waitingOnRemove_ and\n      // quotaExceededErrorRetryTimeout_ are cleared.\n      //\n      // Note that this will only block the current loader. In the case of demuxed content,\n      // the other load may keep filling as fast as possible. In practice, this should be\n      // OK, as it is a rare case when either audio has a high enough bitrate to fill up a\n      // source buffer, or video fills without enough room for audio to append (and without\n      // the availability of clearing out seconds of back buffer to make room for audio).\n      // But it might still be good to handle this case in the future as a TODO.\n\n      this.waitingOnRemove_ = true;\n      this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {\n        segmentInfo,\n        type,\n        bytes\n      }));\n      const currentTime = this.currentTime_(); // Try to remove as much audio and video as possible to make room for new content\n      // before retrying.\n\n      const timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;\n      this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);\n      this.remove(0, timeToRemoveUntil, () => {\n        this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${MIN_BACK_BUFFER}s`);\n        this.waitingOnRemove_ = false; // wait the length of time alotted in the back buffer to prevent wasted\n        // attempts (since we can't clear less than the minimum)\n\n        this.quotaExceededErrorRetryTimeout_ = window.setTimeout(() => {\n          this.logger_('On QUOTA_EXCEEDED_ERR, re-processing call queue');\n          this.quotaExceededErrorRetryTimeout_ = null;\n          this.processCallQueue_();\n        }, MIN_BACK_BUFFER * 1000);\n      }, true);\n    }\n    handleAppendError_({\n      segmentInfo,\n      type,\n      bytes\n    }, error) {\n      // if there's no error, nothing to do\n      if (!error) {\n        return;\n      }\n      if (error.code === QUOTA_EXCEEDED_ERR) {\n        this.handleQuotaExceededError_({\n          segmentInfo,\n          type,\n          bytes\n        }); // A quota exceeded error should be recoverable with a future re-append, so no need\n        // to trigger an append error.\n\n        return;\n      }\n      this.logger_('Received non QUOTA_EXCEEDED_ERR on append', error);\n      this.error(`${type} append of ${bytes.length}b failed for segment ` + `#${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`); // If an append errors, we often can't recover.\n      // (see https://w3c.github.io/media-source/#sourcebuffer-append-error).\n      //\n      // Trigger a special error so that it can be handled separately from normal,\n      // recoverable errors.\n\n      this.trigger('appenderror');\n    }\n    appendToSourceBuffer_({\n      segmentInfo,\n      type,\n      initSegment,\n      data,\n      bytes\n    }) {\n      // If this is a re-append, bytes were already created and don't need to be recreated\n      if (!bytes) {\n        const segments = [data];\n        let byteLength = data.byteLength;\n        if (initSegment) {\n          // if the media initialization segment is changing, append it before the content\n          // segment\n          segments.unshift(initSegment);\n          byteLength += initSegment.byteLength;\n        } // Technically we should be OK appending the init segment separately, however, we\n        // haven't yet tested that, and prepending is how we have always done things.\n\n        bytes = concatSegments({\n          bytes: byteLength,\n          segments\n        });\n      }\n      this.sourceUpdater_.appendBuffer({\n        segmentInfo,\n        type,\n        bytes\n      }, this.handleAppendError_.bind(this, {\n        segmentInfo,\n        type,\n        bytes\n      }));\n    }\n    handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {\n      if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {\n        return;\n      }\n      const segment = this.pendingSegment_.segment;\n      const timingInfoProperty = `${type}TimingInfo`;\n      if (!segment[timingInfoProperty]) {\n        segment[timingInfoProperty] = {};\n      }\n      segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;\n      segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;\n      segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;\n      segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;\n      segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode; // mainly used as a reference for debugging\n\n      segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;\n    }\n    appendData_(segmentInfo, result) {\n      const {\n        type,\n        data\n      } = result;\n      if (!data || !data.byteLength) {\n        return;\n      }\n      if (type === 'audio' && this.audioDisabled_) {\n        return;\n      }\n      const initSegment = this.getInitSegmentAndUpdateState_({\n        type,\n        initSegment: result.initSegment,\n        playlist: segmentInfo.playlist,\n        map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null\n      });\n      this.appendToSourceBuffer_({\n        segmentInfo,\n        type,\n        initSegment,\n        data\n      });\n    }\n    /**\n     * load a specific segment from a request into the buffer\n     *\n     * @private\n     */\n\n    loadSegment_(segmentInfo) {\n      this.state = 'WAITING';\n      this.pendingSegment_ = segmentInfo;\n      this.trimBackBuffer_(segmentInfo);\n      if (typeof segmentInfo.timestampOffset === 'number') {\n        if (this.transmuxer_) {\n          this.transmuxer_.postMessage({\n            action: 'clearAllMp4Captions'\n          });\n        }\n      }\n      if (!this.hasEnoughInfoToLoad_()) {\n        this.loadQueue_.push(() => {\n          // regenerate the audioAppendStart, timestampOffset, etc as they\n          // may have changed since this function was added to the queue.\n          const options = _extends$1({}, segmentInfo, {\n            forceTimestampOffset: true\n          });\n          _extends$1(segmentInfo, this.generateSegmentInfo_(options));\n          this.isPendingTimestampOffset_ = false;\n          this.updateTransmuxerAndRequestSegment_(segmentInfo);\n        });\n        return;\n      }\n      this.updateTransmuxerAndRequestSegment_(segmentInfo);\n    }\n    updateTransmuxerAndRequestSegment_(segmentInfo) {\n      // We'll update the source buffer's timestamp offset once we have transmuxed data, but\n      // the transmuxer still needs to be updated before then.\n      //\n      // Even though keepOriginalTimestamps is set to true for the transmuxer, timestamp\n      // offset must be passed to the transmuxer for stream correcting adjustments.\n      if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {\n        this.gopBuffer_.length = 0; // gopsToAlignWith was set before the GOP buffer was cleared\n\n        segmentInfo.gopsToAlignWith = [];\n        this.timeMapping_ = 0; // reset values in the transmuxer since a discontinuity should start fresh\n\n        this.transmuxer_.postMessage({\n          action: 'reset'\n        });\n        this.transmuxer_.postMessage({\n          action: 'setTimestampOffset',\n          timestampOffset: segmentInfo.timestampOffset\n        });\n      }\n      const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);\n      const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);\n      const isWalkingForward = this.mediaIndex !== null;\n      const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ &&\n      // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,\n      // the first timeline\n      segmentInfo.timeline > 0;\n      const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;\n      this.logger_(`Requesting ${segmentInfoString(segmentInfo)}`); // If there's an init segment associated with this segment, but it is not cached (identified by a lack of bytes),\n      // then this init segment has never been seen before and should be appended.\n      //\n      // At this point the content type (audio/video or both) is not yet known, but it should be safe to set\n      // both to true and leave the decision of whether to append the init segment to append time.\n\n      if (simpleSegment.map && !simpleSegment.map.bytes) {\n        this.logger_('going to request init segment.');\n        this.appendInitSegment_ = {\n          video: true,\n          audio: true\n        };\n      }\n      segmentInfo.abortRequests = mediaSegmentRequest({\n        xhr: this.vhs_.xhr,\n        xhrOptions: this.xhrOptions_,\n        decryptionWorker: this.decrypter_,\n        segment: simpleSegment,\n        abortFn: this.handleAbort_.bind(this, segmentInfo),\n        progressFn: this.handleProgress_.bind(this),\n        trackInfoFn: this.handleTrackInfo_.bind(this),\n        timingInfoFn: this.handleTimingInfo_.bind(this),\n        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'video', segmentInfo.requestId),\n        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'audio', segmentInfo.requestId),\n        captionsFn: this.handleCaptions_.bind(this),\n        isEndOfTimeline,\n        endedTimelineFn: () => {\n          this.logger_('received endedtimeline callback');\n        },\n        id3Fn: this.handleId3_.bind(this),\n        dataFn: this.handleData_.bind(this),\n        doneFn: this.segmentRequestFinished_.bind(this),\n        onTransmuxerLog: ({\n          message,\n          level,\n          stream\n        }) => {\n          this.logger_(`${segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);\n        }\n      });\n    }\n    /**\n     * trim the back buffer so that we don't have too much data\n     * in the source buffer\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     */\n\n    trimBackBuffer_(segmentInfo) {\n      const removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); // Chrome has a hard limit of 150MB of\n      // buffer and a very conservative \"garbage collector\"\n      // We manually clear out the old buffer to ensure\n      // we don't trigger the QuotaExceeded error\n      // on the source buffer during subsequent appends\n\n      if (removeToTime > 0) {\n        this.remove(0, removeToTime);\n      }\n    }\n    /**\n     * created a simplified copy of the segment object with just the\n     * information necessary to perform the XHR and decryption\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     * @return {Object} a simplified segment object copy\n     */\n\n    createSimplifiedSegmentObj_(segmentInfo) {\n      const segment = segmentInfo.segment;\n      const part = segmentInfo.part;\n      const simpleSegment = {\n        resolvedUri: part ? part.resolvedUri : segment.resolvedUri,\n        byterange: part ? part.byterange : segment.byterange,\n        requestId: segmentInfo.requestId,\n        transmuxer: segmentInfo.transmuxer,\n        audioAppendStart: segmentInfo.audioAppendStart,\n        gopsToAlignWith: segmentInfo.gopsToAlignWith,\n        part: segmentInfo.part\n      };\n      const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];\n      if (previousSegment && previousSegment.timeline === segment.timeline) {\n        // The baseStartTime of a segment is used to handle rollover when probing the TS\n        // segment to retrieve timing information. Since the probe only looks at the media's\n        // times (e.g., PTS and DTS values of the segment), and doesn't consider the\n        // player's time (e.g., player.currentTime()), baseStartTime should reflect the\n        // media time as well. transmuxedDecodeEnd represents the end time of a segment, in\n        // seconds of media time, so should be used here. The previous segment is used since\n        // the end of the previous segment should represent the beginning of the current\n        // segment, so long as they are on the same timeline.\n        if (previousSegment.videoTimingInfo) {\n          simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;\n        } else if (previousSegment.audioTimingInfo) {\n          simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;\n        }\n      }\n      if (segment.key) {\n        // if the media sequence is greater than 2^32, the IV will be incorrect\n        // assuming 10s segments, that would be about 1300 years\n        const iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n        simpleSegment.key = this.segmentKey(segment.key);\n        simpleSegment.key.iv = iv;\n      }\n      if (segment.map) {\n        simpleSegment.map = this.initSegmentForMap(segment.map);\n      }\n      return simpleSegment;\n    }\n    saveTransferStats_(stats) {\n      // every request counts as a media request even if it has been aborted\n      // or canceled due to a timeout\n      this.mediaRequests += 1;\n      if (stats) {\n        this.mediaBytesTransferred += stats.bytesReceived;\n        this.mediaTransferDuration += stats.roundTripTime;\n      }\n    }\n    saveBandwidthRelatedStats_(duration, stats) {\n      // byteLength will be used for throughput, and should be based on bytes receieved,\n      // which we only know at the end of the request and should reflect total bytes\n      // downloaded rather than just bytes processed from components of the segment\n      this.pendingSegment_.byteLength = stats.bytesReceived;\n      if (duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\n        this.logger_(`Ignoring segment's bandwidth because its duration of ${duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);\n        return;\n      }\n      this.bandwidth = stats.bandwidth;\n      this.roundTrip = stats.roundTripTime;\n    }\n    handleTimeout_() {\n      // although the VTT segment loader bandwidth isn't really used, it's good to\n      // maintain functinality between segment loaders\n      this.mediaRequestsTimedout += 1;\n      this.bandwidth = 1;\n      this.roundTrip = NaN;\n      this.trigger('bandwidthupdate');\n      this.trigger('timeout');\n    }\n    /**\n     * Handle the callback from the segmentRequest function and set the\n     * associated SegmentLoader state and errors if necessary\n     *\n     * @private\n     */\n\n    segmentRequestFinished_(error, simpleSegment, result) {\n      // TODO handle special cases, e.g., muxed audio/video but only audio in the segment\n      // check the call queue directly since this function doesn't need to deal with any\n      // data, and can continue even if the source buffers are not set up and we didn't get\n      // any data from the segment\n      if (this.callQueue_.length) {\n        this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));\n        return;\n      }\n      this.saveTransferStats_(simpleSegment.stats); // The request was aborted and the SegmentLoader has already been reset\n\n      if (!this.pendingSegment_) {\n        return;\n      } // the request was aborted and the SegmentLoader has already started\n      // another request. this can happen when the timeout for an aborted\n      // request triggers due to a limitation in the XHR library\n      // do not count this as any sort of request or we risk double-counting\n\n      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n        return;\n      } // an error occurred from the active pendingSegment_ so reset everything\n\n      if (error) {\n        this.pendingSegment_ = null;\n        this.state = 'READY'; // aborts are not a true error condition and nothing corrective needs to be done\n\n        if (error.code === REQUEST_ERRORS.ABORTED) {\n          return;\n        }\n        this.pause(); // the error is really just that at least one of the requests timed-out\n        // set the bandwidth to a very low value and trigger an ABR switch to\n        // take emergency action\n\n        if (error.code === REQUEST_ERRORS.TIMEOUT) {\n          this.handleTimeout_();\n          return;\n        } // if control-flow has arrived here, then the error is real\n        // emit an error event to exclude the current playlist\n\n        this.mediaRequestsErrored += 1;\n        this.error(error);\n        this.trigger('error');\n        return;\n      }\n      const segmentInfo = this.pendingSegment_; // the response was a success so set any bandwidth stats the request\n      // generated for ABR purposes\n\n      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);\n      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n      if (result.gopInfo) {\n        this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);\n      } // Although we may have already started appending on progress, we shouldn't switch the\n      // state away from loading until we are officially done loading the segment data.\n\n      this.state = 'APPENDING'; // used for testing\n\n      this.trigger('appending');\n      this.waitForAppendsToComplete_(segmentInfo);\n    }\n    setTimeMapping_(timeline) {\n      const timelineMapping = this.syncController_.mappingForTimeline(timeline);\n      if (timelineMapping !== null) {\n        this.timeMapping_ = timelineMapping;\n      }\n    }\n    updateMediaSecondsLoaded_(segment) {\n      if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n        this.mediaSecondsLoaded += segment.end - segment.start;\n      } else {\n        this.mediaSecondsLoaded += segment.duration;\n      }\n    }\n    shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {\n      if (timestampOffset === null) {\n        return false;\n      } // note that we're potentially using the same timestamp offset for both video and\n      // audio\n\n      if (this.loaderType_ === 'main' && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n        return true;\n      }\n      if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n        return true;\n      }\n      return false;\n    }\n    trueSegmentStart_({\n      currentStart,\n      playlist,\n      mediaIndex,\n      firstVideoFrameTimeForData,\n      currentVideoTimestampOffset,\n      useVideoTimingInfo,\n      videoTimingInfo,\n      audioTimingInfo\n    }) {\n      if (typeof currentStart !== 'undefined') {\n        // if start was set once, keep using it\n        return currentStart;\n      }\n      if (!useVideoTimingInfo) {\n        return audioTimingInfo.start;\n      }\n      const previousSegment = playlist.segments[mediaIndex - 1]; // The start of a segment should be the start of the first full frame contained\n      // within that segment. Since the transmuxer maintains a cache of incomplete data\n      // from and/or the last frame seen, the start time may reflect a frame that starts\n      // in the previous segment. Check for that case and ensure the start time is\n      // accurate for the segment.\n\n      if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === 'undefined' || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {\n        return firstVideoFrameTimeForData;\n      }\n      return videoTimingInfo.start;\n    }\n    waitForAppendsToComplete_(segmentInfo) {\n      const trackInfo = this.getCurrentMediaInfo_(segmentInfo);\n      if (!trackInfo) {\n        this.error({\n          message: 'No starting media returned, likely due to an unsupported media format.',\n          playlistExclusionDuration: Infinity\n        });\n        this.trigger('error');\n        return;\n      } // Although transmuxing is done, appends may not yet be finished. Throw a marker\n      // on each queue this loader is responsible for to ensure that the appends are\n      // complete.\n\n      const {\n        hasAudio,\n        hasVideo,\n        isMuxed\n      } = trackInfo;\n      const waitForVideo = this.loaderType_ === 'main' && hasVideo;\n      const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;\n      segmentInfo.waitingOnAppends = 0; // segments with no data\n\n      if (!segmentInfo.hasAppendedData_) {\n        if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === 'number') {\n          // When there's no audio or video data in the segment, there's no audio or video\n          // timing information.\n          //\n          // If there's no audio or video timing information, then the timestamp offset\n          // can't be adjusted to the appropriate value for the transmuxer and source\n          // buffers.\n          //\n          // Therefore, the next segment should be used to set the timestamp offset.\n          this.isPendingTimestampOffset_ = true;\n        } // override settings for metadata only segments\n\n        segmentInfo.timingInfo = {\n          start: 0\n        };\n        segmentInfo.waitingOnAppends++;\n        if (!this.isPendingTimestampOffset_) {\n          // update the timestampoffset\n          this.updateSourceBufferTimestampOffset_(segmentInfo); // make sure the metadata queue is processed even though we have\n          // no video/audio data.\n\n          this.processMetadataQueue_();\n        } // append is \"done\" instantly with no data.\n\n        this.checkAppendsDone_(segmentInfo);\n        return;\n      } // Since source updater could call back synchronously, do the increments first.\n\n      if (waitForVideo) {\n        segmentInfo.waitingOnAppends++;\n      }\n      if (waitForAudio) {\n        segmentInfo.waitingOnAppends++;\n      }\n      if (waitForVideo) {\n        this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n      }\n      if (waitForAudio) {\n        this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n      }\n    }\n    checkAppendsDone_(segmentInfo) {\n      if (this.checkForAbort_(segmentInfo.requestId)) {\n        return;\n      }\n      segmentInfo.waitingOnAppends--;\n      if (segmentInfo.waitingOnAppends === 0) {\n        this.handleAppendsDone_();\n      }\n    }\n    checkForIllegalMediaSwitch(trackInfo) {\n      const illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);\n      if (illegalMediaSwitchError) {\n        this.error({\n          message: illegalMediaSwitchError,\n          playlistExclusionDuration: Infinity\n        });\n        this.trigger('error');\n        return true;\n      }\n      return false;\n    }\n    updateSourceBufferTimestampOffset_(segmentInfo) {\n      if (segmentInfo.timestampOffset === null ||\n      // we don't yet have the start for whatever media type (video or audio) has\n      // priority, timing-wise, so we must wait\n      typeof segmentInfo.timingInfo.start !== 'number' ||\n      // already updated the timestamp offset for this segment\n      segmentInfo.changedTimestampOffset ||\n      // the alt audio loader should not be responsible for setting the timestamp offset\n      this.loaderType_ !== 'main') {\n        return;\n      }\n      let didChange = false; // Primary timing goes by video, and audio is trimmed in the transmuxer, meaning that\n      // the timing info here comes from video. In the event that the audio is longer than\n      // the video, this will trim the start of the audio.\n      // This also trims any offset from 0 at the beginning of the media\n\n      segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({\n        videoTimingInfo: segmentInfo.segment.videoTimingInfo,\n        audioTimingInfo: segmentInfo.segment.audioTimingInfo,\n        timingInfo: segmentInfo.timingInfo\n      }); // In the event that there are part segment downloads, each will try to update the\n      // timestamp offset. Retaining this bit of state prevents us from updating in the\n      // future (within the same segment), however, there may be a better way to handle it.\n\n      segmentInfo.changedTimestampOffset = true;\n      if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n        this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);\n        didChange = true;\n      }\n      if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n        this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);\n        didChange = true;\n      }\n      if (didChange) {\n        this.trigger('timestampoffset');\n      }\n    }\n    getSegmentStartTimeForTimestampOffsetCalculation_({\n      videoTimingInfo,\n      audioTimingInfo,\n      timingInfo\n    }) {\n      if (!this.useDtsForTimestampOffset_) {\n        return timingInfo.start;\n      }\n      if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === 'number') {\n        return videoTimingInfo.transmuxedDecodeStart;\n      } // handle audio only\n\n      if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === 'number') {\n        return audioTimingInfo.transmuxedDecodeStart;\n      } // handle content not transmuxed (e.g., MP4)\n\n      return timingInfo.start;\n    }\n    updateTimingInfoEnd_(segmentInfo) {\n      segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n      const trackInfo = this.getMediaInfo_();\n      const useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\n      const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;\n      if (!prioritizedTimingInfo) {\n        return;\n      }\n      segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === 'number' ?\n      // End time may not exist in a case where we aren't parsing the full segment (one\n      // current example is the case of fmp4), so use the rough duration to calculate an\n      // end time.\n      prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;\n    }\n    /**\n     * callback to run when appendBuffer is finished. detects if we are\n     * in a good state to do things with the data we got, or if we need\n     * to wait for more\n     *\n     * @private\n     */\n\n    handleAppendsDone_() {\n      // appendsdone can cause an abort\n      if (this.pendingSegment_) {\n        this.trigger('appendsdone');\n      }\n      if (!this.pendingSegment_) {\n        this.state = 'READY'; // TODO should this move into this.checkForAbort to speed up requests post abort in\n        // all appending cases?\n\n        if (!this.paused()) {\n          this.monitorBuffer_();\n        }\n        return;\n      }\n      const segmentInfo = this.pendingSegment_; // Now that the end of the segment has been reached, we can set the end time. It's\n      // best to wait until all appends are done so we're sure that the primary media is\n      // finished (and we have its end time).\n\n      this.updateTimingInfoEnd_(segmentInfo);\n      if (this.shouldSaveSegmentTimingInfo_) {\n        // Timeline mappings should only be saved for the main loader. This is for multiple\n        // reasons:\n        //\n        // 1) Only one mapping is saved per timeline, meaning that if both the audio loader\n        //    and the main loader try to save the timeline mapping, whichever comes later\n        //    will overwrite the first. In theory this is OK, as the mappings should be the\n        //    same, however, it breaks for (2)\n        // 2) In the event of a live stream, the initial live point will make for a somewhat\n        //    arbitrary mapping. If audio and video streams are not perfectly in-sync, then\n        //    the mapping will be off for one of the streams, dependent on which one was\n        //    first saved (see (1)).\n        // 3) Primary timing goes by video in VHS, so the mapping should be video.\n        //\n        // Since the audio loader will wait for the main loader to load the first segment,\n        // the main loader will save the first timeline mapping, and ensure that there won't\n        // be a case where audio loads two segments without saving a mapping (thus leading\n        // to missing segment timing info).\n        this.syncController_.saveSegmentTimingInfo({\n          segmentInfo,\n          shouldSaveTimelineMapping: this.loaderType_ === 'main'\n        });\n      }\n      const segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);\n      if (segmentDurationMessage) {\n        if (segmentDurationMessage.severity === 'warn') {\n          videojs.log.warn(segmentDurationMessage.message);\n        } else {\n          this.logger_(segmentDurationMessage.message);\n        }\n      }\n      this.recordThroughput_(segmentInfo);\n      this.pendingSegment_ = null;\n      this.state = 'READY';\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate'); // if the sync request was not appended\n        // then it was not the correct segment.\n        // throw it away and use the data it gave us\n        // to get the correct one.\n\n        if (!segmentInfo.hasAppendedData_) {\n          this.logger_(`Throwing away un-appended sync request ${segmentInfoString(segmentInfo)}`);\n          return;\n        }\n      }\n      this.logger_(`Appended ${segmentInfoString(segmentInfo)}`);\n      this.addSegmentMetadataCue_(segmentInfo);\n      this.fetchAtBuffer_ = true;\n      if (this.currentTimeline_ !== segmentInfo.timeline) {\n        this.timelineChangeController_.lastTimelineChange({\n          type: this.loaderType_,\n          from: this.currentTimeline_,\n          to: segmentInfo.timeline\n        }); // If audio is not disabled, the main segment loader is responsible for updating\n        // the audio timeline as well. If the content is video only, this won't have any\n        // impact.\n\n        if (this.loaderType_ === 'main' && !this.audioDisabled_) {\n          this.timelineChangeController_.lastTimelineChange({\n            type: 'audio',\n            from: this.currentTimeline_,\n            to: segmentInfo.timeline\n          });\n        }\n      }\n      this.currentTimeline_ = segmentInfo.timeline; // We must update the syncinfo to recalculate the seekable range before\n      // the following conditional otherwise it may consider this a bad \"guess\"\n      // and attempt to resync when the post-update seekable window and live\n      // point would mean that this was the perfect segment to fetch\n\n      this.trigger('syncinfoupdate');\n      const segment = segmentInfo.segment;\n      const part = segmentInfo.part;\n      const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;\n      const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3; // If we previously appended a segment/part that ends more than 3 part/targetDurations before\n      // the currentTime_ that means that our conservative guess was too conservative.\n      // In that case, reset the loader state so that we try to use any information gained\n      // from the previous request to create a new, more accurate, sync-point.\n\n      if (badSegmentGuess || badPartGuess) {\n        this.logger_(`bad ${badSegmentGuess ? 'segment' : 'part'} ${segmentInfoString(segmentInfo)}`);\n        this.resetEverything();\n        return;\n      }\n      const isWalkingForward = this.mediaIndex !== null; // Don't do a rendition switch unless we have enough time to get a sync segment\n      // and conservatively guess\n\n      if (isWalkingForward) {\n        this.trigger('bandwidthupdate');\n      }\n      this.trigger('progress');\n      this.mediaIndex = segmentInfo.mediaIndex;\n      this.partIndex = segmentInfo.partIndex; // any time an update finishes and the last segment is in the\n      // buffer, end the stream. this ensures the \"ended\" event will\n      // fire if playback reaches that point.\n\n      if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {\n        this.endOfStream();\n      } // used for testing\n\n      this.trigger('appended');\n      if (segmentInfo.hasAppendedData_) {\n        this.mediaAppends++;\n      }\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n    /**\n     * Records the current throughput of the decrypt, transmux, and append\n     * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n     * moving average of the throughput. `throughput.count` is the number of\n     * data points in the average.\n     *\n     * @private\n     * @param {Object} segmentInfo the object returned by loadSegment\n     */\n\n    recordThroughput_(segmentInfo) {\n      if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\n        this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);\n        return;\n      }\n      const rate = this.throughput.rate; // Add one to the time to ensure that we don't accidentally attempt to divide\n      // by zero in the case where the throughput is ridiculously high\n\n      const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1; // Multiply by 8000 to convert from bytes/millisecond to bits/second\n\n      const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000); // This is just a cumulative moving average calculation:\n      //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n\n      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n    }\n    /**\n     * Adds a cue to the segment-metadata track with some metadata information about the\n     * segment\n     *\n     * @private\n     * @param {Object} segmentInfo\n     *        the object returned by loadSegment\n     * @method addSegmentMetadataCue_\n     */\n\n    addSegmentMetadataCue_(segmentInfo) {\n      if (!this.segmentMetadataTrack_) {\n        return;\n      }\n      const segment = segmentInfo.segment;\n      const start = segment.start;\n      const end = segment.end; // Do not try adding the cue if the start and end times are invalid.\n\n      if (!finite(start) || !finite(end)) {\n        return;\n      }\n      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\n      const Cue = window.WebKitDataCue || window.VTTCue;\n      const value = {\n        custom: segment.custom,\n        dateTimeObject: segment.dateTimeObject,\n        dateTimeString: segment.dateTimeString,\n        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n        resolution: segmentInfo.playlist.attributes.RESOLUTION,\n        codecs: segmentInfo.playlist.attributes.CODECS,\n        byteLength: segmentInfo.byteLength,\n        uri: segmentInfo.uri,\n        timeline: segmentInfo.timeline,\n        playlist: segmentInfo.playlist.id,\n        start,\n        end\n      };\n      const data = JSON.stringify(value);\n      const cue = new Cue(start, end, data); // Attach the metadata to the value property of the cue to keep consistency between\n      // the differences of WebKitDataCue in safari and VTTCue in other browsers\n\n      cue.value = value;\n      this.segmentMetadataTrack_.addCue(cue);\n    }\n  }\n  function noop() {}\n  const toTitleCase = function (string) {\n    if (typeof string !== 'string') {\n      return string;\n    }\n    return string.replace(/./, w => w.toUpperCase());\n  };\n\n  /**\n   * @file source-updater.js\n   */\n  const bufferTypes = ['video', 'audio'];\n  const updating = (type, sourceUpdater) => {\n    const sourceBuffer = sourceUpdater[`${type}Buffer`];\n    return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];\n  };\n  const nextQueueIndexOfType = (type, queue) => {\n    for (let i = 0; i < queue.length; i++) {\n      const queueEntry = queue[i];\n      if (queueEntry.type === 'mediaSource') {\n        // If the next entry is a media source entry (uses multiple source buffers), block\n        // processing to allow it to go through first.\n        return null;\n      }\n      if (queueEntry.type === type) {\n        return i;\n      }\n    }\n    return null;\n  };\n  const shiftQueue = (type, sourceUpdater) => {\n    if (sourceUpdater.queue.length === 0) {\n      return;\n    }\n    let queueIndex = 0;\n    let queueEntry = sourceUpdater.queue[queueIndex];\n    if (queueEntry.type === 'mediaSource') {\n      if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== 'closed') {\n        sourceUpdater.queue.shift();\n        queueEntry.action(sourceUpdater);\n        if (queueEntry.doneFn) {\n          queueEntry.doneFn();\n        } // Only specific source buffer actions must wait for async updateend events. Media\n        // Source actions process synchronously. Therefore, both audio and video source\n        // buffers are now clear to process the next queue entries.\n\n        shiftQueue('audio', sourceUpdater);\n        shiftQueue('video', sourceUpdater);\n      } // Media Source actions require both source buffers, so if the media source action\n      // couldn't process yet (because one or both source buffers are busy), block other\n      // queue actions until both are available and the media source action can process.\n\n      return;\n    }\n    if (type === 'mediaSource') {\n      // If the queue was shifted by a media source action (this happens when pushing a\n      // media source action onto the queue), then it wasn't from an updateend event from an\n      // audio or video source buffer, so there's no change from previous state, and no\n      // processing should be done.\n      return;\n    } // Media source queue entries don't need to consider whether the source updater is\n    // started (i.e., source buffers are created) as they don't need the source buffers, but\n    // source buffer queue entries do.\n\n    if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === 'closed' || updating(type, sourceUpdater)) {\n      return;\n    }\n    if (queueEntry.type !== type) {\n      queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);\n      if (queueIndex === null) {\n        // Either there's no queue entry that uses this source buffer type in the queue, or\n        // there's a media source queue entry before the next entry of this type, in which\n        // case wait for that action to process first.\n        return;\n      }\n      queueEntry = sourceUpdater.queue[queueIndex];\n    }\n    sourceUpdater.queue.splice(queueIndex, 1); // Keep a record that this source buffer type is in use.\n    //\n    // The queue pending operation must be set before the action is performed in the event\n    // that the action results in a synchronous event that is acted upon. For instance, if\n    // an exception is thrown that can be handled, it's possible that new actions will be\n    // appended to an empty queue and immediately executed, but would not have the correct\n    // pending information if this property was set after the action was performed.\n\n    sourceUpdater.queuePending[type] = queueEntry;\n    queueEntry.action(type, sourceUpdater);\n    if (!queueEntry.doneFn) {\n      // synchronous operation, process next entry\n      sourceUpdater.queuePending[type] = null;\n      shiftQueue(type, sourceUpdater);\n      return;\n    }\n  };\n  const cleanupBuffer = (type, sourceUpdater) => {\n    const buffer = sourceUpdater[`${type}Buffer`];\n    const titleType = toTitleCase(type);\n    if (!buffer) {\n      return;\n    }\n    buffer.removeEventListener('updateend', sourceUpdater[`on${titleType}UpdateEnd_`]);\n    buffer.removeEventListener('error', sourceUpdater[`on${titleType}Error_`]);\n    sourceUpdater.codecs[type] = null;\n    sourceUpdater[`${type}Buffer`] = null;\n  };\n  const inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;\n  const actions = {\n    appendBuffer: (bytes, segmentInfo, onError) => (type, sourceUpdater) => {\n      const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n      sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);\n      try {\n        sourceBuffer.appendBuffer(bytes);\n      } catch (e) {\n        sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === QUOTA_EXCEEDED_ERR ? '(QUOTA_EXCEEDED_ERR) ' : '') + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);\n        sourceUpdater.queuePending[type] = null;\n        onError(e);\n      }\n    },\n    remove: (start, end) => (type, sourceUpdater) => {\n      const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n      sourceUpdater.logger_(`Removing ${start} to ${end} from ${type}Buffer`);\n      try {\n        sourceBuffer.remove(start, end);\n      } catch (e) {\n        sourceUpdater.logger_(`Remove ${start} to ${end} from ${type}Buffer failed`);\n      }\n    },\n    timestampOffset: offset => (type, sourceUpdater) => {\n      const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n      sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset}`);\n      sourceBuffer.timestampOffset = offset;\n    },\n    callback: callback => (type, sourceUpdater) => {\n      callback();\n    },\n    endOfStream: error => sourceUpdater => {\n      if (sourceUpdater.mediaSource.readyState !== 'open') {\n        return;\n      }\n      sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ''})`);\n      try {\n        sourceUpdater.mediaSource.endOfStream(error);\n      } catch (e) {\n        videojs.log.warn('Failed to call media source endOfStream', e);\n      }\n    },\n    duration: duration => sourceUpdater => {\n      sourceUpdater.logger_(`Setting mediaSource duration to ${duration}`);\n      try {\n        sourceUpdater.mediaSource.duration = duration;\n      } catch (e) {\n        videojs.log.warn('Failed to set media source duration', e);\n      }\n    },\n    abort: () => (type, sourceUpdater) => {\n      if (sourceUpdater.mediaSource.readyState !== 'open') {\n        return;\n      }\n      const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n      sourceUpdater.logger_(`calling abort on ${type}Buffer`);\n      try {\n        sourceBuffer.abort();\n      } catch (e) {\n        videojs.log.warn(`Failed to abort on ${type}Buffer`, e);\n      }\n    },\n    addSourceBuffer: (type, codec) => sourceUpdater => {\n      const titleType = toTitleCase(type);\n      const mime = getMimeForCodec(codec);\n      sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);\n      const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);\n      sourceBuffer.addEventListener('updateend', sourceUpdater[`on${titleType}UpdateEnd_`]);\n      sourceBuffer.addEventListener('error', sourceUpdater[`on${titleType}Error_`]);\n      sourceUpdater.codecs[type] = codec;\n      sourceUpdater[`${type}Buffer`] = sourceBuffer;\n    },\n    removeSourceBuffer: type => sourceUpdater => {\n      const sourceBuffer = sourceUpdater[`${type}Buffer`];\n      cleanupBuffer(type, sourceUpdater); // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      }\n      sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);\n      try {\n        sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);\n      } catch (e) {\n        videojs.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);\n      }\n    },\n    changeType: codec => (type, sourceUpdater) => {\n      const sourceBuffer = sourceUpdater[`${type}Buffer`];\n      const mime = getMimeForCodec(codec); // can't do anything if the media source / source buffer is null\n      // or the media source does not contain this source buffer.\n\n      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n        return;\n      } // do not update codec if we don't need to.\n\n      if (sourceUpdater.codecs[type] === codec) {\n        return;\n      }\n      sourceUpdater.logger_(`changing ${type}Buffer codec from ${sourceUpdater.codecs[type]} to ${codec}`);\n      sourceBuffer.changeType(mime);\n      sourceUpdater.codecs[type] = codec;\n    }\n  };\n  const pushQueue = ({\n    type,\n    sourceUpdater,\n    action,\n    doneFn,\n    name\n  }) => {\n    sourceUpdater.queue.push({\n      type,\n      action,\n      doneFn,\n      name\n    });\n    shiftQueue(type, sourceUpdater);\n  };\n  const onUpdateend = (type, sourceUpdater) => e => {\n    // Although there should, in theory, be a pending action for any updateend receieved,\n    // there are some actions that may trigger updateend events without set definitions in\n    // the w3c spec. For instance, setting the duration on the media source may trigger\n    // updateend events on source buffers. This does not appear to be in the spec. As such,\n    // if we encounter an updateend without a corresponding pending action from our queue\n    // for that source buffer type, process the next action.\n    if (sourceUpdater.queuePending[type]) {\n      const doneFn = sourceUpdater.queuePending[type].doneFn;\n      sourceUpdater.queuePending[type] = null;\n      if (doneFn) {\n        // if there's an error, report it\n        doneFn(sourceUpdater[`${type}Error_`]);\n      }\n    }\n    shiftQueue(type, sourceUpdater);\n  };\n  /**\n   * A queue of callbacks to be serialized and applied when a\n   * MediaSource and its associated SourceBuffers are not in the\n   * updating state. It is used by the segment loader to update the\n   * underlying SourceBuffers when new data is loaded, for instance.\n   *\n   * @class SourceUpdater\n   * @param {MediaSource} mediaSource the MediaSource to create the SourceBuffer from\n   * @param {string} mimeType the desired MIME type of the underlying SourceBuffer\n   */\n\n  class SourceUpdater extends videojs.EventTarget {\n    constructor(mediaSource) {\n      super();\n      this.mediaSource = mediaSource;\n      this.sourceopenListener_ = () => shiftQueue('mediaSource', this);\n      this.mediaSource.addEventListener('sourceopen', this.sourceopenListener_);\n      this.logger_ = logger('SourceUpdater'); // initial timestamp offset is 0\n\n      this.audioTimestampOffset_ = 0;\n      this.videoTimestampOffset_ = 0;\n      this.queue = [];\n      this.queuePending = {\n        audio: null,\n        video: null\n      };\n      this.delayedAudioAppendQueue_ = [];\n      this.videoAppendQueued_ = false;\n      this.codecs = {};\n      this.onVideoUpdateEnd_ = onUpdateend('video', this);\n      this.onAudioUpdateEnd_ = onUpdateend('audio', this);\n      this.onVideoError_ = e => {\n        // used for debugging\n        this.videoError_ = e;\n      };\n      this.onAudioError_ = e => {\n        // used for debugging\n        this.audioError_ = e;\n      };\n      this.createdSourceBuffers_ = false;\n      this.initializedEme_ = false;\n      this.triggeredReady_ = false;\n    }\n    initializedEme() {\n      this.initializedEme_ = true;\n      this.triggerReady();\n    }\n    hasCreatedSourceBuffers() {\n      // if false, likely waiting on one of the segment loaders to get enough data to create\n      // source buffers\n      return this.createdSourceBuffers_;\n    }\n    hasInitializedAnyEme() {\n      return this.initializedEme_;\n    }\n    ready() {\n      return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();\n    }\n    createSourceBuffers(codecs) {\n      if (this.hasCreatedSourceBuffers()) {\n        // already created them before\n        return;\n      } // the intial addOrChangeSourceBuffers will always be\n      // two add buffers.\n\n      this.addOrChangeSourceBuffers(codecs);\n      this.createdSourceBuffers_ = true;\n      this.trigger('createdsourcebuffers');\n      this.triggerReady();\n    }\n    triggerReady() {\n      // only allow ready to be triggered once, this prevents the case\n      // where:\n      // 1. we trigger createdsourcebuffers\n      // 2. ie 11 synchronously initializates eme\n      // 3. the synchronous initialization causes us to trigger ready\n      // 4. We go back to the ready check in createSourceBuffers and ready is triggered again.\n      if (this.ready() && !this.triggeredReady_) {\n        this.triggeredReady_ = true;\n        this.trigger('ready');\n      }\n    }\n    /**\n     * Add a type of source buffer to the media source.\n     *\n     * @param {string} type\n     *        The type of source buffer to add.\n     *\n     * @param {string} codec\n     *        The codec to add the source buffer with.\n     */\n\n    addSourceBuffer(type, codec) {\n      pushQueue({\n        type: 'mediaSource',\n        sourceUpdater: this,\n        action: actions.addSourceBuffer(type, codec),\n        name: 'addSourceBuffer'\n      });\n    }\n    /**\n     * call abort on a source buffer.\n     *\n     * @param {string} type\n     *        The type of source buffer to call abort on.\n     */\n\n    abort(type) {\n      pushQueue({\n        type,\n        sourceUpdater: this,\n        action: actions.abort(type),\n        name: 'abort'\n      });\n    }\n    /**\n     * Call removeSourceBuffer and remove a specific type\n     * of source buffer on the mediaSource.\n     *\n     * @param {string} type\n     *        The type of source buffer to remove.\n     */\n\n    removeSourceBuffer(type) {\n      if (!this.canRemoveSourceBuffer()) {\n        videojs.log.error('removeSourceBuffer is not supported!');\n        return;\n      }\n      pushQueue({\n        type: 'mediaSource',\n        sourceUpdater: this,\n        action: actions.removeSourceBuffer(type),\n        name: 'removeSourceBuffer'\n      });\n    }\n    /**\n     * Whether or not the removeSourceBuffer function is supported\n     * on the mediaSource.\n     *\n     * @return {boolean}\n     *          if removeSourceBuffer can be called.\n     */\n\n    canRemoveSourceBuffer() {\n      // IE reports that it supports removeSourceBuffer, but often throws\n      // errors when attempting to use the function. So we report that it\n      // does not support removeSourceBuffer. As of Firefox 83 removeSourceBuffer\n      // throws errors, so we report that it does not support this as well.\n      return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && typeof window.MediaSource.prototype.removeSourceBuffer === 'function';\n    }\n    /**\n     * Whether or not the changeType function is supported\n     * on our SourceBuffers.\n     *\n     * @return {boolean}\n     *         if changeType can be called.\n     */\n\n    static canChangeType() {\n      return window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.changeType === 'function';\n    }\n    /**\n     * Whether or not the changeType function is supported\n     * on our SourceBuffers.\n     *\n     * @return {boolean}\n     *         if changeType can be called.\n     */\n\n    canChangeType() {\n      return this.constructor.canChangeType();\n    }\n    /**\n     * Call the changeType function on a source buffer, given the code and type.\n     *\n     * @param {string} type\n     *        The type of source buffer to call changeType on.\n     *\n     * @param {string} codec\n     *        The codec string to change type with on the source buffer.\n     */\n\n    changeType(type, codec) {\n      if (!this.canChangeType()) {\n        videojs.log.error('changeType is not supported!');\n        return;\n      }\n      pushQueue({\n        type,\n        sourceUpdater: this,\n        action: actions.changeType(codec),\n        name: 'changeType'\n      });\n    }\n    /**\n     * Add source buffers with a codec or, if they are already created,\n     * call changeType on source buffers using changeType.\n     *\n     * @param {Object} codecs\n     *        Codecs to switch to\n     */\n\n    addOrChangeSourceBuffers(codecs) {\n      if (!codecs || typeof codecs !== 'object' || Object.keys(codecs).length === 0) {\n        throw new Error('Cannot addOrChangeSourceBuffers to undefined codecs');\n      }\n      Object.keys(codecs).forEach(type => {\n        const codec = codecs[type];\n        if (!this.hasCreatedSourceBuffers()) {\n          return this.addSourceBuffer(type, codec);\n        }\n        if (this.canChangeType()) {\n          this.changeType(type, codec);\n        }\n      });\n    }\n    /**\n     * Queue an update to append an ArrayBuffer.\n     *\n     * @param {MediaObject} object containing audioBytes and/or videoBytes\n     * @param {Function} done the function to call when done\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\n     */\n\n    appendBuffer(options, doneFn) {\n      const {\n        segmentInfo,\n        type,\n        bytes\n      } = options;\n      this.processedAppend_ = true;\n      if (type === 'audio' && this.videoBuffer && !this.videoAppendQueued_) {\n        this.delayedAudioAppendQueue_.push([options, doneFn]);\n        this.logger_(`delayed audio append of ${bytes.length} until video append`);\n        return;\n      } // In the case of certain errors, for instance, QUOTA_EXCEEDED_ERR, updateend will\n      // not be fired. This means that the queue will be blocked until the next action\n      // taken by the segment-loader. Provide a mechanism for segment-loader to handle\n      // these errors by calling the doneFn with the specific error.\n\n      const onError = doneFn;\n      pushQueue({\n        type,\n        sourceUpdater: this,\n        action: actions.appendBuffer(bytes, segmentInfo || {\n          mediaIndex: -1\n        }, onError),\n        doneFn,\n        name: 'appendBuffer'\n      });\n      if (type === 'video') {\n        this.videoAppendQueued_ = true;\n        if (!this.delayedAudioAppendQueue_.length) {\n          return;\n        }\n        const queue = this.delayedAudioAppendQueue_.slice();\n        this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);\n        this.delayedAudioAppendQueue_.length = 0;\n        queue.forEach(que => {\n          this.appendBuffer.apply(this, que);\n        });\n      }\n    }\n    /**\n     * Get the audio buffer's buffered timerange.\n     *\n     * @return {TimeRange}\n     *         The audio buffer's buffered time range\n     */\n\n    audioBuffered() {\n      // no media source/source buffer or it isn't in the media sources\n      // source buffer list\n      if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {\n        return createTimeRanges();\n      }\n      return this.audioBuffer.buffered ? this.audioBuffer.buffered : createTimeRanges();\n    }\n    /**\n     * Get the video buffer's buffered timerange.\n     *\n     * @return {TimeRange}\n     *         The video buffer's buffered time range\n     */\n\n    videoBuffered() {\n      // no media source/source buffer or it isn't in the media sources\n      // source buffer list\n      if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {\n        return createTimeRanges();\n      }\n      return this.videoBuffer.buffered ? this.videoBuffer.buffered : createTimeRanges();\n    }\n    /**\n     * Get a combined video/audio buffer's buffered timerange.\n     *\n     * @return {TimeRange}\n     *         the combined time range\n     */\n\n    buffered() {\n      const video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;\n      const audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;\n      if (audio && !video) {\n        return this.audioBuffered();\n      }\n      if (video && !audio) {\n        return this.videoBuffered();\n      }\n      return bufferIntersection(this.audioBuffered(), this.videoBuffered());\n    }\n    /**\n     * Add a callback to the queue that will set duration on the mediaSource.\n     *\n     * @param {number} duration\n     *        The duration to set\n     *\n     * @param {Function} [doneFn]\n     *        function to run after duration has been set.\n     */\n\n    setDuration(duration, doneFn = noop) {\n      // In order to set the duration on the media source, it's necessary to wait for all\n      // source buffers to no longer be updating. \"If the updating attribute equals true on\n      // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n      // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n      pushQueue({\n        type: 'mediaSource',\n        sourceUpdater: this,\n        action: actions.duration(duration),\n        name: 'duration',\n        doneFn\n      });\n    }\n    /**\n     * Add a mediaSource endOfStream call to the queue\n     *\n     * @param {Error} [error]\n     *        Call endOfStream with an error\n     *\n     * @param {Function} [doneFn]\n     *        A function that should be called when the\n     *        endOfStream call has finished.\n     */\n\n    endOfStream(error = null, doneFn = noop) {\n      if (typeof error !== 'string') {\n        error = undefined;\n      } // In order to set the duration on the media source, it's necessary to wait for all\n      // source buffers to no longer be updating. \"If the updating attribute equals true on\n      // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n      // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n\n      pushQueue({\n        type: 'mediaSource',\n        sourceUpdater: this,\n        action: actions.endOfStream(error),\n        name: 'endOfStream',\n        doneFn\n      });\n    }\n    /**\n     * Queue an update to remove a time range from the buffer.\n     *\n     * @param {number} start where to start the removal\n     * @param {number} end where to end the removal\n     * @param {Function} [done=noop] optional callback to be executed when the remove\n     * operation is complete\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n     */\n\n    removeAudio(start, end, done = noop) {\n      if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {\n        done();\n        return;\n      }\n      pushQueue({\n        type: 'audio',\n        sourceUpdater: this,\n        action: actions.remove(start, end),\n        doneFn: done,\n        name: 'remove'\n      });\n    }\n    /**\n     * Queue an update to remove a time range from the buffer.\n     *\n     * @param {number} start where to start the removal\n     * @param {number} end where to end the removal\n     * @param {Function} [done=noop] optional callback to be executed when the remove\n     * operation is complete\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n     */\n\n    removeVideo(start, end, done = noop) {\n      if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {\n        done();\n        return;\n      }\n      pushQueue({\n        type: 'video',\n        sourceUpdater: this,\n        action: actions.remove(start, end),\n        doneFn: done,\n        name: 'remove'\n      });\n    }\n    /**\n     * Whether the underlying sourceBuffer is updating or not\n     *\n     * @return {boolean} the updating status of the SourceBuffer\n     */\n\n    updating() {\n      // the audio/video source buffer is updating\n      if (updating('audio', this) || updating('video', this)) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Set/get the timestampoffset on the audio SourceBuffer\n     *\n     * @return {number} the timestamp offset\n     */\n\n    audioTimestampOffset(offset) {\n      if (typeof offset !== 'undefined' && this.audioBuffer &&\n      // no point in updating if it's the same\n      this.audioTimestampOffset_ !== offset) {\n        pushQueue({\n          type: 'audio',\n          sourceUpdater: this,\n          action: actions.timestampOffset(offset),\n          name: 'timestampOffset'\n        });\n        this.audioTimestampOffset_ = offset;\n      }\n      return this.audioTimestampOffset_;\n    }\n    /**\n     * Set/get the timestampoffset on the video SourceBuffer\n     *\n     * @return {number} the timestamp offset\n     */\n\n    videoTimestampOffset(offset) {\n      if (typeof offset !== 'undefined' && this.videoBuffer &&\n      // no point in updating if it's the same\n      this.videoTimestampOffset !== offset) {\n        pushQueue({\n          type: 'video',\n          sourceUpdater: this,\n          action: actions.timestampOffset(offset),\n          name: 'timestampOffset'\n        });\n        this.videoTimestampOffset_ = offset;\n      }\n      return this.videoTimestampOffset_;\n    }\n    /**\n     * Add a function to the queue that will be called\n     * when it is its turn to run in the audio queue.\n     *\n     * @param {Function} callback\n     *        The callback to queue.\n     */\n\n    audioQueueCallback(callback) {\n      if (!this.audioBuffer) {\n        return;\n      }\n      pushQueue({\n        type: 'audio',\n        sourceUpdater: this,\n        action: actions.callback(callback),\n        name: 'callback'\n      });\n    }\n    /**\n     * Add a function to the queue that will be called\n     * when it is its turn to run in the video queue.\n     *\n     * @param {Function} callback\n     *        The callback to queue.\n     */\n\n    videoQueueCallback(callback) {\n      if (!this.videoBuffer) {\n        return;\n      }\n      pushQueue({\n        type: 'video',\n        sourceUpdater: this,\n        action: actions.callback(callback),\n        name: 'callback'\n      });\n    }\n    /**\n     * dispose of the source updater and the underlying sourceBuffer\n     */\n\n    dispose() {\n      this.trigger('dispose');\n      bufferTypes.forEach(type => {\n        this.abort(type);\n        if (this.canRemoveSourceBuffer()) {\n          this.removeSourceBuffer(type);\n        } else {\n          this[`${type}QueueCallback`](() => cleanupBuffer(type, this));\n        }\n      });\n      this.videoAppendQueued_ = false;\n      this.delayedAudioAppendQueue_.length = 0;\n      if (this.sourceopenListener_) {\n        this.mediaSource.removeEventListener('sourceopen', this.sourceopenListener_);\n      }\n      this.off();\n    }\n  }\n  const uint8ToUtf8 = uintArray => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));\n\n  /**\n   * @file vtt-segment-loader.js\n   */\n  const VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(char => char.charCodeAt(0)));\n  /**\n   * An object that manages segment loading and appending.\n   *\n   * @class VTTSegmentLoader\n   * @param {Object} options required and optional options\n   * @extends videojs.EventTarget\n   */\n\n  class VTTSegmentLoader extends SegmentLoader {\n    constructor(settings, options = {}) {\n      super(settings, options); // SegmentLoader requires a MediaSource be specified or it will throw an error;\n      // however, VTTSegmentLoader has no need of a media source, so delete the reference\n\n      this.mediaSource_ = null;\n      this.subtitlesTrack_ = null;\n      this.loaderType_ = 'subtitle';\n      this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks; // The VTT segment will have its own time mappings. Saving VTT segment timing info in\n      // the sync controller leads to improper behavior.\n\n      this.shouldSaveSegmentTimingInfo_ = false;\n    }\n    createTransmuxer_() {\n      // don't need to transmux any subtitles\n      return null;\n    }\n    /**\n     * Indicates which time ranges are buffered\n     *\n     * @return {TimeRange}\n     *         TimeRange object representing the current buffered ranges\n     */\n\n    buffered_() {\n      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {\n        return createTimeRanges();\n      }\n      const cues = this.subtitlesTrack_.cues;\n      const start = cues[0].startTime;\n      const end = cues[cues.length - 1].startTime;\n      return createTimeRanges([[start, end]]);\n    }\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n\n    initSegmentForMap(map, set = false) {\n      if (!map) {\n        return null;\n      }\n      const id = initSegmentId(map);\n      let storedMap = this.initSegments_[id];\n      if (set && !storedMap && map.bytes) {\n        // append WebVTT line terminators to the media initialization segment if it exists\n        // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n        // requires two or more WebVTT line terminators between the WebVTT header and the\n        // rest of the file\n        const combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n        const combinedSegment = new Uint8Array(combinedByteLength);\n        combinedSegment.set(map.bytes);\n        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: combinedSegment\n        };\n      }\n      return storedMap || map;\n    }\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {boolean} True if the all configuration is ready for loading\n     * @private\n     */\n\n    couldBeginLoading_() {\n      return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n    }\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n\n    init_() {\n      this.state = 'READY';\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n    /**\n     * Set a subtitle track on the segment loader to add subtitles to\n     *\n     * @param {TextTrack=} track\n     *        The text track to add loaded subtitles to\n     * @return {TextTrack}\n     *        Returns the subtitles track\n     */\n\n    track(track) {\n      if (typeof track === 'undefined') {\n        return this.subtitlesTrack_;\n      }\n      this.subtitlesTrack_ = track; // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n      return this.subtitlesTrack_;\n    }\n    /**\n     * Remove any data in the source buffer between start and end times\n     *\n     * @param {number} start - the start time of the region to remove from the buffer\n     * @param {number} end - the end time of the region to remove from the buffer\n     */\n\n    remove(start, end) {\n      removeCuesFromTrack(start, end, this.subtitlesTrack_);\n    }\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n\n    fillBuffer_() {\n      // see if we need to begin loading immediately\n      const segmentInfo = this.chooseNextRequest_();\n      if (!segmentInfo) {\n        return;\n      }\n      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n        // We don't have the timestamp offset that we need to sync subtitles.\n        // Rerun on a timestamp offset or user interaction.\n        const checkTimestampOffset = () => {\n          this.state = 'READY';\n          if (!this.paused()) {\n            // if not paused, queue a buffer check as soon as possible\n            this.monitorBuffer_();\n          }\n        };\n        this.syncController_.one('timestampoffset', checkTimestampOffset);\n        this.state = 'WAITING_ON_TIMELINE';\n        return;\n      }\n      this.loadSegment_(segmentInfo);\n    } // never set a timestamp offset for vtt segments.\n\n    timestampOffsetForSegment_() {\n      return null;\n    }\n    chooseNextRequest_() {\n      return this.skipEmptySegments_(super.chooseNextRequest_());\n    }\n    /**\n     * Prevents the segment loader from requesting segments we know contain no subtitles\n     * by walking forward until we find the next segment that we don't know whether it is\n     * empty or not.\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @return {Object}\n     *         a segment info object that describes the current segment\n     */\n\n    skipEmptySegments_(segmentInfo) {\n      while (segmentInfo && segmentInfo.segment.empty) {\n        // stop at the last possible segmentInfo\n        if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {\n          segmentInfo = null;\n          break;\n        }\n        segmentInfo = this.generateSegmentInfo_({\n          playlist: segmentInfo.playlist,\n          mediaIndex: segmentInfo.mediaIndex + 1,\n          startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,\n          isSyncRequest: segmentInfo.isSyncRequest\n        });\n      }\n      return segmentInfo;\n    }\n    stopForError(error) {\n      this.error(error);\n      this.state = 'READY';\n      this.pause();\n      this.trigger('error');\n    }\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n\n    segmentRequestFinished_(error, simpleSegment, result) {\n      if (!this.subtitlesTrack_) {\n        this.state = 'READY';\n        return;\n      }\n      this.saveTransferStats_(simpleSegment.stats); // the request was aborted\n\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        this.mediaRequestsAborted += 1;\n        return;\n      }\n      if (error) {\n        if (error.code === REQUEST_ERRORS.TIMEOUT) {\n          this.handleTimeout_();\n        }\n        if (error.code === REQUEST_ERRORS.ABORTED) {\n          this.mediaRequestsAborted += 1;\n        } else {\n          this.mediaRequestsErrored += 1;\n        }\n        this.stopForError(error);\n        return;\n      }\n      const segmentInfo = this.pendingSegment_; // although the VTT segment loader bandwidth isn't really used, it's good to\n      // maintain functionality between segment loaders\n\n      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats); // if this request included a segment key, save that data in the cache\n\n      if (simpleSegment.key) {\n        this.segmentKey(simpleSegment.key, true);\n      }\n      this.state = 'APPENDING'; // used for tests\n\n      this.trigger('appending');\n      const segment = segmentInfo.segment;\n      if (segment.map) {\n        segment.map.bytes = simpleSegment.map.bytes;\n      }\n      segmentInfo.bytes = simpleSegment.bytes; // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n\n      if (typeof window.WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\n        let loadHandler;\n        const errorHandler = () => {\n          this.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\n          this.stopForError({\n            message: 'Error loading vtt.js'\n          });\n          return;\n        };\n        loadHandler = () => {\n          this.subtitlesTrack_.tech_.off('vttjserror', errorHandler);\n          this.segmentRequestFinished_(error, simpleSegment, result);\n        };\n        this.state = 'WAITING_ON_VTTJS';\n        this.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\n        this.subtitlesTrack_.tech_.one('vttjserror', errorHandler);\n        return;\n      }\n      segment.requested = true;\n      try {\n        this.parseVTTCues_(segmentInfo);\n      } catch (e) {\n        this.stopForError({\n          message: e.message\n        });\n        return;\n      }\n      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n      if (segmentInfo.cues.length) {\n        segmentInfo.timingInfo = {\n          start: segmentInfo.cues[0].startTime,\n          end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime\n        };\n      } else {\n        segmentInfo.timingInfo = {\n          start: segmentInfo.startOfSegment,\n          end: segmentInfo.startOfSegment + segmentInfo.duration\n        };\n      }\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n      this.mediaSecondsLoaded += segment.duration; // Create VTTCue instances for each cue in the new segment and add them to\n      // the subtitle track\n\n      segmentInfo.cues.forEach(cue => {\n        this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);\n      }); // Remove any duplicate cues from the subtitle track. The WebVTT spec allows\n      // cues to have identical time-intervals, but if the text is also identical\n      // we can safely assume it is a duplicate that can be removed (ex. when a cue\n      // \"overlaps\" VTT segments)\n\n      removeDuplicateCuesFromTrack(this.subtitlesTrack_);\n      this.handleAppendsDone_();\n    }\n    handleData_() {// noop as we shouldn't be getting video/audio data captions\n      // that we do not support here.\n    }\n    updateTimingInfoEnd_() {// noop\n    }\n    /**\n     * Uses the WebVTT parser to parse the segment response\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @private\n     */\n\n    parseVTTCues_(segmentInfo) {\n      let decoder;\n      let decodeBytesToString = false;\n      if (typeof window.TextDecoder === 'function') {\n        decoder = new window.TextDecoder('utf8');\n      } else {\n        decoder = window.WebVTT.StringDecoder();\n        decodeBytesToString = true;\n      }\n      const parser = new window.WebVTT.Parser(window, window.vttjs, decoder);\n      segmentInfo.cues = [];\n      segmentInfo.timestampmap = {\n        MPEGTS: 0,\n        LOCAL: 0\n      };\n      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n      parser.ontimestampmap = map => {\n        segmentInfo.timestampmap = map;\n      };\n      parser.onparsingerror = error => {\n        videojs.log.warn('Error encountered when parsing cues: ' + error.message);\n      };\n      if (segmentInfo.segment.map) {\n        let mapData = segmentInfo.segment.map.bytes;\n        if (decodeBytesToString) {\n          mapData = uint8ToUtf8(mapData);\n        }\n        parser.parse(mapData);\n      }\n      let segmentData = segmentInfo.bytes;\n      if (decodeBytesToString) {\n        segmentData = uint8ToUtf8(segmentData);\n      }\n      parser.parse(segmentData);\n      parser.flush();\n    }\n    /**\n     * Updates the start and end times of any cues parsed by the WebVTT parser using\n     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n     * from the SyncController\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @param {Object} mappingObj\n     *        object containing a mapping from TS to media time\n     * @param {Object} playlist\n     *        the playlist object containing the segment\n     * @private\n     */\n\n    updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n      const segment = segmentInfo.segment;\n      if (!mappingObj) {\n        // If the sync controller does not have a mapping of TS to Media Time for the\n        // timeline, then we don't have enough information to update the cue\n        // start/end times\n        return;\n      }\n      if (!segmentInfo.cues.length) {\n        // If there are no cues, we also do not have enough information to figure out\n        // segment timing. Mark that the segment contains no cues so we don't re-request\n        // an empty segment.\n        segment.empty = true;\n        return;\n      }\n      const timestampmap = segmentInfo.timestampmap;\n      const diff = timestampmap.MPEGTS / clock_1 - timestampmap.LOCAL + mappingObj.mapping;\n      segmentInfo.cues.forEach(cue => {\n        // First convert cue time to TS time using the timestamp-map provided within the vtt\n        cue.startTime += diff;\n        cue.endTime += diff;\n      });\n      if (!playlist.syncInfo) {\n        const firstStart = segmentInfo.cues[0].startTime;\n        const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n        playlist.syncInfo = {\n          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n          time: Math.min(firstStart, lastStart - segment.duration)\n        };\n      }\n    }\n  }\n\n  /**\n   * @file ad-cue-tags.js\n   */\n  /**\n   * Searches for an ad cue that overlaps with the given mediaTime\n   *\n   * @param {Object} track\n   *        the track to find the cue for\n   *\n   * @param {number} mediaTime\n   *        the time to find the cue at\n   *\n   * @return {Object|null}\n   *         the found cue or null\n   */\n\n  const findAdCue = function (track, mediaTime) {\n    const cues = track.cues;\n    for (let i = 0; i < cues.length; i++) {\n      const cue = cues[i];\n      if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\n        return cue;\n      }\n    }\n    return null;\n  };\n  const updateAdCues = function (media, track, offset = 0) {\n    if (!media.segments) {\n      return;\n    }\n    let mediaTime = offset;\n    let cue;\n    for (let i = 0; i < media.segments.length; i++) {\n      const segment = media.segments[i];\n      if (!cue) {\n        // Since the cues will span for at least the segment duration, adding a fudge\n        // factor of half segment duration will prevent duplicate cues from being\n        // created when timing info is not exact (e.g. cue start time initialized\n        // at 10.006677, but next call mediaTime is 10.003332 )\n        cue = findAdCue(track, mediaTime + segment.duration / 2);\n      }\n      if (cue) {\n        if ('cueIn' in segment) {\n          // Found a CUE-IN so end the cue\n          cue.endTime = mediaTime;\n          cue.adEndTime = mediaTime;\n          mediaTime += segment.duration;\n          cue = null;\n          continue;\n        }\n        if (mediaTime < cue.endTime) {\n          // Already processed this mediaTime for this cue\n          mediaTime += segment.duration;\n          continue;\n        } // otherwise extend cue until a CUE-IN is found\n\n        cue.endTime += segment.duration;\n      } else {\n        if ('cueOut' in segment) {\n          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\n          cue.adStartTime = mediaTime; // Assumes tag format to be\n          // #EXT-X-CUE-OUT:30\n\n          cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\n          track.addCue(cue);\n        }\n        if ('cueOutCont' in segment) {\n          // Entered into the middle of an ad cue\n          // Assumes tag formate to be\n          // #EXT-X-CUE-OUT-CONT:10/30\n          const [adOffset, adTotal] = segment.cueOutCont.split('/').map(parseFloat);\n          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, '');\n          cue.adStartTime = mediaTime - adOffset;\n          cue.adEndTime = cue.adStartTime + adTotal;\n          track.addCue(cue);\n        }\n      }\n      mediaTime += segment.duration;\n    }\n  };\n\n  /**\n   * @file sync-controller.js\n   */\n  // synchronize expired playlist segments.\n  // the max media sequence diff is 48 hours of live stream\n  // content with two second segments. Anything larger than that\n  // will likely be invalid.\n\n  const MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;\n  const syncPointStrategies = [\n  // Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n  //                the equivalence display-time 0 === segment-index 0\n  {\n    name: 'VOD',\n    run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n      if (duration !== Infinity) {\n        const syncPoint = {\n          time: 0,\n          segmentIndex: 0,\n          partIndex: null\n        };\n        return syncPoint;\n      }\n      return null;\n    }\n  },\n  // Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n  {\n    name: 'ProgramDateTime',\n    run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {\n        return null;\n      }\n      let syncPoint = null;\n      let lastDistance = null;\n      const partsAndSegments = getPartsAndSegments(playlist);\n      currentTime = currentTime || 0;\n      for (let i = 0; i < partsAndSegments.length; i++) {\n        // start from the end and loop backwards for live\n        // or start from the front and loop forwards for non-live\n        const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\n        const partAndSegment = partsAndSegments[index];\n        const segment = partAndSegment.segment;\n        const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];\n        if (!datetimeMapping || !segment.dateTimeObject) {\n          continue;\n        }\n        const segmentTime = segment.dateTimeObject.getTime() / 1000;\n        let start = segmentTime + datetimeMapping; // take part duration into account.\n\n        if (segment.parts && typeof partAndSegment.partIndex === 'number') {\n          for (let z = 0; z < partAndSegment.partIndex; z++) {\n            start += segment.parts[z].duration;\n          }\n        }\n        const distance = Math.abs(currentTime - start); // Once the distance begins to increase, or if distance is 0, we have passed\n        // currentTime and can stop looking for better candidates\n\n        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {\n          break;\n        }\n        lastDistance = distance;\n        syncPoint = {\n          time: start,\n          segmentIndex: partAndSegment.segmentIndex,\n          partIndex: partAndSegment.partIndex\n        };\n      }\n      return syncPoint;\n    }\n  },\n  // Stategy \"Segment\": We have a known time mapping for a timeline and a\n  //                    segment in the current timeline with timing data\n  {\n    name: 'Segment',\n    run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n      let syncPoint = null;\n      let lastDistance = null;\n      currentTime = currentTime || 0;\n      const partsAndSegments = getPartsAndSegments(playlist);\n      for (let i = 0; i < partsAndSegments.length; i++) {\n        // start from the end and loop backwards for live\n        // or start from the front and loop forwards for non-live\n        const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\n        const partAndSegment = partsAndSegments[index];\n        const segment = partAndSegment.segment;\n        const start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;\n        if (segment.timeline === currentTimeline && typeof start !== 'undefined') {\n          const distance = Math.abs(currentTime - start); // Once the distance begins to increase, we have passed\n          // currentTime and can stop looking for better candidates\n\n          if (lastDistance !== null && lastDistance < distance) {\n            break;\n          }\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n            lastDistance = distance;\n            syncPoint = {\n              time: start,\n              segmentIndex: partAndSegment.segmentIndex,\n              partIndex: partAndSegment.partIndex\n            };\n          }\n        }\n      }\n      return syncPoint;\n    }\n  },\n  // Stategy \"Discontinuity\": We have a discontinuity with a known\n  //                          display-time\n  {\n    name: 'Discontinuity',\n    run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n      let syncPoint = null;\n      currentTime = currentTime || 0;\n      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n        let lastDistance = null;\n        for (let i = 0; i < playlist.discontinuityStarts.length; i++) {\n          const segmentIndex = playlist.discontinuityStarts[i];\n          const discontinuity = playlist.discontinuitySequence + i + 1;\n          const discontinuitySync = syncController.discontinuities[discontinuity];\n          if (discontinuitySync) {\n            const distance = Math.abs(currentTime - discontinuitySync.time); // Once the distance begins to increase, we have passed\n            // currentTime and can stop looking for better candidates\n\n            if (lastDistance !== null && lastDistance < distance) {\n              break;\n            }\n            if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n              lastDistance = distance;\n              syncPoint = {\n                time: discontinuitySync.time,\n                segmentIndex,\n                partIndex: null\n              };\n            }\n          }\n        }\n      }\n      return syncPoint;\n    }\n  },\n  // Stategy \"Playlist\": We have a playlist with a known mapping of\n  //                     segment index to display time\n  {\n    name: 'Playlist',\n    run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n      if (playlist.syncInfo) {\n        const syncPoint = {\n          time: playlist.syncInfo.time,\n          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,\n          partIndex: null\n        };\n        return syncPoint;\n      }\n      return null;\n    }\n  }];\n  class SyncController extends videojs.EventTarget {\n    constructor(options = {}) {\n      super(); // ...for synching across variants\n\n      this.timelines = [];\n      this.discontinuities = [];\n      this.timelineToDatetimeMappings = {};\n      this.logger_ = logger('SyncController');\n    }\n    /**\n     * Find a sync-point for the playlist specified\n     *\n     * A sync-point is defined as a known mapping from display-time to\n     * a segment-index in the current playlist.\n     *\n     * @param {Playlist} playlist\n     *        The playlist that needs a sync-point\n     * @param {number} duration\n     *        Duration of the MediaSource (Infinite if playing a live source)\n     * @param {number} currentTimeline\n     *        The last timeline from which a segment was loaded\n     * @return {Object}\n     *          A sync-point object\n     */\n\n    getSyncPoint(playlist, duration, currentTimeline, currentTime) {\n      const syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\n      if (!syncPoints.length) {\n        // Signal that we need to attempt to get a sync-point manually\n        // by fetching a segment in the playlist and constructing\n        // a sync-point from that information\n        return null;\n      } // Now find the sync-point that is closest to the currentTime because\n      // that should result in the most accurate guess about which segment\n      // to fetch\n\n      return this.selectSyncPoint_(syncPoints, {\n        key: 'time',\n        value: currentTime\n      });\n    }\n    /**\n     * Calculate the amount of time that has expired off the playlist during playback\n     *\n     * @param {Playlist} playlist\n     *        Playlist object to calculate expired from\n     * @param {number} duration\n     *        Duration of the MediaSource (Infinity if playling a live source)\n     * @return {number|null}\n     *          The amount of time that has expired off the playlist during playback. Null\n     *          if no sync-points for the playlist can be found.\n     */\n\n    getExpiredTime(playlist, duration) {\n      if (!playlist || !playlist.segments) {\n        return null;\n      }\n      const syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0); // Without sync-points, there is not enough information to determine the expired time\n\n      if (!syncPoints.length) {\n        return null;\n      }\n      const syncPoint = this.selectSyncPoint_(syncPoints, {\n        key: 'segmentIndex',\n        value: 0\n      }); // If the sync-point is beyond the start of the playlist, we want to subtract the\n      // duration from index 0 to syncPoint.segmentIndex instead of adding.\n\n      if (syncPoint.segmentIndex > 0) {\n        syncPoint.time *= -1;\n      }\n      return Math.abs(syncPoint.time + sumDurations({\n        defaultDuration: playlist.targetDuration,\n        durationList: playlist.segments,\n        startIndex: syncPoint.segmentIndex,\n        endIndex: 0\n      }));\n    }\n    /**\n     * Runs each sync-point strategy and returns a list of sync-points returned by the\n     * strategies\n     *\n     * @private\n     * @param {Playlist} playlist\n     *        The playlist that needs a sync-point\n     * @param {number} duration\n     *        Duration of the MediaSource (Infinity if playing a live source)\n     * @param {number} currentTimeline\n     *        The last timeline from which a segment was loaded\n     * @return {Array}\n     *          A list of sync-point objects\n     */\n\n    runStrategies_(playlist, duration, currentTimeline, currentTime) {\n      const syncPoints = []; // Try to find a sync-point in by utilizing various strategies...\n\n      for (let i = 0; i < syncPointStrategies.length; i++) {\n        const strategy = syncPointStrategies[i];\n        const syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\n        if (syncPoint) {\n          syncPoint.strategy = strategy.name;\n          syncPoints.push({\n            strategy: strategy.name,\n            syncPoint\n          });\n        }\n      }\n      return syncPoints;\n    }\n    /**\n     * Selects the sync-point nearest the specified target\n     *\n     * @private\n     * @param {Array} syncPoints\n     *        List of sync-points to select from\n     * @param {Object} target\n     *        Object specifying the property and value we are targeting\n     * @param {string} target.key\n     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n     * @param {number} target.value\n     *        The value to target for the specified key.\n     * @return {Object}\n     *          The sync-point nearest the target\n     */\n\n    selectSyncPoint_(syncPoints, target) {\n      let bestSyncPoint = syncPoints[0].syncPoint;\n      let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n      let bestStrategy = syncPoints[0].strategy;\n      for (let i = 1; i < syncPoints.length; i++) {\n        const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          bestSyncPoint = syncPoints[i].syncPoint;\n          bestStrategy = syncPoints[i].strategy;\n        }\n      }\n      this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy` + ` [${bestStrategy}]: [time:${bestSyncPoint.time},` + ` segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === 'number' ? `,partIndex:${bestSyncPoint.partIndex}` : '') + ']');\n      return bestSyncPoint;\n    }\n    /**\n     * Save any meta-data present on the segments when segments leave\n     * the live window to the playlist to allow for synchronization at the\n     * playlist level later.\n     *\n     * @param {Playlist} oldPlaylist - The previous active playlist\n     * @param {Playlist} newPlaylist - The updated and most current playlist\n     */\n\n    saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n      const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence; // Ignore large media sequence gaps\n\n      if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {\n        videojs.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);\n        return;\n      } // When a segment expires from the playlist and it has a start time\n      // save that information as a possible sync-point reference in future\n\n      for (let i = mediaSequenceDiff - 1; i >= 0; i--) {\n        const lastRemovedSegment = oldPlaylist.segments[i];\n        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n          newPlaylist.syncInfo = {\n            mediaSequence: oldPlaylist.mediaSequence + i,\n            time: lastRemovedSegment.start\n          };\n          this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time},` + ` mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);\n          this.trigger('syncinfoupdate');\n          break;\n        }\n      }\n    }\n    /**\n     * Save the mapping from playlist's ProgramDateTime to display. This should only happen\n     * before segments start to load.\n     *\n     * @param {Playlist} playlist - The currently active playlist\n     */\n\n    setDateTimeMappingForStart(playlist) {\n      // It's possible for the playlist to be updated before playback starts, meaning time\n      // zero is not yet set. If, during these playlist refreshes, a discontinuity is\n      // crossed, then the old time zero mapping (for the prior timeline) would be retained\n      // unless the mappings are cleared.\n      this.timelineToDatetimeMappings = {};\n      if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {\n        const firstSegment = playlist.segments[0];\n        const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1000;\n        this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;\n      }\n    }\n    /**\n     * Calculates and saves timeline mappings, playlist sync info, and segment timing values\n     * based on the latest timing information.\n     *\n     * @param {Object} options\n     *        Options object\n     * @param {SegmentInfo} options.segmentInfo\n     *        The current active request information\n     * @param {boolean} options.shouldSaveTimelineMapping\n     *        If there's a timeline change, determines if the timeline mapping should be\n     *        saved for timeline mapping and program date time mappings.\n     */\n\n    saveSegmentTimingInfo({\n      segmentInfo,\n      shouldSaveTimelineMapping\n    }) {\n      const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);\n      const segment = segmentInfo.segment;\n      if (didCalculateSegmentTimeMapping) {\n        this.saveDiscontinuitySyncInfo_(segmentInfo); // If the playlist does not have sync information yet, record that information\n        // now with segment timing information\n\n        if (!segmentInfo.playlist.syncInfo) {\n          segmentInfo.playlist.syncInfo = {\n            mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,\n            time: segment.start\n          };\n        }\n      }\n      const dateTime = segment.dateTimeObject;\n      if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {\n        this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1000);\n      }\n    }\n    timestampOffsetForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].time;\n    }\n    mappingForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].mapping;\n    }\n    /**\n     * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n     * save that display time to the segment.\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo\n     *        The current active request information\n     * @param {Object} timingInfo\n     *        The start and end time of the current segment in \"media time\"\n     * @param {boolean} shouldSaveTimelineMapping\n     *        If there's a timeline change, determines if the timeline mapping should be\n     *        saved in timelines.\n     * @return {boolean}\n     *          Returns false if segment time mapping could not be calculated\n     */\n\n    calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {\n      // TODO: remove side effects\n      const segment = segmentInfo.segment;\n      const part = segmentInfo.part;\n      let mappingObj = this.timelines[segmentInfo.timeline];\n      let start;\n      let end;\n      if (typeof segmentInfo.timestampOffset === 'number') {\n        mappingObj = {\n          time: segmentInfo.startOfSegment,\n          mapping: segmentInfo.startOfSegment - timingInfo.start\n        };\n        if (shouldSaveTimelineMapping) {\n          this.timelines[segmentInfo.timeline] = mappingObj;\n          this.trigger('timestampoffset');\n          this.logger_(`time mapping for timeline ${segmentInfo.timeline}: ` + `[time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);\n        }\n        start = segmentInfo.startOfSegment;\n        end = timingInfo.end + mappingObj.mapping;\n      } else if (mappingObj) {\n        start = timingInfo.start + mappingObj.mapping;\n        end = timingInfo.end + mappingObj.mapping;\n      } else {\n        return false;\n      }\n      if (part) {\n        part.start = start;\n        part.end = end;\n      } // If we don't have a segment start yet or the start value we got\n      // is less than our current segment.start value, save a new start value.\n      // We have to do this because parts will have segment timing info saved\n      // multiple times and we want segment start to be the earliest part start\n      // value for that segment.\n\n      if (!segment.start || start < segment.start) {\n        segment.start = start;\n      }\n      segment.end = end;\n      return true;\n    }\n    /**\n     * Each time we have discontinuity in the playlist, attempt to calculate the location\n     * in display of the start of the discontinuity and save that. We also save an accuracy\n     * value so that we save values with the most accuracy (closest to 0.)\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n\n    saveDiscontinuitySyncInfo_(segmentInfo) {\n      const playlist = segmentInfo.playlist;\n      const segment = segmentInfo.segment; // If the current segment is a discontinuity then we know exactly where\n      // the start of the range and it's accuracy is 0 (greater accuracy values\n      // mean more approximation)\n\n      if (segment.discontinuity) {\n        this.discontinuities[segment.timeline] = {\n          time: segment.start,\n          accuracy: 0\n        };\n      } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n        // Search for future discontinuities that we can provide better timing\n        // information for and save that information for sync purposes\n        for (let i = 0; i < playlist.discontinuityStarts.length; i++) {\n          const segmentIndex = playlist.discontinuityStarts[i];\n          const discontinuity = playlist.discontinuitySequence + i + 1;\n          const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n          const accuracy = Math.abs(mediaIndexDiff);\n          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n            let time;\n            if (mediaIndexDiff < 0) {\n              time = segment.start - sumDurations({\n                defaultDuration: playlist.targetDuration,\n                durationList: playlist.segments,\n                startIndex: segmentInfo.mediaIndex,\n                endIndex: segmentIndex\n              });\n            } else {\n              time = segment.end + sumDurations({\n                defaultDuration: playlist.targetDuration,\n                durationList: playlist.segments,\n                startIndex: segmentInfo.mediaIndex + 1,\n                endIndex: segmentIndex\n              });\n            }\n            this.discontinuities[discontinuity] = {\n              time,\n              accuracy\n            };\n          }\n        }\n      }\n    }\n    dispose() {\n      this.trigger('dispose');\n      this.off();\n    }\n  }\n\n  /**\n   * The TimelineChangeController acts as a source for segment loaders to listen for and\n   * keep track of latest and pending timeline changes. This is useful to ensure proper\n   * sync, as each loader may need to make a consideration for what timeline the other\n   * loader is on before making changes which could impact the other loader's media.\n   *\n   * @class TimelineChangeController\n   * @extends videojs.EventTarget\n   */\n\n  class TimelineChangeController extends videojs.EventTarget {\n    constructor() {\n      super();\n      this.pendingTimelineChanges_ = {};\n      this.lastTimelineChanges_ = {};\n    }\n    clearPendingTimelineChange(type) {\n      this.pendingTimelineChanges_[type] = null;\n      this.trigger('pendingtimelinechange');\n    }\n    pendingTimelineChange({\n      type,\n      from,\n      to\n    }) {\n      if (typeof from === 'number' && typeof to === 'number') {\n        this.pendingTimelineChanges_[type] = {\n          type,\n          from,\n          to\n        };\n        this.trigger('pendingtimelinechange');\n      }\n      return this.pendingTimelineChanges_[type];\n    }\n    lastTimelineChange({\n      type,\n      from,\n      to\n    }) {\n      if (typeof from === 'number' && typeof to === 'number') {\n        this.lastTimelineChanges_[type] = {\n          type,\n          from,\n          to\n        };\n        delete this.pendingTimelineChanges_[type];\n        this.trigger('timelinechange');\n      }\n      return this.lastTimelineChanges_[type];\n    }\n    dispose() {\n      this.trigger('dispose');\n      this.pendingTimelineChanges_ = {};\n      this.lastTimelineChanges_ = {};\n      this.off();\n    }\n  }\n\n  /* rollup-plugin-worker-factory start for worker!/Users/poneill/dev/http-streaming/src/decrypter-worker.js */\n  const workerCode = transform(getWorkerString(function () {\n    /**\n     * @file stream.js\n     */\n\n    /**\n     * A lightweight readable stream implemention that handles event dispatching.\n     *\n     * @class Stream\n     */\n\n    var Stream = /*#__PURE__*/function () {\n      function Stream() {\n        this.listeners = {};\n      }\n      /**\n       * Add a listener for a specified event type.\n       *\n       * @param {string} type the event name\n       * @param {Function} listener the callback to be invoked when an event of\n       * the specified type occurs\n       */\n\n      var _proto = Stream.prototype;\n      _proto.on = function on(type, listener) {\n        if (!this.listeners[type]) {\n          this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n      }\n      /**\n       * Remove a listener for a specified event type.\n       *\n       * @param {string} type the event name\n       * @param {Function} listener  a function previously registered for this\n       * type of event through `on`\n       * @return {boolean} if we could turn it off or not\n       */;\n\n      _proto.off = function off(type, listener) {\n        if (!this.listeners[type]) {\n          return false;\n        }\n        var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n        // In Video.js we slice listener functions\n        // on trigger so that it does not mess up the order\n        // while we loop through.\n        //\n        // Here we slice on off so that the loop in trigger\n        // can continue using it's old reference to loop without\n        // messing up the order.\n\n        this.listeners[type] = this.listeners[type].slice(0);\n        this.listeners[type].splice(index, 1);\n        return index > -1;\n      }\n      /**\n       * Trigger an event of the specified type on this stream. Any additional\n       * arguments to this function are passed as parameters to event listeners.\n       *\n       * @param {string} type the event name\n       */;\n\n      _proto.trigger = function trigger(type) {\n        var callbacks = this.listeners[type];\n        if (!callbacks) {\n          return;\n        } // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n\n        if (arguments.length === 2) {\n          var length = callbacks.length;\n          for (var i = 0; i < length; ++i) {\n            callbacks[i].call(this, arguments[1]);\n          }\n        } else {\n          var args = Array.prototype.slice.call(arguments, 1);\n          var _length = callbacks.length;\n          for (var _i = 0; _i < _length; ++_i) {\n            callbacks[_i].apply(this, args);\n          }\n        }\n      }\n      /**\n       * Destroys the stream and cleans up.\n       */;\n\n      _proto.dispose = function dispose() {\n        this.listeners = {};\n      }\n      /**\n       * Forwards all `data` events on this stream to the destination stream. The\n       * destination stream should provide a method `push` to receive the data\n       * events as they arrive.\n       *\n       * @param {Stream} destination the stream that will receive all `data` events\n       * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n       */;\n\n      _proto.pipe = function pipe(destination) {\n        this.on('data', function (data) {\n          destination.push(data);\n        });\n      };\n      return Stream;\n    }();\n    /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */\n\n    /**\n     * Returns the subarray of a Uint8Array without PKCS#7 padding.\n     *\n     * @param padded {Uint8Array} unencrypted bytes that have been padded\n     * @return {Uint8Array} the unpadded bytes\n     * @see http://tools.ietf.org/html/rfc5652\n     */\n\n    function unpad(padded) {\n      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n    }\n    /*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */\n\n    /**\n     * @file aes.js\n     *\n     * This file contains an adaptation of the AES decryption algorithm\n     * from the Standford Javascript Cryptography Library. That work is\n     * covered by the following copyright and permissions notice:\n     *\n     * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n     * All rights reserved.\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are\n     * met:\n     *\n     * 1. Redistributions of source code must retain the above copyright\n     *    notice, this list of conditions and the following disclaimer.\n     *\n     * 2. Redistributions in binary form must reproduce the above\n     *    copyright notice, this list of conditions and the following\n     *    disclaimer in the documentation and/or other materials provided\n     *    with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n     * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n     * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     *\n     * The views and conclusions contained in the software and documentation\n     * are those of the authors and should not be interpreted as representing\n     * official policies, either expressed or implied, of the authors.\n     */\n\n    /**\n     * Expand the S-box tables.\n     *\n     * @private\n     */\n\n    const precompute = function () {\n      const tables = [[[], [], [], [], []], [[], [], [], [], []]];\n      const encTable = tables[0];\n      const decTable = tables[1];\n      const sbox = encTable[4];\n      const sboxInv = decTable[4];\n      let i;\n      let x;\n      let xInv;\n      const d = [];\n      const th = [];\n      let x2;\n      let x4;\n      let x8;\n      let s;\n      let tEnc;\n      let tDec; // Compute double and third tables\n\n      for (i = 0; i < 256; i++) {\n        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n      }\n      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n        // Compute sbox\n        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n        s = s >> 8 ^ s & 255 ^ 99;\n        sbox[x] = s;\n        sboxInv[s] = x; // Compute MixColumns\n\n        x8 = d[x4 = d[x2 = d[x]]];\n        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        tEnc = d[s] * 0x101 ^ s * 0x1010100;\n        for (i = 0; i < 4; i++) {\n          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n        }\n      } // Compactify. Considerable speedup on Firefox.\n\n      for (i = 0; i < 5; i++) {\n        encTable[i] = encTable[i].slice(0);\n        decTable[i] = decTable[i].slice(0);\n      }\n      return tables;\n    };\n    let aesTables = null;\n    /**\n     * Schedule out an AES key for both encryption and decryption. This\n     * is a low-level class. Use a cipher mode to do bulk encryption.\n     *\n     * @class AES\n     * @param key {Array} The key as an array of 4, 6 or 8 words.\n     */\n\n    class AES {\n      constructor(key) {\n        /**\n        * The expanded S-box and inverse S-box tables. These will be computed\n        * on the client so that we don't have to send them down the wire.\n        *\n        * There are two tables, _tables[0] is for encryption and\n        * _tables[1] is for decryption.\n        *\n        * The first 4 sub-tables are the expanded S-box with MixColumns. The\n        * last (_tables[01][4]) is the S-box itself.\n        *\n        * @private\n        */\n        // if we have yet to precompute the S-box tables\n        // do so now\n        if (!aesTables) {\n          aesTables = precompute();\n        } // then make a copy of that object for use\n\n        this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n        let i;\n        let j;\n        let tmp;\n        const sbox = this._tables[0][4];\n        const decTable = this._tables[1];\n        const keyLen = key.length;\n        let rcon = 1;\n        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n          throw new Error('Invalid aes key size');\n        }\n        const encKey = key.slice(0);\n        const decKey = [];\n        this._key = [encKey, decKey]; // schedule encryption keys\n\n        for (i = keyLen; i < 4 * keyLen + 28; i++) {\n          tmp = encKey[i - 1]; // apply sbox\n\n          if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255]; // shift rows and add rcon\n\n            if (i % keyLen === 0) {\n              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n              rcon = rcon << 1 ^ (rcon >> 7) * 283;\n            }\n          }\n          encKey[i] = encKey[i - keyLen] ^ tmp;\n        } // schedule decryption keys\n\n        for (j = 0; i; j++, i--) {\n          tmp = encKey[j & 3 ? i : i - 4];\n          if (i <= 4 || j < 4) {\n            decKey[j] = tmp;\n          } else {\n            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n          }\n        }\n      }\n      /**\n       * Decrypt 16 bytes, specified as four 32-bit words.\n       *\n       * @param {number} encrypted0 the first word to decrypt\n       * @param {number} encrypted1 the second word to decrypt\n       * @param {number} encrypted2 the third word to decrypt\n       * @param {number} encrypted3 the fourth word to decrypt\n       * @param {Int32Array} out the array to write the decrypted words\n       * into\n       * @param {number} offset the offset into the output array to start\n       * writing results\n       * @return {Array} The plaintext.\n       */\n\n      decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n        const key = this._key[1]; // state variables a,b,c,d are loaded with pre-whitened data\n\n        let a = encrypted0 ^ key[0];\n        let b = encrypted3 ^ key[1];\n        let c = encrypted2 ^ key[2];\n        let d = encrypted1 ^ key[3];\n        let a2;\n        let b2;\n        let c2; // key.length === 2 ?\n\n        const nInnerRounds = key.length / 4 - 2;\n        let i;\n        let kIndex = 4;\n        const table = this._tables[1]; // load up the tables\n\n        const table0 = table[0];\n        const table1 = table[1];\n        const table2 = table[2];\n        const table3 = table[3];\n        const sbox = table[4]; // Inner rounds. Cribbed from OpenSSL.\n\n        for (i = 0; i < nInnerRounds; i++) {\n          a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n          b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n          c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n          d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n          kIndex += 4;\n          a = a2;\n          b = b2;\n          c = c2;\n        } // Last round.\n\n        for (i = 0; i < 4; i++) {\n          out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n          a2 = a;\n          a = b;\n          b = c;\n          c = d;\n          d = a2;\n        }\n      }\n    }\n    /**\n     * @file async-stream.js\n     */\n\n    /**\n     * A wrapper around the Stream class to use setTimeout\n     * and run stream \"jobs\" Asynchronously\n     *\n     * @class AsyncStream\n     * @extends Stream\n     */\n\n    class AsyncStream extends Stream {\n      constructor() {\n        super(Stream);\n        this.jobs = [];\n        this.delay = 1;\n        this.timeout_ = null;\n      }\n      /**\n       * process an async job\n       *\n       * @private\n       */\n\n      processJob_() {\n        this.jobs.shift()();\n        if (this.jobs.length) {\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n        } else {\n          this.timeout_ = null;\n        }\n      }\n      /**\n       * push a job into the stream\n       *\n       * @param {Function} job the job to push into the stream\n       */\n\n      push(job) {\n        this.jobs.push(job);\n        if (!this.timeout_) {\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n        }\n      }\n    }\n    /**\n     * @file decrypter.js\n     *\n     * An asynchronous implementation of AES-128 CBC decryption with\n     * PKCS#7 padding.\n     */\n\n    /**\n     * Convert network-order (big-endian) bytes into their little-endian\n     * representation.\n     */\n\n    const ntoh = function (word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    };\n    /**\n     * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n     *\n     * @param {Uint8Array} encrypted the encrypted bytes\n     * @param {Uint32Array} key the bytes of the decryption key\n     * @param {Uint32Array} initVector the initialization vector (IV) to\n     * use for the first round of CBC.\n     * @return {Uint8Array} the decrypted bytes\n     *\n     * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n     * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n     * @see https://tools.ietf.org/html/rfc2315\n     */\n\n    const decrypt = function (encrypted, key, initVector) {\n      // word-level access to the encrypted bytes\n      const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n      const decipher = new AES(Array.prototype.slice.call(key)); // byte and word-level access for the decrypted output\n\n      const decrypted = new Uint8Array(encrypted.byteLength);\n      const decrypted32 = new Int32Array(decrypted.buffer); // temporary variables for working with the IV, encrypted, and\n      // decrypted data\n\n      let init0;\n      let init1;\n      let init2;\n      let init3;\n      let encrypted0;\n      let encrypted1;\n      let encrypted2;\n      let encrypted3; // iteration variable\n\n      let wordIx; // pull out the words of the IV to ensure we don't modify the\n      // passed-in reference and easier access\n\n      init0 = initVector[0];\n      init1 = initVector[1];\n      init2 = initVector[2];\n      init3 = initVector[3]; // decrypt four word sequences, applying cipher-block chaining (CBC)\n      // to each decrypted block\n\n      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n        // convert big-endian (network order) words into little-endian\n        // (javascript order)\n        encrypted0 = ntoh(encrypted32[wordIx]);\n        encrypted1 = ntoh(encrypted32[wordIx + 1]);\n        encrypted2 = ntoh(encrypted32[wordIx + 2]);\n        encrypted3 = ntoh(encrypted32[wordIx + 3]); // decrypt the block\n\n        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx); // XOR with the IV, and restore network byte-order to obtain the\n        // plaintext\n\n        decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n        decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n        decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n        decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3); // setup the IV for the next round\n\n        init0 = encrypted0;\n        init1 = encrypted1;\n        init2 = encrypted2;\n        init3 = encrypted3;\n      }\n      return decrypted;\n    };\n    /**\n     * The `Decrypter` class that manages decryption of AES\n     * data through `AsyncStream` objects and the `decrypt`\n     * function\n     *\n     * @param {Uint8Array} encrypted the encrypted bytes\n     * @param {Uint32Array} key the bytes of the decryption key\n     * @param {Uint32Array} initVector the initialization vector (IV) to\n     * @param {Function} done the function to run when done\n     * @class Decrypter\n     */\n\n    class Decrypter {\n      constructor(encrypted, key, initVector, done) {\n        const step = Decrypter.STEP;\n        const encrypted32 = new Int32Array(encrypted.buffer);\n        const decrypted = new Uint8Array(encrypted.byteLength);\n        let i = 0;\n        this.asyncStream_ = new AsyncStream(); // split up the encryption job and do the individual chunks asynchronously\n\n        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n        for (i = step; i < encrypted32.length; i += step) {\n          initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n        } // invoke the done() callback when everything is finished\n\n        this.asyncStream_.push(function () {\n          // remove pkcs#7 padding from the decrypted bytes\n          done(null, unpad(decrypted));\n        });\n      }\n      /**\n       * a getter for step the maximum number of bytes to process at one time\n       *\n       * @return {number} the value of step 32000\n       */\n\n      static get STEP() {\n        // 4 * 8000;\n        return 32000;\n      }\n      /**\n       * @private\n       */\n\n      decryptChunk_(encrypted, key, initVector, decrypted) {\n        return function () {\n          const bytes = decrypt(encrypted, key, initVector);\n          decrypted.set(bytes, encrypted.byteOffset);\n        };\n      }\n    }\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n    var win;\n    if (typeof window !== \"undefined\") {\n      win = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n      win = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n      win = self;\n    } else {\n      win = {};\n    }\n    var window_1 = win;\n    var isArrayBufferView = function isArrayBufferView(obj) {\n      if (ArrayBuffer.isView === 'function') {\n        return ArrayBuffer.isView(obj);\n      }\n      return obj && obj.buffer instanceof ArrayBuffer;\n    };\n    var BigInt = window_1.BigInt || Number;\n    [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n    (function () {\n      var a = new Uint16Array([0xFFCC]);\n      var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n      if (b[0] === 0xFF) {\n        return 'big';\n      }\n      if (b[0] === 0xCC) {\n        return 'little';\n      }\n      return 'unknown';\n    })();\n    /**\n     * Creates an object for sending to a web worker modifying properties that are TypedArrays\n     * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n     *\n     * @param {Object} message\n     *        Object of properties and values to send to the web worker\n     * @return {Object}\n     *         Modified message with TypedArray values expanded\n     * @function createTransferableMessage\n     */\n\n    const createTransferableMessage = function (message) {\n      const transferable = {};\n      Object.keys(message).forEach(key => {\n        const value = message[key];\n        if (isArrayBufferView(value)) {\n          transferable[key] = {\n            bytes: value.buffer,\n            byteOffset: value.byteOffset,\n            byteLength: value.byteLength\n          };\n        } else {\n          transferable[key] = value;\n        }\n      });\n      return transferable;\n    };\n    /* global self */\n\n    /**\n     * Our web worker interface so that things can talk to aes-decrypter\n     * that will be running in a web worker. the scope is passed to this by\n     * webworkify.\n     */\n\n    self.onmessage = function (event) {\n      const data = event.data;\n      const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\n      const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\n      const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\n      /* eslint-disable no-new, handle-callback-err */\n\n      new Decrypter(encrypted, key, iv, function (err, bytes) {\n        self.postMessage(createTransferableMessage({\n          source: data.source,\n          decrypted: bytes\n        }), [bytes.buffer]);\n      });\n      /* eslint-enable */\n    };\n  }));\n\n  var Decrypter = factory(workerCode);\n  /* rollup-plugin-worker-factory end for worker!/Users/poneill/dev/http-streaming/src/decrypter-worker.js */\n\n  /**\n   * Convert the properties of an HLS track into an audioTrackKind.\n   *\n   * @private\n   */\n\n  const audioTrackKind_ = properties => {\n    let kind = properties.default ? 'main' : 'alternative';\n    if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n      kind = 'main-desc';\n    }\n    return kind;\n  };\n  /**\n   * Pause provided segment loader and playlist loader if active\n   *\n   * @param {SegmentLoader} segmentLoader\n   *        SegmentLoader to pause\n   * @param {Object} mediaType\n   *        Active media type\n   * @function stopLoaders\n   */\n\n  const stopLoaders = (segmentLoader, mediaType) => {\n    segmentLoader.abort();\n    segmentLoader.pause();\n    if (mediaType && mediaType.activePlaylistLoader) {\n      mediaType.activePlaylistLoader.pause();\n      mediaType.activePlaylistLoader = null;\n    }\n  };\n  /**\n   * Start loading provided segment loader and playlist loader\n   *\n   * @param {PlaylistLoader} playlistLoader\n   *        PlaylistLoader to start loading\n   * @param {Object} mediaType\n   *        Active media type\n   * @function startLoaders\n   */\n\n  const startLoaders = (playlistLoader, mediaType) => {\n    // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n    // playlist loader\n    mediaType.activePlaylistLoader = playlistLoader;\n    playlistLoader.load();\n  };\n  /**\n   * Returns a function to be called when the media group changes. It performs a\n   * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n   * change of group is merely a rendition switch of the same content at another encoding,\n   * rather than a change of content, such as switching audio from English to Spanish.\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Handler for a non-destructive resync of SegmentLoader when the active media\n   *         group changes.\n   * @function onGroupChanged\n   */\n\n  const onGroupChanged = (type, settings) => () => {\n    const {\n      segmentLoaders: {\n        [type]: segmentLoader,\n        main: mainSegmentLoader\n      },\n      mediaTypes: {\n        [type]: mediaType\n      }\n    } = settings;\n    const activeTrack = mediaType.activeTrack();\n    const activeGroup = mediaType.getActiveGroup();\n    const previousActiveLoader = mediaType.activePlaylistLoader;\n    const lastGroup = mediaType.lastGroup_; // the group did not change do nothing\n\n    if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) {\n      return;\n    }\n    mediaType.lastGroup_ = activeGroup;\n    mediaType.lastTrack_ = activeTrack;\n    stopLoaders(segmentLoader, mediaType);\n    if (!activeGroup || activeGroup.isMainPlaylist) {\n      // there is no group active or active group is a main playlist and won't change\n      return;\n    }\n    if (!activeGroup.playlistLoader) {\n      if (previousActiveLoader) {\n        // The previous group had a playlist loader but the new active group does not\n        // this means we are switching from demuxed to muxed audio. In this case we want to\n        // do a destructive reset of the main segment loader and not restart the audio\n        // loaders.\n        mainSegmentLoader.resetEverything();\n      }\n      return;\n    } // Non-destructive resync\n\n    segmentLoader.resyncLoader();\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n  const onGroupChanging = (type, settings) => () => {\n    const {\n      segmentLoaders: {\n        [type]: segmentLoader\n      },\n      mediaTypes: {\n        [type]: mediaType\n      }\n    } = settings;\n    mediaType.lastGroup_ = null;\n    segmentLoader.abort();\n    segmentLoader.pause();\n  };\n  /**\n   * Returns a function to be called when the media track changes. It performs a\n   * destructive reset of the SegmentLoader to ensure we start loading as close to\n   * currentTime as possible.\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Handler for a destructive reset of SegmentLoader when the active media\n   *         track changes.\n   * @function onTrackChanged\n   */\n\n  const onTrackChanged = (type, settings) => () => {\n    const {\n      mainPlaylistLoader,\n      segmentLoaders: {\n        [type]: segmentLoader,\n        main: mainSegmentLoader\n      },\n      mediaTypes: {\n        [type]: mediaType\n      }\n    } = settings;\n    const activeTrack = mediaType.activeTrack();\n    const activeGroup = mediaType.getActiveGroup();\n    const previousActiveLoader = mediaType.activePlaylistLoader;\n    const lastTrack = mediaType.lastTrack_; // track did not change, do nothing\n\n    if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) {\n      return;\n    }\n    mediaType.lastGroup_ = activeGroup;\n    mediaType.lastTrack_ = activeTrack;\n    stopLoaders(segmentLoader, mediaType);\n    if (!activeGroup) {\n      // there is no group active so we do not want to restart loaders\n      return;\n    }\n    if (activeGroup.isMainPlaylist) {\n      // track did not change, do nothing\n      if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) {\n        return;\n      }\n      const pc = settings.vhs.playlistController_;\n      const newPlaylist = pc.selectPlaylist(); // media will not change do nothing\n\n      if (pc.media() === newPlaylist) {\n        return;\n      }\n      mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack.id}`);\n      mainPlaylistLoader.pause();\n      mainSegmentLoader.resetEverything();\n      pc.fastQualityChange_(newPlaylist);\n      return;\n    }\n    if (type === 'AUDIO') {\n      if (!activeGroup.playlistLoader) {\n        // when switching from demuxed audio/video to muxed audio/video (noted by no\n        // playlist loader for the audio group), we want to do a destructive reset of the\n        // main segment loader and not restart the audio loaders\n        mainSegmentLoader.setAudio(true); // don't have to worry about disabling the audio of the audio segment loader since\n        // it should be stopped\n\n        mainSegmentLoader.resetEverything();\n        return;\n      } // although the segment loader is an audio segment loader, call the setAudio\n      // function to ensure it is prepared to re-append the init segment (or handle other\n      // config changes)\n\n      segmentLoader.setAudio(true);\n      mainSegmentLoader.setAudio(false);\n    }\n    if (previousActiveLoader === activeGroup.playlistLoader) {\n      // Nothing has actually changed. This can happen because track change events can fire\n      // multiple times for a \"single\" change. One for enabling the new active track, and\n      // one for disabling the track that was active\n      startLoaders(activeGroup.playlistLoader, mediaType);\n      return;\n    }\n    if (segmentLoader.track) {\n      // For WebVTT, set the new text track in the segmentloader\n      segmentLoader.track(activeTrack);\n    } // destructive reset\n\n    segmentLoader.resetEverything();\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n  const onError = {\n    /**\n     * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n     * an error.\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Error handler. Logs warning (or error if the playlist is excluded) to\n     *         console and switches back to default audio track.\n     * @function onError.AUDIO\n     */\n    AUDIO: (type, settings) => () => {\n      const {\n        segmentLoaders: {\n          [type]: segmentLoader\n        },\n        mediaTypes: {\n          [type]: mediaType\n        },\n        excludePlaylist\n      } = settings;\n      stopLoaders(segmentLoader, mediaType); // switch back to default audio track\n\n      const activeTrack = mediaType.activeTrack();\n      const activeGroup = mediaType.activeGroup();\n      const id = (activeGroup.filter(group => group.default)[0] || activeGroup[0]).id;\n      const defaultTrack = mediaType.tracks[id];\n      if (activeTrack === defaultTrack) {\n        // Default track encountered an error. All we can do now is exclude the current\n        // rendition and hope another will switch audio groups\n        excludePlaylist({\n          error: {\n            message: 'Problem encountered loading the default audio track.'\n          }\n        });\n        return;\n      }\n      videojs.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n      for (const trackId in mediaType.tracks) {\n        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n      }\n      mediaType.onTrackChanged();\n    },\n    /**\n     * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n     * an error.\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Error handler. Logs warning to console and disables the active subtitle track\n     * @function onError.SUBTITLES\n     */\n    SUBTITLES: (type, settings) => () => {\n      const {\n        segmentLoaders: {\n          [type]: segmentLoader\n        },\n        mediaTypes: {\n          [type]: mediaType\n        }\n      } = settings;\n      videojs.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n      stopLoaders(segmentLoader, mediaType);\n      const track = mediaType.activeTrack();\n      if (track) {\n        track.mode = 'disabled';\n      }\n      mediaType.onTrackChanged();\n    }\n  };\n  const setupListeners = {\n    /**\n     * Setup event listeners for audio playlist loader\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {PlaylistLoader|null} playlistLoader\n     *        PlaylistLoader to register listeners on\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @function setupListeners.AUDIO\n     */\n    AUDIO: (type, playlistLoader, settings) => {\n      if (!playlistLoader) {\n        // no playlist loader means audio will be muxed with the video\n        return;\n      }\n      const {\n        tech,\n        requestOptions,\n        segmentLoaders: {\n          [type]: segmentLoader\n        }\n      } = settings;\n      playlistLoader.on('loadedmetadata', () => {\n        const media = playlistLoader.media();\n        segmentLoader.playlist(media, requestOptions); // if the video is already playing, or if this isn't a live video and preload\n        // permits, start downloading segments\n\n        if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n          segmentLoader.load();\n        }\n      });\n      playlistLoader.on('loadedplaylist', () => {\n        segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n        if (!tech.paused()) {\n          segmentLoader.load();\n        }\n      });\n      playlistLoader.on('error', onError[type](type, settings));\n    },\n    /**\n     * Setup event listeners for subtitle playlist loader\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {PlaylistLoader|null} playlistLoader\n     *        PlaylistLoader to register listeners on\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @function setupListeners.SUBTITLES\n     */\n    SUBTITLES: (type, playlistLoader, settings) => {\n      const {\n        tech,\n        requestOptions,\n        segmentLoaders: {\n          [type]: segmentLoader\n        },\n        mediaTypes: {\n          [type]: mediaType\n        }\n      } = settings;\n      playlistLoader.on('loadedmetadata', () => {\n        const media = playlistLoader.media();\n        segmentLoader.playlist(media, requestOptions);\n        segmentLoader.track(mediaType.activeTrack()); // if the video is already playing, or if this isn't a live video and preload\n        // permits, start downloading segments\n\n        if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n          segmentLoader.load();\n        }\n      });\n      playlistLoader.on('loadedplaylist', () => {\n        segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n        if (!tech.paused()) {\n          segmentLoader.load();\n        }\n      });\n      playlistLoader.on('error', onError[type](type, settings));\n    }\n  };\n  const initialize = {\n    /**\n     * Setup PlaylistLoaders and AudioTracks for the audio groups\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @function initialize.AUDIO\n     */\n    'AUDIO': (type, settings) => {\n      const {\n        vhs,\n        sourceType,\n        segmentLoaders: {\n          [type]: segmentLoader\n        },\n        requestOptions,\n        main: {\n          mediaGroups\n        },\n        mediaTypes: {\n          [type]: {\n            groups,\n            tracks,\n            logger_\n          }\n        },\n        mainPlaylistLoader\n      } = settings;\n      const audioOnlyMain = isAudioOnly(mainPlaylistLoader.main); // force a default if we have none\n\n      if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {\n        mediaGroups[type] = {\n          main: {\n            default: {\n              default: true\n            }\n          }\n        };\n        if (audioOnlyMain) {\n          mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;\n        }\n      }\n      for (const groupId in mediaGroups[type]) {\n        if (!groups[groupId]) {\n          groups[groupId] = [];\n        }\n        for (const variantLabel in mediaGroups[type][groupId]) {\n          let properties = mediaGroups[type][groupId][variantLabel];\n          let playlistLoader;\n          if (audioOnlyMain) {\n            logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);\n            properties.isMainPlaylist = true;\n            playlistLoader = null; // if vhs-json was provided as the source, and the media playlist was resolved,\n            // use the resolved media playlist object\n          } else if (sourceType === 'vhs-json' && properties.playlists) {\n            playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);\n          } else if (properties.resolvedUri) {\n            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions); // TODO: dash isn't the only type with properties.playlists\n            // should we even have properties.playlists in this check.\n          } else if (properties.playlists && sourceType === 'dash') {\n            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);\n          } else {\n            // no resolvedUri means the audio is muxed with the video when using this\n            // audio track\n            playlistLoader = null;\n          }\n          properties = merge({\n            id: variantLabel,\n            playlistLoader\n          }, properties);\n          setupListeners[type](type, properties.playlistLoader, settings);\n          groups[groupId].push(properties);\n          if (typeof tracks[variantLabel] === 'undefined') {\n            const track = new videojs.AudioTrack({\n              id: variantLabel,\n              kind: audioTrackKind_(properties),\n              enabled: false,\n              language: properties.language,\n              default: properties.default,\n              label: variantLabel\n            });\n            tracks[variantLabel] = track;\n          }\n        }\n      } // setup single error event handler for the segment loader\n\n      segmentLoader.on('error', onError[type](type, settings));\n    },\n    /**\n     * Setup PlaylistLoaders and TextTracks for the subtitle groups\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @function initialize.SUBTITLES\n     */\n    'SUBTITLES': (type, settings) => {\n      const {\n        tech,\n        vhs,\n        sourceType,\n        segmentLoaders: {\n          [type]: segmentLoader\n        },\n        requestOptions,\n        main: {\n          mediaGroups\n        },\n        mediaTypes: {\n          [type]: {\n            groups,\n            tracks\n          }\n        },\n        mainPlaylistLoader\n      } = settings;\n      for (const groupId in mediaGroups[type]) {\n        if (!groups[groupId]) {\n          groups[groupId] = [];\n        }\n        for (const variantLabel in mediaGroups[type][groupId]) {\n          if (mediaGroups[type][groupId][variantLabel].forced) {\n            // Subtitle playlists with the forced attribute are not selectable in Safari.\n            // According to Apple's HLS Authoring Specification:\n            //   If content has forced subtitles and regular subtitles in a given language,\n            //   the regular subtitles track in that language MUST contain both the forced\n            //   subtitles and the regular subtitles for that language.\n            // Because of this requirement and that Safari does not add forced subtitles,\n            // forced subtitles are skipped here to maintain consistent experience across\n            // all platforms\n            continue;\n          }\n          let properties = mediaGroups[type][groupId][variantLabel];\n          let playlistLoader;\n          if (sourceType === 'hls') {\n            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);\n          } else if (sourceType === 'dash') {\n            const playlists = properties.playlists.filter(p => p.excludeUntil !== Infinity);\n            if (!playlists.length) {\n              return;\n            }\n            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);\n          } else if (sourceType === 'vhs-json') {\n            playlistLoader = new PlaylistLoader(\n            // if the vhs-json object included the media playlist, use the media playlist\n            // as provided, otherwise use the resolved URI to load the playlist\n            properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);\n          }\n          properties = merge({\n            id: variantLabel,\n            playlistLoader\n          }, properties);\n          setupListeners[type](type, properties.playlistLoader, settings);\n          groups[groupId].push(properties);\n          if (typeof tracks[variantLabel] === 'undefined') {\n            const track = tech.addRemoteTextTrack({\n              id: variantLabel,\n              kind: 'subtitles',\n              default: properties.default && properties.autoselect,\n              language: properties.language,\n              label: variantLabel\n            }, false).track;\n            tracks[variantLabel] = track;\n          }\n        }\n      } // setup single error event handler for the segment loader\n\n      segmentLoader.on('error', onError[type](type, settings));\n    },\n    /**\n     * Setup TextTracks for the closed-caption groups\n     *\n     * @param {String} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @function initialize['CLOSED-CAPTIONS']\n     */\n    'CLOSED-CAPTIONS': (type, settings) => {\n      const {\n        tech,\n        main: {\n          mediaGroups\n        },\n        mediaTypes: {\n          [type]: {\n            groups,\n            tracks\n          }\n        }\n      } = settings;\n      for (const groupId in mediaGroups[type]) {\n        if (!groups[groupId]) {\n          groups[groupId] = [];\n        }\n        for (const variantLabel in mediaGroups[type][groupId]) {\n          const properties = mediaGroups[type][groupId][variantLabel]; // Look for either 608 (CCn) or 708 (SERVICEn) caption services\n\n          if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {\n            continue;\n          }\n          const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\n          let newProps = {\n            label: variantLabel,\n            language: properties.language,\n            instreamId: properties.instreamId,\n            default: properties.default && properties.autoselect\n          };\n          if (captionServices[newProps.instreamId]) {\n            newProps = merge(newProps, captionServices[newProps.instreamId]);\n          }\n          if (newProps.default === undefined) {\n            delete newProps.default;\n          } // No PlaylistLoader is required for Closed-Captions because the captions are\n          // embedded within the video stream\n\n          groups[groupId].push(merge({\n            id: variantLabel\n          }, properties));\n          if (typeof tracks[variantLabel] === 'undefined') {\n            const track = tech.addRemoteTextTrack({\n              id: newProps.instreamId,\n              kind: 'captions',\n              default: newProps.default,\n              language: newProps.language,\n              label: newProps.label\n            }, false).track;\n            tracks[variantLabel] = track;\n          }\n        }\n      }\n    }\n  };\n  const groupMatch = (list, media) => {\n    for (let i = 0; i < list.length; i++) {\n      if (playlistMatch(media, list[i])) {\n        return true;\n      }\n      if (list[i].playlists && groupMatch(list[i].playlists, media)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Returns a function used to get the active group of the provided type\n   *\n   * @param {string} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media group for the provided type. Takes an\n   *         optional parameter {TextTrack} track. If no track is provided, a list of all\n   *         variants in the group, otherwise the variant corresponding to the provided\n   *         track is returned.\n   * @function activeGroup\n   */\n\n  const activeGroup = (type, settings) => track => {\n    const {\n      mainPlaylistLoader,\n      mediaTypes: {\n        [type]: {\n          groups\n        }\n      }\n    } = settings;\n    const media = mainPlaylistLoader.media();\n    if (!media) {\n      return null;\n    }\n    let variants = null; // set to variants to main media active group\n\n    if (media.attributes[type]) {\n      variants = groups[media.attributes[type]];\n    }\n    const groupKeys = Object.keys(groups);\n    if (!variants) {\n      // find the mainPlaylistLoader media\n      // that is in a media group if we are dealing\n      // with audio only\n      if (type === 'AUDIO' && groupKeys.length > 1 && isAudioOnly(settings.main)) {\n        for (let i = 0; i < groupKeys.length; i++) {\n          const groupPropertyList = groups[groupKeys[i]];\n          if (groupMatch(groupPropertyList, media)) {\n            variants = groupPropertyList;\n            break;\n          }\n        } // use the main group if it exists\n      } else if (groups.main) {\n        variants = groups.main; // only one group, use that one\n      } else if (groupKeys.length === 1) {\n        variants = groups[groupKeys[0]];\n      }\n    }\n    if (typeof track === 'undefined') {\n      return variants;\n    }\n    if (track === null || !variants) {\n      // An active track was specified so a corresponding group is expected. track === null\n      // means no track is currently active so there is no corresponding group\n      return null;\n    }\n    return variants.filter(props => props.id === track.id)[0] || null;\n  };\n  const activeTrack = {\n    /**\n     * Returns a function used to get the active track of type provided\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Function that returns the active media track for the provided type. Returns\n     *         null if no track is active\n     * @function activeTrack.AUDIO\n     */\n    AUDIO: (type, settings) => () => {\n      const {\n        mediaTypes: {\n          [type]: {\n            tracks\n          }\n        }\n      } = settings;\n      for (const id in tracks) {\n        if (tracks[id].enabled) {\n          return tracks[id];\n        }\n      }\n      return null;\n    },\n    /**\n     * Returns a function used to get the active track of type provided\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Function that returns the active media track for the provided type. Returns\n     *         null if no track is active\n     * @function activeTrack.SUBTITLES\n     */\n    SUBTITLES: (type, settings) => () => {\n      const {\n        mediaTypes: {\n          [type]: {\n            tracks\n          }\n        }\n      } = settings;\n      for (const id in tracks) {\n        if (tracks[id].mode === 'showing' || tracks[id].mode === 'hidden') {\n          return tracks[id];\n        }\n      }\n      return null;\n    }\n  };\n  const getActiveGroup = (type, {\n    mediaTypes\n  }) => () => {\n    const activeTrack_ = mediaTypes[type].activeTrack();\n    if (!activeTrack_) {\n      return null;\n    }\n    return mediaTypes[type].activeGroup(activeTrack_);\n  };\n  /**\n   * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n   * Closed-Captions) specified in the main manifest.\n   *\n   * @param {Object} settings\n   *        Object containing required information for setting up the media groups\n   * @param {Tech} settings.tech\n   *        The tech of the player\n   * @param {Object} settings.requestOptions\n   *        XHR request options used by the segment loaders\n   * @param {PlaylistLoader} settings.mainPlaylistLoader\n   *        PlaylistLoader for the main source\n   * @param {VhsHandler} settings.vhs\n   *        VHS SourceHandler\n   * @param {Object} settings.main\n   *        The parsed main manifest\n   * @param {Object} settings.mediaTypes\n   *        Object to store the loaders, tracks, and utility methods for each media type\n   * @param {Function} settings.excludePlaylist\n   *        Excludes the current rendition and forces a rendition switch.\n   * @function setupMediaGroups\n   */\n\n  const setupMediaGroups = settings => {\n    ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n      initialize[type](type, settings);\n    });\n    const {\n      mediaTypes,\n      mainPlaylistLoader,\n      tech,\n      vhs,\n      segmentLoaders: {\n        ['AUDIO']: audioSegmentLoader,\n        main: mainSegmentLoader\n      }\n    } = settings; // setup active group and track getters and change event handlers\n\n    ['AUDIO', 'SUBTITLES'].forEach(type => {\n      mediaTypes[type].activeGroup = activeGroup(type, settings);\n      mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n      mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n      mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);\n      mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n      mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);\n    }); // DO NOT enable the default subtitle or caption track.\n    // DO enable the default audio track\n\n    const audioGroup = mediaTypes.AUDIO.activeGroup();\n    if (audioGroup) {\n      const groupId = (audioGroup.filter(group => group.default)[0] || audioGroup[0]).id;\n      mediaTypes.AUDIO.tracks[groupId].enabled = true;\n      mediaTypes.AUDIO.onGroupChanged();\n      mediaTypes.AUDIO.onTrackChanged();\n      const activeAudioGroup = mediaTypes.AUDIO.getActiveGroup(); // a similar check for handling setAudio on each loader is run again each time the\n      // track is changed, but needs to be handled here since the track may not be considered\n      // changed on the first call to onTrackChanged\n\n      if (!activeAudioGroup.playlistLoader) {\n        // either audio is muxed with video or the stream is audio only\n        mainSegmentLoader.setAudio(true);\n      } else {\n        // audio is demuxed\n        mainSegmentLoader.setAudio(false);\n        audioSegmentLoader.setAudio(true);\n      }\n    }\n    mainPlaylistLoader.on('mediachange', () => {\n      ['AUDIO', 'SUBTITLES'].forEach(type => mediaTypes[type].onGroupChanged());\n    });\n    mainPlaylistLoader.on('mediachanging', () => {\n      ['AUDIO', 'SUBTITLES'].forEach(type => mediaTypes[type].onGroupChanging());\n    }); // custom audio track change event handler for usage event\n\n    const onAudioTrackChanged = () => {\n      mediaTypes.AUDIO.onTrackChanged();\n      tech.trigger({\n        type: 'usage',\n        name: 'vhs-audio-change'\n      });\n    };\n    tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n    tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n    vhs.on('dispose', () => {\n      tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n      tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n    }); // clear existing audio tracks and add the ones we just created\n\n    tech.clearTracks('audio');\n    for (const id in mediaTypes.AUDIO.tracks) {\n      tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n    }\n  };\n  /**\n   * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n   * media type\n   *\n   * @return {Object}\n   *         Object to store the loaders, tracks, and utility methods for each media type\n   * @function createMediaTypes\n   */\n\n  const createMediaTypes = () => {\n    const mediaTypes = {};\n    ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n      mediaTypes[type] = {\n        groups: {},\n        tracks: {},\n        activePlaylistLoader: null,\n        activeGroup: noop,\n        activeTrack: noop,\n        getActiveGroup: noop,\n        onGroupChanged: noop,\n        onTrackChanged: noop,\n        lastTrack_: null,\n        logger_: logger(`MediaGroups[${type}]`)\n      };\n    });\n    return mediaTypes;\n  };\n\n  /**\n   * @file playlist-controller.js\n   */\n  const ABORT_EARLY_EXCLUSION_SECONDS = 60 * 2;\n  let Vhs$1; // SegmentLoader stats that need to have each loader's\n  // values summed to calculate the final value\n\n  const loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred', 'mediaAppends'];\n  const sumLoaderStat = function (stat) {\n    return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n  };\n  const shouldSwitchToMedia = function ({\n    currentPlaylist,\n    buffered,\n    currentTime,\n    nextPlaylist,\n    bufferLowWaterLine,\n    bufferHighWaterLine,\n    duration,\n    bufferBasedABR,\n    log\n  }) {\n    // we have no other playlist to switch to\n    if (!nextPlaylist) {\n      videojs.log.warn('We received no playlist to switch to. Please check your stream.');\n      return false;\n    }\n    const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || 'null'} -> ${nextPlaylist.id}`;\n    if (!currentPlaylist) {\n      log(`${sharedLogLine} as current playlist is not set`);\n      return true;\n    } // no need to switch if playlist is the same\n\n    if (nextPlaylist.id === currentPlaylist.id) {\n      return false;\n    } // determine if current time is in a buffered range.\n\n    const isBuffered = Boolean(findRange(buffered, currentTime).length); // If the playlist is live, then we want to not take low water line into account.\n    // This is because in LIVE, the player plays 3 segments from the end of the\n    // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n    // in those segments, a viewer will never experience a rendition upswitch.\n\n    if (!currentPlaylist.endList) {\n      // For LLHLS live streams, don't switch renditions before playback has started, as it almost\n      // doubles the time to first playback.\n      if (!isBuffered && typeof currentPlaylist.partTargetDuration === 'number') {\n        log(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);\n        return false;\n      }\n      log(`${sharedLogLine} as current playlist is live`);\n      return true;\n    }\n    const forwardBuffer = timeAheadOf(buffered, currentTime);\n    const maxBufferLowWaterLine = bufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE; // For the same reason as LIVE, we ignore the low water line when the VOD\n    // duration is below the max potential low water line\n\n    if (duration < maxBufferLowWaterLine) {\n      log(`${sharedLogLine} as duration < max low water line (${duration} < ${maxBufferLowWaterLine})`);\n      return true;\n    }\n    const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;\n    const currBandwidth = currentPlaylist.attributes.BANDWIDTH; // when switching down, if our buffer is lower than the high water line,\n    // we can switch down\n\n    if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {\n      let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;\n      if (bufferBasedABR) {\n        logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;\n      }\n      log(logLine);\n      return true;\n    } // and if our buffer is higher than the low water line,\n    // we can switch up\n\n    if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {\n      let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;\n      if (bufferBasedABR) {\n        logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;\n      }\n      log(logLine);\n      return true;\n    }\n    log(`not ${sharedLogLine} as no switching criteria met`);\n    return false;\n  };\n  /**\n   * the main playlist controller controller all interactons\n   * between playlists and segmentloaders. At this time this mainly\n   * involves a main playlist and a series of audio playlists\n   * if they are available\n   *\n   * @class PlaylistController\n   * @extends videojs.EventTarget\n   */\n\n  class PlaylistController extends videojs.EventTarget {\n    constructor(options) {\n      super();\n      const {\n        src,\n        withCredentials,\n        tech,\n        bandwidth,\n        externVhs,\n        useCueTags,\n        playlistExclusionDuration,\n        enableLowInitialPlaylist,\n        sourceType,\n        cacheEncryptionKeys,\n        bufferBasedABR,\n        leastPixelDiffSelector,\n        captionServices\n      } = options;\n      if (!src) {\n        throw new Error('A non-empty playlist URL or JSON manifest string is required');\n      }\n      let {\n        maxPlaylistRetries\n      } = options;\n      if (maxPlaylistRetries === null || typeof maxPlaylistRetries === 'undefined') {\n        maxPlaylistRetries = Infinity;\n      }\n      Vhs$1 = externVhs;\n      this.bufferBasedABR = Boolean(bufferBasedABR);\n      this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);\n      this.withCredentials = withCredentials;\n      this.tech_ = tech;\n      this.vhs_ = tech.vhs;\n      this.sourceType_ = sourceType;\n      this.useCueTags_ = useCueTags;\n      this.playlistExclusionDuration = playlistExclusionDuration;\n      this.maxPlaylistRetries = maxPlaylistRetries;\n      this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n      if (this.useCueTags_) {\n        this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\n        this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n      }\n      this.requestOptions_ = {\n        withCredentials,\n        maxPlaylistRetries,\n        timeout: null\n      };\n      this.on('error', this.pauseLoading);\n      this.mediaTypes_ = createMediaTypes();\n      this.mediaSource = new window.MediaSource();\n      this.handleDurationChange_ = this.handleDurationChange_.bind(this);\n      this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);\n      this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);\n      this.mediaSource.addEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n      this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_);\n      this.mediaSource.addEventListener('sourceended', this.handleSourceEnded_); // we don't have to handle sourceclose since dispose will handle termination of\n      // everything, and the MediaSource should not be detached without a proper disposal\n\n      this.seekable_ = createTimeRanges();\n      this.hasPlayed_ = false;\n      this.syncController_ = new SyncController(options);\n      this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n        kind: 'metadata',\n        label: 'segment-metadata'\n      }, false).track;\n      this.decrypter_ = new Decrypter();\n      this.sourceUpdater_ = new SourceUpdater(this.mediaSource);\n      this.inbandTextTracks_ = {};\n      this.timelineChangeController_ = new TimelineChangeController();\n      const segmentLoaderSettings = {\n        vhs: this.vhs_,\n        parse708captions: options.parse708captions,\n        useDtsForTimestampOffset: options.useDtsForTimestampOffset,\n        captionServices,\n        mediaSource: this.mediaSource,\n        currentTime: this.tech_.currentTime.bind(this.tech_),\n        seekable: () => this.seekable(),\n        seeking: () => this.tech_.seeking(),\n        duration: () => this.duration(),\n        hasPlayed: () => this.hasPlayed_,\n        goalBufferLength: () => this.goalBufferLength(),\n        bandwidth,\n        syncController: this.syncController_,\n        decrypter: this.decrypter_,\n        sourceType: this.sourceType_,\n        inbandTextTracks: this.inbandTextTracks_,\n        cacheEncryptionKeys,\n        sourceUpdater: this.sourceUpdater_,\n        timelineChangeController: this.timelineChangeController_,\n        exactManifestTimings: options.exactManifestTimings\n      }; // The source type check not only determines whether a special DASH playlist loader\n      // should be used, but also covers the case where the provided src is a vhs-json\n      // manifest object (instead of a URL). In the case of vhs-json, the default\n      // PlaylistLoader should be used.\n\n      this.mainPlaylistLoader_ = this.sourceType_ === 'dash' ? new DashPlaylistLoader(src, this.vhs_, this.requestOptions_) : new PlaylistLoader(src, this.vhs_, this.requestOptions_);\n      this.setupMainPlaylistLoaderListeners_(); // setup segment loaders\n      // combined audio/video or just video when alternate audio track is selected\n\n      this.mainSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {\n        segmentMetadataTrack: this.segmentMetadataTrack_,\n        loaderType: 'main'\n      }), options); // alternate audio track\n\n      this.audioSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {\n        loaderType: 'audio'\n      }), options);\n      this.subtitleSegmentLoader_ = new VTTSegmentLoader(merge(segmentLoaderSettings, {\n        loaderType: 'vtt',\n        featuresNativeTextTracks: this.tech_.featuresNativeTextTracks\n      }), options);\n      this.setupSegmentLoaderListeners_();\n      if (this.bufferBasedABR) {\n        this.mainPlaylistLoader_.one('loadedplaylist', () => this.startABRTimer_());\n        this.tech_.on('pause', () => this.stopABRTimer_());\n        this.tech_.on('play', () => this.startABRTimer_());\n      } // Create SegmentLoader stat-getters\n      // mediaRequests_\n      // mediaRequestsAborted_\n      // mediaRequestsTimedout_\n      // mediaRequestsErrored_\n      // mediaTransferDuration_\n      // mediaBytesTransferred_\n      // mediaAppends_\n\n      loaderStats.forEach(stat => {\n        this[stat + '_'] = sumLoaderStat.bind(this, stat);\n      });\n      this.logger_ = logger('pc');\n      this.triggeredFmp4Usage = false;\n      if (this.tech_.preload() === 'none') {\n        this.loadOnPlay_ = () => {\n          this.loadOnPlay_ = null;\n          this.mainPlaylistLoader_.load();\n        };\n        this.tech_.one('play', this.loadOnPlay_);\n      } else {\n        this.mainPlaylistLoader_.load();\n      }\n      this.timeToLoadedData__ = -1;\n      this.mainAppendsToLoadedData__ = -1;\n      this.audioAppendsToLoadedData__ = -1;\n      const event = this.tech_.preload() === 'none' ? 'play' : 'loadstart'; // start the first frame timer on loadstart or play (for preload none)\n\n      this.tech_.one(event, () => {\n        const timeToLoadedDataStart = Date.now();\n        this.tech_.one('loadeddata', () => {\n          this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;\n          this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;\n          this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;\n        });\n      });\n    }\n    mainAppendsToLoadedData_() {\n      return this.mainAppendsToLoadedData__;\n    }\n    audioAppendsToLoadedData_() {\n      return this.audioAppendsToLoadedData__;\n    }\n    appendsToLoadedData_() {\n      const main = this.mainAppendsToLoadedData_();\n      const audio = this.audioAppendsToLoadedData_();\n      if (main === -1 || audio === -1) {\n        return -1;\n      }\n      return main + audio;\n    }\n    timeToLoadedData_() {\n      return this.timeToLoadedData__;\n    }\n    /**\n     * Run selectPlaylist and switch to the new playlist if we should\n     *\n     * @param {string} [reason=abr] a reason for why the ABR check is made\n     * @private\n     */\n\n    checkABR_(reason = 'abr') {\n      const nextPlaylist = this.selectPlaylist();\n      if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {\n        this.switchMedia_(nextPlaylist, reason);\n      }\n    }\n    switchMedia_(playlist, cause, delay) {\n      const oldMedia = this.media();\n      const oldId = oldMedia && (oldMedia.id || oldMedia.uri);\n      const newId = playlist.id || playlist.uri;\n      if (oldId && oldId !== newId) {\n        this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);\n        this.tech_.trigger({\n          type: 'usage',\n          name: `vhs-rendition-change-${cause}`\n        });\n      }\n      this.mainPlaylistLoader_.media(playlist, delay);\n    }\n    /**\n     * Start a timer that periodically calls checkABR_\n     *\n     * @private\n     */\n\n    startABRTimer_() {\n      this.stopABRTimer_();\n      this.abrTimer_ = window.setInterval(() => this.checkABR_(), 250);\n    }\n    /**\n     * Stop the timer that periodically calls checkABR_\n     *\n     * @private\n     */\n\n    stopABRTimer_() {\n      // if we're scrubbing, we don't need to pause.\n      // This getter will be added to Video.js in version 7.11.\n      if (this.tech_.scrubbing && this.tech_.scrubbing()) {\n        return;\n      }\n      window.clearInterval(this.abrTimer_);\n      this.abrTimer_ = null;\n    }\n    /**\n     * Get a list of playlists for the currently selected audio playlist\n     *\n     * @return {Array} the array of audio playlists\n     */\n\n    getAudioTrackPlaylists_() {\n      const main = this.main();\n      const defaultPlaylists = main && main.playlists || []; // if we don't have any audio groups then we can only\n      // assume that the audio tracks are contained in main\n      // playlist array, use that or an empty array.\n\n      if (!main || !main.mediaGroups || !main.mediaGroups.AUDIO) {\n        return defaultPlaylists;\n      }\n      const AUDIO = main.mediaGroups.AUDIO;\n      const groupKeys = Object.keys(AUDIO);\n      let track; // get the current active track\n\n      if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {\n        track = this.mediaTypes_.AUDIO.activeTrack(); // or get the default track from main if mediaTypes_ isn't setup yet\n      } else {\n        // default group is `main` or just the first group.\n        const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];\n        for (const label in defaultGroup) {\n          if (defaultGroup[label].default) {\n            track = {\n              label\n            };\n            break;\n          }\n        }\n      } // no active track no playlists.\n\n      if (!track) {\n        return defaultPlaylists;\n      }\n      const playlists = []; // get all of the playlists that are possible for the\n      // active track.\n\n      for (const group in AUDIO) {\n        if (AUDIO[group][track.label]) {\n          const properties = AUDIO[group][track.label];\n          if (properties.playlists && properties.playlists.length) {\n            playlists.push.apply(playlists, properties.playlists);\n          } else if (properties.uri) {\n            playlists.push(properties);\n          } else if (main.playlists.length) {\n            // if an audio group does not have a uri\n            // see if we have main playlists that use it as a group.\n            // if we do then add those to the playlists list.\n            for (let i = 0; i < main.playlists.length; i++) {\n              const playlist = main.playlists[i];\n              if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {\n                playlists.push(playlist);\n              }\n            }\n          }\n        }\n      }\n      if (!playlists.length) {\n        return defaultPlaylists;\n      }\n      return playlists;\n    }\n    /**\n     * Register event handlers on the main playlist loader. A helper\n     * function for construction time.\n     *\n     * @private\n     */\n\n    setupMainPlaylistLoaderListeners_() {\n      this.mainPlaylistLoader_.on('loadedmetadata', () => {\n        const media = this.mainPlaylistLoader_.media();\n        const requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n\n        if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {\n          this.requestOptions_.timeout = 0;\n        } else {\n          this.requestOptions_.timeout = requestTimeout;\n        } // if this isn't a live video and preload permits, start\n        // downloading segments\n\n        if (media.endList && this.tech_.preload() !== 'none') {\n          this.mainSegmentLoader_.playlist(media, this.requestOptions_);\n          this.mainSegmentLoader_.load();\n        }\n        setupMediaGroups({\n          sourceType: this.sourceType_,\n          segmentLoaders: {\n            AUDIO: this.audioSegmentLoader_,\n            SUBTITLES: this.subtitleSegmentLoader_,\n            main: this.mainSegmentLoader_\n          },\n          tech: this.tech_,\n          requestOptions: this.requestOptions_,\n          mainPlaylistLoader: this.mainPlaylistLoader_,\n          vhs: this.vhs_,\n          main: this.main(),\n          mediaTypes: this.mediaTypes_,\n          excludePlaylist: this.excludePlaylist.bind(this)\n        });\n        this.triggerPresenceUsage_(this.main(), media);\n        this.setupFirstPlay();\n        if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) {\n          this.trigger('selectedinitialmedia');\n        } else {\n          // We must wait for the active audio playlist loader to\n          // finish setting up before triggering this event so the\n          // representations API and EME setup is correct\n          this.mediaTypes_.AUDIO.activePlaylistLoader.one('loadedmetadata', () => {\n            this.trigger('selectedinitialmedia');\n          });\n        }\n      });\n      this.mainPlaylistLoader_.on('loadedplaylist', () => {\n        if (this.loadOnPlay_) {\n          this.tech_.off('play', this.loadOnPlay_);\n        }\n        let updatedPlaylist = this.mainPlaylistLoader_.media();\n        if (!updatedPlaylist) {\n          // exclude any variants that are not supported by the browser before selecting\n          // an initial media as the playlist selectors do not consider browser support\n          this.excludeUnsupportedVariants_();\n          let selectedMedia;\n          if (this.enableLowInitialPlaylist) {\n            selectedMedia = this.selectInitialPlaylist();\n          }\n          if (!selectedMedia) {\n            selectedMedia = this.selectPlaylist();\n          }\n          if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) {\n            return;\n          }\n          this.initialMedia_ = selectedMedia;\n          this.switchMedia_(this.initialMedia_, 'initial'); // Under the standard case where a source URL is provided, loadedplaylist will\n          // fire again since the playlist will be requested. In the case of vhs-json\n          // (where the manifest object is provided as the source), when the media\n          // playlist's `segments` list is already available, a media playlist won't be\n          // requested, and loadedplaylist won't fire again, so the playlist handler must be\n          // called on its own here.\n\n          const haveJsonSource = this.sourceType_ === 'vhs-json' && this.initialMedia_.segments;\n          if (!haveJsonSource) {\n            return;\n          }\n          updatedPlaylist = this.initialMedia_;\n        }\n        this.handleUpdatedMediaPlaylist(updatedPlaylist);\n      });\n      this.mainPlaylistLoader_.on('error', () => {\n        const error = this.mainPlaylistLoader_.error;\n        this.excludePlaylist({\n          playlistToExclude: error.playlist,\n          error\n        });\n      });\n      this.mainPlaylistLoader_.on('mediachanging', () => {\n        this.mainSegmentLoader_.abort();\n        this.mainSegmentLoader_.pause();\n      });\n      this.mainPlaylistLoader_.on('mediachange', () => {\n        const media = this.mainPlaylistLoader_.media();\n        const requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n\n        if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {\n          this.requestOptions_.timeout = 0;\n        } else {\n          this.requestOptions_.timeout = requestTimeout;\n        }\n        this.mainPlaylistLoader_.load(); // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `loadedplaylist`\n\n        this.mainSegmentLoader_.playlist(media, this.requestOptions_);\n        this.mainSegmentLoader_.load();\n        this.tech_.trigger({\n          type: 'mediachange',\n          bubbles: true\n        });\n      });\n      this.mainPlaylistLoader_.on('playlistunchanged', () => {\n        const updatedPlaylist = this.mainPlaylistLoader_.media(); // ignore unchanged playlists that have already been\n        // excluded for not-changing. We likely just have a really slowly updating\n        // playlist.\n\n        if (updatedPlaylist.lastExcludeReason_ === 'playlist-unchanged') {\n          return;\n        }\n        const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);\n        if (playlistOutdated) {\n          // Playlist has stopped updating and we're stuck at its end. Try to\n          // exclude it and switch to another playlist in the hope that that\n          // one is updating (and give the player a chance to re-adjust to the\n          // safe live point).\n          this.excludePlaylist({\n            error: {\n              message: 'Playlist no longer updating.',\n              reason: 'playlist-unchanged'\n            }\n          }); // useful for monitoring QoS\n\n          this.tech_.trigger('playliststuck');\n        }\n      });\n      this.mainPlaylistLoader_.on('renditiondisabled', () => {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-rendition-disabled'\n        });\n      });\n      this.mainPlaylistLoader_.on('renditionenabled', () => {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-rendition-enabled'\n        });\n      });\n    }\n    /**\n     * Given an updated media playlist (whether it was loaded for the first time, or\n     * refreshed for live playlists), update any relevant properties and state to reflect\n     * changes in the media that should be accounted for (e.g., cues and duration).\n     *\n     * @param {Object} updatedPlaylist the updated media playlist object\n     *\n     * @private\n     */\n\n    handleUpdatedMediaPlaylist(updatedPlaylist) {\n      if (this.useCueTags_) {\n        this.updateAdCues_(updatedPlaylist);\n      } // TODO: Create a new event on the PlaylistLoader that signals\n      // that the segments have changed in some way and use that to\n      // update the SegmentLoader instead of doing it twice here and\n      // on `mediachange`\n\n      this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);\n      this.updateDuration(!updatedPlaylist.endList); // If the player isn't paused, ensure that the segment loader is running,\n      // as it is possible that it was temporarily stopped while waiting for\n      // a playlist (e.g., in case the playlist errored and we re-requested it).\n\n      if (!this.tech_.paused()) {\n        this.mainSegmentLoader_.load();\n        if (this.audioSegmentLoader_) {\n          this.audioSegmentLoader_.load();\n        }\n      }\n    }\n    /**\n     * A helper function for triggerring presence usage events once per source\n     *\n     * @private\n     */\n\n    triggerPresenceUsage_(main, media) {\n      const mediaGroups = main.mediaGroups || {};\n      let defaultDemuxed = true;\n      const audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n      for (const mediaGroup in mediaGroups.AUDIO) {\n        for (const label in mediaGroups.AUDIO[mediaGroup]) {\n          const properties = mediaGroups.AUDIO[mediaGroup][label];\n          if (!properties.uri) {\n            defaultDemuxed = false;\n          }\n        }\n      }\n      if (defaultDemuxed) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-demuxed'\n        });\n      }\n      if (Object.keys(mediaGroups.SUBTITLES).length) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-webvtt'\n        });\n      }\n      if (Vhs$1.Playlist.isAes(media)) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-aes'\n        });\n      }\n      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-alternate-audio'\n        });\n      }\n      if (this.useCueTags_) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-playlist-cue-tags'\n        });\n      }\n    }\n    shouldSwitchToMedia_(nextPlaylist) {\n      const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;\n      const currentTime = this.tech_.currentTime();\n      const bufferLowWaterLine = this.bufferLowWaterLine();\n      const bufferHighWaterLine = this.bufferHighWaterLine();\n      const buffered = this.tech_.buffered();\n      return shouldSwitchToMedia({\n        buffered,\n        currentTime,\n        currentPlaylist,\n        nextPlaylist,\n        bufferLowWaterLine,\n        bufferHighWaterLine,\n        duration: this.duration(),\n        bufferBasedABR: this.bufferBasedABR,\n        log: this.logger_\n      });\n    }\n    /**\n     * Register event handlers on the segment loaders. A helper function\n     * for construction time.\n     *\n     * @private\n     */\n\n    setupSegmentLoaderListeners_() {\n      this.mainSegmentLoader_.on('bandwidthupdate', () => {\n        // Whether or not buffer based ABR or another ABR is used, on a bandwidth change it's\n        // useful to check to see if a rendition switch should be made.\n        this.checkABR_('bandwidthupdate');\n        this.tech_.trigger('bandwidthupdate');\n      });\n      this.mainSegmentLoader_.on('timeout', () => {\n        if (this.bufferBasedABR) {\n          // If a rendition change is needed, then it would've be done on `bandwidthupdate`.\n          // Here the only consideration is that for buffer based ABR there's no guarantee\n          // of an immediate switch (since the bandwidth is averaged with a timeout\n          // bandwidth value of 1), so force a load on the segment loader to keep it going.\n          this.mainSegmentLoader_.load();\n        }\n      }); // `progress` events are not reliable enough of a bandwidth measure to trigger buffer\n      // based ABR.\n\n      if (!this.bufferBasedABR) {\n        this.mainSegmentLoader_.on('progress', () => {\n          this.trigger('progress');\n        });\n      }\n      this.mainSegmentLoader_.on('error', () => {\n        const error = this.mainSegmentLoader_.error();\n        this.excludePlaylist({\n          playlistToExclude: error.playlist,\n          error\n        });\n      });\n      this.mainSegmentLoader_.on('appenderror', () => {\n        this.error = this.mainSegmentLoader_.error_;\n        this.trigger('error');\n      });\n      this.mainSegmentLoader_.on('syncinfoupdate', () => {\n        this.onSyncInfoUpdate_();\n      });\n      this.mainSegmentLoader_.on('timestampoffset', () => {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-timestamp-offset'\n        });\n      });\n      this.audioSegmentLoader_.on('syncinfoupdate', () => {\n        this.onSyncInfoUpdate_();\n      });\n      this.audioSegmentLoader_.on('appenderror', () => {\n        this.error = this.audioSegmentLoader_.error_;\n        this.trigger('error');\n      });\n      this.mainSegmentLoader_.on('ended', () => {\n        this.logger_('main segment loader ended');\n        this.onEndOfStream();\n      });\n      this.mainSegmentLoader_.on('earlyabort', event => {\n        // never try to early abort with the new ABR algorithm\n        if (this.bufferBasedABR) {\n          return;\n        }\n        this.delegateLoaders_('all', ['abort']);\n        this.excludePlaylist({\n          error: {\n            message: 'Aborted early because there isn\\'t enough bandwidth to complete ' + 'the request without rebuffering.'\n          },\n          playlistExclusionDuration: ABORT_EARLY_EXCLUSION_SECONDS\n        });\n      });\n      const updateCodecs = () => {\n        if (!this.sourceUpdater_.hasCreatedSourceBuffers()) {\n          return this.tryToCreateSourceBuffers_();\n        }\n        const codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n        if (!codecs) {\n          return;\n        }\n        this.sourceUpdater_.addOrChangeSourceBuffers(codecs);\n      };\n      this.mainSegmentLoader_.on('trackinfo', updateCodecs);\n      this.audioSegmentLoader_.on('trackinfo', updateCodecs);\n      this.mainSegmentLoader_.on('fmp4', () => {\n        if (!this.triggeredFmp4Usage) {\n          this.tech_.trigger({\n            type: 'usage',\n            name: 'vhs-fmp4'\n          });\n          this.triggeredFmp4Usage = true;\n        }\n      });\n      this.audioSegmentLoader_.on('fmp4', () => {\n        if (!this.triggeredFmp4Usage) {\n          this.tech_.trigger({\n            type: 'usage',\n            name: 'vhs-fmp4'\n          });\n          this.triggeredFmp4Usage = true;\n        }\n      });\n      this.audioSegmentLoader_.on('ended', () => {\n        this.logger_('audioSegmentLoader ended');\n        this.onEndOfStream();\n      });\n    }\n    mediaSecondsLoaded_() {\n      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n    }\n    /**\n     * Call load on our SegmentLoaders\n     */\n\n    load() {\n      this.mainSegmentLoader_.load();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.load();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.load();\n      }\n    }\n    /**\n     * Re-tune playback quality level for the current player\n     * conditions. This method will perform destructive actions like removing\n     * already buffered content in order to readjust the currently active\n     * playlist quickly. This is good for manual quality changes\n     *\n     * @private\n     */\n\n    fastQualityChange_(media = this.selectPlaylist()) {\n      if (media === this.mainPlaylistLoader_.media()) {\n        this.logger_('skipping fastQualityChange because new media is same as old');\n        return;\n      }\n      this.switchMedia_(media, 'fast-quality'); // Delete all buffered data to allow an immediate quality switch, then seek to give\n      // the browser a kick to remove any cached frames from the previous rendtion (.04 seconds\n      // ahead is roughly the minimum that will accomplish this across a variety of content\n      // in IE and Edge, but seeking in place is sufficient on all other browsers)\n      // Edge/IE bug: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14600375/\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=651904\n\n      this.mainSegmentLoader_.resetEverything(() => {\n        // Since this is not a typical seek, we avoid the seekTo method which can cause segments\n        // from the previously enabled rendition to load before the new playlist has finished loading\n        if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {\n          this.tech_.setCurrentTime(this.tech_.currentTime() + 0.04);\n        } else {\n          this.tech_.setCurrentTime(this.tech_.currentTime());\n        }\n      }); // don't need to reset audio as it is reset when media changes\n    }\n    /**\n     * Begin playback.\n     */\n\n    play() {\n      if (this.setupFirstPlay()) {\n        return;\n      }\n      if (this.tech_.ended()) {\n        this.tech_.setCurrentTime(0);\n      }\n      if (this.hasPlayed_) {\n        this.load();\n      }\n      const seekable = this.tech_.seekable(); // if the viewer has paused and we fell out of the live window,\n      // seek forward to the live point\n\n      if (this.tech_.duration() === Infinity) {\n        if (this.tech_.currentTime() < seekable.start(0)) {\n          return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n        }\n      }\n    }\n    /**\n     * Seek to the latest media position if this is a live video and the\n     * player and video are loaded and initialized.\n     */\n\n    setupFirstPlay() {\n      const media = this.mainPlaylistLoader_.media(); // Check that everything is ready to begin buffering for the first call to play\n      //  If 1) there is no active media\n      //     2) the player is paused\n      //     3) the first play has already been setup\n      // then exit early\n\n      if (!media || this.tech_.paused() || this.hasPlayed_) {\n        return false;\n      } // when the video is a live stream\n\n      if (!media.endList) {\n        const seekable = this.seekable();\n        if (!seekable.length) {\n          // without a seekable range, the player cannot seek to begin buffering at the live\n          // point\n          return false;\n        }\n        if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {\n          // IE11 throws an InvalidStateError if you try to set currentTime while the\n          // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n          this.tech_.one('loadedmetadata', () => {\n            this.trigger('firstplay');\n            this.tech_.setCurrentTime(seekable.end(0));\n            this.hasPlayed_ = true;\n          });\n          return false;\n        } // trigger firstplay to inform the source handler to ignore the next seek event\n\n        this.trigger('firstplay'); // seek to the live point\n\n        this.tech_.setCurrentTime(seekable.end(0));\n      }\n      this.hasPlayed_ = true; // we can begin loading now that everything is ready\n\n      this.load();\n      return true;\n    }\n    /**\n     * handle the sourceopen event on the MediaSource\n     *\n     * @private\n     */\n\n    handleSourceOpen_() {\n      // Only attempt to create the source buffer if none already exist.\n      // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n      // after `endOfStream` has been called (in response to a seek for instance)\n      this.tryToCreateSourceBuffers_(); // if autoplay is enabled, begin playback. This is duplicative of\n      // code in video.js but is required because play() must be invoked\n      // *after* the media source has opened.\n\n      if (this.tech_.autoplay()) {\n        const playPromise = this.tech_.play(); // Catch/silence error when a pause interrupts a play request\n        // on browsers which return a promise\n\n        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n          playPromise.then(null, e => {});\n        }\n      }\n      this.trigger('sourceopen');\n    }\n    /**\n     * handle the sourceended event on the MediaSource\n     *\n     * @private\n     */\n\n    handleSourceEnded_() {\n      if (!this.inbandTextTracks_.metadataTrack_) {\n        return;\n      }\n      const cues = this.inbandTextTracks_.metadataTrack_.cues;\n      if (!cues || !cues.length) {\n        return;\n      }\n      const duration = this.duration();\n      cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === Infinity ? Number.MAX_VALUE : duration;\n    }\n    /**\n     * handle the durationchange event on the MediaSource\n     *\n     * @private\n     */\n\n    handleDurationChange_() {\n      this.tech_.trigger('durationchange');\n    }\n    /**\n     * Calls endOfStream on the media source when all active stream types have called\n     * endOfStream\n     *\n     * @param {string} streamType\n     *        Stream type of the segment loader that called endOfStream\n     * @private\n     */\n\n    onEndOfStream() {\n      let isEndOfStream = this.mainSegmentLoader_.ended_;\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_(); // if the audio playlist loader exists, then alternate audio is active\n\n        if (!mainMediaInfo || mainMediaInfo.hasVideo) {\n          // if we do not know if the main segment loader contains video yet or if we\n          // definitively know the main segment loader contains video, then we need to wait\n          // for both main and audio segment loaders to call endOfStream\n          isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n        } else {\n          // otherwise just rely on the audio loader\n          isEndOfStream = this.audioSegmentLoader_.ended_;\n        }\n      }\n      if (!isEndOfStream) {\n        return;\n      }\n      this.stopABRTimer_();\n      this.sourceUpdater_.endOfStream();\n    }\n    /**\n     * Check if a playlist has stopped being updated\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist has stopped being updated or not\n     */\n\n    stuckAtPlaylistEnd_(playlist) {\n      const seekable = this.seekable();\n      if (!seekable.length) {\n        // playlist doesn't have enough information to determine whether we are stuck\n        return false;\n      }\n      const expired = this.syncController_.getExpiredTime(playlist, this.duration());\n      if (expired === null) {\n        return false;\n      } // does not use the safe live end to calculate playlist end, since we\n      // don't want to say we are stuck while there is still content\n\n      const absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);\n      const currentTime = this.tech_.currentTime();\n      const buffered = this.tech_.buffered();\n      if (!buffered.length) {\n        // return true if the playhead reached the absolute end of the playlist\n        return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;\n      }\n      const bufferedEnd = buffered.end(buffered.length - 1); // return true if there is too little buffer left and buffer has reached absolute\n      // end of playlist\n\n      return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;\n    }\n    /**\n     * Exclude a playlist for a set amount of time, making it unavailable for selection by\n     * the rendition selection algorithm, then force a new playlist (rendition) selection.\n     *\n     * @param {Object=} playlistToExclude\n     *                  the playlist to exclude, defaults to the currently selected playlist\n     * @param {Object=} error\n     *                  an optional error\n     * @param {number=} playlistExclusionDuration\n     *                  an optional number of seconds to exclude the playlist\n     */\n\n    excludePlaylist({\n      playlistToExclude = this.mainPlaylistLoader_.media(),\n      error = {},\n      playlistExclusionDuration\n    }) {\n      // If the `error` was generated by the playlist loader, it will contain\n      // the playlist we were trying to load (but failed) and that should be\n      // excluded instead of the currently selected playlist which is likely\n      // out-of-date in this scenario\n      playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();\n      playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration; // If there is no current playlist, then an error occurred while we were\n      // trying to load the main OR while we were disposing of the tech\n\n      if (!playlistToExclude) {\n        this.error = error;\n        if (this.mediaSource.readyState !== 'open') {\n          this.trigger('error');\n        } else {\n          this.sourceUpdater_.endOfStream('network');\n        }\n        return;\n      }\n      playlistToExclude.playlistErrors_++;\n      const playlists = this.mainPlaylistLoader_.main.playlists;\n      const enabledPlaylists = playlists.filter(isEnabled);\n      const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude; // Don't exclude the only playlist unless it was excluded\n      // forever\n\n      if (playlists.length === 1 && playlistExclusionDuration !== Infinity) {\n        videojs.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. ` + 'Trying again since it is the only playlist.');\n        this.tech_.trigger('retryplaylist'); // if this is a final rendition, we should delay\n\n        return this.mainPlaylistLoader_.load(isFinalRendition);\n      }\n      if (isFinalRendition) {\n        // Since we're on the final non-excluded playlist, and we're about to exclude\n        // it, instead of erring the player or retrying this playlist, clear out the current\n        // exclusion list. This allows other playlists to be attempted in case any have been\n        // fixed.\n        let reincluded = false;\n        playlists.forEach(playlist => {\n          // skip current playlist which is about to be excluded\n          if (playlist === playlistToExclude) {\n            return;\n          }\n          const excludeUntil = playlist.excludeUntil; // a playlist cannot be reincluded if it wasn't excluded to begin with.\n\n          if (typeof excludeUntil !== 'undefined' && excludeUntil !== Infinity) {\n            reincluded = true;\n            delete playlist.excludeUntil;\n          }\n        });\n        if (reincluded) {\n          videojs.log.warn('Removing other playlists from the exclusion list because the last ' + 'rendition is about to be excluded.'); // Technically we are retrying a playlist, in that we are simply retrying a previous\n          // playlist. This is needed for users relying on the retryplaylist event to catch a\n          // case where the player might be stuck and looping through \"dead\" playlists.\n\n          this.tech_.trigger('retryplaylist');\n        }\n      } // Exclude this playlist\n\n      let excludeUntil;\n      if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) {\n        excludeUntil = Infinity;\n      } else {\n        excludeUntil = Date.now() + playlistExclusionDuration * 1000;\n      }\n      playlistToExclude.excludeUntil = excludeUntil;\n      if (error.reason) {\n        playlistToExclude.lastExcludeReason_ = error.reason;\n      }\n      this.tech_.trigger('excludeplaylist');\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-rendition-excluded'\n      }); // TODO: only load a new playlist if we're excluding the current playlist\n      // If this function was called with a playlist that's not the current active playlist\n      // (e.g., media().id !== playlistToExclude.id),\n      // then a new playlist should not be selected and loaded, as there's nothing wrong with the current playlist.\n\n      const nextPlaylist = this.selectPlaylist();\n      if (!nextPlaylist) {\n        this.error = 'Playback cannot continue. No available working or supported playlists.';\n        this.trigger('error');\n        return;\n      }\n      const logFn = error.internal ? this.logger_ : videojs.log.warn;\n      const errorMessage = error.message ? ' ' + error.message : '';\n      logFn(`${error.internal ? 'Internal problem' : 'Problem'} encountered with playlist ${playlistToExclude.id}.` + `${errorMessage} Switching to playlist ${nextPlaylist.id}.`); // if audio group changed reset audio loaders\n\n      if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) {\n        this.delegateLoaders_('audio', ['abort', 'pause']);\n      } // if subtitle group changed reset subtitle loaders\n\n      if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) {\n        this.delegateLoaders_('subtitle', ['abort', 'pause']);\n      }\n      this.delegateLoaders_('main', ['abort', 'pause']);\n      const delayDuration = nextPlaylist.targetDuration / 2 * 1000 || 5 * 1000;\n      const shouldDelay = typeof nextPlaylist.lastRequest === 'number' && Date.now() - nextPlaylist.lastRequest <= delayDuration; // delay if it's a final rendition or if the last refresh is sooner than half targetDuration\n\n      return this.switchMedia_(nextPlaylist, 'exclude', isFinalRendition || shouldDelay);\n    }\n    /**\n     * Pause all segment/playlist loaders\n     */\n\n    pauseLoading() {\n      this.delegateLoaders_('all', ['abort', 'pause']);\n      this.stopABRTimer_();\n    }\n    /**\n     * Call a set of functions in order on playlist loaders, segment loaders,\n     * or both types of loaders.\n     *\n     * @param {string} filter\n     *        Filter loaders that should call fnNames using a string. Can be:\n     *        * all - run on all loaders\n     *        * audio - run on all audio loaders\n     *        * subtitle - run on all subtitle loaders\n     *        * main - run on the main loaders\n     *\n     * @param {Array|string} fnNames\n     *        A string or array of function names to call.\n     */\n\n    delegateLoaders_(filter, fnNames) {\n      const loaders = [];\n      const dontFilterPlaylist = filter === 'all';\n      if (dontFilterPlaylist || filter === 'main') {\n        loaders.push(this.mainPlaylistLoader_);\n      }\n      const mediaTypes = [];\n      if (dontFilterPlaylist || filter === 'audio') {\n        mediaTypes.push('AUDIO');\n      }\n      if (dontFilterPlaylist || filter === 'subtitle') {\n        mediaTypes.push('CLOSED-CAPTIONS');\n        mediaTypes.push('SUBTITLES');\n      }\n      mediaTypes.forEach(mediaType => {\n        const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;\n        if (loader) {\n          loaders.push(loader);\n        }\n      });\n      ['main', 'audio', 'subtitle'].forEach(name => {\n        const loader = this[`${name}SegmentLoader_`];\n        if (loader && (filter === name || filter === 'all')) {\n          loaders.push(loader);\n        }\n      });\n      loaders.forEach(loader => fnNames.forEach(fnName => {\n        if (typeof loader[fnName] === 'function') {\n          loader[fnName]();\n        }\n      }));\n    }\n    /**\n     * set the current time on all segment loaders\n     *\n     * @param {TimeRange} currentTime the current time to set\n     * @return {TimeRange} the current time\n     */\n\n    setCurrentTime(currentTime) {\n      const buffered = findRange(this.tech_.buffered(), currentTime);\n      if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) {\n        // return immediately if the metadata is not ready yet\n        return 0;\n      } // it's clearly an edge-case but don't thrown an error if asked to\n      // seek within an empty playlist\n\n      if (!this.mainPlaylistLoader_.media().segments) {\n        return 0;\n      } // if the seek location is already buffered, continue buffering as usual\n\n      if (buffered && buffered.length) {\n        return currentTime;\n      } // cancel outstanding requests so we begin buffering at the new\n      // location\n\n      this.mainSegmentLoader_.resetEverything();\n      this.mainSegmentLoader_.abort();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.resetEverything();\n        this.audioSegmentLoader_.abort();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.resetEverything();\n        this.subtitleSegmentLoader_.abort();\n      } // start segment loader loading in case they are paused\n\n      this.load();\n    }\n    /**\n     * get the current duration\n     *\n     * @return {TimeRange} the duration\n     */\n\n    duration() {\n      if (!this.mainPlaylistLoader_) {\n        return 0;\n      }\n      const media = this.mainPlaylistLoader_.media();\n      if (!media) {\n        // no playlists loaded yet, so can't determine a duration\n        return 0;\n      } // Don't rely on the media source for duration in the case of a live playlist since\n      // setting the native MediaSource's duration to infinity ends up with consequences to\n      // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n      //\n      // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n      // however, few browsers have support for setLiveSeekableRange()\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n      //\n      // Until a time when the duration of the media source can be set to infinity, and a\n      // seekable range specified across browsers, just return Infinity.\n\n      if (!media.endList) {\n        return Infinity;\n      } // Since this is a VOD video, it is safe to rely on the media source's duration (if\n      // available). If it's not available, fall back to a playlist-calculated estimate.\n\n      if (this.mediaSource) {\n        return this.mediaSource.duration;\n      }\n      return Vhs$1.Playlist.duration(media);\n    }\n    /**\n     * check the seekable range\n     *\n     * @return {TimeRange} the seekable range\n     */\n\n    seekable() {\n      return this.seekable_;\n    }\n    onSyncInfoUpdate_() {\n      let audioSeekable; // TODO check for creation of both source buffers before updating seekable\n      //\n      // A fix was made to this function where a check for\n      // this.sourceUpdater_.hasCreatedSourceBuffers\n      // was added to ensure that both source buffers were created before seekable was\n      // updated. However, it originally had a bug where it was checking for a true and\n      // returning early instead of checking for false. Setting it to check for false to\n      // return early though created other issues. A call to play() would check for seekable\n      // end without verifying that a seekable range was present. In addition, even checking\n      // for that didn't solve some issues, as handleFirstPlay is sometimes worked around\n      // due to a media update calling load on the segment loaders, skipping a seek to live,\n      // thereby starting live streams at the beginning of the stream rather than at the end.\n      //\n      // This conditional should be fixed to wait for the creation of two source buffers at\n      // the same time as the other sections of code are fixed to properly seek to live and\n      // not throw an error due to checking for a seekable end when no seekable range exists.\n      //\n      // For now, fall back to the older behavior, with the understanding that the seekable\n      // range may not be completely correct, leading to a suboptimal initial live point.\n\n      if (!this.mainPlaylistLoader_) {\n        return;\n      }\n      let media = this.mainPlaylistLoader_.media();\n      if (!media) {\n        return;\n      }\n      let expired = this.syncController_.getExpiredTime(media, this.duration());\n      if (expired === null) {\n        // not enough information to update seekable\n        return;\n      }\n      const main = this.mainPlaylistLoader_.main;\n      const mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));\n      if (mainSeekable.length === 0) {\n        return;\n      }\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n        expired = this.syncController_.getExpiredTime(media, this.duration());\n        if (expired === null) {\n          return;\n        }\n        audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));\n        if (audioSeekable.length === 0) {\n          return;\n        }\n      }\n      let oldEnd;\n      let oldStart;\n      if (this.seekable_ && this.seekable_.length) {\n        oldEnd = this.seekable_.end(0);\n        oldStart = this.seekable_.start(0);\n      }\n      if (!audioSeekable) {\n        // seekable has been calculated based on buffering video data so it\n        // can be returned directly\n        this.seekable_ = mainSeekable;\n      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n        // seekables are pretty far off, rely on main\n        this.seekable_ = mainSeekable;\n      } else {\n        this.seekable_ = createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n      } // seekable is the same as last time\n\n      if (this.seekable_ && this.seekable_.length) {\n        if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {\n          return;\n        }\n      }\n      this.logger_(`seekable updated [${printableRange(this.seekable_)}]`);\n      this.tech_.trigger('seekablechanged');\n    }\n    /**\n     * Update the player duration\n     */\n\n    updateDuration(isLive) {\n      if (this.updateDuration_) {\n        this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n        this.updateDuration_ = null;\n      }\n      if (this.mediaSource.readyState !== 'open') {\n        this.updateDuration_ = this.updateDuration.bind(this, isLive);\n        this.mediaSource.addEventListener('sourceopen', this.updateDuration_);\n        return;\n      }\n      if (isLive) {\n        const seekable = this.seekable();\n        if (!seekable.length) {\n          return;\n        } // Even in the case of a live playlist, the native MediaSource's duration should not\n        // be set to Infinity (even though this would be expected for a live playlist), since\n        // setting the native MediaSource's duration to infinity ends up with consequences to\n        // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n        //\n        // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n        // however, few browsers have support for setLiveSeekableRange()\n        // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n        //\n        // Until a time when the duration of the media source can be set to infinity, and a\n        // seekable range specified across browsers, the duration should be greater than or\n        // equal to the last possible seekable value.\n        // MediaSource duration starts as NaN\n        // It is possible (and probable) that this case will never be reached for many\n        // sources, since the MediaSource reports duration as the highest value without\n        // accounting for timestamp offset. For example, if the timestamp offset is -100 and\n        // we buffered times 0 to 100 with real times of 100 to 200, even though current\n        // time will be between 0 and 100, the native media source may report the duration\n        // as 200. However, since we report duration separate from the media source (as\n        // Infinity), and as long as the native media source duration value is greater than\n        // our reported seekable range, seeks will work as expected. The large number as\n        // duration for live is actually a strategy used by some players to work around the\n        // issue of live seekable ranges cited above.\n\n        if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) {\n          this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));\n        }\n        return;\n      }\n      const buffered = this.tech_.buffered();\n      let duration = Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());\n      if (buffered.length > 0) {\n        duration = Math.max(duration, buffered.end(buffered.length - 1));\n      }\n      if (this.mediaSource.duration !== duration) {\n        this.sourceUpdater_.setDuration(duration);\n      }\n    }\n    /**\n     * dispose of the PlaylistController and everything\n     * that it controls\n     */\n\n    dispose() {\n      this.trigger('dispose');\n      this.decrypter_.terminate();\n      this.mainPlaylistLoader_.dispose();\n      this.mainSegmentLoader_.dispose();\n      if (this.loadOnPlay_) {\n        this.tech_.off('play', this.loadOnPlay_);\n      }\n      ['AUDIO', 'SUBTITLES'].forEach(type => {\n        const groups = this.mediaTypes_[type].groups;\n        for (const id in groups) {\n          groups[id].forEach(group => {\n            if (group.playlistLoader) {\n              group.playlistLoader.dispose();\n            }\n          });\n        }\n      });\n      this.audioSegmentLoader_.dispose();\n      this.subtitleSegmentLoader_.dispose();\n      this.sourceUpdater_.dispose();\n      this.timelineChangeController_.dispose();\n      this.stopABRTimer_();\n      if (this.updateDuration_) {\n        this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n      }\n      this.mediaSource.removeEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n      this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen_);\n      this.mediaSource.removeEventListener('sourceended', this.handleSourceEnded_);\n      this.off();\n    }\n    /**\n     * return the main playlist object if we have one\n     *\n     * @return {Object} the main playlist object that we parsed\n     */\n\n    main() {\n      return this.mainPlaylistLoader_.main;\n    }\n    /**\n     * return the currently selected playlist\n     *\n     * @return {Object} the currently selected playlist object that we parsed\n     */\n\n    media() {\n      // playlist loader will not return media if it has not been fully loaded\n      return this.mainPlaylistLoader_.media() || this.initialMedia_;\n    }\n    areMediaTypesKnown_() {\n      const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n      const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_(); // if we are not using an audio loader, then we have audio media info\n      // otherwise check on the segment loader.\n\n      const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_(); // one or both loaders has not loaded sufficently to get codecs\n\n      if (!hasMainMediaInfo || !hasAudioMediaInfo) {\n        return false;\n      }\n      return true;\n    }\n    getCodecsOrExclude_() {\n      const media = {\n        main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},\n        audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}\n      }; // set \"main\" media equal to video\n\n      media.video = media.main;\n      const playlistCodecs = codecsForPlaylist(this.main(), this.media());\n      const codecs = {};\n      const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n      if (media.main.hasVideo) {\n        codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;\n      }\n      if (media.main.isMuxed) {\n        codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC}`;\n      }\n      if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {\n        codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC; // set audio isFmp4 so we use the correct \"supports\" function below\n\n        media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;\n      } // no codecs, no playback.\n\n      if (!codecs.audio && !codecs.video) {\n        this.excludePlaylist({\n          playlistToExclude: this.media(),\n          error: {\n            message: 'Could not determine codecs for playlist.'\n          },\n          playlistExclusionDuration: Infinity\n        });\n        return;\n      } // fmp4 relies on browser support, while ts relies on muxer support\n\n      const supportFunction = (isFmp4, codec) => isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);\n      const unsupportedCodecs = {};\n      let unsupportedAudio;\n      ['video', 'audio'].forEach(function (type) {\n        if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {\n          const supporter = media[type].isFmp4 ? 'browser' : 'muxer';\n          unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];\n          unsupportedCodecs[supporter].push(codecs[type]);\n          if (type === 'audio') {\n            unsupportedAudio = supporter;\n          }\n        }\n      });\n      if (usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {\n        const audioGroup = this.media().attributes.AUDIO;\n        this.main().playlists.forEach(variant => {\n          const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;\n          if (variantAudioGroup === audioGroup && variant !== this.media()) {\n            variant.excludeUntil = Infinity;\n          }\n        });\n        this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): \"${codecs.audio}\"`);\n      } // if we have any unsupported codecs exclude this playlist.\n\n      if (Object.keys(unsupportedCodecs).length) {\n        const message = Object.keys(unsupportedCodecs).reduce((acc, supporter) => {\n          if (acc) {\n            acc += ', ';\n          }\n          acc += `${supporter} does not support codec(s): \"${unsupportedCodecs[supporter].join(',')}\"`;\n          return acc;\n        }, '') + '.';\n        this.excludePlaylist({\n          playlistToExclude: this.media(),\n          error: {\n            internal: true,\n            message\n          },\n          playlistExclusionDuration: Infinity\n        });\n        return;\n      } // check if codec switching is happening\n\n      if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {\n        const switchMessages = [];\n        ['video', 'audio'].forEach(type => {\n          const newCodec = (parseCodecs(this.sourceUpdater_.codecs[type] || '')[0] || {}).type;\n          const oldCodec = (parseCodecs(codecs[type] || '')[0] || {}).type;\n          if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {\n            switchMessages.push(`\"${this.sourceUpdater_.codecs[type]}\" -> \"${codecs[type]}\"`);\n          }\n        });\n        if (switchMessages.length) {\n          this.excludePlaylist({\n            playlistToExclude: this.media(),\n            error: {\n              message: `Codec switching not supported: ${switchMessages.join(', ')}.`,\n              internal: true\n            },\n            playlistExclusionDuration: Infinity\n          });\n          return;\n        }\n      } // TODO: when using the muxer shouldn't we just return\n      // the codecs that the muxer outputs?\n\n      return codecs;\n    }\n    /**\n     * Create source buffers and exlude any incompatible renditions.\n     *\n     * @private\n     */\n\n    tryToCreateSourceBuffers_() {\n      // media source is not ready yet or sourceBuffers are already\n      // created.\n      if (this.mediaSource.readyState !== 'open' || this.sourceUpdater_.hasCreatedSourceBuffers()) {\n        return;\n      }\n      if (!this.areMediaTypesKnown_()) {\n        return;\n      }\n      const codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n      if (!codecs) {\n        return;\n      }\n      this.sourceUpdater_.createSourceBuffers(codecs);\n      const codecString = [codecs.video, codecs.audio].filter(Boolean).join(',');\n      this.excludeIncompatibleVariants_(codecString);\n    }\n    /**\n     * Excludes playlists with codecs that are unsupported by the muxer and browser.\n     */\n\n    excludeUnsupportedVariants_() {\n      const playlists = this.main().playlists;\n      const ids = []; // TODO: why don't we have a property to loop through all\n      // playlist? Why did we ever mix indexes and keys?\n\n      Object.keys(playlists).forEach(key => {\n        const variant = playlists[key]; // check if we already processed this playlist.\n\n        if (ids.indexOf(variant.id) !== -1) {\n          return;\n        }\n        ids.push(variant.id);\n        const codecs = codecsForPlaylist(this.main, variant);\n        const unsupported = [];\n        if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {\n          unsupported.push(`audio codec ${codecs.audio}`);\n        }\n        if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {\n          unsupported.push(`video codec ${codecs.video}`);\n        }\n        if (codecs.text && codecs.text === 'stpp.ttml.im1t') {\n          unsupported.push(`text codec ${codecs.text}`);\n        }\n        if (unsupported.length) {\n          variant.excludeUntil = Infinity;\n          this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(', ')}`);\n        }\n      });\n    }\n    /**\n     * Exclude playlists that are known to be codec or\n     * stream-incompatible with the SourceBuffer configuration. For\n     * instance, Media Source Extensions would cause the video element to\n     * stall waiting for video data if you switched from a variant with\n     * video and audio to an audio-only one.\n     *\n     * @param {Object} media a media playlist compatible with the current\n     * set of SourceBuffers. Variants in the current main playlist that\n     * do not appear to have compatible codec or stream configurations\n     * will be excluded from the default playlist selection algorithm\n     * indefinitely.\n     * @private\n     */\n\n    excludeIncompatibleVariants_(codecString) {\n      const ids = [];\n      const playlists = this.main().playlists;\n      const codecs = unwrapCodecList(parseCodecs(codecString));\n      const codecCount_ = codecCount(codecs);\n      const videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;\n      const audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;\n      Object.keys(playlists).forEach(key => {\n        const variant = playlists[key]; // check if we already processed this playlist.\n        // or it if it is already excluded forever.\n\n        if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {\n          return;\n        }\n        ids.push(variant.id);\n        const exclusionReasons = []; // get codecs from the playlist for this variant\n\n        const variantCodecs = codecsForPlaylist(this.mainPlaylistLoader_.main, variant);\n        const variantCodecCount = codecCount(variantCodecs); // if no codecs are listed, we cannot determine that this\n        // variant is incompatible. Wait for mux.js to probe\n\n        if (!variantCodecs.audio && !variantCodecs.video) {\n          return;\n        } // TODO: we can support this by removing the\n        // old media source and creating a new one, but it will take some work.\n        // The number of streams cannot change\n\n        if (variantCodecCount !== codecCount_) {\n          exclusionReasons.push(`codec count \"${variantCodecCount}\" !== \"${codecCount_}\"`);\n        } // only exclude playlists by codec change, if codecs cannot switch\n        // during playback.\n\n        if (!this.sourceUpdater_.canChangeType()) {\n          const variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;\n          const variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null; // the video codec cannot change\n\n          if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {\n            exclusionReasons.push(`video codec \"${variantVideoDetails.type}\" !== \"${videoDetails.type}\"`);\n          } // the audio codec cannot change\n\n          if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {\n            exclusionReasons.push(`audio codec \"${variantAudioDetails.type}\" !== \"${audioDetails.type}\"`);\n          }\n        }\n        if (exclusionReasons.length) {\n          variant.excludeUntil = Infinity;\n          this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(' && ')}`);\n        }\n      });\n    }\n    updateAdCues_(media) {\n      let offset = 0;\n      const seekable = this.seekable();\n      if (seekable.length) {\n        offset = seekable.start(0);\n      }\n      updateAdCues(media, this.cueTagsTrack_, offset);\n    }\n    /**\n     * Calculates the desired forward buffer length based on current time\n     *\n     * @return {number} Desired forward buffer length in seconds\n     */\n\n    goalBufferLength() {\n      const currentTime = this.tech_.currentTime();\n      const initial = Config.GOAL_BUFFER_LENGTH;\n      const rate = Config.GOAL_BUFFER_LENGTH_RATE;\n      const max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);\n      return Math.min(initial + currentTime * rate, max);\n    }\n    /**\n     * Calculates the desired buffer low water line based on current time\n     *\n     * @return {number} Desired buffer low water line in seconds\n     */\n\n    bufferLowWaterLine() {\n      const currentTime = this.tech_.currentTime();\n      const initial = Config.BUFFER_LOW_WATER_LINE;\n      const rate = Config.BUFFER_LOW_WATER_LINE_RATE;\n      const max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);\n      const newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);\n      return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max);\n    }\n    bufferHighWaterLine() {\n      return Config.BUFFER_HIGH_WATER_LINE;\n    }\n  }\n\n  /**\n   * Returns a function that acts as the Enable/disable playlist function.\n   *\n   * @param {PlaylistLoader} loader - The main playlist loader\n   * @param {string} playlistID - id of the playlist\n   * @param {Function} changePlaylistFn - A function to be called after a\n   * playlist's enabled-state has been changed. Will NOT be called if a\n   * playlist's enabled-state is unchanged\n   * @param {boolean=} enable - Value to set the playlist enabled-state to\n   * or if undefined returns the current enabled-state for the playlist\n   * @return {Function} Function for setting/getting enabled\n   */\n\n  const enableFunction = (loader, playlistID, changePlaylistFn) => enable => {\n    const playlist = loader.main.playlists[playlistID];\n    const incompatible = isIncompatible(playlist);\n    const currentlyEnabled = isEnabled(playlist);\n    if (typeof enable === 'undefined') {\n      return currentlyEnabled;\n    }\n    if (enable) {\n      delete playlist.disabled;\n    } else {\n      playlist.disabled = true;\n    }\n    if (enable !== currentlyEnabled && !incompatible) {\n      // Ensure the outside world knows about our changes\n      changePlaylistFn();\n      if (enable) {\n        loader.trigger('renditionenabled');\n      } else {\n        loader.trigger('renditiondisabled');\n      }\n    }\n    return enable;\n  };\n  /**\n   * The representation object encapsulates the publicly visible information\n   * in a media playlist along with a setter/getter-type function (enabled)\n   * for changing the enabled-state of a particular playlist entry\n   *\n   * @class Representation\n   */\n\n  class Representation {\n    constructor(vhsHandler, playlist, id) {\n      const {\n        playlistController_: pc\n      } = vhsHandler;\n      const qualityChangeFunction = pc.fastQualityChange_.bind(pc); // some playlist attributes are optional\n\n      if (playlist.attributes) {\n        const resolution = playlist.attributes.RESOLUTION;\n        this.width = resolution && resolution.width;\n        this.height = resolution && resolution.height;\n        this.bandwidth = playlist.attributes.BANDWIDTH;\n        this.frameRate = playlist.attributes['FRAME-RATE'];\n      }\n      this.codecs = codecsForPlaylist(pc.main(), playlist);\n      this.playlist = playlist; // The id is simply the ordinality of the media playlist\n      // within the main playlist\n\n      this.id = id; // Partially-apply the enableFunction to create a playlist-\n      // specific variant\n\n      this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);\n    }\n  }\n  /**\n   * A mixin function that adds the `representations` api to an instance\n   * of the VhsHandler class\n   *\n   * @param {VhsHandler} vhsHandler - An instance of VhsHandler to add the\n   * representation API into\n   */\n\n  const renditionSelectionMixin = function (vhsHandler) {\n    // Add a single API-specific function to the VhsHandler instance\n    vhsHandler.representations = () => {\n      const main = vhsHandler.playlistController_.main();\n      const playlists = isAudioOnly(main) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main.playlists;\n      if (!playlists) {\n        return [];\n      }\n      return playlists.filter(media => !isIncompatible(media)).map((e, i) => new Representation(vhsHandler, e, e.id));\n    };\n  };\n\n  /**\n   * @file playback-watcher.js\n   *\n   * Playback starts, and now my watch begins. It shall not end until my death. I shall\n   * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\n   * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\n   * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\n   * my life and honor to the Playback Watch, for this Player and all the Players to come.\n   */\n\n  const timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\n  /**\n   * @class PlaybackWatcher\n   */\n\n  class PlaybackWatcher {\n    /**\n     * Represents an PlaybackWatcher object.\n     *\n     * @class\n     * @param {Object} options an object that includes the tech and settings\n     */\n    constructor(options) {\n      this.playlistController_ = options.playlistController;\n      this.tech_ = options.tech;\n      this.seekable = options.seekable;\n      this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;\n      this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;\n      this.media = options.media;\n      this.consecutiveUpdates = 0;\n      this.lastRecordedTime = null;\n      this.checkCurrentTimeTimeout_ = null;\n      this.logger_ = logger('PlaybackWatcher');\n      this.logger_('initialize');\n      const playHandler = () => this.monitorCurrentTime_();\n      const canPlayHandler = () => this.monitorCurrentTime_();\n      const waitingHandler = () => this.techWaiting_();\n      const cancelTimerHandler = () => this.resetTimeUpdate_();\n      const pc = this.playlistController_;\n      const loaderTypes = ['main', 'subtitle', 'audio'];\n      const loaderChecks = {};\n      loaderTypes.forEach(type => {\n        loaderChecks[type] = {\n          reset: () => this.resetSegmentDownloads_(type),\n          updateend: () => this.checkSegmentDownloads_(type)\n        };\n        pc[`${type}SegmentLoader_`].on('appendsdone', loaderChecks[type].updateend); // If a rendition switch happens during a playback stall where the buffer\n        // isn't changing we want to reset. We cannot assume that the new rendition\n        // will also be stalled, until after new appends.\n\n        pc[`${type}SegmentLoader_`].on('playlistupdate', loaderChecks[type].reset); // Playback stalls should not be detected right after seeking.\n        // This prevents one segment playlists (single vtt or single segment content)\n        // from being detected as stalling. As the buffer will not change in those cases, since\n        // the buffer is the entire video duration.\n\n        this.tech_.on(['seeked', 'seeking'], loaderChecks[type].reset);\n      });\n      /**\n       * We check if a seek was into a gap through the following steps:\n       * 1. We get a seeking event and we do not get a seeked event. This means that\n       *    a seek was attempted but not completed.\n       * 2. We run `fixesBadSeeks_` on segment loader appends. This means that we already\n       *    removed everything from our buffer and appended a segment, and should be ready\n       *    to check for gaps.\n       */\n\n      const setSeekingHandlers = fn => {\n        ['main', 'audio'].forEach(type => {\n          pc[`${type}SegmentLoader_`][fn]('appended', this.seekingAppendCheck_);\n        });\n      };\n      this.seekingAppendCheck_ = () => {\n        if (this.fixesBadSeeks_()) {\n          this.consecutiveUpdates = 0;\n          this.lastRecordedTime = this.tech_.currentTime();\n          setSeekingHandlers('off');\n        }\n      };\n      this.clearSeekingAppendCheck_ = () => setSeekingHandlers('off');\n      this.watchForBadSeeking_ = () => {\n        this.clearSeekingAppendCheck_();\n        setSeekingHandlers('on');\n      };\n      this.tech_.on('seeked', this.clearSeekingAppendCheck_);\n      this.tech_.on('seeking', this.watchForBadSeeking_);\n      this.tech_.on('waiting', waitingHandler);\n      this.tech_.on(timerCancelEvents, cancelTimerHandler);\n      this.tech_.on('canplay', canPlayHandler);\n      /*\n        An edge case exists that results in gaps not being skipped when they exist at the beginning of a stream. This case\n        is surfaced in one of two ways:\n         1)  The `waiting` event is fired before the player has buffered content, making it impossible\n            to find or skip the gap. The `waiting` event is followed by a `play` event. On first play\n            we can check if playback is stalled due to a gap, and skip the gap if necessary.\n        2)  A source with a gap at the beginning of the stream is loaded programatically while the player\n            is in a playing state. To catch this case, it's important that our one-time play listener is setup\n            even if the player is in a playing state\n      */\n\n      this.tech_.one('play', playHandler); // Define the dispose function to clean up our events\n\n      this.dispose = () => {\n        this.clearSeekingAppendCheck_();\n        this.logger_('dispose');\n        this.tech_.off('waiting', waitingHandler);\n        this.tech_.off(timerCancelEvents, cancelTimerHandler);\n        this.tech_.off('canplay', canPlayHandler);\n        this.tech_.off('play', playHandler);\n        this.tech_.off('seeking', this.watchForBadSeeking_);\n        this.tech_.off('seeked', this.clearSeekingAppendCheck_);\n        loaderTypes.forEach(type => {\n          pc[`${type}SegmentLoader_`].off('appendsdone', loaderChecks[type].updateend);\n          pc[`${type}SegmentLoader_`].off('playlistupdate', loaderChecks[type].reset);\n          this.tech_.off(['seeked', 'seeking'], loaderChecks[type].reset);\n        });\n        if (this.checkCurrentTimeTimeout_) {\n          window.clearTimeout(this.checkCurrentTimeTimeout_);\n        }\n        this.resetTimeUpdate_();\n      };\n    }\n    /**\n     * Periodically check current time to see if playback stopped\n     *\n     * @private\n     */\n\n    monitorCurrentTime_() {\n      this.checkCurrentTime_();\n      if (this.checkCurrentTimeTimeout_) {\n        window.clearTimeout(this.checkCurrentTimeTimeout_);\n      } // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n\n      this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250);\n    }\n    /**\n     * Reset stalled download stats for a specific type of loader\n     *\n     * @param {string} type\n     *        The segment loader type to check.\n     *\n     * @listens SegmentLoader#playlistupdate\n     * @listens Tech#seeking\n     * @listens Tech#seeked\n     */\n\n    resetSegmentDownloads_(type) {\n      const loader = this.playlistController_[`${type}SegmentLoader_`];\n      if (this[`${type}StalledDownloads_`] > 0) {\n        this.logger_(`resetting possible stalled download count for ${type} loader`);\n      }\n      this[`${type}StalledDownloads_`] = 0;\n      this[`${type}Buffered_`] = loader.buffered_();\n    }\n    /**\n     * Checks on every segment `appendsdone` to see\n     * if segment appends are making progress. If they are not\n     * and we are still downloading bytes. We exclude the playlist.\n     *\n     * @param {string} type\n     *        The segment loader type to check.\n     *\n     * @listens SegmentLoader#appendsdone\n     */\n\n    checkSegmentDownloads_(type) {\n      const pc = this.playlistController_;\n      const loader = pc[`${type}SegmentLoader_`];\n      const buffered = loader.buffered_();\n      const isBufferedDifferent = isRangeDifferent(this[`${type}Buffered_`], buffered);\n      this[`${type}Buffered_`] = buffered; // if another watcher is going to fix the issue or\n      // the buffered value for this loader changed\n      // appends are working\n\n      if (isBufferedDifferent) {\n        this.resetSegmentDownloads_(type);\n        return;\n      }\n      this[`${type}StalledDownloads_`]++;\n      this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {\n        playlistId: loader.playlist_ && loader.playlist_.id,\n        buffered: timeRangesToArray(buffered)\n      }); // after 10 possibly stalled appends with no reset, exclude\n\n      if (this[`${type}StalledDownloads_`] < 10) {\n        return;\n      }\n      this.logger_(`${type} loader stalled download exclusion`);\n      this.resetSegmentDownloads_(type);\n      this.tech_.trigger({\n        type: 'usage',\n        name: `vhs-${type}-download-exclusion`\n      });\n      if (type === 'subtitle') {\n        return;\n      } // TODO: should we exclude audio tracks rather than main tracks\n      // when type is audio?\n\n      pc.excludePlaylist({\n        error: {\n          message: `Excessive ${type} segment downloading detected.`\n        },\n        playlistExclusionDuration: Infinity\n      });\n    }\n    /**\n     * The purpose of this function is to emulate the \"waiting\" event on\n     * browsers that do not emit it when they are waiting for more\n     * data to continue playback\n     *\n     * @private\n     */\n\n    checkCurrentTime_() {\n      if (this.tech_.paused() || this.tech_.seeking()) {\n        return;\n      }\n      const currentTime = this.tech_.currentTime();\n      const buffered = this.tech_.buffered();\n      if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\n        // If current time is at the end of the final buffered region, then any playback\n        // stall is most likely caused by buffering in a low bandwidth environment. The tech\n        // should fire a `waiting` event in this scenario, but due to browser and tech\n        // inconsistencies. Calling `techWaiting_` here allows us to simulate\n        // responding to a native `waiting` event when the tech fails to emit one.\n        return this.techWaiting_();\n      }\n      if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\n        this.consecutiveUpdates++;\n        this.waiting_();\n      } else if (currentTime === this.lastRecordedTime) {\n        this.consecutiveUpdates++;\n      } else {\n        this.consecutiveUpdates = 0;\n        this.lastRecordedTime = currentTime;\n      }\n    }\n    /**\n     * Resets the 'timeupdate' mechanism designed to detect that we are stalled\n     *\n     * @private\n     */\n\n    resetTimeUpdate_() {\n      this.consecutiveUpdates = 0;\n    }\n    /**\n     * Fixes situations where there's a bad seek\n     *\n     * @return {boolean} whether an action was taken to fix the seek\n     * @private\n     */\n\n    fixesBadSeeks_() {\n      const seeking = this.tech_.seeking();\n      if (!seeking) {\n        return false;\n      } // TODO: It's possible that these seekable checks should be moved out of this function\n      // and into a function that runs on seekablechange. It's also possible that we only need\n      // afterSeekableWindow as the buffered check at the bottom is good enough to handle before\n      // seekable range.\n\n      const seekable = this.seekable();\n      const currentTime = this.tech_.currentTime();\n      const isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);\n      let seekTo;\n      if (isAfterSeekableRange) {\n        const seekableEnd = seekable.end(seekable.length - 1); // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\n\n        seekTo = seekableEnd;\n      }\n      if (this.beforeSeekableWindow_(seekable, currentTime)) {\n        const seekableStart = seekable.start(0); // sync to the beginning of the live window\n        // provide a buffer of .1 seconds to handle rounding/imprecise numbers\n\n        seekTo = seekableStart + (\n        // if the playlist is too short and the seekable range is an exact time (can\n        // happen in live with a 3 segment playlist), then don't use a time delta\n        seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);\n      }\n      if (typeof seekTo !== 'undefined') {\n        this.logger_(`Trying to seek outside of seekable at time ${currentTime} with ` + `seekable range ${printableRange(seekable)}. Seeking to ` + `${seekTo}.`);\n        this.tech_.setCurrentTime(seekTo);\n        return true;\n      }\n      const sourceUpdater = this.playlistController_.sourceUpdater_;\n      const buffered = this.tech_.buffered();\n      const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;\n      const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;\n      const media = this.media(); // verify that at least two segment durations or one part duration have been\n      // appended before checking for a gap.\n\n      const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2; // verify that at least two segment durations have been\n      // appended before checking for a gap.\n\n      const bufferedToCheck = [audioBuffered, videoBuffered];\n      for (let i = 0; i < bufferedToCheck.length; i++) {\n        // skip null buffered\n        if (!bufferedToCheck[i]) {\n          continue;\n        }\n        const timeAhead = timeAheadOf(bufferedToCheck[i], currentTime); // if we are less than two video/audio segment durations or one part\n        // duration behind we haven't appended enough to call this a bad seek.\n\n        if (timeAhead < minAppendedDuration) {\n          return false;\n        }\n      }\n      const nextRange = findNextRange(buffered, currentTime); // we have appended enough content, but we don't have anything buffered\n      // to seek over the gap\n\n      if (nextRange.length === 0) {\n        return false;\n      }\n      seekTo = nextRange.start(0) + SAFE_TIME_DELTA;\n      this.logger_(`Buffered region starts (${nextRange.start(0)}) ` + ` just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);\n      this.tech_.setCurrentTime(seekTo);\n      return true;\n    }\n    /**\n     * Handler for situations when we determine the player is waiting.\n     *\n     * @private\n     */\n\n    waiting_() {\n      if (this.techWaiting_()) {\n        return;\n      } // All tech waiting checks failed. Use last resort correction\n\n      const currentTime = this.tech_.currentTime();\n      const buffered = this.tech_.buffered();\n      const currentRange = findRange(buffered, currentTime); // Sometimes the player can stall for unknown reasons within a contiguous buffered\n      // region with no indication that anything is amiss (seen in Firefox). Seeking to\n      // currentTime is usually enough to kickstart the player. This checks that the player\n      // is currently within a buffered region before attempting a corrective seek.\n      // Chrome does not appear to continue `timeupdate` events after a `waiting` event\n      // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\n      // make sure there is ~3 seconds of forward buffer before taking any corrective action\n      // to avoid triggering an `unknownwaiting` event when the network is slow.\n\n      if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\n        this.resetTimeUpdate_();\n        this.tech_.setCurrentTime(currentTime);\n        this.logger_(`Stopped at ${currentTime} while inside a buffered region ` + `[${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume ` + 'playback by seeking to the current time.'); // unknown waiting corrections may be useful for monitoring QoS\n\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-unknown-waiting'\n        });\n        return;\n      }\n    }\n    /**\n     * Handler for situations when the tech fires a `waiting` event\n     *\n     * @return {boolean}\n     *         True if an action (or none) was needed to correct the waiting. False if no\n     *         checks passed\n     * @private\n     */\n\n    techWaiting_() {\n      const seekable = this.seekable();\n      const currentTime = this.tech_.currentTime();\n      if (this.tech_.seeking()) {\n        // Tech is seeking or already waiting on another action, no action needed\n        return true;\n      }\n      if (this.beforeSeekableWindow_(seekable, currentTime)) {\n        const livePoint = seekable.end(seekable.length - 1);\n        this.logger_(`Fell out of live window at time ${currentTime}. Seeking to ` + `live point (seekable end) ${livePoint}`);\n        this.resetTimeUpdate_();\n        this.tech_.setCurrentTime(livePoint); // live window resyncs may be useful for monitoring QoS\n\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-live-resync'\n        });\n        return true;\n      }\n      const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;\n      const buffered = this.tech_.buffered();\n      const videoUnderflow = this.videoUnderflow_({\n        audioBuffered: sourceUpdater.audioBuffered(),\n        videoBuffered: sourceUpdater.videoBuffered(),\n        currentTime\n      });\n      if (videoUnderflow) {\n        // Even though the video underflowed and was stuck in a gap, the audio overplayed\n        // the gap, leading currentTime into a buffered range. Seeking to currentTime\n        // allows the video to catch up to the audio position without losing any audio\n        // (only suffering ~3 seconds of frozen video and a pause in audio playback).\n        this.resetTimeUpdate_();\n        this.tech_.setCurrentTime(currentTime); // video underflow may be useful for monitoring QoS\n\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'vhs-video-underflow'\n        });\n        return true;\n      }\n      const nextRange = findNextRange(buffered, currentTime); // check for gap\n\n      if (nextRange.length > 0) {\n        this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);\n        this.resetTimeUpdate_();\n        this.skipTheGap_(currentTime);\n        return true;\n      } // All checks failed. Returning false to indicate failure to correct waiting\n\n      return false;\n    }\n    afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {\n      if (!seekable.length) {\n        // we can't make a solid case if there's no seekable, default to false\n        return false;\n      }\n      let allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;\n      const isLive = !playlist.endList;\n      if (isLive && allowSeeksWithinUnsafeLiveWindow) {\n        allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;\n      }\n      if (currentTime > allowedEnd) {\n        return true;\n      }\n      return false;\n    }\n    beforeSeekableWindow_(seekable, currentTime) {\n      if (seekable.length &&\n      // can't fall before 0 and 0 seekable start identifies VOD stream\n      seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) {\n        return true;\n      }\n      return false;\n    }\n    videoUnderflow_({\n      videoBuffered,\n      audioBuffered,\n      currentTime\n    }) {\n      // audio only content will not have video underflow :)\n      if (!videoBuffered) {\n        return;\n      }\n      let gap; // find a gap in demuxed content.\n\n      if (videoBuffered.length && audioBuffered.length) {\n        // in Chrome audio will continue to play for ~3s when we run out of video\n        // so we have to check that the video buffer did have some buffer in the\n        // past.\n        const lastVideoRange = findRange(videoBuffered, currentTime - 3);\n        const videoRange = findRange(videoBuffered, currentTime);\n        const audioRange = findRange(audioBuffered, currentTime);\n        if (audioRange.length && !videoRange.length && lastVideoRange.length) {\n          gap = {\n            start: lastVideoRange.end(0),\n            end: audioRange.end(0)\n          };\n        } // find a gap in muxed content.\n      } else {\n        const nextRange = findNextRange(videoBuffered, currentTime); // Even if there is no available next range, there is still a possibility we are\n        // stuck in a gap due to video underflow.\n\n        if (!nextRange.length) {\n          gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);\n        }\n      }\n      if (gap) {\n        this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. ` + `Seeking to current time ${currentTime}`);\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Timer callback. If playback still has not proceeded, then we seek\n     * to the start of the next buffered region.\n     *\n     * @private\n     */\n\n    skipTheGap_(scheduledCurrentTime) {\n      const buffered = this.tech_.buffered();\n      const currentTime = this.tech_.currentTime();\n      const nextRange = findNextRange(buffered, currentTime);\n      this.resetTimeUpdate_();\n      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\n        return;\n      }\n      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0)); // only seek if we still have not played\n\n      this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'vhs-gap-skip'\n      });\n    }\n    gapFromVideoUnderflow_(buffered, currentTime) {\n      // At least in Chrome, if there is a gap in the video buffer, the audio will continue\n      // playing for ~3 seconds after the video gap starts. This is done to account for\n      // video buffer underflow/underrun (note that this is not done when there is audio\n      // buffer underflow/underrun -- in that case the video will stop as soon as it\n      // encounters the gap, as audio stalls are more noticeable/jarring to a user than\n      // video stalls). The player's time will reflect the playthrough of audio, so the\n      // time will appear as if we are in a buffered region, even if we are stuck in a\n      // \"gap.\"\n      //\n      // Example:\n      // video buffer:   0 => 10.1, 10.2 => 20\n      // audio buffer:   0 => 20\n      // overall buffer: 0 => 10.1, 10.2 => 20\n      // current time: 13\n      //\n      // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\n      // however, the audio continued playing until it reached ~3 seconds past the gap\n      // (13 seconds), at which point it stops as well. Since current time is past the\n      // gap, findNextRange will return no ranges.\n      //\n      // To check for this issue, we see if there is a gap that starts somewhere within\n      // a 3 second range (3 seconds +/- 1 second) back from our current time.\n      const gaps = findGaps(buffered);\n      for (let i = 0; i < gaps.length; i++) {\n        const start = gaps.start(i);\n        const end = gaps.end(i); // gap is starts no more than 4 seconds back\n\n        if (currentTime - start < 4 && currentTime - start > 2) {\n          return {\n            start,\n            end\n          };\n        }\n      }\n      return null;\n    }\n  }\n  const defaultOptions = {\n    errorInterval: 30,\n    getSource(next) {\n      const tech = this.tech({\n        IWillNotUseThisInPlugins: true\n      });\n      const sourceObj = tech.currentSource_ || this.currentSource();\n      return next(sourceObj);\n    }\n  };\n  /**\n   * Main entry point for the plugin\n   *\n   * @param {Player} player a reference to a videojs Player instance\n   * @param {Object} [options] an object with plugin options\n   * @private\n   */\n\n  const initPlugin = function (player, options) {\n    let lastCalled = 0;\n    let seekTo = 0;\n    const localOptions = merge(defaultOptions, options);\n    player.ready(() => {\n      player.trigger({\n        type: 'usage',\n        name: 'vhs-error-reload-initialized'\n      });\n    });\n    /**\n     * Player modifications to perform that must wait until `loadedmetadata`\n     * has been triggered\n     *\n     * @private\n     */\n\n    const loadedMetadataHandler = function () {\n      if (seekTo) {\n        player.currentTime(seekTo);\n      }\n    };\n    /**\n     * Set the source on the player element, play, and seek if necessary\n     *\n     * @param {Object} sourceObj An object specifying the source url and mime-type to play\n     * @private\n     */\n\n    const setSource = function (sourceObj) {\n      if (sourceObj === null || sourceObj === undefined) {\n        return;\n      }\n      seekTo = player.duration() !== Infinity && player.currentTime() || 0;\n      player.one('loadedmetadata', loadedMetadataHandler);\n      player.src(sourceObj);\n      player.trigger({\n        type: 'usage',\n        name: 'vhs-error-reload'\n      });\n      player.play();\n    };\n    /**\n     * Attempt to get a source from either the built-in getSource function\n     * or a custom function provided via the options\n     *\n     * @private\n     */\n\n    const errorHandler = function () {\n      // Do not attempt to reload the source if a source-reload occurred before\n      // 'errorInterval' time has elapsed since the last source-reload\n      if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\n        player.trigger({\n          type: 'usage',\n          name: 'vhs-error-reload-canceled'\n        });\n        return;\n      }\n      if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\n        videojs.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\n        return;\n      }\n      lastCalled = Date.now();\n      return localOptions.getSource.call(player, setSource);\n    };\n    /**\n     * Unbind any event handlers that were bound by the plugin\n     *\n     * @private\n     */\n\n    const cleanupEvents = function () {\n      player.off('loadedmetadata', loadedMetadataHandler);\n      player.off('error', errorHandler);\n      player.off('dispose', cleanupEvents);\n    };\n    /**\n     * Cleanup before re-initializing the plugin\n     *\n     * @param {Object} [newOptions] an object with plugin options\n     * @private\n     */\n\n    const reinitPlugin = function (newOptions) {\n      cleanupEvents();\n      initPlugin(player, newOptions);\n    };\n    player.on('error', errorHandler);\n    player.on('dispose', cleanupEvents); // Overwrite the plugin function so that we can correctly cleanup before\n    // initializing the plugin\n\n    player.reloadSourceOnError = reinitPlugin;\n  };\n  /**\n   * Reload the source when an error is detected as long as there\n   * wasn't an error previously within the last 30 seconds\n   *\n   * @param {Object} [options] an object with plugin options\n   */\n\n  const reloadSourceOnError = function (options) {\n    initPlugin(this, options);\n  };\n  var version$4 = \"3.0.0\";\n  var version$3 = \"6.2.0\";\n  var version$2 = \"1.0.1\";\n  var version$1 = \"6.0.0\";\n  var version = \"4.0.1\";\n\n  /**\n   * @file videojs-http-streaming.js\n   *\n   * The main file for the VHS project.\n   * License: https://github.com/videojs/videojs-http-streaming/blob/main/LICENSE\n   */\n  const Vhs = {\n    PlaylistLoader,\n    Playlist,\n    utils,\n    STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,\n    INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,\n    lastBandwidthSelector,\n    movingAverageBandwidthSelector,\n    comparePlaylistBandwidth,\n    comparePlaylistResolution,\n    xhr: xhrFactory()\n  }; // Define getter/setters for config properties\n\n  Object.keys(Config).forEach(prop => {\n    Object.defineProperty(Vhs, prop, {\n      get() {\n        videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);\n        return Config[prop];\n      },\n      set(value) {\n        videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);\n        if (typeof value !== 'number' || value < 0) {\n          videojs.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);\n          return;\n        }\n        Config[prop] = value;\n      }\n    });\n  });\n  const LOCAL_STORAGE_KEY = 'videojs-vhs';\n  /**\n   * Updates the selectedIndex of the QualityLevelList when a mediachange happens in vhs.\n   *\n   * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\n   * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\n   * @function handleVhsMediaChange\n   */\n\n  const handleVhsMediaChange = function (qualityLevels, playlistLoader) {\n    const newPlaylist = playlistLoader.media();\n    let selectedIndex = -1;\n    for (let i = 0; i < qualityLevels.length; i++) {\n      if (qualityLevels[i].id === newPlaylist.id) {\n        selectedIndex = i;\n        break;\n      }\n    }\n    qualityLevels.selectedIndex_ = selectedIndex;\n    qualityLevels.trigger({\n      selectedIndex,\n      type: 'change'\n    });\n  };\n  /**\n   * Adds quality levels to list once playlist metadata is available\n   *\n   * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\n   * @param {Object} vhs Vhs object to listen to for media events.\n   * @function handleVhsLoadedMetadata\n   */\n\n  const handleVhsLoadedMetadata = function (qualityLevels, vhs) {\n    vhs.representations().forEach(rep => {\n      qualityLevels.addQualityLevel(rep);\n    });\n    handleVhsMediaChange(qualityLevels, vhs.playlists);\n  }; // VHS is a source handler, not a tech. Make sure attempts to use it\n  // as one do not cause exceptions.\n\n  Vhs.canPlaySource = function () {\n    return videojs.log.warn('VHS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n  };\n  const emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {\n    if (!keySystemOptions) {\n      return keySystemOptions;\n    }\n    let codecs = {};\n    if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {\n      codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));\n    }\n    if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {\n      codecs.audio = audioPlaylist.attributes.CODECS;\n    }\n    const videoContentType = getMimeForCodec(codecs.video);\n    const audioContentType = getMimeForCodec(codecs.audio); // upsert the content types based on the selected playlist\n\n    const keySystemContentTypes = {};\n    for (const keySystem in keySystemOptions) {\n      keySystemContentTypes[keySystem] = {};\n      if (audioContentType) {\n        keySystemContentTypes[keySystem].audioContentType = audioContentType;\n      }\n      if (videoContentType) {\n        keySystemContentTypes[keySystem].videoContentType = videoContentType;\n      } // Default to using the video playlist's PSSH even though they may be different, as\n      // videojs-contrib-eme will only accept one in the options.\n      //\n      // This shouldn't be an issue for most cases as early intialization will handle all\n      // unique PSSH values, and if they aren't, then encrypted events should have the\n      // specific information needed for the unique license.\n\n      if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {\n        keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;\n      } // videojs-contrib-eme accepts the option of specifying: 'com.some.cdm': 'url'\n      // so we need to prevent overwriting the URL entirely\n\n      if (typeof keySystemOptions[keySystem] === 'string') {\n        keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];\n      }\n    }\n    return merge(keySystemOptions, keySystemContentTypes);\n  };\n  /**\n   * @typedef {Object} KeySystems\n   *\n   * keySystems configuration for https://github.com/videojs/videojs-contrib-eme\n   * Note: not all options are listed here.\n   *\n   * @property {Uint8Array} [pssh]\n   *           Protection System Specific Header\n   */\n\n  /**\n   * Goes through all the playlists and collects an array of KeySystems options objects\n   * containing each playlist's keySystems and their pssh values, if available.\n   *\n   * @param {Object[]} playlists\n   *        The playlists to look through\n   * @param {string[]} keySystems\n   *        The keySystems to collect pssh values for\n   *\n   * @return {KeySystems[]}\n   *         An array of KeySystems objects containing available key systems and their\n   *         pssh values\n   */\n\n  const getAllPsshKeySystemsOptions = (playlists, keySystems) => {\n    return playlists.reduce((keySystemsArr, playlist) => {\n      if (!playlist.contentProtection) {\n        return keySystemsArr;\n      }\n      const keySystemsOptions = keySystems.reduce((keySystemsObj, keySystem) => {\n        const keySystemOptions = playlist.contentProtection[keySystem];\n        if (keySystemOptions && keySystemOptions.pssh) {\n          keySystemsObj[keySystem] = {\n            pssh: keySystemOptions.pssh\n          };\n        }\n        return keySystemsObj;\n      }, {});\n      if (Object.keys(keySystemsOptions).length) {\n        keySystemsArr.push(keySystemsOptions);\n      }\n      return keySystemsArr;\n    }, []);\n  };\n  /**\n   * Returns a promise that waits for the\n   * [eme plugin](https://github.com/videojs/videojs-contrib-eme) to create a key session.\n   *\n   * Works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449 in non-IE11\n   * browsers.\n   *\n   * As per the above ticket, this is particularly important for Chrome, where, if\n   * unencrypted content is appended before encrypted content and the key session has not\n   * been created, a MEDIA_ERR_DECODE will be thrown once the encrypted content is reached\n   * during playback.\n   *\n   * @param {Object} player\n   *        The player instance\n   * @param {Object[]} sourceKeySystems\n   *        The key systems options from the player source\n   * @param {Object} [audioMedia]\n   *        The active audio media playlist (optional)\n   * @param {Object[]} mainPlaylists\n   *        The playlists found on the main playlist object\n   *\n   * @return {Object}\n   *         Promise that resolves when the key session has been created\n   */\n\n  const waitForKeySessionCreation = ({\n    player,\n    sourceKeySystems,\n    audioMedia,\n    mainPlaylists\n  }) => {\n    if (!player.eme.initializeMediaKeys) {\n      return Promise.resolve();\n    } // TODO should all audio PSSH values be initialized for DRM?\n    //\n    // All unique video rendition pssh values are initialized for DRM, but here only\n    // the initial audio playlist license is initialized. In theory, an encrypted\n    // event should be fired if the user switches to an alternative audio playlist\n    // where a license is required, but this case hasn't yet been tested. In addition, there\n    // may be many alternate audio playlists unlikely to be used (e.g., multiple different\n    // languages).\n\n    const playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;\n    const keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));\n    const initializationFinishedPromises = [];\n    const keySessionCreatedPromises = []; // Since PSSH values are interpreted as initData, EME will dedupe any duplicates. The\n    // only place where it should not be deduped is for ms-prefixed APIs, but the early\n    // return for IE11 above, and the existence of modern EME APIs in addition to\n    // ms-prefixed APIs on Edge should prevent this from being a concern.\n    // initializeMediaKeys also won't use the webkit-prefixed APIs.\n\n    keySystemsOptionsArr.forEach(keySystemsOptions => {\n      keySessionCreatedPromises.push(new Promise((resolve, reject) => {\n        player.tech_.one('keysessioncreated', resolve);\n      }));\n      initializationFinishedPromises.push(new Promise((resolve, reject) => {\n        player.eme.initializeMediaKeys({\n          keySystems: keySystemsOptions\n        }, err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve();\n        });\n      }));\n    }); // The reasons Promise.race is chosen over Promise.any:\n    //\n    // * Promise.any is only available in Safari 14+.\n    // * None of these promises are expected to reject. If they do reject, it might be\n    //   better here for the race to surface the rejection, rather than mask it by using\n    //   Promise.any.\n\n    return Promise.race([\n    // If a session was previously created, these will all finish resolving without\n    // creating a new session, otherwise it will take until the end of all license\n    // requests, which is why the key session check is used (to make setup much faster).\n    Promise.all(initializationFinishedPromises),\n    // Once a single session is created, the browser knows DRM will be used.\n    Promise.race(keySessionCreatedPromises)]);\n  };\n  /**\n   * If the [eme](https://github.com/videojs/videojs-contrib-eme) plugin is available, and\n   * there are keySystems on the source, sets up source options to prepare the source for\n   * eme.\n   *\n   * @param {Object} player\n   *        The player instance\n   * @param {Object[]} sourceKeySystems\n   *        The key systems options from the player source\n   * @param {Object} media\n   *        The active media playlist\n   * @param {Object} [audioMedia]\n   *        The active audio media playlist (optional)\n   *\n   * @return {boolean}\n   *         Whether or not options were configured and EME is available\n   */\n\n  const setupEmeOptions = ({\n    player,\n    sourceKeySystems,\n    media,\n    audioMedia\n  }) => {\n    const sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);\n    if (!sourceOptions) {\n      return false;\n    }\n    player.currentSource().keySystems = sourceOptions; // eme handles the rest of the setup, so if it is missing\n    // do nothing.\n\n    if (sourceOptions && !player.eme) {\n      videojs.log.warn('DRM encrypted source cannot be decrypted without a DRM plugin');\n      return false;\n    }\n    return true;\n  };\n  const getVhsLocalStorage = () => {\n    if (!window.localStorage) {\n      return null;\n    }\n    const storedObject = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (!storedObject) {\n      return null;\n    }\n    try {\n      return JSON.parse(storedObject);\n    } catch (e) {\n      // someone may have tampered with the value\n      return null;\n    }\n  };\n  const updateVhsLocalStorage = options => {\n    if (!window.localStorage) {\n      return false;\n    }\n    let objectToStore = getVhsLocalStorage();\n    objectToStore = objectToStore ? merge(objectToStore, options) : options;\n    try {\n      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));\n    } catch (e) {\n      // Throws if storage is full (e.g., always on iOS 5+ Safari private mode, where\n      // storage is set to 0).\n      // https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem#Exceptions\n      // No need to perform any operation.\n      return false;\n    }\n    return objectToStore;\n  };\n  /**\n   * Parses VHS-supported media types from data URIs. See\n   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n   * for information on data URIs.\n   *\n   * @param {string} dataUri\n   *        The data URI\n   *\n   * @return {string|Object}\n   *         The parsed object/string, or the original string if no supported media type\n   *         was found\n   */\n\n  const expandDataUri = dataUri => {\n    if (dataUri.toLowerCase().indexOf('data:application/vnd.videojs.vhs+json,') === 0) {\n      return JSON.parse(dataUri.substring(dataUri.indexOf(',') + 1));\n    } // no known case for this data URI, return the string as-is\n\n    return dataUri;\n  };\n  /**\n   * Whether the browser has built-in HLS support.\n   */\n\n  Vhs.supportsNativeHls = function () {\n    if (!document || !document.createElement) {\n      return false;\n    }\n    const video = document.createElement('video'); // native HLS is definitely not supported if HTML5 video isn't\n\n    if (!videojs.getTech('Html5').isSupported()) {\n      return false;\n    } // HLS manifests can go by many mime-types\n\n    const canPlay = [\n    // Apple santioned\n    'application/vnd.apple.mpegurl',\n    // Apple sanctioned for backwards compatibility\n    'audio/mpegurl',\n    // Very common\n    'audio/x-mpegurl',\n    // Very common\n    'application/x-mpegurl',\n    // Included for completeness\n    'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\n    return canPlay.some(function (canItPlay) {\n      return /maybe|probably/i.test(video.canPlayType(canItPlay));\n    });\n  }();\n  Vhs.supportsNativeDash = function () {\n    if (!document || !document.createElement || !videojs.getTech('Html5').isSupported()) {\n      return false;\n    }\n    return /maybe|probably/i.test(document.createElement('video').canPlayType('application/dash+xml'));\n  }();\n  Vhs.supportsTypeNatively = type => {\n    if (type === 'hls') {\n      return Vhs.supportsNativeHls;\n    }\n    if (type === 'dash') {\n      return Vhs.supportsNativeDash;\n    }\n    return false;\n  };\n  /**\n   * VHS is a source handler, not a tech. Make sure attempts to use it\n   * as one do not cause exceptions.\n   */\n\n  Vhs.isSupported = function () {\n    return videojs.log.warn('VHS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n  };\n  const Component = videojs.getComponent('Component');\n  /**\n   * The Vhs Handler object, where we orchestrate all of the parts\n   * of VHS to interact with video.js\n   *\n   * @class VhsHandler\n   * @extends videojs.Component\n   * @param {Object} source the soruce object\n   * @param {Tech} tech the parent tech object\n   * @param {Object} options optional and required options\n   */\n\n  class VhsHandler extends Component {\n    constructor(source, tech, options) {\n      super(tech, options.vhs); // if a tech level `initialBandwidth` option was passed\n      // use that over the VHS level `bandwidth` option\n\n      if (typeof options.initialBandwidth === 'number') {\n        this.options_.bandwidth = options.initialBandwidth;\n      }\n      this.logger_ = logger('VhsHandler'); // we need access to the player in some cases,\n      // so, get it from Video.js via the `playerId`\n\n      if (tech.options_ && tech.options_.playerId) {\n        const _player = videojs.getPlayer(tech.options_.playerId);\n        this.player_ = _player;\n      }\n      this.tech_ = tech;\n      this.source_ = source;\n      this.stats = {};\n      this.ignoreNextSeekingEvent_ = false;\n      this.setOptions_();\n      if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {\n        tech.overrideNativeAudioTracks(true);\n        tech.overrideNativeVideoTracks(true);\n      } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\n        // overriding native VHS only works if audio tracks have been emulated\n        // error early if we're misconfigured\n        throw new Error('Overriding native VHS requires emulated tracks. ' + 'See https://git.io/vMpjB');\n      } // listen for fullscreenchange events for this player so that we\n      // can adjust our quality selection quickly\n\n      this.on(document, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], event => {\n        const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n        if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) {\n          this.playlistController_.fastQualityChange_();\n        } else {\n          // When leaving fullscreen, since the in page pixel dimensions should be smaller\n          // than full screen, see if there should be a rendition switch down to preserve\n          // bandwidth.\n          this.playlistController_.checkABR_();\n        }\n      });\n      this.on(this.tech_, 'seeking', function () {\n        if (this.ignoreNextSeekingEvent_) {\n          this.ignoreNextSeekingEvent_ = false;\n          return;\n        }\n        this.setCurrentTime(this.tech_.currentTime());\n      });\n      this.on(this.tech_, 'error', function () {\n        // verify that the error was real and we are loaded\n        // enough to have pc loaded.\n        if (this.tech_.error() && this.playlistController_) {\n          this.playlistController_.pauseLoading();\n        }\n      });\n      this.on(this.tech_, 'play', this.play);\n    }\n    setOptions_() {\n      // defaults\n      this.options_.withCredentials = this.options_.withCredentials || false;\n      this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;\n      this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;\n      this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== 'undefined' ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;\n      this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;\n      this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;\n      this.options_.customTagParsers = this.options_.customTagParsers || [];\n      this.options_.customTagMappers = this.options_.customTagMappers || [];\n      this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;\n      this.options_.llhls = this.options_.llhls === false ? false : true;\n      this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;\n      if (typeof this.options_.playlistExclusionDuration !== 'number') {\n        this.options_.playlistExclusionDuration = 5 * 60;\n      }\n      if (typeof this.options_.bandwidth !== 'number') {\n        if (this.options_.useBandwidthFromLocalStorage) {\n          const storedObject = getVhsLocalStorage();\n          if (storedObject && storedObject.bandwidth) {\n            this.options_.bandwidth = storedObject.bandwidth;\n            this.tech_.trigger({\n              type: 'usage',\n              name: 'vhs-bandwidth-from-local-storage'\n            });\n          }\n          if (storedObject && storedObject.throughput) {\n            this.options_.throughput = storedObject.throughput;\n            this.tech_.trigger({\n              type: 'usage',\n              name: 'vhs-throughput-from-local-storage'\n            });\n          }\n        }\n      } // if bandwidth was not set by options or pulled from local storage, start playlist\n      // selection at a reasonable bandwidth\n\n      if (typeof this.options_.bandwidth !== 'number') {\n        this.options_.bandwidth = Config.INITIAL_BANDWIDTH;\n      } // If the bandwidth number is unchanged from the initial setting\n      // then this takes precedence over the enableLowInitialPlaylist option\n\n      this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH; // grab options passed to player.src\n\n      ['withCredentials', 'useDevicePixelRatio', 'limitRenditionByPlayerDimensions', 'bandwidth', 'customTagParsers', 'customTagMappers', 'cacheEncryptionKeys', 'playlistSelector', 'initialPlaylistSelector', 'bufferBasedABR', 'liveRangeSafeTimeDelta', 'llhls', 'useNetworkInformationApi', 'useDtsForTimestampOffset', 'exactManifestTimings', 'leastPixelDiffSelector'].forEach(option => {\n        if (typeof this.source_[option] !== 'undefined') {\n          this.options_[option] = this.source_[option];\n        }\n      });\n      this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;\n      this.useDevicePixelRatio = this.options_.useDevicePixelRatio;\n    }\n    /**\n     * called when player.src gets called, handle a new source\n     *\n     * @param {Object} src the source object to handle\n     */\n\n    src(src, type) {\n      // do nothing if the src is falsey\n      if (!src) {\n        return;\n      }\n      this.setOptions_(); // add main playlist controller options\n\n      this.options_.src = expandDataUri(this.source_.src);\n      this.options_.tech = this.tech_;\n      this.options_.externVhs = Vhs;\n      this.options_.sourceType = simpleTypeFromSourceType(type); // Whenever we seek internally, we should update the tech\n\n      this.options_.seekTo = time => {\n        this.tech_.setCurrentTime(time);\n      };\n      this.playlistController_ = new PlaylistController(this.options_);\n      const playbackWatcherOptions = merge({\n        liveRangeSafeTimeDelta: SAFE_TIME_DELTA\n      }, this.options_, {\n        seekable: () => this.seekable(),\n        media: () => this.playlistController_.media(),\n        playlistController: this.playlistController_\n      });\n      this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);\n      this.playlistController_.on('error', () => {\n        const player = videojs.players[this.tech_.options_.playerId];\n        let error = this.playlistController_.error;\n        if (typeof error === 'object' && !error.code) {\n          error.code = 3;\n        } else if (typeof error === 'string') {\n          error = {\n            message: error,\n            code: 3\n          };\n        }\n        player.error(error);\n      });\n      const defaultSelector = this.options_.bufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR; // `this` in selectPlaylist should be the VhsHandler for backwards\n      // compatibility with < v2\n\n      this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);\n      this.playlistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this); // re-expose some internal objects for backwards compatibility with < v2\n\n      this.playlists = this.playlistController_.mainPlaylistLoader_;\n      this.mediaSource = this.playlistController_.mediaSource; // Proxy assignment of some properties to the main playlist\n      // controller. Using a custom property for backwards compatibility\n      // with < v2\n\n      Object.defineProperties(this, {\n        selectPlaylist: {\n          get() {\n            return this.playlistController_.selectPlaylist;\n          },\n          set(selectPlaylist) {\n            this.playlistController_.selectPlaylist = selectPlaylist.bind(this);\n          }\n        },\n        throughput: {\n          get() {\n            return this.playlistController_.mainSegmentLoader_.throughput.rate;\n          },\n          set(throughput) {\n            this.playlistController_.mainSegmentLoader_.throughput.rate = throughput; // By setting `count` to 1 the throughput value becomes the starting value\n            // for the cumulative average\n\n            this.playlistController_.mainSegmentLoader_.throughput.count = 1;\n          }\n        },\n        bandwidth: {\n          get() {\n            let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;\n            const networkInformation = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\n            const tenMbpsAsBitsPerSecond = 10e6;\n            if (this.options_.useNetworkInformationApi && networkInformation) {\n              // downlink returns Mbps\n              // https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/downlink\n              const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1000 * 1000; // downlink maxes out at 10 Mbps. In the event that both networkInformationApi and the player\n              // estimate a bandwidth greater than 10 Mbps, use the larger of the two estimates to ensure that\n              // high quality streams are not filtered out.\n\n              if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {\n                playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);\n              } else {\n                playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;\n              }\n            }\n            return playerBandwidthEst;\n          },\n          set(bandwidth) {\n            this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth; // setting the bandwidth manually resets the throughput counter\n            // `count` is set to zero that current value of `rate` isn't included\n            // in the cumulative average\n\n            this.playlistController_.mainSegmentLoader_.throughput = {\n              rate: 0,\n              count: 0\n            };\n          }\n        },\n        /**\n         * `systemBandwidth` is a combination of two serial processes bit-rates. The first\n         * is the network bitrate provided by `bandwidth` and the second is the bitrate of\n         * the entire process after that - decryption, transmuxing, and appending - provided\n         * by `throughput`.\n         *\n         * Since the two process are serial, the overall system bandwidth is given by:\n         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\n         */\n        systemBandwidth: {\n          get() {\n            const invBandwidth = 1 / (this.bandwidth || 1);\n            let invThroughput;\n            if (this.throughput > 0) {\n              invThroughput = 1 / this.throughput;\n            } else {\n              invThroughput = 0;\n            }\n            const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\n            return systemBitrate;\n          },\n          set() {\n            videojs.log.error('The \"systemBandwidth\" property is read-only');\n          }\n        }\n      });\n      if (this.options_.bandwidth) {\n        this.bandwidth = this.options_.bandwidth;\n      }\n      if (this.options_.throughput) {\n        this.throughput = this.options_.throughput;\n      }\n      Object.defineProperties(this.stats, {\n        bandwidth: {\n          get: () => this.bandwidth || 0,\n          enumerable: true\n        },\n        mediaRequests: {\n          get: () => this.playlistController_.mediaRequests_() || 0,\n          enumerable: true\n        },\n        mediaRequestsAborted: {\n          get: () => this.playlistController_.mediaRequestsAborted_() || 0,\n          enumerable: true\n        },\n        mediaRequestsTimedout: {\n          get: () => this.playlistController_.mediaRequestsTimedout_() || 0,\n          enumerable: true\n        },\n        mediaRequestsErrored: {\n          get: () => this.playlistController_.mediaRequestsErrored_() || 0,\n          enumerable: true\n        },\n        mediaTransferDuration: {\n          get: () => this.playlistController_.mediaTransferDuration_() || 0,\n          enumerable: true\n        },\n        mediaBytesTransferred: {\n          get: () => this.playlistController_.mediaBytesTransferred_() || 0,\n          enumerable: true\n        },\n        mediaSecondsLoaded: {\n          get: () => this.playlistController_.mediaSecondsLoaded_() || 0,\n          enumerable: true\n        },\n        mediaAppends: {\n          get: () => this.playlistController_.mediaAppends_() || 0,\n          enumerable: true\n        },\n        mainAppendsToLoadedData: {\n          get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,\n          enumerable: true\n        },\n        audioAppendsToLoadedData: {\n          get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,\n          enumerable: true\n        },\n        appendsToLoadedData: {\n          get: () => this.playlistController_.appendsToLoadedData_() || 0,\n          enumerable: true\n        },\n        timeToLoadedData: {\n          get: () => this.playlistController_.timeToLoadedData_() || 0,\n          enumerable: true\n        },\n        buffered: {\n          get: () => timeRangesToArray(this.tech_.buffered()),\n          enumerable: true\n        },\n        currentTime: {\n          get: () => this.tech_.currentTime(),\n          enumerable: true\n        },\n        currentSource: {\n          get: () => this.tech_.currentSource_,\n          enumerable: true\n        },\n        currentTech: {\n          get: () => this.tech_.name_,\n          enumerable: true\n        },\n        duration: {\n          get: () => this.tech_.duration(),\n          enumerable: true\n        },\n        main: {\n          get: () => this.playlists.main,\n          enumerable: true\n        },\n        playerDimensions: {\n          get: () => this.tech_.currentDimensions(),\n          enumerable: true\n        },\n        seekable: {\n          get: () => timeRangesToArray(this.tech_.seekable()),\n          enumerable: true\n        },\n        timestamp: {\n          get: () => Date.now(),\n          enumerable: true\n        },\n        videoPlaybackQuality: {\n          get: () => this.tech_.getVideoPlaybackQuality(),\n          enumerable: true\n        }\n      });\n      this.tech_.one('canplay', this.playlistController_.setupFirstPlay.bind(this.playlistController_));\n      this.tech_.on('bandwidthupdate', () => {\n        if (this.options_.useBandwidthFromLocalStorage) {\n          updateVhsLocalStorage({\n            bandwidth: this.bandwidth,\n            throughput: Math.round(this.throughput)\n          });\n        }\n      });\n      this.playlistController_.on('selectedinitialmedia', () => {\n        // Add the manual rendition mix-in to VhsHandler\n        renditionSelectionMixin(this);\n      });\n      this.playlistController_.sourceUpdater_.on('createdsourcebuffers', () => {\n        this.setupEme_();\n      }); // the bandwidth of the primary segment loader is our best\n      // estimate of overall bandwidth\n\n      this.on(this.playlistController_, 'progress', function () {\n        this.tech_.trigger('progress');\n      }); // In the live case, we need to ignore the very first `seeking` event since\n      // that will be the result of the seek-to-live behavior\n\n      this.on(this.playlistController_, 'firstplay', function () {\n        this.ignoreNextSeekingEvent_ = true;\n      });\n      this.setupQualityLevels_(); // do nothing if the tech has been disposed already\n      // this can occur if someone sets the src in player.ready(), for instance\n\n      if (!this.tech_.el()) {\n        return;\n      }\n      this.mediaSourceUrl_ = window.URL.createObjectURL(this.playlistController_.mediaSource);\n      this.tech_.src(this.mediaSourceUrl_);\n    }\n    createKeySessions_() {\n      const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n      this.logger_('waiting for EME key session creation');\n      waitForKeySessionCreation({\n        player: this.player_,\n        sourceKeySystems: this.source_.keySystems,\n        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),\n        mainPlaylists: this.playlists.main.playlists\n      }).then(() => {\n        this.logger_('created EME key session');\n        this.playlistController_.sourceUpdater_.initializedEme();\n      }).catch(err => {\n        this.logger_('error while creating EME key session', err);\n        this.player_.error({\n          message: 'Failed to initialize media keys for EME',\n          code: 3\n        });\n      });\n    }\n    handleWaitingForKey_() {\n      // If waitingforkey is fired, it's possible that the data that's necessary to retrieve\n      // the key is in the manifest. While this should've happened on initial source load, it\n      // may happen again in live streams where the keys change, and the manifest info\n      // reflects the update.\n      //\n      // Because videojs-contrib-eme compares the PSSH data we send to that of PSSH data it's\n      // already requested keys for, we don't have to worry about this generating extraneous\n      // requests.\n      this.logger_('waitingforkey fired, attempting to create any new key sessions');\n      this.createKeySessions_();\n    }\n    /**\n     * If necessary and EME is available, sets up EME options and waits for key session\n     * creation.\n     *\n     * This function also updates the source updater so taht it can be used, as for some\n     * browsers, EME must be configured before content is appended (if appending unencrypted\n     * content before encrypted content).\n     */\n\n    setupEme_() {\n      const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n      const didSetupEmeOptions = setupEmeOptions({\n        player: this.player_,\n        sourceKeySystems: this.source_.keySystems,\n        media: this.playlists.media(),\n        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()\n      });\n      this.player_.tech_.on('keystatuschange', e => {\n        if (e.status !== 'output-restricted') {\n          return;\n        }\n        const mainPlaylist = this.playlistController_.main();\n        if (!mainPlaylist || !mainPlaylist.playlists) {\n          return;\n        }\n        const excludedHDPlaylists = []; // Assume all HD streams are unplayable and exclude them from ABR selection\n\n        mainPlaylist.playlists.forEach(playlist => {\n          if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {\n            if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {\n              playlist.excludeUntil = Infinity;\n              excludedHDPlaylists.push(playlist);\n            }\n          }\n        });\n        if (excludedHDPlaylists.length) {\n          videojs.log.warn('DRM keystatus changed to \"output-restricted.\" Removing the following HD playlists ' + 'that will most likely fail to play and clearing the buffer. ' + 'This may be due to HDCP restrictions on the stream and the capabilities of the current device.', ...excludedHDPlaylists); // Clear the buffer before switching playlists, since it may already contain unplayable segments\n\n          this.playlistController_.fastQualityChange_();\n        }\n      });\n      this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);\n      this.player_.tech_.on('waitingforkey', this.handleWaitingForKey_); // In IE11 this is too early to initialize media keys, and IE11 does not support\n      // promises.\n\n      if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {\n        // If EME options were not set up, we've done all we could to initialize EME.\n        this.playlistController_.sourceUpdater_.initializedEme();\n        return;\n      }\n      this.createKeySessions_();\n    }\n    /**\n     * Initializes the quality levels and sets listeners to update them.\n     *\n     * @method setupQualityLevels_\n     * @private\n     */\n\n    setupQualityLevels_() {\n      const player = videojs.players[this.tech_.options_.playerId]; // if there isn't a player or there isn't a qualityLevels plugin\n      // or qualityLevels_ listeners have already been setup, do nothing.\n\n      if (!player || !player.qualityLevels || this.qualityLevels_) {\n        return;\n      }\n      this.qualityLevels_ = player.qualityLevels();\n      this.playlistController_.on('selectedinitialmedia', () => {\n        handleVhsLoadedMetadata(this.qualityLevels_, this);\n      });\n      this.playlists.on('mediachange', () => {\n        handleVhsMediaChange(this.qualityLevels_, this.playlists);\n      });\n    }\n    /**\n     * return the version\n     */\n\n    static version() {\n      return {\n        '@videojs/http-streaming': version$4,\n        'mux.js': version$3,\n        'mpd-parser': version$2,\n        'm3u8-parser': version$1,\n        'aes-decrypter': version\n      };\n    }\n    /**\n     * return the version\n     */\n\n    version() {\n      return this.constructor.version();\n    }\n    canChangeType() {\n      return SourceUpdater.canChangeType();\n    }\n    /**\n     * Begin playing the video.\n     */\n\n    play() {\n      this.playlistController_.play();\n    }\n    /**\n     * a wrapper around the function in PlaylistController\n     */\n\n    setCurrentTime(currentTime) {\n      this.playlistController_.setCurrentTime(currentTime);\n    }\n    /**\n     * a wrapper around the function in PlaylistController\n     */\n\n    duration() {\n      return this.playlistController_.duration();\n    }\n    /**\n     * a wrapper around the function in PlaylistController\n     */\n\n    seekable() {\n      return this.playlistController_.seekable();\n    }\n    /**\n     * Abort all outstanding work and cleanup.\n     */\n\n    dispose() {\n      if (this.playbackWatcher_) {\n        this.playbackWatcher_.dispose();\n      }\n      if (this.playlistController_) {\n        this.playlistController_.dispose();\n      }\n      if (this.qualityLevels_) {\n        this.qualityLevels_.dispose();\n      }\n      if (this.tech_ && this.tech_.vhs) {\n        delete this.tech_.vhs;\n      }\n      if (this.mediaSourceUrl_ && window.URL.revokeObjectURL) {\n        window.URL.revokeObjectURL(this.mediaSourceUrl_);\n        this.mediaSourceUrl_ = null;\n      }\n      if (this.tech_) {\n        this.tech_.off('waitingforkey', this.handleWaitingForKey_);\n      }\n      super.dispose();\n    }\n    convertToProgramTime(time, callback) {\n      return getProgramTime({\n        playlist: this.playlistController_.media(),\n        time,\n        callback\n      });\n    } // the player must be playing before calling this\n\n    seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {\n      return seekToProgramTime({\n        programTime,\n        playlist: this.playlistController_.media(),\n        retryCount,\n        pauseAfterSeek,\n        seekTo: this.options_.seekTo,\n        tech: this.options_.tech,\n        callback\n      });\n    }\n  }\n  /**\n   * The Source Handler object, which informs video.js what additional\n   * MIME types are supported and sets up playback. It is registered\n   * automatically to the appropriate tech based on the capabilities of\n   * the browser it is running in. It is not necessary to use or modify\n   * this object in normal usage.\n   */\n\n  const VhsSourceHandler = {\n    name: 'videojs-http-streaming',\n    VERSION: version$4,\n    canHandleSource(srcObj, options = {}) {\n      const localOptions = merge(videojs.options, options);\n      return VhsSourceHandler.canPlayType(srcObj.type, localOptions);\n    },\n    handleSource(source, tech, options = {}) {\n      const localOptions = merge(videojs.options, options);\n      tech.vhs = new VhsHandler(source, tech, localOptions);\n      tech.vhs.xhr = xhrFactory();\n      tech.vhs.src(source.src, source.type);\n      return tech.vhs;\n    },\n    canPlayType(type, options = {}) {\n      const {\n        vhs: {\n          overrideNative = !videojs.browser.IS_ANY_SAFARI\n        } = {}\n      } = merge(videojs.options, options);\n      const supportedType = simpleTypeFromSourceType(type);\n      const canUseMsePlayback = supportedType && (!Vhs.supportsTypeNatively(supportedType) || overrideNative);\n      return canUseMsePlayback ? 'maybe' : '';\n    }\n  };\n  /**\n   * Check to see if the native MediaSource object exists and supports\n   * an MP4 container with both H.264 video and AAC-LC audio.\n   *\n   * @return {boolean} if  native media sources are supported\n   */\n\n  const supportsNativeMediaSources = () => {\n    return browserSupportsCodec('avc1.4d400d,mp4a.40.2');\n  }; // register source handlers with the appropriate techs\n\n  if (supportsNativeMediaSources()) {\n    videojs.getTech('Html5').registerSourceHandler(VhsSourceHandler, 0);\n  }\n  videojs.VhsHandler = VhsHandler;\n  videojs.VhsSourceHandler = VhsSourceHandler;\n  videojs.Vhs = Vhs;\n  if (!videojs.use) {\n    videojs.registerComponent('Vhs', Vhs);\n  }\n  videojs.options.vhs = videojs.options.vhs || {};\n  if (!videojs.getPlugin || !videojs.getPlugin('reloadSourceOnError')) {\n    videojs.registerPlugin('reloadSourceOnError', reloadSourceOnError);\n  }\n\n  return videojs;\n\n}));\n"],"names":["global","factory","exports","module","define","amd","globalThis","self","videojs","this","hooks_","hooks","type","fn","concat","removeHook","index","indexOf","slice","splice","FullscreenApi","prefixed","apiMap","specApi","browserApi","i","length","document","history","log$1","createLogger$1","name","logByType","level","log","args","lvl","levels","lvlRegExp","RegExp","unshift","toUpperCase","push","window","console","info","test","Array","isArray","LogByTypeFactory","createLogger","subname","all","off","debug","warn","error","DEFAULT","hasOwnProperty","Error","filter","fname","historyItem","clear","disable","enable","toString$1","Object","prototype","toString","keys","object","isObject$1","each","forEach","key","reduce","initial","accum","value","isPlain","call","constructor","merge$2","result","sources","source","defineLazyProperty","obj","getValue","setter","set","defineProperty","enumerable","writable","options","configurable","get","Obj","freeze","__proto__","isObject","merge","ANDROID_VERSION","IS_IPOD","IOS_VERSION","IS_ANDROID","IS_FIREFOX","IS_EDGE","IS_CHROMIUM","IS_CHROME","CHROMIUM_VERSION","CHROME_VERSION","IE_VERSION","IS_SAFARI","IS_WINDOWS","IS_IPAD","IS_IPHONE","TOUCH_ENABLED","Boolean","isReal","navigator","maxTouchPoints","DocumentTouch","UAD","userAgentData","platform","brands","find","b","brand","version","USER_AGENT","userAgent","match","major","parseFloat","minor","exec","IS_IOS","IS_ANY_SAFARI","browser","isNonBlankString","str","trim","isEl","nodeType","isInFrame","parent","x","createQuerier","method","selector","context","querySelector","ctx","createEl","tagName","properties","attributes","content","el","createElement","getOwnPropertyNames","propName","val","textContent","attrName","setAttribute","appendContent","text","innerText","prependTo","child","firstChild","insertBefore","appendChild","hasClass","element","classToCheck","throwIfWhitespace","classList","contains","addClass","classesToAdd","add","prev","current","split","removeClass","classesToRemove","remove","toggleClass","classToToggle","predicate","undefined","className","toggle","setAttributes","attrValue","removeAttribute","getAttributes","tag","knownBooleans","attrs","attrVal","getAttribute","attribute","blockTextSelection","body","focus","onselectstart","unblockTextSelection","getBoundingClientRect","parentNode","rect","k","height","computedStyle","width","findPosition","offsetParent","left","top","offsetWidth","offsetHeight","fullscreenElement","offsetLeft","offsetTop","getPointerPosition","event","translated","y","item","nodeName","toLowerCase","transform","values","map","Number","position","boxTarget","target","box","boxW","boxH","offsetY","offsetX","changedTouches","pageX","pageY","Math","max","min","isTextNode$1","emptyEl","removeChild","normalizeContent","createTextNode","node","insertContent","isSingleLeftClick","button","buttons","$","$$","prop","getComputedStyle","computedStyleValue","e","getPropertyValue","Dom","isTextNode","videojs$1","_windowLoaded","autoSetup","vids","getElementsByTagName","audios","divs","mediaEls","mediaEl","autoSetupTimeout","player","wait","vjs","setTimeout","setWindowLoaded","removeEventListener","readyState","addEventListener","createStyleElement","style","setTextContent","styleSheet","cssText","DomData","WeakMap","_supportsPassive","_guid","newGUID","_cleanUpEvents","elem","has","data","handlers","dispatcher","detachEvent","disabled","delete","_handleMultipleEvents","types","callback","fixEvent","fixed_","returnTrue","returnFalse","isPropagationStopped","isImmediatePropagationStopped","old","preventDefault","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","clientX","doc","documentElement","scrollLeft","clientLeft","clientY","scrollTop","clientTop","which","charCode","keyCode","passiveEvents","on","guid","hash","handlersCopy","m","n","opts","supportsPassive","passive","attachEvent","removeType","t","trigger","elemData","ownerDocument","bubbles","targetData","one","func","apply","arguments","any","Events","bind_","uid","bound","bind","throttle","last","performance","now","debounce","immediate","timeout","cancel","clearTimeout","debounced","later","Fn","UPDATE_REFRESH_INTERVAL","EVENT_MAP","EventTarget$2","ael","allowedEvents_","queueTrigger","Map","oldTimeout","size","dispatchEvent","objName","name_","isEvented","eventBusEl_","every","isValidEventType","validateTarget","fnName","validateEventType","validateListener","listener","normalizeListenArgs","isTargetingSelf","shift","listen","EventedMixin","removeListenerOnDispose","removeRemoverOnTargetDispose","wrapper","_this","largs","_this2","targetOrType","typeOrListener","evented","eventBusKey","assign","eventedCallbacks","el_","StatefulMixin","state","setState","stateUpdates","changes","from","to","stateful","defaultState","handleStateChanged","string","replace","w","toTitleCase$1","titleCaseEquals","str1","str2","Str","toTitleCase","commonjsGlobal","createCommonjsModule","keycode","searchInput","hasKeyCode","names","foundNamedKey","search","String","codes","aliases","charCodeAt","isEventKey","nameOrCode","code","fromCharCode","title","alias","Component$1","ready","play","player_","isDisposed_","parentComponent_","options_","id_","id","c","handleLanguagechange","children_","childIndex_","childNameIndex_","setTimeoutIds_","Set","setIntervalIds_","rafIds_","namedRafs_","clearingTimersOnDispose_","initChildren","reportTouchActivity","enableTouchActivity","dispose","readyQueue_","restoreEl","replaceChild","isDisposed","localize","tokens","defaultValue","language","languages","primaryCode","primaryLang","localizedString","ret","contentEl","contentEl_","children","getChildById","getChild","getDescendant","acc","currentChild","addChild","component","componentName","componentClassName","componentClass","ComponentClass","getComponent","refNode","childFound","compEl","parentOptions","handleAdd","playerOptions","newChild","workingChildren","Tech","some","wchild","isTech","buildCSSClass","sync","isReady_","triggerReady","readyQueue","show","hide","lockShowing","unlockShowing","num","skipListeners","dimension","dimensions","widthOrHeight","pxIndex","parseInt","currentDimension","computedWidthOrHeight","isNaN","rule","currentDimensions","currentWidth","currentHeight","blur","handleKeyDown","handleKeyPress","emitTapEvents","touchStart","firstTouch","couldBeTap","touches","xdiff","ydiff","sqrt","noTap","reportUserActivity","report","touchHolding","clearInterval","setInterval","touchEnd","timeoutId","clearTimersOnDispose_","interval","intervalId","requestAnimationFrame","requestNamedAnimationFrame","cancelNamedAnimationFrame","cancelAnimationFrame","_ref4","idName","cancelName","ComponentToRegister","isComp","isPrototypeOf","reason","components_","Player","players","playerNames","pname","getRange","valueIndex","ranges","rangeIndex","maxIndex","rangeCheck","createTimeRangesObj","timeRangesObj","start","end","Symbol","iterator","createTimeRanges$1","registerComponent","defaultImplementation","seconds","guide","s","floor","h","gm","gh","Infinity","implementation","setFormatTime","customImplementation","resetFormatTime","formatTime","Time","createTimeRanges","createTimeRange","bufferedPercent","buffered","duration","bufferedDuration","MediaError","message","defaultMessages","status","errorTypes","errNum","tuple","reviver","json","JSON","parse","err","isPromise","then","silencePromise","trackToJson_","track","cues","cue","startTime","endTime","textTrackConverter","tech","trackEls","trackObjs","trackEl","src","textTracks","addedTrack","addRemoteTextTrack","addCue","ModalDialog","handleKeyDown_","close_","close","opened_","hasBeenOpened_","hasBeenFilled_","closeable","uncloseable","role","descEl_","description","super","tabIndex","label","previouslyActiveEl_","desc","open","fillAlways","fill","wasPlaying_","paused","pauseOnOpen","pause","hadControls_","controls","conditionalFocus_","opened","conditionalBlur_","temporary","closeable_","temp","controlText","fillWith","parentEl","nextSiblingEl","nextSibling","empty","closeButton","content_","activeEl","activeElement","playerEl","focusableEls","focusableEls_","focusIndex","shiftKey","allChildren","querySelectorAll","HTMLAnchorElement","HTMLAreaElement","hasAttribute","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","HTMLButtonElement","HTMLIFrameElement","HTMLObjectElement","HTMLEmbedElement","TrackList","tracks","tracks_","addTrack","labelchange_","removeTrack","rtrack","l","getTrackById","change","addtrack","removetrack","labelchange","disableOthers$1","list","enabled","disableOthers","selected","TextTrackList","queueChange_","triggerSelectedlanguagechange","triggerSelectedlanguagechange_","kind","selectedlanguagechange_","TextTrackCueList","setCues_","length_","oldLength","cues_","defineProp","getCueById","VideoTrackKind","alternative","captions","main","sign","subtitles","commentary","AudioTrackKind","TextTrackKind","descriptions","chapters","metadata","TextTrackMode","hidden","showing","Track","trackProps","newLabel","parseUrl","url","props","a","href","details","protocol","host","location","getAbsoluteURL","getFileExtension","path","pathParts","pop","isCrossOrigin","winLoc","urlInfo","srcProtocol","crossOrigin","Url","window_1","_extends_1","_extends","__esModule","_extends$1","isFunction_1","alert","confirm","prompt","httpHandler","decodeResponseBody","response","responseBody","statusCode","cause","TextDecoder","charset","contentTypeHeader","contentType","_contentType$split","getCharset","headers","decode","Uint8Array","createXHR","lib","default_1","initParams","uri","params","_createXHR","called","getBody","xhr","responseText","responseType","responseXML","firefoxBugTakenEffect","getXml","isJson","errorFunc","evt","timeoutTimer","failureResponse","loadFunc","aborted","useXDR","rawRequest","getAllResponseHeaders","row","parseHeaders","cors","XDomainRequest","XMLHttpRequest","stringify","onreadystatechange","onload","onerror","onprogress","onabort","ontimeout","username","password","withCredentials","abort","setRequestHeader","isEmpty","beforeSend","send","array","forEachArray","default","parseCues","srcContent","parser","WebVTT","Parser","vttjs","StringDecoder","errors","oncue","onparsingerror","onflush","groupCollapsed","groupEnd","flush","loadTrack","tech_","loaded_","TextTrack","settings","srclang","mode","default_","activeCues_","preload_","preloadTextTracks","activeCues","changed","timeupdateHandler","rvf_","requestVideoFrameCallback","stopTracking","startTracking","defineProperties","newMode","ct","currentTime","active","cancelVideoFrameCallback","originalCue","VTTCue","originalCue_","removeCue","cuechange","AudioTrack","newEnabled","VideoTrack","newSelected","HTMLTrackElement","NONE","LOADED","load","LOADING","ERROR","NORMAL","audio","ListClass","changing_","enabledChange_","TrackClass","capitalName","video","selectedChange_","getterName","privateName","REMOTE","remoteText","remoteTextEl","trackElements","trackElements_","addTrackElement_","trackElement","getTrackElementByTrack_","trackElement_","removeTrackElement_","ALL","doccy","topLevel","document_1","_objCreate","create","F","o","ParsingError","errorData","parseTimeStamp","input","computeSeconds","f","Settings","parseOptions","keyValueDelim","groupDelim","groups","kv","parseCue","regionList","oInput","consumeTimeStamp","ts","Errors","BadTimeStamp","skipWhitespace","substr","v","region","alt","vals","vals0","integer","percent","vertical","line","lineAlign","snapToLines","align","center","middle","right","positionAlign","consumeCueSettings","BadSignature","dflt","defaultKey","TEXTAREA_ELEMENT","TAG_NAME","u","ruby","rt","lang","DEFAULT_COLOR_CLASS","white","lime","cyan","red","yellow","magenta","blue","black","TAG_ANNOTATION","NEEDS_PARENT","parseContent","nextToken","shouldAdd","localName","annotation","rootDiv","tagStack","innerHTML","createProcessingInstruction","classes","cl","bgColor","colorName","propValue","join","strongRTLRanges","isStrongRTLChar","currentRange","determineBidi","cueDiv","nodeStack","childNodes","pushNodes","nextTextNode","StyleBox","CueStyleBox","styleOptions","styles","color","backgroundColor","bottom","display","writingMode","unicodeBidi","applyStyles","div","direction","textAlign","font","whiteSpace","textPos","formatStyle","move","BoxPosition","lh","rects","getClientRects","lineHeight","moveBoxToLinePosition","styleBox","containerBox","boxPositions","boxPosition","linePos","textTrackList","mediaElement","trackList","count","computeLinePos","axis","step","round","maxPosition","initialAxis","abs","ceil","reverse","calculatedPercentage","bestPosition","specifiedPosition","percentage","overlapsOppositeAxis","within","overlapsAny","p","intersectPercentage","findBestPosition","toCSSCompatValues","WebVTT$1","unit","toMove","overlaps","b2","boxes","container","reference","getSimpleBoxPosition","decodeURIComponent","encodeURIComponent","convertCueToDOMTree","cuetext","processCues","overlay","paddedOverlay","margin","hasBeenReset","displayState","shouldCompute","fontSize","decoder","buffer","reportOrThrowError","collectNextLine","pos","parseHeader","ontimestampmap","parseTimestampMap","xy","anchor","VTTRegion","lines","regionAnchorX","regionAnchorY","viewportAnchorX","viewportAnchorY","scroll","onregion","parseRegion","stream","alreadyCollectedLine","hasSubstring","vtt","directionSetting","alignSetting","findAlignSetting","_id","_pauseOnExit","_startTime","_endTime","_text","_region","_vertical","_snapToLines","_line","_lineAlign","_position","_positionAlign","_size","_align","TypeError","setting","findDirectionSetting","SyntaxError","getCueAsHTML","vttcue","scrollSetting","isValidPercentValue","vttregion","_width","_lines","_regionAnchorX","_regionAnchorY","_viewportAnchorX","_viewportAnchorY","_scroll","findScrollSetting","browserIndex","cueShim","regionShim","nativeVTTCue","nativeVTTRegion","shim","restore","onDurationChange_","onDurationChange","trackProgress_","trackProgress","trackCurrentTime_","trackCurrentTime","stopTrackingCurrentTime_","stopTrackingCurrentTime","disposeSourceHandler_","disposeSourceHandler","queuedHanders_","hasStarted_","featuresProgressEvents","manualProgressOn","featuresTimeupdateEvents","manualTimeUpdatesOn","nativeCaptions","nativeTextTracks","featuresNativeTextTracks","emulateTextTracks","autoRemoteTextTracks_","initTrackListeners","nativeControlsForTouch","triggerSourceset","manualProgress","manualProgressOff","stopTrackingProgress","progressInterval","numBufferedPercent","bufferedPercent_","duration_","manualTimeUpdates","manualTimeUpdatesOff","currentTimeInterval","manuallyTriggered","clearTracks","removeRemoteTextTrack","cleanupAutoTextTracks","reset","setCrossOrigin","error_","played","setScrubbing","scrubbing","setCurrentTime","trackListChanges","addWebVttScript_","script","remoteTracks","remoteTextTracks","handleAddTrack","handleRemoveTrack","updateDisplay","textTracksChanges","addTextTrack","createTrackHelper","createRemoteTextTrack","manualCleanup","htmlTrackElement","remoteTextTrackEls","getVideoPlaybackQuality","requestPictureInPicture","Promise","reject","disablePictureInPicture","setDisablePictureInPicture","cb","setPoster","playsinline","setPlaysinline","overrideNativeAudioTracks","overrideNativeVideoTracks","canPlayType","srcObj","techs_","canPlaySource","defaultTechOrder_","featuresVolumeControl","featuresMuteControl","featuresFullscreenResize","featuresPlaybackRate","featuresSourceset","featuresVideoFrameCallback","withSourceHandlers","_Tech","registerSourceHandler","handler","sourceHandlers","can","selectSourceHandler","canHandleSource","sh","originalFn","sourceHandler_","setSource","nativeSourceHandler","currentSource_","handleSource","registerTech","middlewares","middlewareInstances","TERMINATOR","next","setSourceHelper","mediate","middleware","arg","callMethod","middlewareValue","middlewareIterator","terminated","executeRight","allowedGetters","muted","seekable","volume","ended","allowedSetters","setMuted","setVolume","allowedMediators","mw","mws","getOrCreateFactory","mwFactory","mwf","mwi","lastRun","mwrest","_src","MimetypesKind","opus","ogv","mp4","mov","m4v","mkv","m4a","mp3","aac","caf","flac","oga","wav","m3u8","mpd","jpg","jpeg","gif","png","svg","webp","getMimetype","ext","mimetype","filterSource","newsrc","srcobj","fixSource","j","techOrder","techName","getTech","isSupported","loadTech_","ClickableComponent","handleMouseOver_","handleMouseOver","handleMouseOut_","handleMouseOut","handleClick_","handleClick","tabIndex_","createControlTextEl","controlTextEl_","controlText_","localizedText","nonIconControl","noUITitleAttributes","enabled_","clickHandler","PosterImage","update","update_","loading","crossorigin","poster","setSrc","fontMap","monospace","sansSerif","serif","monospaceSansSerif","monospaceSerif","proportionalSansSerif","proportionalSerif","casual","smallcaps","constructColor","opacity","hex","tryUpdateStyle","updateDisplayHandler","toggleDisplay","preselectTrack","screenOrientation","screen","orientation","changeOrientationEvent","modes","userPref","cache_","selectedLanguage","firstDesc","firstCaptions","preferredTrack","clearDisplay","allowMultipleShowingTracks","showingTracks","updateForTrack","descriptionsTrack","captionsSubtitlesTrack","updateDisplayState","overrides","textTrackSettings","getValues","textOpacity","backgroundOpacity","windowColor","windowOpacity","edgeStyle","textShadow","fontPercent","fontFamily","fontVariant","cueEl","isAudio","playerType","dir","Button","BigPlayButton","mouseused_","handleMouseDown","playPromise","playToggle","playFocus","PlayToggle","replay","handlePlay","handlePause","handleEnded","handleSeeked","TimeDisplay","updateContent","updateTextNode_","span","labelText_","textNode_","time","formattedTime_","oldNode","CurrentTimeDisplay","getCache","DurationDisplay","RemainingTimeDisplay","displayNegative","remainingTimeDisplay","remainingTime","updateShowing","SeekToLive","updateLiveEdgeStatus","liveTracker","updateLiveEdgeStatusHandler_","textEl_","atLiveEdge","seekToLiveEdge","clamp","number","Num","Slider","handleMouseDown_","handleMouseUp_","handleMouseUp","handleMouseMove_","handleMouseMove","bar","barName","playerEvent","progress","getProgress","progress_","sizeKey","toFixed","getPercent","calculateDistance","stepBack","stepForward","bool","vertical_","percentify","partEls_","loadedText","separator","percentageEl_","isLive","seekableEnd","bufferedEnd","percent_","part","dataset","seekBarRect","seekBarPoint","tooltipRect","playerRect","seekBarPointPx","spaceLeftOfPoint","spaceRightOfPoint","pullTooltipBy","write","updateTime","liveWindow","secondsBehind","PlayProgressBar","timeTooltip","MouseTimeDisplay","SeekBar","setEventHandlers_","updateInterval","enableIntervalHandler_","enableInterval_","disableIntervalHandler_","disableInterval_","toggleVisibility_","visibilityState","getCurrentTime_","liveCurrentTime","currentTime_","userSeek_","nextSeekedFromUser","seekableStart","videoWasPlaying","newTime","mouseDown","distance","mouseTimeDisplay","handleAction","gotoFraction","STEP_SECONDS","ProgressControl","throttledHandleMouseSeek","handleMouseSeek","handleMouseUpHandler_","handleMouseDownHandler_","seekBar","playProgressBar","seekBarEl","removeListenersAddedOnMousedownAndTouchstart","PictureInPictureToggle","handlePictureInPictureChange","handlePictureInPictureEnabledChange","currentType","substring","audioPosterMode","audioOnlyMode","isInPictureInPicture","exitPictureInPicture","pictureInPictureEnabled","FullscreenToggle","handleFullscreenChange","fsApi_","fullscreenEnabled","isFullscreen","exitFullscreen","requestFullscreen","rangeBarRect","rangeBarPoint","volumeBarPointPx","updateVolume","MouseVolumeLevelDisplay","VolumeBar","updateLastVolume_","updateARIAAttributes","mouseVolumeLevelDisplay","volumeBarEl","volumeBarRect","volumeBarPoint","checkMuted","ariaValue","volumeAsPercentage_","volumeBeforeDrag","lastVolume_","VolumeControl","volumeBar","checkVolumeSupport","throttledHandleMouseMove","orientationClass","MuteToggle","checkMuteSupport","vol","lastVolume","volumeToSet","updateIcon_","updateControlText_","VolumePanel","inline","volumeControl","handleKeyPressHandler_","volumePanelState_","muteToggle","handleVolumeControlKeyUp","sliderActive_","sliderInactive_","Menu","menuButton_","menuButton","focusedChild_","boundHandleBlur_","handleBlur","boundHandleTapClick_","handleTapClick","addEventListenerForItem","removeEventListenerForItem","addItem","childComponent","contentElType","append","btn","buttonPressed_","unpressButton","childComponents","foundComponent","stepChild","MenuButton","buttonClass","handleMenuKeyUp_","handleMenuKeyUp","menu","handleMouseLeave","handleSubmenuKeyDown","createMenu","items","hideThreshold_","titleEl","titleComponent","createItems","buildWrapperCSSClass","menuButtonClass","pressButton","handleSubmenuKeyPress","TrackButton","updateHandler","MenuKeys","MenuItem","selectable","isSelected_","multiSelectable","TextTrackMenuItem","kinds","changeHandler","_this3","handleTracksChange","selectedLanguageChangeHandler","handleSelectedLanguageChange","onchange","Event","createEvent","initEvent","referenceTrack","shouldBeSelected","OffTextTrackMenuItem","allHidden","TextTrackButton","TrackMenuItem","label_","kinds_","kind_","ChaptersTrackMenuItem","ChaptersButton","selectCurrentItem_","track_","findChaptersTrack","setTrack","updateHandler_","remoteTextTrackEl","getMenuCaption","mi","DescriptionsButton","SubtitlesButton","CaptionSettingsMenuItem","CaptionsButton","SubsCapsMenuItem","parentSpan","SubsCapsButton","language_","AudioTrackMenuItem","audioTracks","_this4","featuresNativeAudioTracks","AudioTrackButton","PlaybackRateMenuItem","rate","playbackRate","PlaybackRateMenuButton","labelElId_","updateVisibility","updateLabel","handlePlaybackRateschange","labelEl_","rates","playbackRates","playbackRateSupported","Spacer","ControlBar","ErrorDisplay","COLOR_BLACK","COLOR_BLUE","COLOR_CYAN","COLOR_GREEN","COLOR_MAGENTA","COLOR_RED","COLOR_WHITE","COLOR_YELLOW","OPACITY_OPAQUE","OPACITY_SEMI","OPACITY_TRANS","selectConfigs","parseOptionValue","endDialog","setDefaults","persistTextTrackSettings","saveSettings","config","restoreSettings","createElSelect_","legendId","selectLabelledbyIds","optionId","createElFgColor_","createElBgColor_","createElWinColor_","createElColors_","createElFont_","createElControls_","defaultsDescription","selectedIndex","setValues","setSelectedOption","localStorage","getItem","setItem","removeItem","ttDisplay","controlBar","subsCapsBtn","subsCapsButton","ccBtn","captionsButton","RESIZE_OBSERVER_AVAILABLE","ResizeObserver","loadListener_","resizeObserver_","debouncedHandler_","resizeHandler","observe","contentWindow","unloadListener_","unobserve","disconnect","resizeObserver","defaults","trackingThreshold","liveTolerance","trackLiveHandler_","trackLive_","handlePlay_","handleFirstTimeupdate_","handleFirstTimeupdate","handleSeeked_","seekToLiveEdge_","reset_","handleDurationchange","toggleTracking","deltaTime","lastTime_","pastSeekEnd_","pastSeekEnd","isBehind","seekedBehindLive_","timeupdateSeen_","behindLiveEdge_","liveui","isTracking","hasStarted","trackingInterval_","timeDiff","nextSeekedFromUser_","lastSeekEnd_","seekableEnds","sort","seekableStarts","behindLiveEdge","updateDom_","els","techEl","techAriaAttrs","techAriaAttr","sourcesetLoad","srcUrls","innerHTMLDescriptorPolyfill","cloneNode","dummy","docFrag","createDocumentFragment","Element","getDescriptor","priority","descriptor","getOwnPropertyDescriptor","firstSourceWatch","resetSourceWatch_","innerDescriptor","HTMLMediaElement","getInnerHTMLDescriptor","appendWrapper","appendFn","retval","srcDescriptorPolyfill","setupSourceset","resetSourceset_","srcDescriptor","getSrcDescriptor","oldSetAttribute","oldLoad","currentSrc","Html5","crossoriginTracks","initNetworkState_","handleLateInit_","enableSourceset","setupSourcesetHandling_","isScrubbing_","hasChildNodes","nodes","nodesLength","removeNodes","proxyNativeTracks_","restoreMetadataTracksInIOSNativePlayer_","setControls","proxyWebkitFullscreen_","disposeMediaElement","metadataTracksPreFullscreenState","takeMetadataTrackSnapshot","storedMode","restoreTrackMode","storedTrack","overrideNative_","override","lowerCaseType","eventName","proxyNativeTracksForType_","elTracks","techTracks","listeners","currentTarget","removeOldTracks","removeTracks","found","playerElIngest","movingMediaElementInDOM","clone","techId","class","playerId","preload","settingsAttrs","attr","networkState","loadstartFired","setLoadstartFired","triggerLoadstart","eventsToTrigger","isScrubbing","fastSeek","checkProgress","NaN","endFn","beginFn","webkitPresentationMode","nativeIOSFullscreen","supportsFullScreen","webkitEnterFullScreen","enterFullScreen","HAVE_METADATA","exitFullScreen","webkitDisplayingFullscreen","webkitExitFullScreen","webkitKeys","resetMediaElement","videoPlaybackQuality","webkitDroppedFrameCount","webkitDecodedFrameCount","droppedVideoFrames","totalVideoFrames","creationTime","TEST_VID","canControlVolume","canControl","canMuteVolume","canControlPlaybackRate","canOverrideAttributes","noop","supportsNativeTextTracks","supportsNativeVideoTracks","videoTracks","supportsNativeAudioTracks","TECH_EVENTS_RETRIGGER","TECH_EVENTS_QUEUE","canplay","canplaythrough","playing","seeked","BREAKPOINT_ORDER","BREAKPOINT_CLASSES","charAt","DEFAULT_BREAKPOINTS","tiny","xsmall","small","medium","large","xlarge","huge","getTagSettings","closest","boundDocumentFullscreenChange_","documentFullscreenChange_","boundFullWindowOnEscKey_","fullWindowOnEscKey","boundUpdateStyleEl_","updateStyleEl_","boundApplyInitTime_","applyInitTime_","boundUpdateCurrentBreakpoint_","updateCurrentBreakpoint_","boundHandleTechClick_","handleTechClick_","boundHandleTechDoubleClick_","handleTechDoubleClick_","boundHandleTechTouchStart_","handleTechTouchStart_","boundHandleTechTouchMove_","handleTechTouchMove_","boundHandleTechTouchEnd_","handleTechTouchEnd_","boundHandleTechTap_","handleTechTap_","isFullscreen_","isPosterFromTech_","queuedCallbacks_","userActive_","debugEnabled_","audioOnlyMode_","audioPosterMode_","audioOnlyCache_","playerHeight","hiddenChildren","tagAttributes","languagesToLower","languages_","resetCache_","poster_","controls_","changingSrc_","playCallbacks_","playTerminatedQueue_","autoplay","plugins","scrubbing_","fullscreenchange","fluid_","playerOptionsCopy","middleware_","majorVersion","userActive","listenForUserActivity_","breakpoints","responsive","styleEl_","playerElIngest_","divEmbed","tabindex","VIDEOJS_NO_DYNAMIC_STYLE","defaultsStyleEl","head","fill_","fluid","aspectRatio","links","linkEl","techGet_","techCall_","posterImage","privDimension","parsedVal","ratio","aspectRatio_","width_","height_","idClass","videoWidth","videoHeight","ratioParts","ratioMultiplier","unloadTech_","titleTechName","camelTechName","techName_","normalizeAutoplay","techOptions","loop","techCanOverridePoster","TechClass","handleTechReady_","textTracksJson_","eventObj","seeking","handleTechLoadStart_","handleTechSourceset_","handleTechWaiting_","handleTechEnded_","handleTechSeeking_","handleTechPlay_","handleTechPause_","handleTechDurationChange_","handleTechFullscreenChange_","handleTechFullscreenError_","handleTechEnterPictureInPicture_","handleTechLeavePictureInPicture_","handleTechError_","handleTechPosterChange_","handleTechTextData_","handleTechRateChange_","usingNativeControls","addTechControlsListeners_","safety","removeTechControlsListeners_","manualAutoplay_","resolveMuted","previouslyMuted","restoreMuted","mutedPromise","catch","promise","updateSourceCaches_","matchingSources","findMimetype","sourceElSources","sourceEls","matchingSourceEls","sourceObj","updateSourceCaches","playerSrc","currentSource","eventSrc","lastSource_","techSrc","techGet","request","lastPlaybackRate","queued","timeWhenWaiting","timeUpdateListener","handleTechCanPlay_","handleTechCanPlayThrough_","handleTechPlaying_","handleTechSeeked_","userActions","click","doubleClick","userWasActive","cancelable","toggleFullscreenClass_","targetPlayer","isFs","matches","fullscreen","msMatchesSelector","togglePictureInPictureClass_","initTime","inactivityTimeout","defaultPlaybackRate","media","reduceRight","resolve","play_","isSrcReady","waitToPlay_","runPlayTerminatedQueue_","runPlayCallbacks_","queue","q","callbacks","percentAsDecimal","defaultMuted","isFS","oldValue","fullscreenOptions","offHandler","errorHandler","requestFullscreenHelper_","fsOptions","preferFullWindow","enterFullWindow","exitFullscreenHelper_","exitFullWindow","isFullWindow","docOrigOverflow","overflow","isPiP","isInPictureInPicture_","hotkeys","isContentEditable","excludeElement","handleHotkeys","fullscreenKey","keydownEvent","muteKey","playPauseKey","FSToggle","selectSource","techs","_ref6","findFirstPassingTechSourcePair","outerArray","innerArray","tester","outerChoice","innerChoice","foundSourceAndTech","finder","sourceOrder","handleSrc_","isRetry","resetRetryOnError_","middlewareSource","src_","notSupportedMessage","setTech","retry","stopListeningForErrors","sourceTech","doReset_","resetControlBarUI_","resetProgressBar_","resetPlaybackRate_","resetVolumeBar_","durationDisplay","currentSources","techAutoplay","newPoster","usingNativeControls_","hookFunction","newErr","suppressNotSupportedError","triggerSuppressedError","errorDisplay","userActivity_","mouseInProgress","lastMoveX","lastMoveY","handleActivity","handleMouseUpAndMouseLeave","screenX","screenY","isAudio_","enableAudioOnlyUI_","playerChildren","controlBarHeight","disableAudioOnlyUI_","exitPromises","enablePosterModeUI_","disablePosterModeUI_","toJSON","createModal","modal","currentBreakpoint","candidateBreakpoint","breakpoints_","breakpoint_","removeCurrentBreakpoint_","currentBreakpointClass","responsive_","loadMedia","artist","artwork","tt","titleBar","getMedia","baseOptions","tagOptions","dataSetup","childName","previousLogLevel_","newRates","html5","userLanguage","navigationUI","pluginStorage","pluginExists","getPlugin","markPluginAsActive","triggerSetupEvent","before","createPluginFactory","PluginSubClass","plugin","instance","getEventHash","Plugin","VERSION","isBasic","basicPluginWrapper","createBasicPlugin","deprecateForMajor","oldName","newName","warned","deprecate","BASE_PLUGIN_NAME","registerPlugin","usingPlugin","hasPlugin","normalizeId","getPlayer","defaultView","PlayerComponent","hook","hookOnce","original","getPlayers","nId","getAllPlayers","comp","use","writeable","mergeOptions","deregisterPlugin","getPlugins","getPluginVersion","addLanguage","EventTarget","dom","_interopDefaultLegacy","videojs__default","QualityLevel","representation","bitrate","bandwidth","frameRate","QualityLevelList","levels_","selectedIndex_","addQualityLevel","qualityLevel","getQualityLevelById","removeQualityLevel","removed","addqualitylevel","removequalitylevel","initPlugin","originalPluginFn","qualityLevels","qualityLevelList","disposeHandler","urlToolkit","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","alwaysNormalize","basePartsForNormalise","parseURL","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","builtParts","query","fragment","baseURLPath","newPath","lastIndexOf","parts","Stream","_proto","_length","_i","pipe","destination","decodeB64ToUint8Array$1","b64Text","decodedString","atob","Buffer","LineStream","nextNewline","TAB","parseByterange","byterangeString","offset","parseAttributes$1","ParseStream","customParsers","tagMappers","mapper","mappedLine","newLine","tagType","playlistType","allowed","URI","BYTERANGE","byterange","RESOLUTION","resolution","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","Uint32Array","PRECISE","subkey","addParser","expression","customType","dataParser","segment","addTagMapper","camelCaseKeys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","hb","phb","minTargetDuration","minPartDuration","lineStream","parseStream","uris","currentMap","currentUri","hasParts","defaultMediaGroups","currentTimeline","allowCache","discontinuityStarts","segments","lastByterangeEnd","lastPartByterangeEnd","preloadHints","timeline","preloadSegment","entry","mediaGroup","rendition","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","KEYID","schemeIdUri","keyId","pssh","iv","isFinite","playlist","playlists","mediaGroups","TYPE","NAME","mediaGroupType","autoselect","AUTOSELECT","LANGUAGE","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","targetduration","timeOffset","precise","cueOut","cueOutCont","cueIn","skip","warnOnMissingAttributes_","segmentIndex","partIndex","renditionReports","r","canBlockReload","canSkipDateranges","hint","isPart","otherHint","required","partInf","partTarget","comment","custom","identifier","missing","chunk","regexs","webm","ogg","muxerVideo","muxerAudio","muxerText","mediaTypes","upperMediaTypes","translateLegacyCodec","codec","orig","profile","avcLevel","parseCodecs","codecString","codecs","codecType","mediaType","isAudioCodec","getMimeForCodec","browserSupportsCodec","MediaSource","isTypeSupported","muxerSupportsCodec","MPEGURL_REGEX","DASH_REGEX","simpleTypeFromSourceType","isArrayBufferView","ArrayBuffer","isView","toUint8","bytes","byteOffset","byteLength","BigInt","BYTE_TABLE","Uint16Array","bytesToNumber","_temp","_ref","_ref$signed","signed","_ref$le","le","total","byte","exponent","numberToBytes","_temp2","_ref2$le","byteCount","countBits","countBytes","byteIndex","stringToBytes","stringIsBytes","unescape","view","bytesMatch","_temp3","_ref3","_ref3$offset","_ref3$mask","mask","bByte","resolveUrl$1","baseUrl","relativeUrl","nativeURL","URL","protocolLess","removeLocation","newUrl","decodeB64ToUint8Array","oc","MIME_TYPE","HTML","isHTML","XML_APPLICATION","XML_TEXT","XML_XHTML_APPLICATION","XML_SVG_IMAGE","NAMESPACE$3","SVG","XML","XMLNS","conventions","ac","NAMESPACE","NAMESPACE$2","notEmptyString","orderedSetReducer","toOrderedSet","splitOnASCIIWhitespace","copy","dest","Class","Super","pt","NodeType","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","ExceptionCode","ExceptionMessage","INDEX_SIZE_ERR","DOMSTRING_SIZE_ERR","HIERARCHY_REQUEST_ERR","WRONG_DOCUMENT_ERR","INVALID_CHARACTER_ERR","NO_DATA_ALLOWED_ERR","NO_MODIFICATION_ALLOWED_ERR","NOT_FOUND_ERR","NOT_SUPPORTED_ERR","INUSE_ATTRIBUTE_ERR","DOMException","captureStackTrace","NodeList","LiveNodeList","refresh","_node","_refresh","_updateLiveList","inc","_inc","ls","__set__","NamedNodeMap","_findNodeIndex","_addNamedNode","newAttr","oldAttr","ownerElement","_onRemoveAttribute","namespaceURI","_nsMap","prefix","_onAddAttribute","_removeNamedNode","lastIndex","DOMImplementation$1","Node","_xmlEncoder","_visitNode","Document","_onUpdateChild","cs","_removeChild","previous","previousSibling","lastChild","isDocTypeNode","isElementNode","isElementInsertionPossible","parentChildNodes","docTypeNode","isElementReplacementPossible","assertPreInsertionValidity1to5","hasValidParentNodeType","hasInsertableNodeType","assertPreInsertionValidityInDocument","nodeChildNodes","nodeChildElements","parentElementChild","assertPreReplacementValidityInDocument","hasDoctypeChildThatIsNotChild","_insertBefore","_inDocumentAssertion","cp","newFirst","newLast","pre","Attr","CharacterData","Text","Comment","CDATASection","DocumentType","Notation","Entity","EntityReference","DocumentFragment","ProcessingInstruction","XMLSerializer","nodeSerializeToString","isHtml","nodeFilter","buf","lookupPrefix","visibleNamespaces","namespace","serializeToString","needNamespaceDefine","ns","addSerializedAttribute","qualifiedName","len","prefixedNodeName","defaultNS","ai","nsi","pubid","publicId","sysid","systemId","sub","internalSubset","importNode","deep","node2","attrs2","_ownerElement","setAttributeNode","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","NAMESPACE_ERR","INVALID_ACCESS_ERR","getNamedItem","setNamedItem","setNamedItemNS","getNamedItemNS","removeNamedItem","removeNamedItemNS","hasFeature","feature","createDocument","doctype","root","createElementNS","createDocumentType","nodeValue","refChild","oldChild","normalize","appendData","hasAttributes","lookupNamespaceURI","isDefaultNamespace","importedNode","getElementById","rtv","getElementsByClassName","classNames","classNamesSet","base","nodeClassNames","nodeClassNamesSet","createComment","createCDATASection","createAttribute","specified","createEntityReference","pl","createAttributeNS","getAttributeNode","removeAttributeNode","_appendSingleChild","setAttributeNodeNS","removeAttributeNS","getAttributeNodeNS","hasAttributeNS","getAttributeNS","setAttributeNS","getElementsByTagNameNS","substringData","insertData","replaceData","deleteData","splitText","newText","newNode","getTextContent","$$length","DOMImplementation","entities","XML_ENTITIES","amp","apos","gt","lt","quot","HTML_ENTITIES","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","forall","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","there4","sim","cong","asymp","ne","equiv","ge","sup","nsub","sube","supe","oplus","otimes","perp","sdot","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","euro","trade","larr","uarr","rarr","darr","harr","crarr","lceil","rceil","lfloor","rfloor","loz","spades","clubs","hearts","diams","entityMap","NAMESPACE$1","nameStartChar","nameChar","tagNamePattern","ParseError$1","locator","XMLReader$1","copyLocator","lineNumber","columnNumber","parseElementStartPart","currentNSMap","entityReplacer","addAttribute","qname","startIndex","attributeNames","fatalError","addValue","warning","setTagName","closed","appendElement$1","domBuilder","localNSMap","qName","nsp","nsPrefix","_copy","startPrefixMapping","startElement","endElement","endPrefixMapping","parseHtmlSpecialContent","elStartEnd","elEndStart","characters","fixSelfClosed","closeMap","parseDCC","startCDATA","endCDATA","matchs","lastMatch","startDTD","endDTD","parseInstruction","processingInstruction","ElementAttributes","defaultNSMap","startDocument","defaultNSMapCopy","fixedFromCharCode","surrogate1","surrogate2","appendText","xt","lineEnd","linePattern","lineStart","parseStack","tagStart","currentElement","endMatch","locator2","parse$1","endDocument","getLocalName","getLocator","getQName","getURI","sax","XMLReader","ParseError","normalizeLineEndings","DOMParser$1","DOMHandler","cdata","_locator","_toString","chars","java","appendElement","hander","parseFromString","mimeType","xmlns","setDocumentLocator","errorImpl","isCallback","Function","build","msg","buildErrorHandler","xml","documentURI","ins","ignorableWhitespace","ch","charNode","skippedEntity","comm","impl","dt","DOMParser","__DOMHandler","merge$1","objects","flatten","lists","urlTypeToSegment","_ref10","range","indexRange","resolvedUri","startRange","endRange","MAX_SAFE_INTEGER","parseEndNumber","endNumber","segmentRange","static","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","periodStart","minimumUpdatePeriod","timeShiftBufferDepth","periodStartWC","segmentCount","availableStart","availableEnd","parseByDuration","startNumber","toSegments","sectionDuration","segmentsFromBase","initialization","presentationTime","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","sidx","sidxByteRange","sidxEnd","mediaReferences","references","referenceType","firstOffset","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","getUniqueTimelineStarts","timelineStarts","keyFunction","_ref11","getMediaGroupPlaylists","mediaGroupPlaylists","master","group","groupKey","labelKey","mediaProperties","updateMediaSequenceForPlaylist","_ref12","positionManifestOnTimeline","_ref15","oldManifest","newManifest","oldPlaylists","newPlaylists","_ref13","findIndex","oldPlaylist","findPlaylistWithName","firstNewSegment","oldMatchingSegmentIndex","oldSegment","updateSequenceNumbers","generateSidxKey","byteRangeToString","mergeDiscontiguousPlaylists","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatAudioPlaylist","isAudioOnly","CODECS","AUDIO","SUBTITLES","formatVttPlaylist","_ref17","m3u8Attributes","formatVideoPlaylist","_ref18","videoOnly","_ref19","audioOnly","_ref20","vttOnly","_ref21","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref23","dashPlaylists","locations","previousManifest","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captionServices","VIDEO","organizedAudioGroup","mainPlaylist","formattedPlaylists","roleLabel","formatted","organizeAudioPlaylists","organizedVttGroup","organizeVttPlaylists","playlistTimelineStarts","_ref24","subs","cc","svcObj","svc","service","channel","easyReader","getLiveRValue","parseByTimeline","segmentTimeline","sIndex","S","d","repeat","segmentTime","nextS","identifierPattern","constructTemplateUrl","format","identifierReplacement","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","parseTemplateInfo","presentationTimeOffset","segmentsFromList","segmentUrls","segmentUrlMap","segmentUrlObject","segmentUrl","mediaRange","SegmentURLToSegmentObject","generateSegments","_ref25","segmentAttributes","segmentsFn","segmentInfo","template","segmentsInfo","toPlaylists","representations","findChildren","_ref26","getContent","parseDuration","year","month","day","hour","minute","second","parsers","mediaPresentationDuration","parseDivisionValue","parsedValue","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","adaptationSetAttributes","adaptationSetBaseUrls","roleAttributes","accessibility","flags","opt","parseCaptionServiceMetadata","labelVal","keySystem","psshNode","adaptationSetSegmentInfo","repBaseUrlElements","repBaseUrls","representationSegmentInfo","inheritBaseUrls","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","adaptationSets","getPeriodStart","_ref27","priorPeriodAttributes","mpdType","inheritAttributes","manifestUri","periodNodes","periods","priorPeriod","representationInfo","stringToMpdXml","manifestString","parseUTCTiming","UTCTimingNode","parseUTCTimingScheme","MAX_UINT32","pow","getUint64","uint8","dv","DataView","getBigUint64","getUint32","parseSidx_1","subarray","referenceId","earliestPresentationTime","referenceCount","getUint16","startsWithSap","sapType","sapDeltaTime","ID3","getId3Offset","returnSize","getId3Size","normalizePath$1","findBox","paths","complete","normalizePaths$1","results","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getvint","removeLength","getLength","valueBytes","getInfinityDataSize","innerid","dataHeader","findEbml","normalizePaths","dataStart","dataEnd","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","positions","newLength","newData","sourceIndex","findNal","dataType","nalLimit","nalStart","nalsFound","nalOffset","nalType","CONSTANTS","_isLikely","docType","matroska","fmp4","moof","moov","ac3","avi","riff","findH264Nal","findH265Nal","isLikelyTypes","isLikelyFn","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","isLikely","detectContainerForBytes","sampleRate","timestamp","clock_1","resolveUrl","resolveManifestRedirect","req","responseURL","logger","filterRanges","timeRanges","findRange","TIME_FUDGE_FACTOR","findNextRange","printableRange","strArr","timeRangesToArray","timeRangesList","lastBufferedEnd","timeAheadOf","segmentDurationWithParts","getPartsAndSegments","si","getLastParts","lastSegment","getKnownPartCount","_ref28","partCount","liveEdgeDelay","partHoldBack","holdBack","intervalDuration","endSequence","expired","backward","backwardDuration","forward","forwardDuration","totalDuration","sumDurations","defaultDuration","durationList","durations","playlistEnd","useSafeLiveEnd","liveEdgePadding","lastSegmentEndTime","isExcluded","excludeUntil","isIncompatible","isEnabled","excluded","isLowestEnabledRendition","currentBandwidth","MAX_VALUE","playlistMatch","someAudioVariant","groupName","variant","Playlist","getMediaInfoForTime","startingSegmentIndex","startingPartIndex","exactManifestTimings","partsAndSegments","partAndSegment","isDisabled","isAes","estimateSegmentRequestTime","bytesReceived","createPlaylistID","forEachMediaGroup","setupMediaPlaylist","_ref32","playlistErrors_","addPropertiesToMain","phonyUri","audioOnlyMain","groupId","setupMediaPlaylists","resolveMediaGroupUris","EventTarget$1","updateSegment","skipped","updateSegments","oldSegments","newSegments","newIndex","newSegment","resolveSegmentUris","baseUri","getAllSegments","isPlaylistUnchanged","updateMain$1","newMedia","unchangedCheck","oldMedia","mergedPlaylist","skippedSegments","refreshDelay","lastPart","lastDuration","PlaylistLoader","vhs","logger_","vhs_","vhsOptions","customTagParsers","customTagMappers","llhls","handleMediaupdatetimeout_","parameters","nextMSN","nextPart","_HLS_part","_HLS_msn","canSkipUntil","_HLS_skip","parsedUri","searchParams","addLLHLSQueryDirectives","playlistRequestError","haveMetadata","playlistString","startingState","parseManifest_","_ref31","onwarn","oninfo","customParser","parseManifest","_ref34","_ref35","playlistObject","lastRequest","pendingMedia_","media_","updateMediaUpdateTimeout_","stopRequest","mediaUpdateTimeout","finalRenditionTimeout","oldRequest","shouldDelay","delay","mediaChange","mainPlaylistRef","started","setupInitialPlaylist","srcUri","mainForMedia","videojsXHR","callbackWrapper","reqResponse","responseTime","roundTripTime","requestTime","responseHeaders","timedout","xhrFactory","XhrFunction","beforeRequest","Vhs","newOptions","originalAbort","segmentXhrHeaders","Range","byterangeEnd","byterangeStart","byterangeStr","textRange","formatHexString","formatAsciiString","createTransferableMessage","transferable","initSegmentId","segmentKeyId","hexDump","ascii","utils","tagDump","_ref37","textRanges","getProgramTime","_ref38","matchedSegment","segmentEnd","videoTimingInfo","transmuxedPresentationEnd","estimatedStart","transmuxedPresentationStart","findSegmentForPlayerTime","seekTime","programTimeObject","mediaSeconds","programTime","playerTime","transmuxerPrependedSeconds","offsetFromSegmentStart","getTime","playerTimeToProgramTime","programDateTime","toISOString","seekToProgramTime","_ref39","retryCount","seekTo","pauseAfterSeek","verifyProgramDateTimeTags","lastSegmentStart","lastSegmentDuration","findSegmentForProgramTime","mediaOffset","comparisonTimeStamp","segmentDateTime","segmentTimeEpoch","getOffsetFromTimestamp","seekToTime","callbackOnCompleted","containerRequest","id3Offset","finished","endRequestAndCallback","_bytes","progressListener","newPart","_len","buffers","_key","totalLen","tempBuffer","concatTypedArrays","overrideMimeType","loaded","dashPlaylistUnchanged","aSegment","bSegment","aByterange","bByterange","parseMainXml","_ref41","mainXml","srcUrl","parsedManifestInfo","equivalentSidx","compareSidxEntry","oldSidxMapping","newSidxMapping","currentSidxInfo","savedSidxInfo","sidxInfo","DashPlaylistLoader","srcUrlOrPlaylist","mainPlaylistLoader","mainPlaylistLoader_","isMain_","refreshXml_","refreshMedia_","loadedPlaylists_","sidxMapping_","childPlaylist_","requestErrored_","addSidxSegments_","mediaRequest_","fin","internal","playlistExclusionDuration","minimumUpdatePeriodTimeout_","createMupOnMedia_","hasPendingRequest","sidxChanged","isFinalRendition","updateMinimumUpdatePeriodTimeout_","requestMain_","mainChanged","haveMain_","mainXml_","date","mainLoaded_","handleMain_","syncClientServerClock_","done","utcTiming","clientOffset_","serverTime","oldMain","newMain","noChanges","playlistUpdate","updateMain","mpl","mup","createMUPTimeout_","mediaGroupSidx","filterChangedSidxMappings","mediaID","mediaChanged","createMediaUpdateTimeout","Config","GOAL_BUFFER_LENGTH","MAX_GOAL_BUFFER_LENGTH","BACK_BUFFER_LENGTH","GOAL_BUFFER_LENGTH_RATE","INITIAL_BANDWIDTH","BANDWIDTH_VARIANCE","BUFFER_LOW_WATER_LINE","MAX_BUFFER_LOW_WATER_LINE","EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE","BUFFER_LOW_WATER_LINE_RATE","BUFFER_HIGH_WATER_LINE","browserWorkerPolyFill","workerObj","objectUrl","createObjectURL","Blob","blob","BlobBuilder","getBlob","worker","Worker","objURL","terminate","revokeObjectURL","getWorkerString","workerCode$1","Stream$8","init","flushSource","partialFlush","endTimeline","dinf","esds","ftyp","mfhd","minf","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun$1","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","videoSample","audioSample","audioTrun","videoTrun","trunHeader","MAX_UINT32$1","numbers","avc1","avcC","btrt","dref","mdat","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","trun","vmhd","payload","setUint32","audioobjecttype","samplingfrequencyindex","channelcount","samplerate","sequenceNumber","trackFragments","samples","dependsOn","isDependedOn","hasRedundancy","avc1Box","sps","pps","sequenceParameterSets","pictureParameterSets","profileIdc","profileCompatibility","levelIdc","sarRatio","hSpacing","vSpacing","samplesize","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","silence","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","mp4Generator","fileType","movie","sampleForFrame","frame","dataOffset","pts","dts","keyFrame","frameUtils$1","groupNalsIntoFrames","nalUnits","currentNal","currentFrame","frames","nalCount","nalUnitType","groupFramesIntoGops","currentGop","gops","extendFirstKeyFrame","generateSampleTable","baseDataOffset","concatenateNalData","nalsByteLength","numberOfNals","generateSampleTableForFrame","concatenateNalDataForFrame","highPrefix","lowPrefix","zeroFill","timelineStartPts","keepOriginalTimestamps","clock$2","ONE_SECOND_IN_TS","coneOfSilence","metaTable","arr","clock$1","audioFrameUtils$1","prefixWithSilence","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","frameDuration","silentFrame","firstFrame","audioGapDuration","audioFillFrameCount","audioFillDuration","trimAdtsFramesByEarliestDts","adtsFrames","earliestAllowedDts","minSegmentDts","minSegmentPts","concatenateFrameData","sumFrameByteLengths","ONE_SECOND_IN_TS$3","trackDecodeInfo$1","clearDtsInfo","maxSegmentDts","maxSegmentPts","calculateTrackBaseMediaDecodeTime","timelineStartInfo","collectDtsInfo","captionPacketParser","parseSei","payloadType","payloadSize","parseUserData","sei","parseCaptionPackets","userData","ccData","emulationPreventionBytesPositions","USER_DATA_REGISTERED_ITU_T_T35","Stream$7","cea708Parser","CaptionStream$2","parse708captions_","parse708captions","captionPackets_","ccStreams_","Cea608Stream","cc708Stream_","Cea708Stream","newCaptionPackets","escapedRBSP","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","idx","presortIndex","packet","dispatchCea608Packet","dispatchCea708Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION_708","within708TextBlock","Cea708Window","windowNum","clearText","pendingNewLine","winAttr","penAttr","penLoc","penColor","visible","rowLock","columnLock","relativePositioning","anchorVertical","anchorHorizontal","anchorPoint","rowCount","virtualRowCount","columnCount","windowStyle","penStyle","getText","rows","rowIdx","beforeRowOverflow","addText","backspace","Cea708Service","serviceNum","encoding","currentWindow","windows","createTextDecoder","startPts","win","setCurrentWindow","textDecoder_","serviceProps","captionServiceEncodings","serviceName","serviceEncodings","current708Packet","services","new708Packet","add708Bytes","push708Packet","ptsVals","byte0","byte1","packet708","packetData","blockSize","seq","sizeCode","pushServiceBlock","initService","handleText","multiByteCharacter","extendedCommands","defineWindow","clearWindows","deleteWindows","displayWindows","hideWindows","toggleWindows","setWindowAttributes","setPenAttributes","setPenColor","setPenLocation","isExtended","getPts","flushDisplayed","char","charCodeArray","newCode","isMultiByte","extended","currentByte","nextByte","firstByte","secondByte","fillOpacity","fillRed","fillGreen","fillBlue","borderType","borderRed","borderGreen","borderBlue","wordWrap","printDirection","scrollDirection","justify","effectSpeed","effectDirection","displayEffect","displayedText","winId","endPts","pushCaption","textTag","penSize","italics","underline","edgeType","fontStyle","fgOpacity","fgRed","fgGreen","fgBlue","bgOpacity","bgRed","bgGreen","bgBlue","edgeRed","edgeGreen","edgeBlue","column","CHARACTER_TRANSLATION","getCharFromCode","ROWS","createDisplayBuffer","BOTTOM_ROW","field","dataChannel","field_","dataChannel_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","formatting_","isColorPAC","isNormalChar","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","newBaseRow","popOn","baseRow","rollUp","paintOn","captionStream","CaptionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","Stream$6","handleRollover$1","TimestampRolloverStream$1","lastDTS","referenceDTS","type_","MetadataStream","timestampRolloverStream","TimestampRolloverStream","handleRollover","typedArray","fromIndex","currentIndex","StreamTypes$3","typedArrayIndexOf","textEncodingDescriptionByte","percentEncode$1","parseUtf8","parseIso88591$1","parseSyncSafeInteger$1","frameParsers","mimeTypeEndIndex","descriptionEndIndex","pictureType","pictureData","owner","privateData","tagSize","bufferSize","dispatchType","frameStart","frameSize","dataAlignmentIndicator","timeStamp","TransportPacketStream","TransportParseStream","ElementaryStream","metadataStream","Stream$4","CaptionStream$1","StreamTypes$2","bytesInBuffer","everything","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","streamType","pid","processPes_","STREAM_TYPES","h264","adts","segmentHadPmt","timedMetadata","forceFlush","packetFlushable","trackId","pes","ptsDtsFlags","startPrefix","packetLength","parsePes","flushStreams_","m2ts$1","PAT_PID","MP2T_PACKET_LENGTH","AdtsStream$1","m2ts_1","ONE_SECOND_IN_TS$2","ADTS_SAMPLING_FREQUENCIES$1","handlePartialSegments","frameNum","skipWarn_","frameLength","protectionSkipBytes","oldBuffer","sampleCount","adtsFrameDuration","ExpGolomb$1","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","skipBits","skipBytes","readBits","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","H264Stream$1","NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","Stream$2","ExpGolomb","syncPoint","swapBuffer","currentPts","currentDts","readSequenceParameterSet","skipScalingList","nalByteStream","nalUnitTypeCode","expGolombDecoder","lastScale","nextScale","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","AacStream$1","H264Stream","ADTS_SAMPLING_FREQUENCIES","parseId3TagSize","parseSyncSafeInteger","isLikelyAacData","parseAdtsSize","lowThree","parseType","parseSampleRate","parseAacTimestamp","percentEncode","aacUtils","setTimestamp","bytesLeft","tempLength","VideoSegmentStream","AudioSegmentStream","Transmuxer","CoalesceStream","frameUtils","audioFrameUtils","trackDecodeInfo","m2ts","clock","AdtsStream","AacStream","ONE_SECOND_IN_TS$1","AUDIO_PROPERTIES","VIDEO_PROPERTIES","retriggerForStream","addPipelineLogRetriggers","transmuxer","pipeline","arrayEquals","generateSegmentTimingInfo","startDts","endDts","prependedContentDuration","firstSequenceNumber","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","videoClockCyclesOfSilencePrefixed","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","dtsDistance","nearestGopObj","currentGopObj","nearestDistance","alignIndex","gopIndex","alignEndIndex","matchFound","trimIndex","alignGopsWith","newGopsToAlignWith","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","caption","id3","captionStreams","cueTime","setRemux","hasFlushed","transmuxPipeline_","setupAacPipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","getLogTrigger_","hasAudio","hasVideo","setupTsPipeline","packetStream","elementaryStream","h264Stream","videoSegmentStream","id3Frame","setBaseMediaDecodeTime","isAac","resetCaptions","getTracks","getTimescaleFromMediaHeader","bin","parseType_1","toUnsigned$2","parseType$2","findBox$2","subresults","toUnsigned$1","getUint64$1","parseTfdt$2","parseSampleFlags","parseTrun$2","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","parseTfhd$2","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","findBox$1","parseTfdt$1","parseTrun$1","parseTfhd$1","window$2","mapToSample","approximateOffset","parseCaptionNals","videoTrackId","trafs","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","headerInfo","truns","allSamples","parseSamples","avcStream","seiNal","lastMatchedSample","avcView","logs","seiNals","matchingSample","findSeiNals","captionParser","segmentCache","parsedCaptions","parsingPartial","isInitialized","isPartial","isNewInit","videoTrackIds","timescales","parsedData","cachedSegment","trackNals","parseEmbeddedCaptions","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","toUnsigned","toHexString","parseType$1","parseTfhd","parseTrun","parseTfdt","window$1","lowestTime","baseTime","scale","traks","tkhdVersion","getUint8","sampleDescriptions","codecConfig","codecBox","probe$2","StreamTypes$1","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","parseNalUnitType","probe$1","pusi","payloadOffset","parsePesType","parsePesTime","videoPacketContainsKeyFrame","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","StreamTypes","probe","parseAudioPes_","pesType","parsed","endLoop","table","parseVideoPes_","firstKeyFrame","inspectTs_","parsePsi_","tsInspector","baseTimestamp","audioCount","audioTimescale","inspectAac_","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","adjustTimestamp_","MessageHandlers","initArray","postMessage","action","gopInfo","timingInfo","videoSegmentTimingInfo","presentation","audioSegmentTimingInfo","trackInfo","audioTimingInfo","wireTransmuxerEvents","pushMp4Captions","trackIds","probeMp4StartTime","probeMp4Tracks","probeTs","baseStartTime","tsStartTime","timeInfo","videoStart","audioStart","clearAllMp4Captions","clearParsedMp4Captions","setTimestampOffset","timestampOffset","appendStart","onmessage","messageHandlers","TransmuxWorker","processTransmux","audioAppendStart","onData","onTrackInfo","onAudioTimingInfo","onVideoTimingInfo","onVideoSegmentTimingInfo","onAudioSegmentTimingInfo","onId3","onCaptions","onDone","onEndedTimeline","onTransmuxerLog","isEndOfTimeline","transmuxedData","waitForEndedTimelineEvent","currentTransmux","videoFrameDtsTime","videoFramePtsTime","handleData_","handleGopInfo_","_ref46","handleDone_","dequeue","transmuxQueue","processAction","enqueueAction","transmux","segmentTransmuxer","term","workerCallback","endAction","listenForEndEvent","isArrayBuffer","transfers","REQUEST_ERRORS","abortAll","activeXhrs","handleErrors","handleKeyResponse","finishProcessingFn","errorObj","parseInitSegment","_ref47","handleSegmentResponse","_ref49","newBytes","stringToArrayBuffer","lastReachedChar","stats","getRequestStats","encryptedBytes","transmuxAndNotify","_ref50","trackInfoFn","timingInfoFn","videoSegmentTimingInfoFn","audioSegmentTimingInfoFn","id3Fn","captionsFn","endedTimelineFn","dataFn","doneFn","fmp4Tracks","isMuxed","audioStartFn","audioEndFn","videoStartFn","videoEndFn","probeResult","id3Frames","handleSegmentBytes","_ref51","bytesAsUint8Array","isLikelyFmp4MediaSegment","isFmp4","audioCodec","videoCodec","finishLoading","_ref52","decrypt","decryptionWorker","decryptionHandler","decrypted","keyBytes","encrypted","waitForCompletion","_ref55","didError","segmentFinish","_ref54","requestId","decryptedBytes","decryptSegment","endOfAllRequests","parseError","handleProgress","_ref57","progressFn","progressEvent","getProgressStats","firstBytesReceivedAt","mediaSegmentRequest","_ref58","xhrOptions","abortFn","keyXhr","mapKeyXhr","initSegmentOptions","initSegmentRequestCallback","_ref48","handleInitSegmentResponse","initSegmentXhr","segmentRequestOptions","segmentXhr","loadendState","activeXhr","_ref56","calledAbortFn","handleLoadEnd","logFn$1","isMaat","mediaAttributes","unwrapCodecList","codecList","_ref59","codecCount","codecObj","codecsForPlaylist","codecInfo","getCodecs","audioGroup","defaultCodecs","audioGroupId","audioType","codecsFromDefault","logFn","representationToString","safeGetComputedStyle","property","stableSort","sortFn","newArray","cmp","comparePlaylistBandwidth","leftBandwidth","rightBandwidth","simpleSelector","playerBandwidth","playerWidth","limitRenditionByPlayerDimensions","playlistController","getAudioTrackPlaylists_","sortedPlaylistReps","rep","enabledPlaylistReps","bandwidthPlaylistReps","highestRemainingBandwidthRep","bandwidthBestRep","chosenRep","haveResolution","resolutionBestRepList","resolutionBestRep","resolutionPlusOneList","resolutionPlusOneSmallest","resolutionPlusOneRep","leastPixelDiffRep","leastPixelDiffSelector","leastPixelDiffList","pixelDiff","lastBandwidthSelector","pixelRatio","useDevicePixelRatio","devicePixelRatio","systemBandwidth","playlistController_","addMetadata","_ref61","inbandTextTracks","metadataArray","videoDuration","Cue","WebKitDataCue","metadataTrack","metadataTrack_","deprecateOldCue","cuesArray","cuesGroupedByStartTime","timeSlot","sortedStartTimes","cueGroup","nextTime","removeCuesFromTrack","finite","segmentInfoString","startOfSegment","mediaIndex","segmentLen","selection","isSyncRequest","independent","hasPartIndex","zeroBasedPartCount","timingInfoPropertyForMedia","shouldWaitForTimelineChange","_ref63","timelineChangeController","loaderType","audioDisabled","lastMainTimelineChange","lastTimelineChange","pendingAudioTimelineChange","pendingTimelineChange","segmentTooLong","_ref64","maxDuration","getTroublesomeSegmentDurationMessage","sourceType","timingInfos","typeTimingInfo","mediaDuration","isSegmentWayTooLong","isSegmentSlightlyTooLong","segmentTooLongMessage","severity","SegmentLoader","mediaSource","throughput","roundTrip","resetStats_","hasPlayed_","hasPlayed","seekable_","seeking_","mediaSource_","loaderType_","currentMediaInfo_","startingMediaInfo_","segmentMetadataTrack_","segmentMetadataTrack","goalBufferLength_","goalBufferLength","sourceType_","sourceUpdater_","sourceUpdater","inbandTextTracks_","state_","timelineChangeController_","shouldSaveSegmentTimingInfo_","useDtsForTimestampOffset_","useDtsForTimestampOffset","captionServices_","checkBufferTimeout_","currentTimeline_","pendingSegment_","xhrOptions_","pendingSegments_","audioDisabled_","isPendingTimestampOffset_","gopBuffer_","timeMapping_","safeAppend_","appendInitSegment_","playlistOfLastInitSegment_","callQueue_","loadQueue_","metadataQueue_","waitingOnRemove_","quotaExceededErrorRetryTimeout_","activeInitSegmentId_","initSegments_","cacheEncryptionKeys_","cacheEncryptionKeys","keyCache_","decrypter_","decrypter","syncController_","syncController","syncPoint_","transmuxer_","createTransmuxer_","triggerSyncInfoUpdate_","isEndOfStream_","ended_","fetchAtBuffer_","newState","hasEnoughInfoToAppend_","processCallQueue_","hasEnoughInfoToLoad_","processLoadQueue_","mediaBytesTransferred","mediaRequests","mediaRequestsAborted","mediaRequestsTimedout","mediaRequestsErrored","mediaTransferDuration","mediaSecondsLoaded","mediaAppends","abort_","setAudio","removeAudio","monitorBuffer_","abortRequests","clearPendingTimelineChange","checkForAbort_","endOfStream","buffered_","getMediaInfo_","videoBuffered","audioBuffered","initSegmentForMap","storedMap","segmentKey","storedKey","couldBeginLoading_","playlist_","init_","resetEverything","newPlaylist","syncInfo","setDateTimeMappingForStart","oldId","resyncLoader","resetLoader","mediaSequenceDiff","saveExpiredSegmentInfo","force","removesRemaining","removeFinished","mapping","updatedBuffer","removeGopBuffer","removeVideo","monitorBufferTick_","fillBuffer_","updating","chooseNextRequest_","loadSegment_","appendedLastSegment","appendedLastPart","bufferedTime","preloaded","haveEnoughBuffer","getSyncPoint","targetTime","timelineSegments","getSyncSegmentCandidate","nextSegment","lastSegmentLastPart","generateSegmentInfo_","forceTimestampOffset","random","overrideCheck","timestampOffsetForSegment_","audioBufferedEnd","audioTimestampOffset","currentTimePts","gopsSafeToAlignWith","videoTimestampOffset","_ref62","timestampOffsetForSegment","earlyAbortWhenNeeded_","measuredBandwidth","requestTimeRemaining","timeUntilRebuffer$1","timeUntilRebuffer","switchCandidate","compatiblePlaylists","enabledPlaylists","rebufferingEstimates","numRequests","rebufferingImpact","noRebufferingPlaylists","estimate","minRebufferMaxBandwidthSelector","timeSavedBySwitching","minimumTimeSaving","handleAbort_","handleProgress_","simpleSegment","handleTrackInfo_","checkForIllegalMediaSwitch","akeys","bkeys","shallowEqual","handleTimingInfo_","timeType","timingInfoProperty","handleCaptions_","captionData","hasAppendedData_","captionTracks","captionTrack","trackName","def","captionService","createCaptionsTrackIfNotExists","captionArray","addCaptionData","handleId3_","inBandMetadataTrackDispatchType","createMetadataTrackIfNotExists","processMetadataQueue_","callQueue","fun","loadQueue","getCurrentMediaInfo_","setTimeMapping_","updateMediaSecondsLoaded_","useVideoTimingInfo","firstVideoFrameTimeForData","trueSegmentStart_","currentStart","currentVideoTimestampOffset","updateAppendInitSegmentStatus","updateSourceBufferTimestampOffset_","updateTimingInfoEnd_","saveSegmentTimingInfo","shouldSaveTimelineMapping","appendData_","changedTimestampOffset","getInitSegmentAndUpdateState_","handleQuotaExceededError_","audioBufferStart","audioBufferEnd","videoBufferStart","videoBufferEnd","appendToSourceBuffer_","timeToRemoveUntil","MIN_BACK_BUFFER","handleAppendError_","segmentObj","concatSegments","appendBuffer","handleSegmentTimingInfo_","segmentTimingInfo","transmuxedDecodeStart","transmuxedDecodeEnd","trimBackBuffer_","updateTransmuxerAndRequestSegment_","shouldUpdateTransmuxerTimestampOffset_","createSimplifiedSegmentObj_","isEndOfStream","isWalkingForward","isDiscontinuity","segmentRequestFinished_","_ref69","removeToTime","trimTime","maxTrimTime","safeBackBufferTrimTime","previousSegment","saveTransferStats_","saveBandwidthRelatedStats_","handleTimeout_","updateGopBuffer","waitForAppendsToComplete_","timelineMapping","mappingForTimeline","waitForVideo","waitForAudio","waitingOnAppends","checkAppendsDone_","videoQueueCallback","audioQueueCallback","handleAppendsDone_","illegalMediaSwitchError","startingMedia","illegalMediaSwitch","didChange","getSegmentStartTimeForTimestampOffsetCalculation_","prioritizedTimingInfo","segmentDurationMessage","recordThroughput_","addSegmentMetadataCue_","badSegmentGuess","badPartGuess","segmentProcessingTime","segmentProcessingThroughput","bufferTypes","sourceBuffer","queuePending","shiftQueue","queueIndex","queueEntry","nextQueueIndexOfType","cleanupBuffer","titleType","inSourceBuffers","sourceBuffers","actions","onError","mime","addSourceBuffer","removeSourceBuffer","changeType","pushQueue","_ref72","onUpdateend","SourceUpdater","sourceopenListener_","audioTimestampOffset_","videoTimestampOffset_","delayedAudioAppendQueue_","videoAppendQueued_","onVideoUpdateEnd_","onAudioUpdateEnd_","onVideoError_","videoError_","onAudioError_","audioError_","createdSourceBuffers_","initializedEme_","triggeredReady_","initializedEme","hasCreatedSourceBuffers","hasInitializedAnyEme","createSourceBuffers","addOrChangeSourceBuffers","canRemoveSourceBuffer","SourceBuffer","canChangeType","processedAppend_","videoBuffer","que","audioBuffer","bufferA","bufferB","arity","extents","bufferIntersection","setDuration","uint8ToUtf8","uintArray","escape","VTT_LINE_TERMINATORS","VTTSegmentLoader","subtitlesTrack_","featuresNativeTextTracks_","combinedByteLength","combinedSegment","timestampOffsetForTimeline","checkTimestampOffset","skipEmptySegments_","stopForError","loadHandler","requested","parseVTTCues_","updateTimeMapping_","timelines","duplicates","occurrences","dupe","removeDuplicateCuesFromTrack","decodeBytesToString","timestampmap","MPEGTS","LOCAL","mapData","segmentData","mappingObj","diff","firstStart","lastStart","findAdCue","mediaTime","adStartTime","adEndTime","syncPointStrategies","run","timelineToDatetimeMappings","lastDistance","datetimeMapping","z","discontinuitySync","discontinuities","SyncController","syncPoints","runStrategies_","selectSyncPoint_","getExpiredTime","strategy","bestSyncPoint","bestDistance","bestStrategy","newDistance","lastRemovedSegment","firstSegment","playlistTimestamp","didCalculateSegmentTimeMapping","calculateSegmentTimeMapping_","saveDiscontinuitySyncInfo_","dateTime","accuracy","mediaIndexDiff","TimelineChangeController","pendingTimelineChanges_","lastTimelineChanges_","workerCode","aesTables","AES","tmp","tables","encTable","decTable","sbox","sboxInv","xInv","th","x2","x4","x8","tEnc","tDec","precompute","_tables","keyLen","rcon","encKey","decKey","encrypted0","encrypted1","encrypted2","encrypted3","out","a2","c2","nInnerRounds","kIndex","table0","table1","table2","table3","AsyncStream","jobs","timeout_","processJob_","job","ntoh","word","Decrypter","initVector","STEP","encrypted32","Int32Array","asyncStream_","decryptChunk_","padded","decipher","decrypted32","init0","init1","init2","init3","wordIx","audioTrackKind_","stopLoaders","segmentLoader","activePlaylistLoader","startLoaders","playlistLoader","segmentLoaders","excludePlaylist","activeTrack","activeGroup","defaultTrack","onTrackChanged","setupListeners","requestOptions","initialize","variantLabel","isMainPlaylist","newProps","groupMatch","setupMediaGroups","audioSegmentLoader","mainSegmentLoader","variants","groupKeys","groupPropertyList","onGroupChanged","getActiveGroup","previousActiveLoader","lastGroup","lastGroup_","lastTrack_","onGroupChanging","lastTrack","pc","selectPlaylist","fastQualityChange_","activeTrack_","onAudioTrackChanged","Vhs$1","loaderStats","sumLoaderStat","stat","audioSegmentLoader_","mainSegmentLoader_","PlaylistController","externVhs","useCueTags","enableLowInitialPlaylist","bufferBasedABR","maxPlaylistRetries","useCueTags_","cueTagsTrack_","requestOptions_","pauseLoading","mediaTypes_","createMediaTypes","handleDurationChange_","handleSourceOpen_","handleSourceEnded_","segmentLoaderSettings","setupMainPlaylistLoaderListeners_","subtitleSegmentLoader_","setupSegmentLoaderListeners_","startABRTimer_","stopABRTimer_","triggeredFmp4Usage","loadOnPlay_","timeToLoadedData__","mainAppendsToLoadedData__","audioAppendsToLoadedData__","timeToLoadedDataStart","mainAppendsToLoadedData_","audioAppendsToLoadedData_","appendsToLoadedData_","timeToLoadedData_","checkABR_","nextPlaylist","shouldSwitchToMedia_","switchMedia_","newId","abrTimer_","defaultPlaylists","defaultGroup","requestTimeout","triggerPresenceUsage_","setupFirstPlay","updatedPlaylist","selectedMedia","excludeUnsupportedVariants_","selectInitialPlaylist","initialMedia_","handleUpdatedMediaPlaylist","playlistToExclude","lastExcludeReason_","stuckAtPlaylistEnd_","updateAdCues_","updateDuration","defaultDemuxed","audioGroupKeys","currentPlaylist","bufferLowWaterLine","bufferHighWaterLine","sharedLogLine","isBuffered","forwardBuffer","maxBufferLowWaterLine","nextBandwidth","currBandwidth","logLine","shouldSwitchToMedia","onSyncInfoUpdate_","onEndOfStream","delegateLoaders_","updateCodecs","tryToCreateSourceBuffers_","getCodecsOrExclude_","mediaSecondsLoaded_","mainMediaInfo","absolutePlaylistEnd","reincluded","errorMessage","delayDuration","fnNames","loaders","dontFilterPlaylist","loader","audioSeekable","mainSeekable","oldEnd","oldStart","updateDuration_","areMediaTypesKnown_","usingAudioLoader","hasMainMediaInfo","hasAudioMediaInfo","playlistCodecs","unsupportedCodecs","unsupportedAudio","supporter","switchMessages","newCodec","oldCodec","excludeIncompatibleVariants_","ids","unsupported","codecCount_","videoDetails","audioDetails","exclusionReasons","variantCodecs","variantCodecCount","variantVideoDetails","variantAudioDetails","adOffset","adTotal","updateAdCues","newMax","Representation","vhsHandler","qualityChangeFunction","playlistID","changePlaylistFn","incompatible","currentlyEnabled","timerCancelEvents","PlaybackWatcher","allowSeeksWithinUnsafeLiveWindow","liveRangeSafeTimeDelta","consecutiveUpdates","lastRecordedTime","checkCurrentTimeTimeout_","playHandler","monitorCurrentTime_","canPlayHandler","waitingHandler","techWaiting_","cancelTimerHandler","resetTimeUpdate_","loaderTypes","loaderChecks","resetSegmentDownloads_","updateend","checkSegmentDownloads_","setSeekingHandlers","seekingAppendCheck_","fixesBadSeeks_","clearSeekingAppendCheck_","watchForBadSeeking_","checkCurrentTime_","isBufferedDifferent","isRangeDifferent","playlistId","waiting_","afterSeekableWindow_","beforeSeekableWindow_","minAppendedDuration","bufferedToCheck","nextRange","livePoint","videoUnderflow_","skipTheGap_","allowedEnd","gap","lastVideoRange","videoRange","audioRange","gapFromVideoUnderflow_","scheduledCurrentTime","gaps","findGaps","defaultOptions","errorInterval","getSource","IWillNotUseThisInPlugins","lastCalled","localOptions","loadedMetadataHandler","cleanupEvents","reloadSourceOnError","STANDARD_PLAYLIST_SELECTOR","INITIAL_PLAYLIST_SELECTOR","movingAverageBandwidthSelector","decay","average","lastSystemBandwidth","comparePlaylistResolution","leftWidth","rightWidth","handleVhsMediaChange","waitForKeySessionCreation","_ref80","sourceKeySystems","audioMedia","mainPlaylists","eme","initializeMediaKeys","keySystemsOptionsArr","keySystems","keySystemsArr","keySystemsOptions","keySystemsObj","keySystemOptions","getAllPsshKeySystemsOptions","initializationFinishedPromises","keySessionCreatedPromises","race","setupEmeOptions","_ref81","sourceOptions","audioPlaylist","videoContentType","audioContentType","keySystemContentTypes","emeKeySystems","getVhsLocalStorage","storedObject","supportsNativeHls","canItPlay","supportsNativeDash","supportsTypeNatively","Component","VhsHandler","initialBandwidth","_player","source_","ignoreNextSeekingEvent_","setOptions_","overrideNative","featuresNativeVideoTracks","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","useBandwidthFromLocalStorage","useNetworkInformationApi","option","dataUri","playbackWatcherOptions","playbackWatcher_","defaultSelector","playerBandwidthEst","networkInformation","connection","mozConnection","webkitConnection","networkInfoBandwidthEstBitsPerSec","downlink","invBandwidth","invThroughput","mediaRequests_","mediaRequestsAborted_","mediaRequestsTimedout_","mediaRequestsErrored_","mediaTransferDuration_","mediaBytesTransferred_","mediaAppends_","mainAppendsToLoadedData","audioAppendsToLoadedData","appendsToLoadedData","timeToLoadedData","currentTech","playerDimensions","objectToStore","updateVhsLocalStorage","setupEme_","setupQualityLevels_","mediaSourceUrl_","createKeySessions_","audioPlaylistLoader","handleWaitingForKey_","didSetupEmeOptions","excludedHDPlaylists","qualityLevels_","convertToProgramTime","VhsSourceHandler","supportedType"],"mappings":"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"}